<!DOCTYPE HTML>
<html>
  <head i18n-values="dir:textdirection;">
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>Trace from tracing/test_data/battor.zip</title>
  <polymer-element constructor="TracingAnalysisTabView" name="tr-ui-a-tab-view">
  <template>
    <style>
      :host {
        display: flex;
        flex-flow: column nowrap;
        overflow: hidden;
        box-sizing: border-box;
      }

      tab-strip[tabs-hidden] {
        display: none;
      }

      tab-strip {
        background-color: rgb(236, 236, 236);
        border-bottom: 1px solid #8e8e8e;
        display: flex;
        flex: 0 0 auto;
        flex-flow: row;
        overflow-x: auto;
        padding: 0 10px 0 10px;
        font-size: 12px;
      }

      tab-button {
        display: block;
        flex: 0 0 auto;
        padding: 4px 15px 1px 15px;
        margin-top: 2px;
      }

      tab-button[selected=true] {
        background-color: white;
        border: 1px solid rgb(163, 163, 163);
        border-bottom: none;
        padding: 3px 14px 1px 14px;
      }

      tabs-content-container {
        display: flex;
        flex: 1 1 auto;
        overflow: auto;
        width: 100%;
      }

      ::content > * {
        flex: 1 1 auto;
      }

      ::content > *:not([selected]) {
        display: none;
      }

      button-label {
        display: inline;
      }

      tab-strip-heading {
        display: block;
        flex: 0 0 auto;
        padding: 4px 15px 1px 15px;
        margin-top: 2px;
        margin-before: 20px;
        margin-after: 10px;
      }
      #tsh {
        display: inline;
        font-weight: bold;
      }
    </style>

    <tab-strip>
      <tab-strip-heading id="tshh">
        <span id="tsh"></span>
      </tab-strip-heading>
      <template repeat="{{tab in tabs_}}">
        <tab-button button-id="{{ tab.id }}" on-click="{{ tabButtonSelectHandler_ }}" selected="{{ selectedTab_.id === tab.id }}">
          <button-label>{{ tab.label ? tab.label : 'No Label'}}</button-label>
        </tab-button>
      </template>
    </tab-strip>

    <tabs-content-container id="content-container">
        <content></content>
    </tabs-content-container>

  </template>

  
</polymer-element><!--
@fileoverview Polymer element for various analysis sub-views.
--><polymer-element name="tr-ui-a-sub-view">
  
</polymer-element><style>
* /deep/ .labeled-checkbox {
  display: flex;
  white-space: nowrap;
}
</style><polymer-element is="a" name="tr-ui-a-analysis-link" on-click="{{onClicked_}}" on-mouseenter="{{onMouseEnter_}}" on-mouseleave="{{onMouseLeave_}}">
  <template>
    <style>
    :host {
      display: inline;
      color: -webkit-link;
      cursor: pointer;
      text-decoration: underline;
      cursor: pointer;
    }
    </style>
    <content></content>
  </template>
  
</polymer-element><!--
@fileoverview A container that constructs a table-like container.
--><polymer-element name="tr-ui-b-table">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      table {
        font-size: 12px;

        flex: 1 1 auto;
        align-self: stretch;
        border-collapse: separate;
        border-spacing: 0;
        border-width: 0;
        -webkit-user-select: initial;
      }

      tr > td {
        padding: 2px 4px 2px 4px;
        vertical-align: text-top;
      }

      tr:focus,
      td:focus {
        outline: 1px dotted rgba(0,0,0,0.1);
        outline-offset: 0;
      }

      button.toggle-button {
        height: 15px;
        line-height: 60%;
        vertical-align: middle;
        width: 100%;
      }

      button > * {
        height: 15px;
        vertical-align: middle;
      }

      td.button-column {
        width: 30px;
      }

      table > thead > tr > td.sensitive:hover {
        background-color: #fcfcfc;
      }

      table > thead > tr > td {
        font-weight: bold;
        text-align: left;

        background-color: #eee;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        border-top: 1px solid #ffffff;
        border-bottom: 1px solid #aaa;
      }

      table > tfoot {
        background-color: #eee;
        font-weight: bold;
      }

      /* Selection. */
      table > tbody.row-selection-mode > tr[selected],
      table > tbody.cell-selection-mode > tr > td[selected] {
        background-color: rgb(103, 199, 165);  /* turquoise */
      }
      table > tbody.cell-selection-mode.row-highlight-enabled >
          tr.highlighted-row {
        background-color: rgb(213, 236, 229);  /* light turquoise */
      }

      /* Hover. */
      table > tbody.row-selection-mode >
          tr:hover:not(.empty-row):not([selected]),
      table > tbody.cell-selection-mode >
          tr:not(.empty-row):not(.highlighted-row) >
          td.supports-selection:hover:not([selected]),
      table > tfoot > tr:hover {
        background-color: #e6e6e6;  /* grey */
      }
      table > tbody.cell-selection-mode.row-highlight-enabled >
          tr:hover:not(.empty-row):not(.highlighted-row) {
        background-color: #f6f6f6;  /* light grey */
      }

      /* Hover on selected and highlighted elements. */
      table > tbody.row-selection-mode > tr:hover[selected],
      table > tbody.cell-selection-mode > tr > td:hover[selected],
      table > tbody.cell-selection-mode > tr.highlighted-row > td:hover {
        background-color: rgb(171, 217, 202);  /* semi-light turquoise */
      }

      table > tbody > tr.empty-row > td {
        color: #666;
        font-style: italic;
        text-align: center;
      }

      table > tbody.has-footer > tr:last-child > td {
        border-bottom: 1px solid #aaa;
      }

      table > tfoot > tr:first-child > td {
        border-top: 1px solid #ffffff;
      }

      expand-button {
        -webkit-user-select: none;
        display: inline-block;
        cursor: pointer;
        font-size: 9px;
        min-width: 8px;
        max-width: 8px;
      }

      .button-expanded {
        transform: rotate(90deg);
      }
    </style>
    <table>
      <thead id="head">
      </thead>
      <tbody id="body">
      </tbody>
      <tfoot id="foot">
      </tfoot>
    </table>
  </template>
  
</polymer-element><polymer-element name="tr-ui-b-table-header-cell" on-tap="onTap_">
  <template>
  <style>
    :host {
      -webkit-user-select: none;
      display: flex;
    }

    span {
      flex: 0 1 auto;
    }

    side-element {
      -webkit-user-select: none;
      flex: 1 0 auto;
      padding-left: 4px;
      vertical-align: top;
      font-size: 15px;
      font-family: sans-serif;
      display: inline;
      line-height: 85%;
    }
  </style>

    <span id="title"></span><side-element id="side"></side-element>
  </template>

  
</polymer-element><polymer-element name="tr-ui-u-scalar-span">
  <template>
    <style>
    :host {
      display: block;
      position: relative;
    }
    #content.right-align {
      text-align: right;
      position: relative;
      display: block;
    }
    #sparkline {
      width: 0%;
      position: absolute;
      bottom: 0;
      right: 0;
      display: none;
      height: 100%;
      background-color: hsla(216, 100%, 94.5%, .75);
      border-left: 1px solid hsl(216, 100%, 89%);
      box-sizing: border-box;
    }
    #warning {
      margin-left: 4px;
      font-size: 66%;
    }
    </style>
    <span id="sparkline"></span>
    <span id="content"></span>
    <span id="warning" style="display:none">⚠</span>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-u-scalar-span" name="tr-ui-u-time-duration-span">
  
</polymer-element><polymer-element extends="tr-ui-u-scalar-span" name="tr-ui-u-time-stamp-span">
  
</polymer-element><polymer-element is="HTMLUnknownElement" name="tr-ui-a-generic-object-view">
  <template>
    <style>
    :host {
      display: block;
      font-family: monospace;
    }
    </style>
    <div id="content">
    </div>
  </template>

  
</polymer-element><polymer-element is="HTMLUnknownElement" name="tr-ui-a-generic-object-view-with-label">
  <template>
    <style>
    :host {
      display: block;
    }
    </style>
  </template>

  
</polymer-element><polymer-element name="tr-ui-a-stack-frame">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
      align-items: center;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-event-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
    }
    </style>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
  </template>
  
</polymer-element><polymer-element name="tr-ui-a-related-events">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-thread-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
    }
    #events {
      display: flex;
      flex-direction: column;
    }

    </style>
    <tr-ui-a-single-event-sub-view id="content"></tr-ui-a-single-event-sub-view>
    <div id="events">
      <tr-ui-a-related-events id="relatedEvents">
      </tr-ui-a-related-events>
    </div>
  </template>

  
</polymer-element><polymer-element name="tr-ui-a-selection-summary-table">
  <template>
    <style>
    :host {
      display: flex;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
    }
    </style>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
    
  </template>
  
</polymer-element><polymer-element name="tr-ui-a-multi-event-summary-table">
  <template>
    <style>
    :host {
      display: flex;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
    }
    </style>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
    
  </template>
  
</polymer-element><polymer-element name="tr-ui-a-multi-event-details-table">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
    }

    #titletable {
      font-weight: bold;
    }

    #title-info {
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="titletable">
    </tr-ui-b-table>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-event-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      overflow: auto;
    }
    #content {
      display: flex;
      flex-direction: column;
      flex: 0 1 auto;
      align-self: stretch;
    }
    #content > * {
      flex: 0 0 auto;
      align-self: stretch;
    }
    tr-ui-a-multi-event-summary-table {
      border-bottom: 1px solid #aaa;
    }

    tr-ui-a-selection-summary-table  {
      margin-top: 1.25em;
      border-top: 1px solid #aaa;
      background-color: #eee;
      font-weight: bold;
      margin-bottom: 1.25em;
      border-bottom: 1px solid #aaa;
    }
    </style>
    <div id="content"></div>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-thread-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #content {
      display: flex;
      flex: 1 1 auto;
    }
    #content > tr-ui-a-related-events {
      margin-left: 8px;
      flex: 0 1 200px;
    }
    </style>
    <div id="content"></div>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-single-event-sub-view" name="tr-ui-a-single-async-slice-sub-view">
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-async-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    </style>
    <tr-ui-a-multi-event-sub-view id="content"></tr-ui-a-multi-event-sub-view>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-cpu-slice-sub-view">
  <template>
    <style>
    table {
      border-collapse: collapse;
      border-width: 0;
      margin-bottom: 25px;
      width: 100%;
    }

    table tr > td:first-child {
      padding-left: 2px;
    }

    table tr > td {
      padding: 2px 4px 2px 4px;
      vertical-align: text-top;
      width: 150px;
    }

    table td td {
      padding: 0 0 0 0;
      width: auto;
    }
    tr {
      vertical-align: top;
    }

    tr:nth-child(2n+0) {
      background-color: #e2e2e2;
    }
    </style>
    <table>
      <tbody><tr>
        <td>Running process:</td><td id="process-name"></td>
      </tr>
      <tr>
        <td>Running thread:</td><td id="thread-name"></td>
      </tr>
      <tr>
        <td>Start:</td>
        <td>
          <tr-ui-u-time-stamp-span id="start">
          </tr-ui-u-time-stamp-span>
        </td>
      </tr>
      <tr>
        <td>Duration:</td>
        <td>
          <tr-ui-u-time-duration-span id="duration">
          </tr-ui-u-time-duration-span>
        </td>
      </tr>
      <tr>
        <td>Active slices:</td><td id="running-thread"></td>
      </tr>
      <tr>
        <td>Args:</td>
        <td>
          <tr-ui-a-generic-object-view id="args">
          </tr-ui-a-generic-object-view>
        </td>
      </tr>
    </tbody></table>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-cpu-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #content {
      flex: 1 1 auto;
    }
    </style>
    <tr-ui-a-multi-event-sub-view id="content"></tr-ui-a-multi-event-sub-view>
  </template>

  
</polymer-element><template id="overlay-template">
  <style>
    overlay-mask {
      left: 0;
      padding: 8px;
      position: absolute;
      top: 0;
      z-index: 1000;
      font-family: sans-serif;
      -webkit-justify-content: center;
      background: rgba(0, 0, 0, 0.8);
      display: -webkit-flex;
      height: 100%;
      left: 0;
      position: fixed;
      top: 0;
      width: 100%;
    }
    overlay-mask:focus {
      outline: none;
    }
    overlay-vertical-centering-container {
      -webkit-justify-content: center;
      -webkit-flex-direction: column;
      display: -webkit-flex;
    }
    overlay-frame {
      z-index: 1100;
      background: rgb(255, 255, 255);
      border: 1px solid #ccc;
      margin: 75px;
      display: -webkit-flex;
      -webkit-flex-direction: column;
      min-height: 0;
    }
    title-bar {
      -webkit-align-items: center;
      -webkit-flex-direction: row;
      border-bottom: 1px solid #ccc;
      background-color: #ddd;
      display: -webkit-flex;
      padding: 5px;
      -webkit-flex: 0 0 auto;
    }
    title {
      display: inline;
      font-weight: bold;
      -webkit-box-flex: 1;
      -webkit-flex: 1 1 auto;
    }
    close-button {
      -webkit-align-self: flex-end;
      border: 1px solid #eee;
      background-color: #999;
      font-size: 10pt;
      font-weight: bold;
      padding: 2px;
      text-align: center;
      width: 16px;
    }
    close-button:hover {
      background-color: #ddd;
      border-color: black;
      cursor: pointer;
    }
    overlay-content {
      display: -webkit-flex;
      -webkit-flex: 1 1 auto;
      -webkit-flex-direction: column;
      overflow-y: auto;
      padding: 10px;
      min-width: 300px;
      min-height: 0;
    }
    button-bar {
      -webkit-align-items: baseline;
      border-top: 1px solid #ccc;
      display: -webkit-flex;
      -webkit-flex: 0 0 auto;
      -webkit-flex-direction: row-reverse;
      padding: 4px;
    }
  </style>

  <overlay-mask>
    <overlay-vertical-centering-container>
      <overlay-frame>
        <title-bar>
          <title></title>
          <close-button>✕</close-button>
        </title-bar>
        <overlay-content>
          <content></content>
        </overlay-content>
        <button-bar></button-bar>
      </overlay-frame>
    </overlay-vertical-centering-container>
  </overlay-mask>
</template><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-thread-time-slice-sub-view">
  <template>
    <style>
    table {
      border-collapse: collapse;
      border-width: 0;
      margin-bottom: 25px;
      width: 100%;
    }

    table tr > td:first-child {
      padding-left: 2px;
    }

    table tr > td {
      padding: 2px 4px 2px 4px;
      vertical-align: text-top;
      width: 150px;
    }

    table td td {
      padding: 0 0 0 0;
      width: auto;
    }
    tr {
      vertical-align: top;
    }

    tr:nth-child(2n+0) {
      background-color: #e2e2e2;
    }
    </style>
    <table>
      <tbody><tr>
        <td>Running process:</td><td id="process-name"></td>
      </tr>
      <tr>
        <td>Running thread:</td><td id="thread-name"></td>
      </tr>
      <tr>
        <td>State:</td>
        <td><b><span id="state"></span></b></td>
      </tr>
      <tr>
        <td>Start:</td>
        <td>
          <tr-ui-u-time-stamp-span id="start">
          </tr-ui-u-time-stamp-span>
        </td>
      </tr>
      <tr>
        <td>Duration:</td>
        <td>
          <tr-ui-u-time-duration-span id="duration">
          </tr-ui-u-time-duration-span>
        </td>
      </tr>

      <tr>
        <td>On CPU:</td><td id="on-cpu"></td>
      </tr>

      <tr>
        <td>Running instead:</td><td id="running-instead"></td>
      </tr>

      <tr>
        <td>Args:</td><td id="args"></td>
      </tr>
    </tbody></table>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-thread-time-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #content {
      flex: 1 1 auto;
    }
    </style>
    <tr-ui-a-multi-event-sub-view id="content"></tr-ui-a-multi-event-sub-view>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-instant-event-sub-view">
  <template>
    <style>
    :host {
      display: block;
    }
    </style>
    <div id="content"></div>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-instant-event-sub-view">
  <template>
    <style>
    :host {
      display: block;
    }
    </style>
    <div id="content"></div>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-counter-sample-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</polymer-element><polymer-element extends="tr-ui-a-single-event-sub-view" name="tr-ui-a-single-flow-event-sub-view">
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-flow-event-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    </style>
    <tr-ui-a-multi-event-sub-view id="content"></tr-ui-a-multi-event-sub-view>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-object-instance-sub-view">
  <template>
    <style>
    :host {
      display: block;
    }

    #snapshots > * {
      display: block;
    }

    :host {
      overflow: auto;
      display: block;
    }

    * {
      -webkit-user-select: text;
    }

    .title {
      border-bottom: 1px solid rgb(128, 128, 128);
      font-size: 110%;
      font-weight: bold;
    }

    td, th {
      font-family: monospace;
      vertical-align: top;
    }
    </style>
    <div id="content"></div>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-object-snapshot-sub-view">
  <template>
    <style>
    #args {
      white-space: pre;
    }

    :host {
      overflow: auto;
      display: flex;
    }

    ::content * {
      -webkit-user-select: text;
    }

    ::content .title {
      border-bottom: 1px solid rgb(128, 128, 128);
      font-size: 110%;
      font-weight: bold;
    }

    ::content td, th {
      font-family: monospace;
      vertical-align: top;
    }
    </style>
    <content></content>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-object-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    </style>
    <tr-ui-b-table id="content"></tr-ui-b-table>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-sample-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    </style>
    <tr-ui-b-table id="content"></tr-ui-b-table>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-sampling-panel">
  <template>
    <style>
    :host { display: block; }
    </style>

    <tr-ui-b-table id="table">
    </tr-ui-b-table>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-sample-sub-view">
  <template>
    <style>
    :host { display: block; }
    </style>
    <tr-ui-a-sampling-panel id="panel"></tr-ui-a-sampling-panel>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-interaction-record-sub-view">
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-interaction-record-sub-view">
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-alert-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
    }
    </style>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-frame-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #asv {
      flex: 0 0 auto;
      align-self: stretch;
    }
    </style>
    <tr-ui-a-alert-sub-view id="asv">
    </tr-ui-a-alert-sub-view>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-frame-sub-view">
  
</polymer-element><!--
@fileoverview A component used to display a label and a color square.

The colored square is typically filled with the color associated with
that label, using the getColorId* methods from base/color_scheme.
--><polymer-element name="tr-ui-b-color-legend">
  <template>
    <style>
    :host {
      display: inline-block;
    }

    #square {
      font-size: 150%;  /* Make the square bigger. */
      line-height: 0%;  /* Prevent the square from increasing legend height. */
    }
    </style>
    <span id="square"></span>
    <span id="label"></span>
  </template>
  
</polymer-element><!--
@fileoverview Analysis view stacked pane. See the stacked pane view element
(tr-ui-a-stacked-pane-view) documentation for more details.
--><polymer-element name="tr-ui-a-stacked-pane">
  
</polymer-element><polymer-element extends="tr-ui-a-stacked-pane" name="tr-ui-a-memory-dump-allocator-details-pane">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      #label {
        flex: 0 0 auto;
        padding: 8px;

        background-color: #eee;
        border-bottom: 1px solid #8e8e8e;
        border-top: 1px solid white;

        font-size:  15px;
        font-weight: bold;
      }

      #contents {
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
      }

      #contents .info-text {
        padding: 8px;
        color: #666;
        font-style: italic;
        text-align: center;
      }
    </style>
    <div id="label">Allocator details</div>
    <div id="contents"></div>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-stacked-pane" name="tr-ui-a-memory-dump-vm-regions-details-pane">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      #label {
        flex: 0 0 auto;
        padding: 8px;

        background-color: #eee;
        border-bottom: 1px solid #8e8e8e;
        border-top: 1px solid white;

        font-size:  15px;
        font-weight: bold;
      }

      #contents {
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
      }

      #contents .info-text {
        padding: 8px;
        color: #666;
        font-style: italic;
        text-align: center;
      }
    </style>
    <div id="label">Memory maps</div>
    <div id="contents"></div>
  </template>
  
</polymer-element><!--
This element handles storing and retrieving the brushing state of arbitrary
views (e.g. analysis sub-views). An element can use it by instantiating it and
appending it to itself:

  <div id="some-view-with-specific-brushing-state">
    <tr-ui-b-view-specific-brushing-state view-id="unique-view-identifier">
    </tr-ui-b-view-specific-brushing-state>
    ... other child elements ...
  </div>

The state can then be retrieved from and pushed to the state element as
follows:

  newStateElement.set(state);
  state = newStateElement.get();

Under the hood, the state element searches the DOM tree for an ancestor element
with a brushingStateController field to persist the state (see the
tr.c.BrushingStateController and tr.ui.b.BrushingState classes for more
details).
--><polymer-element name="tr-ui-b-view-specific-brushing-state">
  
</polymer-element><polymer-element extends="tr-ui-a-stacked-pane" name="tr-ui-a-memory-dump-overview-pane">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      #label {
        flex: 0 0 auto;
        padding: 8px;

        background-color: #eee;
        border-bottom: 1px solid #8e8e8e;
        border-top: 1px solid white;

        font-size:  15px;
        font-weight: bold;
      }

      #table {
        flex: 1 0 auto;
        align-self: stretch;
      }
    </style>
    <tr-ui-b-view-specific-brushing-state id="state" view-id="analysis.memory_dump_overview_pane">
    </tr-ui-b-view-specific-brushing-state>
    <div id="label">Overview</div>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
  </template>
  
</polymer-element><!--
@fileoverview Analysis view container which displays vertically stacked panes.
The panes represent a hierarchy where a child pane contains the details of the
current selection in its parent pane. The container provides simple primitives
for panes to request changing their child pane:

  +=<tr-ui-a-stacked-pane-view>=+              +=<tr-ui-a-stacked-pane-view>=+
  |+.<tr-ui-a-stacked-pane>....+|              |+.<tr-ui-a-stacked-pane>....+|
  |: Pane 1                    +| ===========> |: Pane 1                    +|
  |+...........................+|    Pane 1    |+...........................+|
  |+.<tr-ui-a-stacked-pane>....+|   requests   |+.<tr-ui-a-stacked-pane>....+|
  |: Pane 2 (detail of Pane 1) +|  child pane  |: Pane 4 (detail of Pane 1) +|
  |+...........................+| change (e.g. |+...........................+|
  |+.<tr-ui-a-stacked-pane>....+|  selection   +=============================+
  |: Pane 3 (detail of Pane 2) +|   changed)
  |+...........................+|
  +=============================+

Note that the actual UI provided by tr-ui-a-stacked-pane-view and
tr-ui-a-stacked-pane is merely a wrapper container with flex box vertical
stacking. No other visual features (such as pane spacing or borders) is
provided by either element.

The stacked pane element (tr-ui-a-stacked-pane) is defined in a separate file.

Sample use case:

  Create an empty stacked pane view and add it to the DOM:

    var paneView = document.createElement('tr-ui-a-stacked-pane-view');
    someParentView.appendChild(paneView);

  Define one or more pane subclasses:

    <polymer-element name="some-pane-1" extends="tr-ui-a-stacked-pane">
      ...
    </polymer-element>

  Set the top-level pane (by providing a builder function):

    paneView.setPaneBuilder(function() {
      var topPane = document.createElement('some-pane-1');
      pane.someProperty = someValue;
      return topPane;
    });

  Show a child pane with details upon user interaction (these methods should be
  in the definition of the pane subclass Polymer element):

    ready: function() {
      this.$.table.addEventListener(
          'selection-changed', this.changeChildPane_.bind(this));
    }

    changeChildPane_: function() {
      this.childPaneBuilder = function() {
        var selectedRow = this.$.table.selectedTableRow;
        var detailsPane = document.createElement('some-pane-2');
        detailsPane.someProperty = selectedRow;
        return detailsPane;
      }.bind(this);
    }
--><polymer-element name="tr-ui-a-stacked-pane-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }

    #pane_container > * {
      flex: 0 0 auto;
    }
    </style>
    <div id="pane_container">
    </div>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-stacked-pane-view" name="tr-ui-a-memory-dump-view">
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-process-memory-dump-sub-view">
  <template>
    <tr-ui-a-memory-dump-view id="memory_dump_view">
    </tr-ui-a-memory-dump-view>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-process-memory-dump-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    </style>
    <tr-ui-b-table id="content"></tr-ui-b-table>
  </template>

  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-global-memory-dump-sub-view">
  <template>
    <tr-ui-a-memory-dump-view id="memory_dump_view">
    </tr-ui-a-memory-dump-view>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-global-memory-dump-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    </style>
    <tr-ui-b-table id="content"></tr-ui-b-table>
  </template>

  
</polymer-element><polymer-element name="tr-ui-a-power-sample-table">
  <template>
    <style>
    :host {
      display: flex;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-single-power-sample-sub-view">
  <template>
    <style>
    :host { display: block; }
    </style>
    <tr-ui-a-power-sample-table id="samplesTable">
    </tr-ui-a-power-sample-table>
  </template>

  
</polymer-element><style>
  * /deep/ .chart-base #title {
    font-size: 16pt;
  }

  * /deep/ .chart-base {
    font-size: 12pt;
    -webkit-user-select: none;
    cursor: default;
  }

  * /deep/ .chart-base .axis path,
  * /deep/ .chart-base .axis line {
    fill: none;
    shape-rendering: crispEdges;
    stroke: #000;
  }
</style><template id="chart-base-template">
  <svg> <!-- svg tag is dropped by ChartBase.decorate. -->
    <g id="chart-area" xmlns="http://www.w3.org/2000/svg">
      <g class="x axis"></g>
      <g class="y axis"></g>
      <text id="title"></text>
    </g>
  </svg>
</template><style>
/* Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .line-chart .line {
  fill: none;
  stroke-width: 1.5px;
}

* /deep/ .line-chart #brushes > rect {
  fill: rgb(192, 192, 192);
}

</style><!--
@fileoverview A line chart showing milliseconds since the start of the frame on
the x-axis and power consumption on the y-axis. Each frame is shown as a
separate line in the chart. Vertical sync events are used as the start of each
frame.

This chart aims to help users understand the shape of the power consumption
curve over the course of a frame or set of frames.
--><polymer-element name="tr-ui-a-frame-power-usage-chart">
  <template>
    <div id="content"></div>
  </template>
</polymer-element><polymer-element name="tr-ui-a-power-sample-summary-table">
  <template>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-a-sub-view" name="tr-ui-a-multi-power-sample-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
    }
    #tables {
      display: flex;
      flex-direction: column;
      width: 50%;
    }
    #chart {
      width: 50%;
    }
    </style>
    <div id="tables">
      <tr-ui-a-power-sample-summary-table id="summaryTable">
      </tr-ui-a-power-sample-summary-table>
      <tr-ui-a-power-sample-table id="samplesTable">
      </tr-ui-a-power-sample-table>
    </div>
    <tr-ui-a-frame-power-usage-chart id="chart">
    </tr-ui-a-frame-power-usage-chart>
  </template>
</polymer-element><!-- Sub Views. --><!--
@fileoverview A component used to display an analysis of a selection,
using custom elements specialized for different event types.
--><polymer-element name="tr-ui-a-analysis-view">
  <template>
    <style>
      :host {
        background-color: white;
        display: flex;
        flex-direction: column;
        height: 275px;
        overflow: auto;
      }

      :host(.tall-mode) {
        height: 525px;
      }

      ::content > * {
        flex: 1 0 auto;
      }
    </style>
    <content></content>
  </template>
  
</polymer-element><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ x-drag-handle {
  -webkit-user-select: none;
  box-sizing: border-box;
  display: block;
}

* /deep/ x-drag-handle.horizontal-drag-handle {
  background-image: -webkit-gradient(linear,
                                     0 0, 0 100%,
                                     from(#E5E5E5),
                                     to(#D1D1D1));
  border-bottom: 1px solid #8e8e8e;
  border-top: 1px solid white;
  cursor: ns-resize;
  height: 7px;
  position: relative;
  z-index: 10;
}

* /deep/ x-drag-handle.vertical-drag-handle {
  background-image: -webkit-gradient(linear,
                                     0 0, 100% 0,
                                     from(#E5E5E5),
                                     to(#D1D1D1));
  border-left: 1px solid white;
  border-right: 1px solid #8e8e8e;
  cursor: ew-resize;
  position: relative;
  width: 7px;
  z-index: 10;
}

</style><polymer-element name="tr-ui-b-dropdown">
  <template>
    <style>
    :host {
      position: relative;
      display: flex;
    }
    #outer {
      display: flex;
      flex: 0 0 auto;
      padding: 1px 4px 1px 4px;
      -webkit-user-select: none;
      cursor: default;
    }

    #state {
      display: flex;
      flex: 0 0 auto;
      margin-left: 2px;
      margin-right: 0px;
      flex: 0 0 auto;
    }

    #icon {
      display: flex;
      flex: 0 0 auto;
      flex: 0 0 auto;
    }
    dialog {
      position: absolute;
      padding: 0;
      border: 0;
      margin: 0;
    }
    dialog::backdrop {
      background: rgba(0,0,0,.05);
    }

    #dialog-frame {
      background-color: #fff;
      display: flex;
      flex-direction: column;
      flex: 1 1 auto;
      padding: 6px;
      border: 1px solid black;
      -webkit-user-select: none;
      cursor: default;
    }
    </style>
    <tr-ui-b-toolbar-button id="outer" on-click="{{ onOuterClick_ }}" on-keydown="{{ onOuterKeyDown_ }}">
      <div id="icon">⚙</div>
      <div id="state">▾</div>
    </tr-ui-b-toolbar-button>
    <dialog id="dialog" on-cancel="{{ onDialogCancel_ }}" on-click="{{ onDialogClick_ }}">
      <div id="dialog-frame">
        <content></content>
      </div>
    </dialog>
  </template>
  
</polymer-element><polymer-element name="tv-ui-b-hotkey-controller">
  
</polymer-element><polymer-element name="tr-ui-b-toolbar-button" noscript="">
  <template>
    <style>
    :host {
      display: flex;
      background-color: #f8f8f8;
      border: 1px solid rgba(0, 0, 0, 0.5);
      color: rgba(0,0,0,0.8);
      justify-content: center;
      align-self: stretch;
      min-width: 23px;
    }

    :host(:hover) {
      background-color: rgba(255, 255, 255, 1.0);
      border-color: rgba(0, 0, 0, 0.8);
      box-shadow: 0 0 .05em rgba(0, 0, 0, 0.4);
      color: rgba(0, 0, 0, 1);
    }

    #aligner {
      display: flex;
      flex: 0 0 auto;
      align-self: center;
    }
    </style>
    <div id="aligner">
      <content></content>
    </div>
  </template>
</polymer-element><polymer-element name="tr-ui-b-mouse-mode-icon">
  <template>
    <style>
    :host {
      display: block;
      background-image: url(data:image/png;base64,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);
      width: 27px;
      height: 30px;
    }
    :host.active {
      cursor: auto;
    }
    </style>
  </template>
  
</polymer-element><polymer-element name="tr-ui-b-mouse-mode-selector">
  <template>
    <style>
    :host {

      -webkit-user-drag: element;
      -webkit-user-select: none;

      background: #DDD;
      border: 1px solid #BBB;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      left: calc(100% - 120px);
      position: absolute;
      top: 100px;
      user-select: none;
      width: 29px;
      z-index: 20;
    }

    .drag-handle {
      background: url(data:image/png;base64,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) 2px 3px no-repeat;
      background-repeat: no-repeat;
      border-bottom: 1px solid #BCBCBC;
      cursor: move;
      display: block;
      height: 13px;
      width: 27px;
    }

    .tool-button {
      background-position: center center;
      background-repeat: no-repeat;
      border-bottom: 1px solid #BCBCBC;
      border-top: 1px solid #F1F1F1;
      cursor: pointer;
    }

    .buttons > .tool-button:last-child {
      border-bottom: none;
    }

    </style>
    <div class="drag-handle"></div>
    <div class="buttons">
    </div>
  </template>
</polymer-element><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.track-button {
  background-color: rgba(255, 255, 255, 0.5);
  border: 1px solid rgba(0, 0, 0, 0.1);
  color: rgba(0,0,0,0.2);
  font-size: 10px;
  height: 12px;
  text-align: center;
  width: 12px;
}

.track-button:hover {
  background-color: rgba(255, 255, 255, 1.0);
  border: 1px solid rgba(0, 0, 0, 0.5);
  box-shadow: 0 0 .05em rgba(0, 0, 0, 0.4);
  color: rgba(0, 0, 0, 1);
}

.track-close-button {
  left: 2px;
  position: absolute;
  top: 2px;
}

.track-collapse-button {
  left: 3px;
  position: absolute;
  top: 2px;
}

</style><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.drawing-container {
  -webkit-box-flex: 1;
  display: inline;
  overflow: auto;
  overflow-x: hidden;
  position: relative;
}

.drawing-container-canvas {
  -webkit-box-flex: 1;
  display: block;
  pointer-events: none;
  position: absolute;
  top: 0;
}

</style><polymer-element name="tr-ui-heading">
  <template>
    <style>
    :host {
      background-color: rgb(243, 245, 247);
      border-right: 1px solid #8e8e8e;
      display: block;
      height: 100%;
      margin: 0;
      padding: 0 5px 0 0;
    }

    heading {
      display: block;
      overflow-x: hidden;
      text-align: left;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #arrow {
      -webkit-flex: 0 0 auto;
      font-family: sans-serif;
      margin-left: 5px;
      margin-right: 5px;
      width: 8px;
    }

    #link, #heading_content {
      display: none;
    }
    </style>
    <heading id="heading" on-click="{{onHeadingDivClicked_}}">
      <span id="arrow"></span>
      <span id="heading_content"></span>
      <tr-ui-a-analysis-link id="link"></tr-ui-a-analysis-link>
    </heading>
  </template>

  
</polymer-element><style>
.letter-dot-track {
  height: 18px;
}
</style><style>
.chart-track {
  height: 30px;
  position: relative;
}
</style><style>
.power-series-track {
  height: 90px;
}
</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */
.spacing-track {
  height: 4px;
}

</style><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.object-instance-track {
  height: 18px;
}

</style><style>
/* Copyright (c) 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.rect-track {
  height: 18px;
}

</style><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.thread-track {
  -webkit-box-orient: vertical;
  display: -webkit-box;
  position: relative;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.process-track-header {
  -webkit-flex: 0 0 auto;
  background-image: -webkit-gradient(linear,
                                     0 0, 100% 0,
                                     from(#E5E5E5),
                                     to(#D1D1D1));
  border-bottom: 1px solid #8e8e8e;
  border-top: 1px solid white;
  font-size: 75%;
}

.process-track-name:before {
  content: '\25B8'; /* Right triangle */
  padding: 0 5px;
}

.process-track-base.expanded .process-track-name:before {
  content: '\25BE'; /* Down triangle */
}

</style><style>
.model-track {
  -webkit-box-flex: 1;
}
</style><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.ruler-track {
  height: 12px;
}

.ruler-track.tall-mode {
  height: 30px;
}

</style><!--
  Interactive visualizaiton of Model objects based loosely on gantt charts.
  Each thread in the Model is given a set of Tracks, one per subrow in the
  thread. The TimelineTrackView class acts as a controller, creating the
  individual tracks, while Tracks do actual drawing.

  Visually, the TimelineTrackView produces (prettier) visualizations like the
  following:
    Thread1:  AAAAAAAAAA         AAAAA
                  BBBB              BB
    Thread2:     CCCCCC                 CCCCC
--><polymer-element name="tr-ui-timeline-track-view">
  <template>
    <style>
    :host {
      -webkit-box-orient: vertical;
      display: -webkit-box;
      position: relative;
    }

    :host ::content * {
      -webkit-user-select: none;
      cursor: default;
    }

    #drag_box {
      background-color: rgba(0, 0, 255, 0.25);
      border: 1px solid rgb(0, 0, 96);
      font-size: 75%;
      position: fixed;
    }

    #hint_text {
      position: absolute;
      bottom: 6px;
      right: 6px;
      font-size: 8pt;
    }
    </style>
    <content></content>

    <div id="drag_box"></div>
    <div id="hint_text"></div>

    <tv-ui-b-hotkey-controller id="hotkey_controller">
    </tv-ui-b-hotkey-controller>
  </template>

  
</polymer-element><polymer-element name="tr-ui-find-control">
  <template>
    <style>
      :host {
        -webkit-user-select: none;
        display: -webkit-flex;
        position: relative;
      }
      input {
        -webkit-user-select: auto;
        background-color: #f8f8f8;
        border: 1px solid rgba(0, 0, 0, 0.5);
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        width: 170px;
      }
      input:focus {
        background-color: white;
      }
      tr-ui-b-toolbar-button {
        border-left: none;
        margin: 0;
      }
      #hitCount {
        left: 0;
        opacity: 0.25;
        pointer-events: none;
        position: absolute;
        text-align: right;
        top: 2px;
        width: 167px;
        z-index: 1;
      }
      #spinner {
        visibility: hidden;
        width: 8px;
        height: 8px;
        left: 154px;
        pointer-events: none;
        position: absolute;
        top: 4px;
        z-index: 1;

        border: 2px solid transparent;
        border-bottom: 2px solid rgba(0, 0, 0, 0.5);
        border-right: 2px solid rgba(0, 0, 0, 0.5);
        border-radius: 50%;

        animation: spin 1s linear infinite;
      }
      @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <input id="filter" on-blur="{{ filterBlur }}" on-focus="{{ filterFocus }}" on-input="{{ filterTextChanged }}" on-keydown="{{ filterKeyDown }}" on-mouseup="{{ filterMouseUp }}" type="text"/>
    <div id="spinner"></div>
    <tr-ui-b-toolbar-button on-click="{{ findPrevious }}">
      ←
    </tr-ui-b-toolbar-button>
    <tr-ui-b-toolbar-button on-click="{{ findNext }}">
      →
    </tr-ui-b-toolbar-button>
    <div id="hitCount">0 of 0</div>
  </template>

  
</polymer-element><polymer-element name="tr-ui-scripting-control">
  <template>
    <style>
      :host {
        flex: 1 1 auto;
      }
      .root {
        font-family: monospace;
        cursor: text;

        padding: 2px;
        margin: 2px;
        border: 1px solid rgba(0, 0, 0, 0.5);
        background: white;

        height: 100px;
        overflow-y: auto;

        transition-property: opacity, height, padding, margin;
        transition-duration: .2s;
        transition-timing-function: ease-out;
      }
      .hidden {
        margin-top: 0px;
        margin-bottom: 0px;
        padding-top: 0px;
        padding-bottom: 0px;
        height: 0px;
        opacity: 0;
      }
      .focused {
        outline: auto 5px -webkit-focus-ring-color;
      }
      #history {
        -webkit-user-select: text;
        color: #777;
      }
      #prompt {
        -webkit-user-select: text;
        -webkit-user-modify: read-write-plaintext-only;
        text-overflow: clip !important;
        text-decoration: none !important;
      }
      #prompt:focus {
        outline: none;
      }
      #prompt br {
        display: none;
      }
      #prompt ::before {
        content: ">";
        color: #468;
      }
    </style>

    <div class="root hidden" id="root" on-focus="{{ onConsoleFocus }}" tabindex="0">
      <div id="history"></div>
      <div id="prompt" on-blur="{{ onConsoleBlur }}" on-keydown="{{ promptKeyDown }}" on-keypress="{{ promptKeyPress }}">
  

  

</div></div></template></polymer-element><polymer-element name="tr-ui-side-panel">
  
</polymer-element><polymer-element is="HTMLUnknownElement" name="tr-ui-side-panel-container">
  <template>
    <style>
    :host {
      align-items: stretch;
      display: -webkit-flex;
    }

    :host([expanded]) > active-panel-container {
      -webkit-flex: 1 1 auto;
      border-left: 1px solid black;
      display: -webkit-flex;
    }

    :host(:not([expanded])) > active-panel-container {
      display: none;
    }

    active-panel-container {
      display: flex;
    }

    tab-strip {
      -webkit-flex: 0 0 auto;
      -webkit-flex-direction: column;
      -webkit-user-select: none;
      background-color: rgb(236, 236, 236);
      border-left: 1px solid black;
      cursor: default;
      display: -webkit-flex;
      min-width: 18px; /* workaround for flexbox and writing-mode mixing bug */
      padding: 10px 0 10px 0;
      font-size: 12px;
    }

    tab-strip > tab-strip-label {
      -webkit-writing-mode: vertical-rl;
      display: inline;
      margin-right: 1px;
      min-height: 20px;
      padding: 15px 3px 15px 1px;
    }

    tab-strip >
        tab-strip-label:not([enabled]) {
      color: rgb(128, 128, 128);
    }

    tab-strip > tab-strip-label[selected] {
      background-color: white;
      border: 1px solid rgb(163, 163, 163);
      border-left: none;
      padding: 14px 2px 14px 1px;
    }
    </style>

    <active-panel-container id="active_panel_container">
    </active-panel-container>
    <tab-strip id="tab_strip"></tab-strip>
  </template>

  
</polymer-element><polymer-element name="tr-ui-timeline-view-help-overlay">
  <template>
    <style>
    :host {
      -webkit-flex: 1 1 auto;
      -webkit-flex-direction: row;
      display: -webkit-flex;
      width: 700px;
    }
    .column {
      width: 50%;
    }
    h2 {
      font-size: 1.2em;
      margin: 0;
      margin-top: 5px;
      text-align: center;
    }
    h3 {
      margin: 0;
      margin-left: 126px;
      margin-top: 10px;
    }
    .pair {
      -webkit-flex: 1 1 auto;
      -webkit-flex-direction: row;
      display: -webkit-flex;
    }
    .command {
      font-family: monospace;
      margin-right: 5px;
      text-align: right;
      width: 150px;
    }
    .action {
      font-size: 0.9em;
      text-align: left;
      width: 200px;
    }
    tr-ui-b-mouse-mode-icon {
      border: 1px solid #888;
      border-radius: 3px;
      box-shadow: inset 0 0 2px rgba(0,0,0,0.3);
      display: inline-block;
      margin-right: 1px;
      position: relative;
      top: 4px;
    }
    .mouse-mode-icon.pan-mode {
      background-position: -1px -11px;
    }
    .mouse-mode-icon.select-mode {
      background-position: -1px -41px;
    }
    .mouse-mode-icon.zoom-mode {
      background-position: -1px -71px;
    }
    .mouse-mode-icon.timing-mode {
      background-position: -1px -101px;
    }
    </style>
    <div class="column left">
      <h2>Navigation</h2>
      <div class="pair">
        <div class="command">w/s</div>
        <div class="action">Zoom in/out (+shift: faster)</div>
      </div>

      <div class="pair">
        <div class="command">a/d</div>
        <div class="action">Pan left/right (+shift: faster)</div>
      </div>

      <div class="pair">
        <div class="command">→/shift-TAB</div>
        <div class="action">Select previous event</div>
      </div>

      <div class="pair">
        <div class="command">←/TAB</div>
        <div class="action">Select next event</div>
      </div>

      <h2>Mouse Controls</h2>
      <div class="pair">
        <div class="command">click</div>
        <div class="action">Select event</div>
      </div>
      <div class="pair">
        <div class="command">alt-mousewheel</div>
        <div class="action">Zoom in/out</div>
      </div>

      <h3>
        <tr-ui-b-mouse-mode-icon modename="SELECTION"></tr-ui-b-mouse-mode-icon>
        Select mode
      </h3>
      <div class="pair">
        <div class="command">drag</div>
        <div class="action">Box select</div>
      </div>

      <div class="pair">
        <div class="command">double click</div>
        <div class="action">Select all events with same title</div>
      </div>

      <h3>
        <tr-ui-b-mouse-mode-icon modename="PANSCAN"></tr-ui-b-mouse-mode-icon>
        Pan mode
      </h3>
      <div class="pair">
        <div class="command">drag</div>
        <div class="action">Pan the view</div>
      </div>

      <h3>
        <tr-ui-b-mouse-mode-icon modename="ZOOM"></tr-ui-b-mouse-mode-icon>
        Zoom mode
      </h3>
      <div class="pair">
        <div class="command">drag</div>
        <div class="action">Zoom in/out by dragging up/down</div>
      </div>

      <h3>
        <tr-ui-b-mouse-mode-icon modename="TIMING"></tr-ui-b-mouse-mode-icon>
        Timing mode
      </h3>
      <div class="pair">
        <div class="command">drag</div>
        <div class="action">Create or move markers</div>
      </div>

      <div class="pair">
        <div class="command">double click</div>
        <div class="action">Set marker range to slice</div>
      </div>
    </div>

    <div class="column right">
      <h2>General</h2>
      <div class="pair">
        <div class="command">1-4</div>
        <div class="action">Switch mouse mode</div>
      </div>

      <div class="pair">
        <div class="command">shift</div>
        <div class="action">Hold for temporary select</div>
      </div>

      <div class="pair">
        <div class="command">space</div>
        <div class="action">Hold for temporary pan</div>
      </div>

      <div class="pair">
        <div class="command"><span class="mod"></span></div>
        <div class="action">Hold for temporary zoom</div>
      </div>

      <div class="pair">
        <div class="command">/</div>
        <div class="action">Search</div>
      </div>

      <div class="pair">
        <div class="command">enter</div>
        <div class="action">Step through search results</div>
      </div>

      <div class="pair">
        <div class="command">f</div>
        <div class="action">Zoom into selection</div>
      </div>

      <div class="pair">
        <div class="command">z/0</div>
        <div class="action">Reset zoom and pan</div>
      </div>

      <div class="pair">
        <div class="command">g/G</div>
        <div class="action">Toggle 60hz grid</div>
      </div>

      <div class="pair">
        <div class="command">v</div>
        <div class="action">Highlight VSync</div>
      </div>

      <div class="pair">
        <div class="command">h</div>
        <div class="action">Toggle low/high details</div>
      </div>

      <div class="pair">
        <div class="command">m</div>
        <div class="action">Mark current selection</div>
      </div>

      <div class="pair">
        <div class="command">`</div>
        <div class="action">Show or hide the scripting console</div>
      </div>

      <div class="pair">
        <div class="command">?</div>
        <div class="action">Show help</div>
      </div>
    </div>
  </template>

  
</polymer-element><polymer-element name="tr-ui-u-array-of-numbers-span">
  <template>
  </template>
  
</polymer-element><polymer-element name="tr-ui-u-generic-table-view">
  <template>
    <style>
    :host {
    display: flex;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</polymer-element><polymer-element name="tr-ui-timeline-view-metadata-overlay">
  <template>
    <style>
    :host {
      width: 700px;

      overflow: auto;
    }
    </style>
    <tr-ui-u-generic-table-view id="gtv"></tr-ui-u-generic-table-view>
  </template>

  
</polymer-element><polymer-element name="tr-ui-u-preferred-display-unit">
  
</polymer-element><polymer-element name="tr-ui-timeline-view">
  <template>
    <style>
    :host {
      flex-direction: column;
      cursor: default;
      display: flex;
      font-family: sans-serif;
      padding: 0;
    }

    #control {
      background-color: #e6e6e6;
      background-image: -webkit-gradient(linear, 0 0, 0 100%,
          from(#E5E5E5), to(#D1D1D1));
      flex: 0 0 auto;
      overflow-x: auto;
    }

    #control::-webkit-scrollbar { height: 0px; }

    #control > #bar {
      font-size: 12px;
      display: flex;
      flex-direction: row;
      margin: 1px;
    }

    #control > #bar > #title {
      display: flex;
      align-items: center;
      padding-left: 8px;
      padding-right: 8px;
      flex: 1 1 auto;
    }

    #control > #bar > #left_controls,
    #control > #bar > #right_controls {
      display: flex;
      flex-direction: row;
      align-items: stretch;
    }

    #control > #bar > #left_controls > * { margin-right: 2px; }
    #control > #bar > #right_controls > * { margin-left: 2px; }
    #control > #collapsing_controls { display: flex; }

    middle-container {
      flex: 1 1 auto;
      flex-direction: row;
      border-bottom: 1px solid #8e8e8e;
      display: flex;
      min-height: 0;
    }

    middle-container ::content track-view-container {
      flex: 1 1 auto;
      display: flex;
      min-height: 0;
      min-width: 0;
    }

    middle-container ::content track-view-container > * { flex: 1 1 auto; }
    middle-container > x-timeline-view-side-panel-container { flex: 0 0 auto; }
    x-drag-handle { flex: 0 0 auto; }
    tr-ui-a-analysis-view { flex: 0 0 auto; }
    </style>

    <tv-ui-b-hotkey-controller id="hkc"></tv-ui-b-hotkey-controller>
    <div id="control">
      <div id="bar">
        <div id="left_controls"></div>
        <div id="title">^_^</div>
        <div id="right_controls">
          <tr-ui-b-toolbar-button id="view_metadata_button">
            M
          </tr-ui-b-toolbar-button>
          <tr-ui-b-dropdown id="view_options_dropdown"></tr-ui-b-dropdown>
          <tr-ui-find-control id="view_find_control"></tr-ui-find-control>
          <tr-ui-b-toolbar-button id="view_console_button">
            »
          </tr-ui-b-toolbar-button>
          <tr-ui-b-toolbar-button id="view_help_button">
            ?
          </tr-ui-b-toolbar-button>
        </div>
      </div>
      <div id="collapsing_controls"></div>
    </div>
    <middle-container>
      <content></content>

      <tr-ui-side-panel-container id="side_panel_container">
      </tr-ui-side-panel-container>
    </middle-container>
    <x-drag-handle id="drag_handle"></x-drag-handle>
    <tr-ui-a-analysis-view id="analysis"></tr-ui-a-analysis-view>

    <tr-ui-u-preferred-display-unit id="display_unit">
    </tr-ui-u-preferred-display-unit>
  </template>

  
</polymer-element><!-- Features used by Android systrace. --><!-- Chrome also supports systrace & lean config --><!-- General importers --><!--- Domain specific importers --><!-- Lots of chrome-specific extras --><!-- Auditors are fun --><polymer-element is="HTMLDivElement" name="tr-ui-b-info-bar">
  <template>
    <style>
    :host {
      align-items: center;
      flex: 0 0 auto;
      background-color: rgb(252, 235, 162);
      border-bottom: 1px solid #A3A3A3;
      border-left: 1px solid white;
      border-right: 1px solid #A3A3A3;
      border-top: 1px solid white;
      display: flex;
      height: 26px;
      padding: 0 3px 0 3px;
    }

    :host(.info-bar-hidden) {
      display: none;
    }

    #message { flex: 1 1 auto; }
    </style>

    <span id="message"></span>
    <span id="buttons"></span>
  </template>

  
</polymer-element><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .x-list-view {
  -webkit-user-select: none;
  display: block;
}
* /deep/ .x-list-view:focus {
  outline: none;
}

* /deep/ .x-list-view * {
  -webkit-user-select: none;
}

* /deep/ .x-list-view > .list-item {
  padding: 2px 4px 2px 4px;
}

* /deep/ .x-list-view:focus > .list-item[selected] {
  background-color: rgb(171, 217, 202);
  outline: 1px dotted rgba(0,0,0,0.1);
  outline-offset: 0;
}

* /deep/ .x-list-view > .list-item[selected] {
  background-color: rgb(103, 199, 165);
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* * /deep/ tr-ui-e-chrome-cc-picture-ops-list-view {
  -webkit-flex-direction: column;
  border-top: 1px solid grey;
  display: -webkit-flex;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view > .x-list-view {
  -webkit-flex: 1 1 auto;
  overflow: auto;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view > .x-list-view .list-item {
  border-bottom: 1px solid #555;
  font-size: small;
  font-weight: bold;
  padding-bottom: 5px;
  padding-left: 5px;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view >
      .x-list-view .list-item:hover {
  background-color: #f0f0f0;
  cursor: pointer;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view >
      .x-list-view .list-item > * {
  color: #777;
  font-size: x-small;
  font-weight: normal;
  margin-left: 1em;
  max-width: 300px; /* force long strings to wrap */
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view >
      .x-list-view .list-item > .elementInfo {
  color: purple;
  font-size: small;
  font-weight: bold;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view >
      .x-list-view .list-item > .time {
  color: rgb(136, 0, 0);
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view .x-list-view:focus >
      .list-item[beforeSelection] {
  background-color: rgb(171, 217, 202);
  outline: 1px dotted rgba(0, 0, 0, 0.1);
  outline-offset: 0;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view .x-list-view >
      .list-item[beforeSelection] {
  background-color: rgb(103, 199, 165);
}

</style><template id="tr-ui-e-chrome-cc-display-item-debugger-template">
  <style>
  * /deep/ tr-ui-e-chrome-cc-display-item-debugger {
    -webkit-flex: 1 1 auto;
    display: -webkit-flex;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel {
    -webkit-flex-direction: column;
    display: -webkit-flex;
    min-width: 300px;
    overflow-y: auto;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
        display-item-info {
    -webkit-flex: 1 1 auto;
    padding-top: 2px;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
        display-item-info .title {
    font-weight: bold;
    margin-left: 5px;
    margin-right: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
        display-item-info .export {
    margin: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > x-drag-handle {
    -webkit-flex: 0 0 auto;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel {
    -webkit-flex: 1 1 auto;
    display: -webkit-flex;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
      display-item-info > header {
    border-bottom: 1px solid #555;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
      display-item-info > .x-list-view > div {
    border-bottom: 1px solid #555;
    padding-top: 3px;
    padding-bottom: 3px;
    padding-left: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
      display-item-info > .x-list-view > div:hover {
    background-color: #f0f0f0;
    cursor: pointer;
  }

  /*************************************************/

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel >
      tr-ui-e-chrome-cc-picture-ops-list-view.hasPictureOps {
    display: block;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel >
        x-drag-handle.hasPictureOps {
    display: block;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel >
        tr-ui-e-chrome-cc-picture-ops-list-view {
    display: none;
    overflow-y: auto;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel >
        x-drag-handle {
    display: none;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger raster-area {
    -webkit-flex: 1 1 auto;
    background-color: #ddd;
    min-height: 200px;
    min-width: 200px;
    overflow-y: auto;
    padding-left: 5px;
  }
  </style>

  <left-panel>
    <display-item-info>
      <header>
        <span class="title">Display Item List</span>
        <span class="size"></span>
        <div class="export">
          <input class="dlfilename" type="text" value="displayitemlist.json"/>
          <button class="dlexport">Export display item list</button>
        </div>
        <div class="export">
          <input class="skpfilename" type="text" value="skpicture.skp"/>
          <button class="skpexport">Export list as SkPicture</button>
        </div>
      </header>
    </display-item-info>
  </left-panel>
  <right-panel>
    <raster-area><canvas></canvas></raster-area>
  </right-panel>
</template><style>
/* Copyright (c) 2015 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .tr-ui-e-chrome-cc-display-item-list-view {
  -webkit-flex: 1 1 auto !important;
  display: -webkit-flex;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ tr-ui-e-chrome-cc-layer-picker {
  -webkit-flex-direction: column;
  display: -webkit-flex;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > top-controls {
  -webkit-flex: 0 0 auto;
  background-image: -webkit-gradient(linear,
                                     0 0, 100% 0,
                                     from(#E5E5E5),
                                     to(#D1D1D1));
  border-bottom: 1px solid #8e8e8e;
  border-top: 1px solid white;
  display: inline;
  font-size: 14px;
  padding-left: 2px;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > top-controls input[type='checkbox'] {
    vertical-align: -2px;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > .x-list-view {
  -webkit-flex: 1 1 auto;
  font-family: monospace;
  overflow: auto;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > tr-ui-a-generic-object-view {
  -webkit-flex: 0 0 auto;
  height: 200px;
  overflow: auto;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > tr-ui-a-generic-object-view * {
  -webkit-user-select: text !important;
  cursor: text;
}

</style><style>
* /deep/ quad-stack-view {
  display: block;
  float: left;
  height: 100%;
  overflow: hidden;
  position: relative; /* For the absolute positioned mouse-mode-selector */
  width: 100%;
}

* /deep/ quad-stack-view > #header {
  position: absolute;
  font-size: 70%;
  top: 10px;
  left: 10px;
  width: 800px;
}
* /deep/ quad-stack-view > #stacking-distance-slider {
  position: absolute;
  font-size: 70%;
  top: 10px;
  right: 10px;
}

* /deep/ quad-stack-view > #chrome-left {
  content: url(data:image/png;base64,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);
  display: none;
}

* /deep/ quad-stack-view > #chrome-mid {
  content: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAABICAYAAADRa1RpAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH3QcNFycE5v9iFQAAAQtJREFUOMvtkjGSWzEMQx/0eYrM3v8k3vgqycalSwlI8Ufyl3OBFMtGIgUCIEd6PB6RBEASqvfONSrJXrDNbNkQ8ywA2y/SmayW+ZIESTsiyQsxo40xmMS2aUmYbheHpCVd0+UqJGGMsey3mUyldoUvlY3D9rIN0K7Wbe/WbZ+y1yWtaVtrp3VJzAEX6ZVjc2p7b2mtnYhNdl6m05rwtfV/ltx7XypJTpXeO7Y5juOlchzHaWxyrJmuhLapqgIJONv05+srThBgiQpBTSRwGOr3rwccgWHUhJ7P5/YNlbd/2XiL78L/WajP240AQUihfnx84EDJjCHKHjTAbkimQDgBjAJ1/3kHAgEk/gL71AHEWVXPGQAAAABJRU5ErkJggg==);
  display: none;
}

* /deep/ quad-stack-view > #chrome-right {
  content: url(data:image/png;base64,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);
  display: none;
}
</style><template id="quad-stack-view-template">
  <div id="header"></div>
  <input id="stacking-distance-slider" max="400" min="1" step="1" type="range"/>
  
  <canvas id="canvas"></canvas>
  <img id="chrome-left"/>
  <img id="chrome-mid"/>
  <img id="chrome-right"/>
</template><style>
* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view {
  position: relative;
}

* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view > top-controls {
  -webkit-flex: 0 0 auto;
  background-image: -webkit-gradient(linear,
                                     0 0, 100% 0,
                                     from(#E5E5E5),
                                     to(#D1D1D1));
  border-bottom: 1px solid #8e8e8e;
  border-top: 1px solid white;
  display: flex;
  flex-flow: row wrap;
  flex-direction: row;
  font-size:  14px;
  padding-left: 2px;
  overflow: hidden;
}

* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view >
      top-controls input[type='checkbox'] {
  vertical-align: -2px;
}

* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view > .what-rasterized {
  color: -webkit-link;
  cursor: pointer;
  text-decoration: underline;
  position: absolute;
  bottom: 10px;
  left: 10px;
}

* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view > #input-event {
  content: url(data:image/png;base64,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);
  display: none;
}
</style><template id="tr-ui-e-chrome-cc-layer-tree-quad-stack-view-template">
  <img id="input-event"/>
</template><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ tr-ui-e-chrome-cc-layer-view {
  -webkit-flex-direction: column;
  display:  -webkit-flex;
  left: 0;
  position: relative;
  top: 0;
}

* /deep/ tr-ui-e-chrome-cc-layer-view >
      tr-ui-e-chrome-cc-layer-tree-quad-stack-view {
  -webkit-flex: 1 1 100%;
  -webkit-flex-direction: column;
  min-height: 0;
  display: -webkit-flex;
  width: 100%;
}

* /deep/tr-ui-e-chrome-cc- layer-view > tr-ui-e-chrome-cc-layer-view-analysis {
  height: 150px; /* fixed height given by drag control */
  overflow-y: auto;
}

* /deep/ tr-ui-e-chrome-cc-layer-view >
      tr-ui-e-chrome-cc-layer-view-analysis * {
  -webkit-user-select: text;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .tr-ui-e-chrome-cc-lthi-s-view {
  -webkit-flex: 1 1 auto !important;
  -webkit-flex-direction: row;
  display: -webkit-flex;
}

* /deep/ .tr-ui-e-chrome-cc-lthi-s-view > tr-ui-e-chrome-cc-layer-picker {
  -webkit-flex: 1 1 auto;
}

* /deep/ .tr-ui-e-chrome-cc-lthi-s-view > x-drag-handle {
  -webkit-flex: 0 0 auto;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ tr-ui-e-chrome-cc-picture-ops-chart-summary-view {
  -webkit-flex: 0 0 auto;
  font-size: 0;
  margin: 0;
  min-height: 200px;
  min-width: 200px;
  overflow: hidden;
  padding: 0;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-chart-summary-view.hidden {
  display: none;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ tr-ui-e-chrome-cc-picture-ops-chart-view {
  display: block;
  height: 180px;
  margin: 0;
  padding: 0;
  position: relative;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-chart-view > .use-percentile-scale {
  left: 0;
  position: absolute;
  top: 0;
}

</style><template id="tr-ui-e-chrome-cc-picture-debugger-template">
  <style>
  * /deep/ tr-ui-e-chrome-cc-picture-debugger {
    -webkit-flex: 1 1 auto;
    -webkit-flex-direction: row;
    display: -webkit-flex;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > tr-ui-a-generic-object-view {
    -webkit-flex-direction: column;
    display: -webkit-flex;
    width: 400px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > left-panel {
    -webkit-flex-direction: column;
    display: -webkit-flex;
    min-width: 300px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > left-panel > picture-info {
    -webkit-flex: 0 0 auto;
    padding-top: 2px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > left-panel >
        picture-info .title {
    font-weight: bold;
    margin-left: 5px;
    margin-right: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > x-drag-handle {
    -webkit-flex: 0 0 auto;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger .filename {
    -webkit-user-select: text;
    margin-left: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > right-panel {
    -webkit-flex: 1 1 auto;
    -webkit-flex-direction: column;
    display: -webkit-flex;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > right-panel >
        tr-ui-e-chrome-cc-picture-ops-chart-view {
    min-height: 150px;
    min-width : 0;
    overflow-x: auto;
    overflow-y: hidden;
  }

  /*************************************************/

  * /deep/ tr-ui-e-chrome-cc-picture-debugger raster-area {
    background-color: #ddd;
    min-height: 200px;
    min-width: 200px;
    overflow-y: auto;
    padding-left: 5px;
  }
  </style>

  <left-panel>
    <picture-info>
      <div>
        <span class="title">Skia Picture</span>
        <span class="size"></span>
      </div>
      <div>
        <input class="filename" type="text" value="skpicture.skp"/>
        <button class="export">Export</button>
      </div>
    </picture-info>
  </left-panel>
  <right-panel>
    <tr-ui-e-chrome-cc-picture-ops-chart-view>
    </tr-ui-e-chrome-cc-picture-ops-chart-view>
    <raster-area><canvas></canvas></raster-area>
  </right-panel>
</template><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .tr-ui-e-chrome-cc-picture-snapshot-view {
  -webkit-flex: 0 1 auto !important;
  display: -webkit-flex;
}

</style><polymer-element name="tr-ui-e-chrome-cc-raster-task-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #heading {
      flex: 0 0 auto;
    }
    </style>

    <div id="heading">
      Rasterization costs in
      <tr-ui-a-analysis-link id="link"></tr-ui-a-analysis-link>
    </div>
    <tr-ui-b-table id="content"></tr-ui-b-table>
  </template>

  
</polymer-element><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-chrome-gpu-state-snapshot-view {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAZiS0dEAEwATABMYqp3KAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90JCQsBMCH7ZqYAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAUElEQVRYw+3WwQkAIAiF4Vc0hTO5/wiuURvYIcQOv1cRPhDlDXffSsrMsrYiQi/zU80FAACAVX3nt3lWAABA/x+ovnPyAAAA5AHyAAAA3wMOd34Xd+lsglgAAAAASUVORK5CYII=);
  display: -webkit-flex;
  overflow: auto;
}

.tr-ui-e-chrome-gpu-state-snapshot-view img {
  display: block;
  margin: 16px auto 16px auto;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-system-stats-snapshot-view .subhead {
  font-size: small;
  padding-bottom: 10px;
}

.tr-ui-e-system-stats-snapshot-view ul {
  background-position: 0 5px;
  background-repeat: no-repeat;
  cursor: pointer;
  font-family: monospace;
  list-style: none;
  margin: 0;
  padding-left: 15px;
}

.tr-ui-e-system-stats-snapshot-view li {
  background-position: 0 5px;
  background-repeat: no-repeat;
  cursor: pointer;
  list-style: none;
  margin: 0;
  padding-left: 15px;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-system-stats-instance-track {
  height: 500px;
}

.tr-ui-e-system-stats-instance-track ul {
  list-style: none;
  list-style-position: outside;
  margin: 0;
  overflow: hidden;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-tcmalloc-instance-view .subhead {
  font-size: small;
  padding-bottom: 10px;
}

.tr-ui-e-tcmalloc-instance-view #args {
  white-space: pre;
}

.tr-ui-e-tcmalloc-instance-view #snapshots > * {
  display: block;
}

.tr-ui-e-tcmalloc-instance-view {
  overflow: auto;
}

.tr-ui-e-tcmalloc-instance-view * {
  -webkit-user-select: text;
}

.tr-ui-e-tcmalloc-instance-view .title {
  border-bottom: 1px solid rgb(128, 128, 128);
  font-size: 110%;
  font-weight: bold;
}

.tr-ui-e-tcmalloc-instance-view td,
.tr-ui-e-tcmalloc-instance-view th {
  font-size: small;
  text-align: right;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-tcmalloc-heap-snapshot-view .subhead {
  font-size: small;
  padding-bottom: 10px;
}

.tr-ui-e-tcmalloc-heap-snapshot-view ul {
  background-position: 0 5px;
  background-repeat: no-repeat;
  cursor: pointer;
  font-family: monospace;
  list-style: none;
  margin: 0;
  padding-left: 15px;
}

.tr-ui-e-tcmalloc-heap-snapshot-view li {
  background-position: 0 5px;
  background-repeat: no-repeat;
  cursor: pointer;
  list-style: none;
  margin: 0;
  padding-left: 15px;
}

/* Collapsed state for list element */
.tr-ui-e-tcmalloc-heap-snapshot-view .collapsed {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAMAAADz0U65AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAwBQTFRFAAAAVVVVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASd3+7gAAAQB0Uk5T////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AFP3ByUAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjbQg61aAAAAGklEQVQYV2P4//8/IyOQYMBkMEIBA5yBWzEAD3Mj+VR5R78AAAAASUVORK5CYII=);
}

/* Expanded state for list element. Must be located under the collapsed one. */
.tr-ui-e-tcmalloc-heap-snapshot-view .expanded {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAABl0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjUuNtCDrVoAAAAoSURBVChTY2CgKggNDVUHYnsUQ4EC//FhBoIKkI0DKlYAYhmqupsBAMwgJH8K5nKoAAAAAElFTkSuQmCC);
}

/* Allocation size in MB, right-aligned for easier comparison of columns. */
.tr-ui-e-tcmalloc-heap-snapshot-view .trace-bytes {
  display: inline-block;
  padding-right: 10px;
  text-align: right;
  width: 80px;
}

/* Trace allocation count. */
.tr-ui-e-tcmalloc-heap-snapshot-view .trace-allocs {
  display: inline-block;
  padding-right: 10px;
  text-align: right;
  width: 120px;
}

/* Trace name, inline so it appears to the right of the byte count. */
.tr-ui-e-tcmalloc-heap-snapshot-view .trace-name {
  display: inline-block;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-tcmalloc-heap-instance-track {
  height: 150px;
}

.tr-ui-e-tcmalloc-heap-instance-track ul {
  list-style: none;
  list-style-position: outside;
  margin: 0;
  overflow: hidden;
}

</style><polymer-element extends="tr-ui-side-panel" name="tr-ui-e-s-input-latency-side-panel">
  <template>
    <style>
    :host {
      flex-direction: column;
      display: flex;
    }
    toolbar {
      flex: 0 0 auto;
      border-bottom: 1px solid black;
      display: flex;
    }
    result-area {
      flex: 1 1 auto;
      display: block;
      min-height: 0;
      overflow-y: auto;
    }
    </style>

    <toolbar id="toolbar"></toolbar>
    <result-area id="result_area"></result-area>
  </template>

  
</polymer-element><style>
/* Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */
* /deep/ .pie-chart .arc-text {
  font-size: 8pt;
}

* /deep/ .pie-chart .label {
  font-size: 10pt;
}

* /deep/ .pie-chart polyline {
  fill: none;
  stroke: black;
}

</style><polymer-element extends="tr-ui-side-panel" name="tr-ui-e-s-time-summary-side-panel">
  <template>
    <style>
    :host {
      flex-direction: column;
      display: flex;
    }
    toolbar {
      flex: 0 0 auto;
      border-bottom: 1px solid black;
      display: flex;
    }
    result-area {
      flex: 1 1 auto;
      display: block;
      min-height: 0;
      overflow-y: auto;
    }
    </style>

    <toolbar id="toolbar"></toolbar>
    <result-area id="result_area"></result-area>
  </template>

  
</polymer-element><polymer-element name="tr-ui-e-rail-rail-score-span">
  <template>
  <style>
    :host {
      display: span;
    }
  </style>
  <span id="content">
    <span>RAIL Score: </span><span id="score"></span>
  </span>
  </template>
  
</polymer-element><polymer-element extends="tr-ui-side-panel" name="tr-ui-e-rail-rail-score-side-panel">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
      width: 450px;
      overflow-x: auto;
    }

    #score {
      background-color: rgb(236, 236, 236)
      flex: 0 0 auto;
    }

    #content {
      min-width: 0;
      flex-direction: column;
      display: flex;
      flex: 1 1 auto;
    }

    #coverage {
      font-size: 10px;
    }
    </style>

    <tr-ui-e-rail-rail-score-span id="score"></tr-ui-e-rail-rail-score-span>
    <tr-ui-b-table id="table"></tr-ui-b-table>

    <div id="coverage">
      <b>Coverage:</b><br/>
      <tr-ui-a-analysis-link id="associated-events"></tr-ui-a-analysis-link><br/>
      <tr-ui-a-analysis-link id="unassociated-events"></tr-ui-a-analysis-link>
    </div>
    <button id="test">Create Test</button>
  </template>
</polymer-element><!--
The chrome config is heavily used:
  - chrome://tracing,
  - trace2html, which in turn implies
    - adb_profile_chrome
    - telemetry
--><!-- Core UI configs --><!-- Lots of chrome-specific extras --><!-- Side panels --><!-- RAIL is fun too --><polymer-element extends="tr-ui-side-panel" name="tr-ui-e-s-alerts-side-panel">
  <template>
    <style>
    :host {
      display: block;
      width: 250px;
    }
    #content {
      flex-direction: column;
      display: flex;
    }
    </style>

    <div id="content">
      <toolbar id="toolbar"></toolbar>
      <result-area id="result_area"></result-area>
    </div>
  </template>

  
</polymer-element><!-- Core and UI configs. --><!-- Features used by Android systrace. --><!--
The lean config is just enough to import uncompressed, trace-event-formatted
json blobs.
--><script>

// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/* WARNING: This file is auto generated.
 *
 * Do not edit directly.
 */

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.5.5
window.PolymerGestures={},function(a){var b=!1,c=document.createElement("meta");if(c.createShadowRoot){var d=c.createShadowRoot(),e=document.createElement("span");d.appendChild(e),c.addEventListener("testpath",function(a){a.path&&(b=a.path[0]===e),a.stopPropagation()});var f=new CustomEvent("testpath",{bubbles:!0});document.head.appendChild(c),e.dispatchEvent(f),c.parentNode.removeChild(c),d=e=null}c=null;var g={shadow:function(a){return a?a.shadowRoot||a.webkitShadowRoot:void 0},canTarget:function(a){return a&&Boolean(a.elementFromPoint)},targetingShadow:function(a){var b=this.shadow(a);return this.canTarget(b)?b:void 0},olderShadow:function(a){var b=a.olderShadowRoot;if(!b){var c=a.querySelector("shadow");c&&(b=c.olderShadowRoot)}return b},allShadows:function(a){for(var b=[],c=this.shadow(a);c;)b.push(c),c=this.olderShadow(c);return b},searchRoot:function(a,b,c){var d,e;return a?(d=a.elementFromPoint(b,c),d?e=this.targetingShadow(d):a!==document&&(e=this.olderShadow(a)),this.searchRoot(e,b,c)||d):void 0},owner:function(a){if(!a)return document;for(var b=a;b.parentNode;)b=b.parentNode;return b.nodeType!=Node.DOCUMENT_NODE&&b.nodeType!=Node.DOCUMENT_FRAGMENT_NODE&&(b=document),b},findTarget:function(a){if(b&&a.path&&a.path.length)return a.path[0];var c=a.clientX,d=a.clientY,e=this.owner(a.target);return e.elementFromPoint(c,d)||(e=document),this.searchRoot(e,c,d)},findTouchAction:function(a){var c;if(b&&a.path&&a.path.length){for(var d=a.path,e=0;e<d.length;e++)if(c=d[e],c.nodeType===Node.ELEMENT_NODE&&c.hasAttribute("touch-action"))return c.getAttribute("touch-action")}else for(c=a.target;c;){if(c.nodeType===Node.ELEMENT_NODE&&c.hasAttribute("touch-action"))return c.getAttribute("touch-action");c=c.parentNode||c.host}return"auto"},LCA:function(a,b){if(a===b)return a;if(a&&!b)return a;if(b&&!a)return b;if(!b&&!a)return document;if(a.contains&&a.contains(b))return a;if(b.contains&&b.contains(a))return b;var c=this.depth(a),d=this.depth(b),e=c-d;for(e>=0?a=this.walk(a,e):b=this.walk(b,-e);a&&b&&a!==b;)a=a.parentNode||a.host,b=b.parentNode||b.host;return a},walk:function(a,b){for(var c=0;a&&b>c;c++)a=a.parentNode||a.host;return a},depth:function(a){for(var b=0;a;)b++,a=a.parentNode||a.host;return b},deepContains:function(a,b){var c=this.LCA(a,b);return c===a},insideNode:function(a,b,c){var d=a.getBoundingClientRect();return d.left<=b&&b<=d.right&&d.top<=c&&c<=d.bottom},path:function(a){var c;if(b&&a.path&&a.path.length)c=a.path;else{c=[];for(var d=this.findTarget(a);d;)c.push(d),d=d.parentNode||d.host}return c}};a.targetFinding=g,a.findTarget=g.findTarget.bind(g),a.deepContains=g.deepContains.bind(g),a.insideNode=g.insideNode}(window.PolymerGestures),function(){function a(a){return"html /deep/ "+b(a)}function b(a){return'[touch-action="'+a+'"]'}function c(a){return"{ -ms-touch-action: "+a+"; touch-action: "+a+";}"}var d=["none","auto","pan-x","pan-y",{rule:"pan-x pan-y",selectors:["pan-x pan-y","pan-y pan-x"]},"manipulation"],e="",f="string"==typeof document.head.style.touchAction,g=!window.ShadowDOMPolyfill&&document.head.createShadowRoot;if(f){d.forEach(function(d){String(d)===d?(e+=b(d)+c(d)+"\n",g&&(e+=a(d)+c(d)+"\n")):(e+=d.selectors.map(b)+c(d.rule)+"\n",g&&(e+=d.selectors.map(a)+c(d.rule)+"\n"))});var h=document.createElement("style");h.textContent=e,document.head.appendChild(h)}}(),function(a){var b=["bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","pageX","pageY"],c=[!1,!1,null,null,0,0,0,0,!1,!1,!1,!1,0,null,0,0],d=function(){return function(){}},e={preventTap:d,makeBaseEvent:function(a,b){var c=document.createEvent("Event");return c.initEvent(a,b.bubbles||!1,b.cancelable||!1),c.preventTap=e.preventTap(c),c},makeGestureEvent:function(a,b){b=b||Object.create(null);for(var c,d=this.makeBaseEvent(a,b),e=0,f=Object.keys(b);e<f.length;e++)c=f[e],"bubbles"!==c&&"cancelable"!==c&&(d[c]=b[c]);return d},makePointerEvent:function(a,d){d=d||Object.create(null);for(var e,f=this.makeBaseEvent(a,d),g=2;g<b.length;g++)e=b[g],f[e]=d[e]||c[g];f.buttons=d.buttons||0;var h=0;return h=d.pressure?d.pressure:f.buttons?.5:0,f.x=f.clientX,f.y=f.clientY,f.pointerId=d.pointerId||0,f.width=d.width||0,f.height=d.height||0,f.pressure=h,f.tiltX=d.tiltX||0,f.tiltY=d.tiltY||0,f.pointerType=d.pointerType||"",f.hwTimestamp=d.hwTimestamp||0,f.isPrimary=d.isPrimary||!1,f._source=d._source||"",f}};a.eventFactory=e}(window.PolymerGestures),function(a){function b(){if(c){var a=new Map;return a.pointers=d,a}this.keys=[],this.values=[]}var c=window.Map&&window.Map.prototype.forEach,d=function(){return this.size};b.prototype={set:function(a,b){var c=this.keys.indexOf(a);c>-1?this.values[c]=b:(this.keys.push(a),this.values.push(b))},has:function(a){return this.keys.indexOf(a)>-1},"delete":function(a){var b=this.keys.indexOf(a);b>-1&&(this.keys.splice(b,1),this.values.splice(b,1))},get:function(a){var b=this.keys.indexOf(a);return this.values[b]},clear:function(){this.keys.length=0,this.values.length=0},forEach:function(a,b){this.values.forEach(function(c,d){a.call(b,c,this.keys[d],this)},this)},pointers:function(){return this.keys.length}},a.PointerMap=b}(window.PolymerGestures),function(a){var b,c=["bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","buttons","pointerId","width","height","pressure","tiltX","tiltY","pointerType","hwTimestamp","isPrimary","type","target","currentTarget","which","pageX","pageY","timeStamp","preventTap","tapPrevented","_source"],d=[!1,!1,null,null,0,0,0,0,!1,!1,!1,!1,0,null,0,0,0,0,0,0,0,"",0,!1,"",null,null,0,0,0,0,function(){},!1],e="undefined"!=typeof SVGElementInstance,f=a.eventFactory,g={IS_IOS:!1,pointermap:new a.PointerMap,requiredGestures:new a.PointerMap,eventMap:Object.create(null),eventSources:Object.create(null),eventSourceList:[],gestures:[],dependencyMap:{down:{listeners:0,index:-1},up:{listeners:0,index:-1}},gestureQueue:[],registerSource:function(a,b){var c=b,d=c.events;d&&(d.forEach(function(a){c[a]&&(this.eventMap[a]=c[a].bind(c))},this),this.eventSources[a]=c,this.eventSourceList.push(c))},registerGesture:function(a,b){var c=Object.create(null);c.listeners=0,c.index=this.gestures.length;for(var d,e=0;e<b.exposes.length;e++)d=b.exposes[e].toLowerCase(),this.dependencyMap[d]=c;this.gestures.push(b)},register:function(a,b){for(var c,d=this.eventSourceList.length,e=0;d>e&&(c=this.eventSourceList[e]);e++)c.register.call(c,a,b)},unregister:function(a){for(var b,c=this.eventSourceList.length,d=0;c>d&&(b=this.eventSourceList[d]);d++)b.unregister.call(b,a)},down:function(a){this.requiredGestures.set(a.pointerId,b),this.fireEvent("down",a)},move:function(a){a.type="move",this.fillGestureQueue(a)},up:function(a){this.fireEvent("up",a),this.requiredGestures["delete"](a.pointerId)},cancel:function(a){a.tapPrevented=!0,this.fireEvent("up",a),this.requiredGestures["delete"](a.pointerId)},addGestureDependency:function(a,b){var c=a._pgEvents;if(c&&b)for(var d,e,f,g=Object.keys(c),h=0;h<g.length;h++)f=g[h],c[f]>0&&(d=this.dependencyMap[f],e=d?d.index:-1,b[e]=!0)},eventHandler:function(c){var d=c.type;if("touchstart"===d||"mousedown"===d||"pointerdown"===d||"MSPointerDown"===d)if(c._handledByPG||(b={}),this.IS_IOS){var e=c;if("touchstart"===d){var f=c.changedTouches[0];e={target:c.target,clientX:f.clientX,clientY:f.clientY,path:c.path}}for(var g,h=c.path||a.targetFinding.path(e),i=0;i<h.length;i++)g=h[i],this.addGestureDependency(g,b)}else this.addGestureDependency(c.currentTarget,b);if(!c._handledByPG){var j=this.eventMap&&this.eventMap[d];j&&j(c),c._handledByPG=!0}},listen:function(a,b){for(var c,d=0,e=b.length;e>d&&(c=b[d]);d++)this.addEvent(a,c)},unlisten:function(a,b){for(var c,d=0,e=b.length;e>d&&(c=b[d]);d++)this.removeEvent(a,c)},addEvent:function(a,b){a.addEventListener(b,this.boundHandler)},removeEvent:function(a,b){a.removeEventListener(b,this.boundHandler)},makeEvent:function(a,b){var c=f.makePointerEvent(a,b);return c.preventDefault=b.preventDefault,c.tapPrevented=b.tapPrevented,c._target=c._target||b.target,c},fireEvent:function(a,b){var c=this.makeEvent(a,b);return this.dispatchEvent(c)},cloneEvent:function(a){for(var b,f=Object.create(null),g=0;g<c.length;g++)b=c[g],f[b]=a[b]||d[g],("target"===b||"relatedTarget"===b)&&e&&f[b]instanceof SVGElementInstance&&(f[b]=f[b].correspondingUseElement);return f.preventDefault=function(){a.preventDefault()},f},dispatchEvent:function(a){var b=a._target;if(b){b.dispatchEvent(a);var c=this.cloneEvent(a);c.target=b,this.fillGestureQueue(c)}},gestureTrigger:function(){for(var a,b,c=0;c<this.gestureQueue.length;c++)if(a=this.gestureQueue[c],b=a._requiredGestures)for(var d,e,f=0;f<this.gestures.length;f++)b[f]&&(d=this.gestures[f],e=d[a.type],e&&e.call(d,a));this.gestureQueue.length=0},fillGestureQueue:function(a){this.gestureQueue.length||requestAnimationFrame(this.boundGestureTrigger),a._requiredGestures=this.requiredGestures.get(a.pointerId),this.gestureQueue.push(a)}};g.boundHandler=g.eventHandler.bind(g),g.boundGestureTrigger=g.gestureTrigger.bind(g),a.dispatcher=g,a.activateGesture=function(a,b){var c=b.toLowerCase(),d=g.dependencyMap[c];if(d){var e=g.gestures[d.index];if(a._pgListeners||(g.register(a),a._pgListeners=0),e){var f,h=e.defaultActions&&e.defaultActions[c];switch(a.nodeType){case Node.ELEMENT_NODE:f=a;break;case Node.DOCUMENT_FRAGMENT_NODE:f=a.host;break;default:f=null}h&&f&&!f.hasAttribute("touch-action")&&f.setAttribute("touch-action",h)}a._pgEvents||(a._pgEvents={}),a._pgEvents[c]=(a._pgEvents[c]||0)+1,a._pgListeners++}return Boolean(d)},a.addEventListener=function(b,c,d,e){d&&(a.activateGesture(b,c),b.addEventListener(c,d,e))},a.deactivateGesture=function(a,b){var c=b.toLowerCase(),d=g.dependencyMap[c];return d&&(a._pgListeners>0&&a._pgListeners--,0===a._pgListeners&&g.unregister(a),a._pgEvents&&(a._pgEvents[c]>0?a._pgEvents[c]--:a._pgEvents[c]=0)),Boolean(d)},a.removeEventListener=function(b,c,d,e){d&&(a.deactivateGesture(b,c),b.removeEventListener(c,d,e))}}(window.PolymerGestures),function(a){var b=a.dispatcher,c=b.pointermap,d=25,e=[0,1,4,2],f=0,g=/Linux.*Firefox\//i,h=function(){if(g.test(navigator.userAgent))return!1;try{return 1===new MouseEvent("test",{buttons:1}).buttons}catch(a){return!1}}(),i={POINTER_ID:1,POINTER_TYPE:"mouse",events:["mousedown","mousemove","mouseup"],exposes:["down","up","move"],register:function(a){b.listen(a,this.events)},unregister:function(a){a.nodeType!==Node.DOCUMENT_NODE&&b.unlisten(a,this.events)},lastTouches:[],isEventSimulatedFromTouch:function(a){for(var b,c=this.lastTouches,e=a.clientX,f=a.clientY,g=0,h=c.length;h>g&&(b=c[g]);g++){var i=Math.abs(e-b.x),j=Math.abs(f-b.y);if(d>=i&&d>=j)return!0}},prepareEvent:function(a){var c=b.cloneEvent(a);if(c.pointerId=this.POINTER_ID,c.isPrimary=!0,c.pointerType=this.POINTER_TYPE,c._source="mouse",!h){var d=a.type,g=e[a.which]||0;"mousedown"===d?f|=g:"mouseup"===d&&(f&=~g),c.buttons=f}return c},mousedown:function(d){if(!this.isEventSimulatedFromTouch(d)){var e=(c.has(this.POINTER_ID),this.prepareEvent(d));e.target=a.findTarget(d),c.set(this.POINTER_ID,e.target),b.down(e)}},mousemove:function(a){if(!this.isEventSimulatedFromTouch(a)){var d=c.get(this.POINTER_ID);if(d){var e=this.prepareEvent(a);e.target=d,0===(h?e.buttons:e.which)?(h||(f=e.buttons=0),b.cancel(e),this.cleanupMouse(e.buttons)):b.move(e)}}},mouseup:function(d){if(!this.isEventSimulatedFromTouch(d)){var e=this.prepareEvent(d);e.relatedTarget=a.findTarget(d),e.target=c.get(this.POINTER_ID),b.up(e),this.cleanupMouse(e.buttons)}},cleanupMouse:function(a){0===a&&c["delete"](this.POINTER_ID)}};a.mouseEvents=i}(window.PolymerGestures),function(a){var b=a.dispatcher,c=(a.targetFinding.allShadows.bind(a.targetFinding),b.pointermap),d=(Array.prototype.map.call.bind(Array.prototype.map),2500),e=25,f=200,g=20,h=!1,i={IS_IOS:!1,events:["touchstart","touchmove","touchend","touchcancel"],exposes:["down","up","move"],register:function(a,c){(this.IS_IOS?c:!c)&&b.listen(a,this.events)},unregister:function(a){this.IS_IOS||b.unlisten(a,this.events)},scrollTypes:{EMITTER:"none",XSCROLLER:"pan-x",YSCROLLER:"pan-y"},touchActionToScrollType:function(a){var b=a,c=this.scrollTypes;return b===c.EMITTER?"none":b===c.XSCROLLER?"X":b===c.YSCROLLER?"Y":"XY"},POINTER_TYPE:"touch",firstTouch:null,isPrimaryTouch:function(a){return this.firstTouch===a.identifier},setPrimaryTouch:function(a){(0===c.pointers()||1===c.pointers()&&c.has(1))&&(this.firstTouch=a.identifier,this.firstXY={X:a.clientX,Y:a.clientY},this.firstTarget=a.target,this.scrolling=null,this.cancelResetClickCount())},removePrimaryPointer:function(a){a.isPrimary&&(this.firstTouch=null,this.firstXY=null,this.resetClickCount())},clickCount:0,resetId:null,resetClickCount:function(){var a=function(){this.clickCount=0,this.resetId=null}.bind(this);this.resetId=setTimeout(a,f)},cancelResetClickCount:function(){this.resetId&&clearTimeout(this.resetId)},typeToButtons:function(a){var b=0;return("touchstart"===a||"touchmove"===a)&&(b=1),b},findTarget:function(b,d){if("touchstart"===this.currentTouchEvent.type){if(this.isPrimaryTouch(b)){var e={clientX:b.clientX,clientY:b.clientY,path:this.currentTouchEvent.path,target:this.currentTouchEvent.target};return a.findTarget(e)}return a.findTarget(b)}return c.get(d)},touchToPointer:function(a){var c=this.currentTouchEvent,d=b.cloneEvent(a),e=d.pointerId=a.identifier+2;d.target=this.findTarget(a,e),d.bubbles=!0,d.cancelable=!0,d.detail=this.clickCount,d.buttons=this.typeToButtons(c.type),d.width=a.webkitRadiusX||a.radiusX||0,d.height=a.webkitRadiusY||a.radiusY||0,d.pressure=a.webkitForce||a.force||.5,d.isPrimary=this.isPrimaryTouch(a),d.pointerType=this.POINTER_TYPE,d._source="touch";var f=this;return d.preventDefault=function(){f.scrolling=!1,f.firstXY=null,c.preventDefault()},d},processTouches:function(a,b){var d=a.changedTouches;this.currentTouchEvent=a;for(var e,f,g=0;g<d.length;g++)e=d[g],f=this.touchToPointer(e),"touchstart"===a.type&&c.set(f.pointerId,f.target),c.has(f.pointerId)&&b.call(this,f),("touchend"===a.type||a._cancel)&&this.cleanUpPointer(f)},shouldScroll:function(b){if(this.firstXY){var c,d=a.targetFinding.findTouchAction(b),e=this.touchActionToScrollType(d);if("none"===e)c=!1;else if("XY"===e)c=!0;else{var f=b.changedTouches[0],g=e,h="Y"===e?"X":"Y",i=Math.abs(f["client"+g]-this.firstXY[g]),j=Math.abs(f["client"+h]-this.firstXY[h]);c=i>=j}return c}},findTouch:function(a,b){for(var c,d=0,e=a.length;e>d&&(c=a[d]);d++)if(c.identifier===b)return!0},vacuumTouches:function(a){var b=a.touches;if(c.pointers()>=b.length){var d=[];c.forEach(function(a,c){if(1!==c&&!this.findTouch(b,c-2)){var e=a;d.push(e)}},this),d.forEach(function(a){this.cancel(a),c["delete"](a.pointerId)},this)}},touchstart:function(a){this.vacuumTouches(a),this.setPrimaryTouch(a.changedTouches[0]),this.dedupSynthMouse(a),this.scrolling||(this.clickCount++,this.processTouches(a,this.down))},down:function(a){b.down(a)},touchmove:function(a){if(h)a.cancelable&&this.processTouches(a,this.move);else if(this.scrolling){if(this.firstXY){var b=a.changedTouches[0],c=b.clientX-this.firstXY.X,d=b.clientY-this.firstXY.Y,e=Math.sqrt(c*c+d*d);e>=g&&(this.touchcancel(a),this.scrolling=!0,this.firstXY=null)}}else null===this.scrolling&&this.shouldScroll(a)?this.scrolling=!0:(this.scrolling=!1,a.preventDefault(),this.processTouches(a,this.move))},move:function(a){b.move(a)},touchend:function(a){this.dedupSynthMouse(a),this.processTouches(a,this.up)},up:function(c){c.relatedTarget=a.findTarget(c),b.up(c)},cancel:function(a){b.cancel(a)},touchcancel:function(a){a._cancel=!0,this.processTouches(a,this.cancel)},cleanUpPointer:function(a){c["delete"](a.pointerId),this.removePrimaryPointer(a)},dedupSynthMouse:function(b){var c=a.mouseEvents.lastTouches,e=b.changedTouches[0];if(this.isPrimaryTouch(e)){var f={x:e.clientX,y:e.clientY};c.push(f);var g=function(a,b){var c=a.indexOf(b);c>-1&&a.splice(c,1)}.bind(null,c,f);setTimeout(g,d)}}},j=Event.prototype.stopImmediatePropagation||Event.prototype.stopPropagation;document.addEventListener("click",function(b){var c=b.clientX,d=b.clientY,f=function(a){var b=Math.abs(c-a.x),f=Math.abs(d-a.y);return e>=b&&e>=f},g=a.mouseEvents.lastTouches.some(f),h=a.targetFinding.path(b);if(g){for(var k=0;k<h.length;k++)if(h[k]===i.firstTarget)return;b.preventDefault(),j.call(b)}},!0),a.touchEvents=i}(window.PolymerGestures),function(a){var b=a.dispatcher,c=b.pointermap,d=window.MSPointerEvent&&"number"==typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE,e={events:["MSPointerDown","MSPointerMove","MSPointerUp","MSPointerCancel"],register:function(a){b.listen(a,this.events)},unregister:function(a){a.nodeType!==Node.DOCUMENT_NODE&&b.unlisten(a,this.events)},POINTER_TYPES:["","unavailable","touch","pen","mouse"],prepareEvent:function(a){var c=a;return c=b.cloneEvent(a),d&&(c.pointerType=this.POINTER_TYPES[a.pointerType]),c._source="ms",c},cleanup:function(a){c["delete"](a)},MSPointerDown:function(d){var e=this.prepareEvent(d);e.target=a.findTarget(d),c.set(d.pointerId,e.target),b.down(e)},MSPointerMove:function(a){var d=c.get(a.pointerId);if(d){var e=this.prepareEvent(a);e.target=d,b.move(e)}},MSPointerUp:function(d){var e=this.prepareEvent(d);e.relatedTarget=a.findTarget(d),e.target=c.get(e.pointerId),b.up(e),this.cleanup(d.pointerId)},MSPointerCancel:function(d){var e=this.prepareEvent(d);e.relatedTarget=a.findTarget(d),e.target=c.get(e.pointerId),b.cancel(e),this.cleanup(d.pointerId)}};a.msEvents=e}(window.PolymerGestures),function(a){var b=a.dispatcher,c=b.pointermap,d={events:["pointerdown","pointermove","pointerup","pointercancel"],prepareEvent:function(a){var c=b.cloneEvent(a);return c._source="pointer",c},register:function(a){b.listen(a,this.events)},unregister:function(a){a.nodeType!==Node.DOCUMENT_NODE&&b.unlisten(a,this.events)},cleanup:function(a){c["delete"](a)},pointerdown:function(d){var e=this.prepareEvent(d);e.target=a.findTarget(d),c.set(e.pointerId,e.target),b.down(e)},pointermove:function(a){var d=c.get(a.pointerId);if(d){var e=this.prepareEvent(a);e.target=d,b.move(e)}},pointerup:function(d){var e=this.prepareEvent(d);e.relatedTarget=a.findTarget(d),e.target=c.get(e.pointerId),b.up(e),this.cleanup(d.pointerId)},pointercancel:function(d){var e=this.prepareEvent(d);e.relatedTarget=a.findTarget(d),e.target=c.get(e.pointerId),b.cancel(e),this.cleanup(d.pointerId)}};a.pointerEvents=d}(window.PolymerGestures),function(a){var b=a.dispatcher,c=window.navigator;window.PointerEvent?b.registerSource("pointer",a.pointerEvents):c.msPointerEnabled?b.registerSource("ms",a.msEvents):(b.registerSource("mouse",a.mouseEvents),void 0!==window.ontouchstart&&b.registerSource("touch",a.touchEvents));var d=navigator.userAgent,e=d.match(/iPad|iPhone|iPod/)&&"ontouchstart"in window;b.IS_IOS=e,a.touchEvents.IS_IOS=e,b.register(document,!0)}(window.PolymerGestures),function(a){var b=a.dispatcher,c=a.eventFactory,d=new a.PointerMap,e={events:["down","move","up"],exposes:["trackstart","track","trackx","tracky","trackend"],defaultActions:{track:"none",trackx:"pan-y",tracky:"pan-x"},WIGGLE_THRESHOLD:4,clampDir:function(a){return a>0?1:-1},calcPositionDelta:function(a,b){var c=0,d=0;return a&&b&&(c=b.pageX-a.pageX,d=b.pageY-a.pageY),{x:c,y:d}},fireTrack:function(a,b,d){var e=d,f=this.calcPositionDelta(e.downEvent,b),g=this.calcPositionDelta(e.lastMoveEvent,b);if(g.x)e.xDirection=this.clampDir(g.x);else if("trackx"===a)return;if(g.y)e.yDirection=this.clampDir(g.y);else if("tracky"===a)return;var h={bubbles:!0,cancelable:!0,trackInfo:e.trackInfo,relatedTarget:b.relatedTarget,pointerType:b.pointerType,pointerId:b.pointerId,_source:"track"};"tracky"!==a&&(h.x=b.x,h.dx=f.x,h.ddx=g.x,h.clientX=b.clientX,h.pageX=b.pageX,h.screenX=b.screenX,h.xDirection=e.xDirection),"trackx"!==a&&(h.dy=f.y,h.ddy=g.y,h.y=b.y,h.clientY=b.clientY,h.pageY=b.pageY,h.screenY=b.screenY,h.yDirection=e.yDirection);var i=c.makeGestureEvent(a,h);e.downTarget.dispatchEvent(i)},down:function(a){if(a.isPrimary&&("mouse"===a.pointerType?1===a.buttons:!0)){var b={downEvent:a,downTarget:a.target,trackInfo:{},lastMoveEvent:null,xDirection:0,yDirection:0,tracking:!1};d.set(a.pointerId,b)}},move:function(a){var b=d.get(a.pointerId);if(b){if(!b.tracking){var c=this.calcPositionDelta(b.downEvent,a),e=c.x*c.x+c.y*c.y;e>this.WIGGLE_THRESHOLD&&(b.tracking=!0,b.lastMoveEvent=b.downEvent,this.fireTrack("trackstart",a,b))}b.tracking&&(this.fireTrack("track",a,b),this.fireTrack("trackx",a,b),this.fireTrack("tracky",a,b)),b.lastMoveEvent=a}},up:function(a){var b=d.get(a.pointerId);b&&(b.tracking&&this.fireTrack("trackend",a,b),d["delete"](a.pointerId))}};b.registerGesture("track",e)}(window.PolymerGestures),function(a){var b=a.dispatcher,c=a.eventFactory,d={HOLD_DELAY:200,WIGGLE_THRESHOLD:16,events:["down","move","up"],exposes:["hold","holdpulse","release"],heldPointer:null,holdJob:null,pulse:function(){var a=Date.now()-this.heldPointer.timeStamp,b=this.held?"holdpulse":"hold";this.fireHold(b,a),this.held=!0},cancel:function(){clearInterval(this.holdJob),this.held&&this.fireHold("release"),this.held=!1,this.heldPointer=null,this.target=null,this.holdJob=null},down:function(a){a.isPrimary&&!this.heldPointer&&(this.heldPointer=a,this.target=a.target,this.holdJob=setInterval(this.pulse.bind(this),this.HOLD_DELAY))},up:function(a){this.heldPointer&&this.heldPointer.pointerId===a.pointerId&&this.cancel()},move:function(a){if(this.heldPointer&&this.heldPointer.pointerId===a.pointerId){var b=a.clientX-this.heldPointer.clientX,c=a.clientY-this.heldPointer.clientY;b*b+c*c>this.WIGGLE_THRESHOLD&&this.cancel()}},fireHold:function(a,b){var d={bubbles:!0,cancelable:!0,pointerType:this.heldPointer.pointerType,pointerId:this.heldPointer.pointerId,x:this.heldPointer.clientX,y:this.heldPointer.clientY,_source:"hold"};b&&(d.holdTime=b);var e=c.makeGestureEvent(a,d);this.target.dispatchEvent(e)}};b.registerGesture("hold",d)}(window.PolymerGestures),function(a){var b=a.dispatcher,c=a.eventFactory,d=new a.PointerMap,e={events:["down","up"],exposes:["tap"],down:function(a){a.isPrimary&&!a.tapPrevented&&d.set(a.pointerId,{target:a.target,buttons:a.buttons,x:a.clientX,y:a.clientY})},shouldTap:function(a,b){var c=!0;return"mouse"===a.pointerType&&(c=1^a.buttons&&1&b.buttons),c&&!a.tapPrevented},up:function(b){var e=d.get(b.pointerId);if(e&&this.shouldTap(b,e)){var f=a.targetFinding.LCA(e.target,b.relatedTarget);if(f){var g=c.makeGestureEvent("tap",{bubbles:!0,cancelable:!0,x:b.clientX,y:b.clientY,detail:b.detail,pointerType:b.pointerType,pointerId:b.pointerId,altKey:b.altKey,ctrlKey:b.ctrlKey,metaKey:b.metaKey,shiftKey:b.shiftKey,_source:"tap"});f.dispatchEvent(g)}}d["delete"](b.pointerId)}};c.preventTap=function(a){return function(){a.tapPrevented=!0,d["delete"](a.pointerId)}},b.registerGesture("tap",e)}(window.PolymerGestures),function(a){var b=a.dispatcher,c=a.eventFactory,d=new a.PointerMap,e=180/Math.PI,f={events:["down","up","move","cancel"],exposes:["pinchstart","pinch","pinchend","rotate"],defaultActions:{pinch:"none",rotate:"none"},reference:{},down:function(b){if(d.set(b.pointerId,b),2==d.pointers()){var c=this.calcChord(),e=this.calcAngle(c);this.reference={angle:e,diameter:c.diameter,target:a.targetFinding.LCA(c.a.target,c.b.target)},this.firePinch("pinchstart",c.diameter,c)}},up:function(a){var b=d.get(a.pointerId),c=d.pointers();if(b){if(2===c){var e=this.calcChord();this.firePinch("pinchend",e.diameter,e)}d["delete"](a.pointerId)}},move:function(a){d.has(a.pointerId)&&(d.set(a.pointerId,a),d.pointers()>1&&this.calcPinchRotate())},cancel:function(a){this.up(a)},firePinch:function(a,b,d){var e=b/this.reference.diameter,f=c.makeGestureEvent(a,{bubbles:!0,cancelable:!0,scale:e,centerX:d.center.x,centerY:d.center.y,_source:"pinch"});this.reference.target.dispatchEvent(f)},fireRotate:function(a,b){var d=Math.round((a-this.reference.angle)%360),e=c.makeGestureEvent("rotate",{bubbles:!0,cancelable:!0,angle:d,centerX:b.center.x,centerY:b.center.y,_source:"pinch"});this.reference.target.dispatchEvent(e)},calcPinchRotate:function(){var a=this.calcChord(),b=a.diameter,c=this.calcAngle(a);b!=this.reference.diameter&&this.firePinch("pinch",b,a),c!=this.reference.angle&&this.fireRotate(c,a)},calcChord:function(){var a=[];d.forEach(function(b){a.push(b)});for(var b,c,e,f=0,g={a:a[0],b:a[1]},h=0;h<a.length;h++)for(var i=a[h],j=h+1;j<a.length;j++){var k=a[j];b=Math.abs(i.clientX-k.clientX),c=Math.abs(i.clientY-k.clientY),e=b+c,e>f&&(f=e,g={a:i,b:k})}return b=Math.abs(g.a.clientX+g.b.clientX)/2,c=Math.abs(g.a.clientY+g.b.clientY)/2,g.center={x:b,y:c},g.diameter=f,g},calcAngle:function(a){var b=a.a.clientX-a.b.clientX,c=a.a.clientY-a.b.clientY;return(360+Math.atan2(c,b)*e)%360}};b.registerGesture("pinch",f)}(window.PolymerGestures),function(a){"use strict";function b(a,b){if(!a)throw new Error("ASSERT: "+b)}function c(a){return a>=48&&57>=a}function d(a){return 32===a||9===a||11===a||12===a||160===a||a>=5760&&" ᠎             　﻿".indexOf(String.fromCharCode(a))>0}function e(a){return 10===a||13===a||8232===a||8233===a}function f(a){return 36===a||95===a||a>=65&&90>=a||a>=97&&122>=a}function g(a){return 36===a||95===a||a>=65&&90>=a||a>=97&&122>=a||a>=48&&57>=a}function h(a){return"this"===a}function i(){for(;Y>X&&d(W.charCodeAt(X));)++X}function j(){var a,b;for(a=X++;Y>X&&(b=W.charCodeAt(X),g(b));)++X;return W.slice(a,X)}function k(){var a,b,c;return a=X,b=j(),c=1===b.length?S.Identifier:h(b)?S.Keyword:"null"===b?S.NullLiteral:"true"===b||"false"===b?S.BooleanLiteral:S.Identifier,{type:c,value:b,range:[a,X]}}function l(){var a,b,c=X,d=W.charCodeAt(X),e=W[X];switch(d){case 46:case 40:case 41:case 59:case 44:case 123:case 125:case 91:case 93:case 58:case 63:return++X,{type:S.Punctuator,value:String.fromCharCode(d),range:[c,X]};default:if(a=W.charCodeAt(X+1),61===a)switch(d){case 37:case 38:case 42:case 43:case 45:case 47:case 60:case 62:case 124:return X+=2,{type:S.Punctuator,value:String.fromCharCode(d)+String.fromCharCode(a),range:[c,X]};case 33:case 61:return X+=2,61===W.charCodeAt(X)&&++X,{type:S.Punctuator,value:W.slice(c,X),range:[c,X]}}}return b=W[X+1],e===b&&"&|".indexOf(e)>=0?(X+=2,{type:S.Punctuator,value:e+b,range:[c,X]}):"<>=!+-*%&|^/".indexOf(e)>=0?(++X,{type:S.Punctuator,value:e,range:[c,X]}):void s({},V.UnexpectedToken,"ILLEGAL")}function m(){var a,d,e;if(e=W[X],b(c(e.charCodeAt(0))||"."===e,"Numeric literal must start with a decimal digit or a decimal point"),d=X,a="","."!==e){for(a=W[X++],e=W[X],"0"===a&&e&&c(e.charCodeAt(0))&&s({},V.UnexpectedToken,"ILLEGAL");c(W.charCodeAt(X));)a+=W[X++];e=W[X]}if("."===e){for(a+=W[X++];c(W.charCodeAt(X));)a+=W[X++];e=W[X]}if("e"===e||"E"===e)if(a+=W[X++],e=W[X],("+"===e||"-"===e)&&(a+=W[X++]),c(W.charCodeAt(X)))for(;c(W.charCodeAt(X));)a+=W[X++];else s({},V.UnexpectedToken,"ILLEGAL");return f(W.charCodeAt(X))&&s({},V.UnexpectedToken,"ILLEGAL"),{type:S.NumericLiteral,value:parseFloat(a),range:[d,X]}}function n(){var a,c,d,f="",g=!1;for(a=W[X],b("'"===a||'"'===a,"String literal must starts with a quote"),c=X,++X;Y>X;){if(d=W[X++],d===a){a="";break}if("\\"===d)if(d=W[X++],d&&e(d.charCodeAt(0)))"\r"===d&&"\n"===W[X]&&++X;else switch(d){case"n":f+="\n";break;case"r":f+="\r";break;case"t":f+="	";break;case"b":f+="\b";break;case"f":f+="\f";break;case"v":f+="";break;default:f+=d}else{if(e(d.charCodeAt(0)))break;f+=d}}return""!==a&&s({},V.UnexpectedToken,"ILLEGAL"),{type:S.StringLiteral,value:f,octal:g,range:[c,X]}}function o(a){return a.type===S.Identifier||a.type===S.Keyword||a.type===S.BooleanLiteral||a.type===S.NullLiteral}function p(){var a;return i(),X>=Y?{type:S.EOF,range:[X,X]}:(a=W.charCodeAt(X),40===a||41===a||58===a?l():39===a||34===a?n():f(a)?k():46===a?c(W.charCodeAt(X+1))?m():l():c(a)?m():l())}function q(){var a;return a=$,X=a.range[1],$=p(),X=a.range[1],a}function r(){var a;a=X,$=p(),X=a}function s(a,c){var d,e=Array.prototype.slice.call(arguments,2),f=c.replace(/%(\d)/g,function(a,c){return b(c<e.length,"Message reference must be in range"),e[c]});throw d=new Error(f),d.index=X,d.description=f,d}function t(a){s(a,V.UnexpectedToken,a.value)}function u(a){var b=q();(b.type!==S.Punctuator||b.value!==a)&&t(b)}function v(a){return $.type===S.Punctuator&&$.value===a}function w(a){return $.type===S.Keyword&&$.value===a}function x(){var a=[];for(u("[");!v("]");)v(",")?(q(),a.push(null)):(a.push(bb()),v("]")||u(","));return u("]"),Z.createArrayExpression(a)}function y(){var a;return i(),a=q(),a.type===S.StringLiteral||a.type===S.NumericLiteral?Z.createLiteral(a):Z.createIdentifier(a.value)}function z(){var a,b;return a=$,i(),(a.type===S.EOF||a.type===S.Punctuator)&&t(a),b=y(),u(":"),Z.createProperty("init",b,bb())}function A(){var a=[];for(u("{");!v("}");)a.push(z()),v("}")||u(",");return u("}"),Z.createObjectExpression(a)}function B(){var a;return u("("),a=bb(),u(")"),a}function C(){var a,b,c;return v("(")?B():(a=$.type,a===S.Identifier?c=Z.createIdentifier(q().value):a===S.StringLiteral||a===S.NumericLiteral?c=Z.createLiteral(q()):a===S.Keyword?w("this")&&(q(),c=Z.createThisExpression()):a===S.BooleanLiteral?(b=q(),b.value="true"===b.value,c=Z.createLiteral(b)):a===S.NullLiteral?(b=q(),b.value=null,c=Z.createLiteral(b)):v("[")?c=x():v("{")&&(c=A()),c?c:void t(q()))}function D(){var a=[];if(u("("),!v(")"))for(;Y>X&&(a.push(bb()),!v(")"));)u(",");return u(")"),a}function E(){var a;return a=q(),o(a)||t(a),Z.createIdentifier(a.value)}function F(){return u("."),E()}function G(){var a;return u("["),a=bb(),u("]"),a}function H(){var a,b,c;for(a=C();;)if(v("["))c=G(),a=Z.createMemberExpression("[",a,c);else if(v("."))c=F(),a=Z.createMemberExpression(".",a,c);else{if(!v("("))break;b=D(),a=Z.createCallExpression(a,b)}return a}function I(){var a,b;return $.type!==S.Punctuator&&$.type!==S.Keyword?b=ab():v("+")||v("-")||v("!")?(a=q(),b=I(),b=Z.createUnaryExpression(a.value,b)):w("delete")||w("void")||w("typeof")?s({},V.UnexpectedToken):b=ab(),b}function J(a){var b=0;if(a.type!==S.Punctuator&&a.type!==S.Keyword)return 0;switch(a.value){case"||":b=1;break;case"&&":b=2;break;case"==":case"!=":case"===":case"!==":b=6;break;case"<":case">":case"<=":case">=":case"instanceof":b=7;break;case"in":b=7;break;case"+":case"-":b=9;break;case"*":case"/":case"%":b=11}return b}function K(){var a,b,c,d,e,f,g,h;if(g=I(),b=$,c=J(b),0===c)return g;for(b.prec=c,q(),e=I(),d=[g,b,e];(c=J($))>0;){for(;d.length>2&&c<=d[d.length-2].prec;)e=d.pop(),f=d.pop().value,g=d.pop(),a=Z.createBinaryExpression(f,g,e),d.push(a);b=q(),b.prec=c,d.push(b),a=I(),d.push(a)}for(h=d.length-1,a=d[h];h>1;)a=Z.createBinaryExpression(d[h-1].value,d[h-2],a),h-=2;return a}function L(){var a,b,c;return a=K(),v("?")&&(q(),b=L(),u(":"),c=L(),a=Z.createConditionalExpression(a,b,c)),a}function M(){var a,b;return a=q(),a.type!==S.Identifier&&t(a),b=v("(")?D():[],Z.createFilter(a.value,b)}function N(){for(;v("|");)q(),M()}function O(){i(),r();var a=bb();a&&(","===$.value||"in"==$.value&&a.type===U.Identifier?Q(a):(N(),"as"===$.value?P(a):Z.createTopLevel(a))),$.type!==S.EOF&&t($)}function P(a){q();var b=q().value;Z.createAsExpression(a,b)}function Q(a){var b;","===$.value&&(q(),$.type!==S.Identifier&&t($),b=q().value),q();var c=bb();N(),Z.createInExpression(a.name,b,c)}function R(a,b){return Z=b,W=a,X=0,Y=W.length,$=null,_={labelSet:{}},O()}var S,T,U,V,W,X,Y,Z,$,_;S={BooleanLiteral:1,EOF:2,Identifier:3,Keyword:4,NullLiteral:5,NumericLiteral:6,Punctuator:7,StringLiteral:8},T={},T[S.BooleanLiteral]="Boolean",T[S.EOF]="<end>",T[S.Identifier]="Identifier",T[S.Keyword]="Keyword",T[S.NullLiteral]="Null",T[S.NumericLiteral]="Numeric",T[S.Punctuator]="Punctuator",T[S.StringLiteral]="String",U={ArrayExpression:"ArrayExpression",BinaryExpression:"BinaryExpression",CallExpression:"CallExpression",ConditionalExpression:"ConditionalExpression",EmptyStatement:"EmptyStatement",ExpressionStatement:"ExpressionStatement",Identifier:"Identifier",Literal:"Literal",LabeledStatement:"LabeledStatement",LogicalExpression:"LogicalExpression",MemberExpression:"MemberExpression",ObjectExpression:"ObjectExpression",Program:"Program",Property:"Property",ThisExpression:"ThisExpression",UnaryExpression:"UnaryExpression"},V={UnexpectedToken:"Unexpected token %0",UnknownLabel:"Undefined label '%0'",Redeclaration:"%0 '%1' has already been declared"};
var ab=H,bb=L;a.esprima={parse:R}}(this),function(a){"use strict";function b(a,b,d,e){var f;try{if(f=c(a),f.scopeIdent&&(d.nodeType!==Node.ELEMENT_NODE||"TEMPLATE"!==d.tagName||"bind"!==b&&"repeat"!==b))throw Error("as and in can only be used within <template bind/repeat>")}catch(g){return void console.error("Invalid expression syntax: "+a,g)}return function(a,b,c){var d=f.getBinding(a,e,c);return f.scopeIdent&&d&&(b.polymerExpressionScopeIdent_=f.scopeIdent,f.indexIdent&&(b.polymerExpressionIndexIdent_=f.indexIdent)),d}}function c(a){var b=q[a];if(!b){var c=new j;esprima.parse(a,c),b=new l(c),q[a]=b}return b}function d(a){this.value=a,this.valueFn_=void 0}function e(a){this.name=a,this.path=Path.get(a)}function f(a,b,c){this.computed="["==c,this.dynamicDeps="function"==typeof a||a.dynamicDeps||this.computed&&!(b instanceof d),this.simplePath=!this.dynamicDeps&&(b instanceof e||b instanceof d)&&(a instanceof f||a instanceof e),this.object=this.simplePath?a:i(a),this.property=!this.computed||this.simplePath?b:i(b)}function g(a,b){this.name=a,this.args=[];for(var c=0;c<b.length;c++)this.args[c]=i(b[c])}function h(){throw Error("Not Implemented")}function i(a){return"function"==typeof a?a:a.valueFn()}function j(){this.expression=null,this.filters=[],this.deps={},this.currentPath=void 0,this.scopeIdent=void 0,this.indexIdent=void 0,this.dynamicDeps=!1}function k(a){this.value_=a}function l(a){if(this.scopeIdent=a.scopeIdent,this.indexIdent=a.indexIdent,!a.expression)throw Error("No expression found.");this.expression=a.expression,i(this.expression),this.filters=a.filters,this.dynamicDeps=a.dynamicDeps}function m(a){return String(a).replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()})}function n(a,b){for(;a[t]&&!Object.prototype.hasOwnProperty.call(a,b);)a=a[t];return a}function o(a){switch(a){case"":return!1;case"false":case"null":case"true":return!0}return isNaN(Number(a))?!1:!0}function p(){}var q=Object.create(null);d.prototype={valueFn:function(){if(!this.valueFn_){var a=this.value;this.valueFn_=function(){return a}}return this.valueFn_}},e.prototype={valueFn:function(){if(!this.valueFn_){var a=(this.name,this.path);this.valueFn_=function(b,c){return c&&c.addPath(b,a),a.getValueFrom(b)}}return this.valueFn_},setValue:function(a,b){return 1==this.path.length&&(a=n(a,this.path[0])),this.path.setValueFrom(a,b)}},f.prototype={get fullPath(){if(!this.fullPath_){var a=this.object instanceof f?this.object.fullPath.slice():[this.object.name];a.push(this.property instanceof e?this.property.name:this.property.value),this.fullPath_=Path.get(a)}return this.fullPath_},valueFn:function(){if(!this.valueFn_){var a=this.object;if(this.simplePath){var b=this.fullPath;this.valueFn_=function(a,c){return c&&c.addPath(a,b),b.getValueFrom(a)}}else if(this.computed){var c=this.property;this.valueFn_=function(b,d,e){var f=a(b,d,e),g=c(b,d,e);return d&&d.addPath(f,[g]),f?f[g]:void 0}}else{var b=Path.get(this.property.name);this.valueFn_=function(c,d,e){var f=a(c,d,e);return d&&d.addPath(f,b),b.getValueFrom(f)}}}return this.valueFn_},setValue:function(a,b){if(this.simplePath)return this.fullPath.setValueFrom(a,b),b;var c=this.object(a),d=this.property instanceof e?this.property.name:this.property(a);return c[d]=b}},g.prototype={transform:function(a,b,c,d,e){var f=a,g=f[this.name];if(!g&&(g=c[this.name],!g))return void console.error("Cannot find function or filter: "+this.name);if(d?g=g.toModel:"function"==typeof g.toDOM&&(g=g.toDOM),"function"!=typeof g)return void console.error("Cannot find function or filter: "+this.name);for(var h=e||[],j=0;j<this.args.length;j++)h.push(i(this.args[j])(a,b,c));return g.apply(f,h)}};var r={"+":function(a){return+a},"-":function(a){return-a},"!":function(a){return!a}},s={"+":function(a,b){return a+b},"-":function(a,b){return a-b},"*":function(a,b){return a*b},"/":function(a,b){return a/b},"%":function(a,b){return a%b},"<":function(a,b){return b>a},">":function(a,b){return a>b},"<=":function(a,b){return b>=a},">=":function(a,b){return a>=b},"==":function(a,b){return a==b},"!=":function(a,b){return a!=b},"===":function(a,b){return a===b},"!==":function(a,b){return a!==b},"&&":function(a,b){return a&&b},"||":function(a,b){return a||b}};j.prototype={createUnaryExpression:function(a,b){if(!r[a])throw Error("Disallowed operator: "+a);return b=i(b),function(c,d,e){return r[a](b(c,d,e))}},createBinaryExpression:function(a,b,c){if(!s[a])throw Error("Disallowed operator: "+a);switch(b=i(b),c=i(c),a){case"||":return this.dynamicDeps=!0,function(a,d,e){return b(a,d,e)||c(a,d,e)};case"&&":return this.dynamicDeps=!0,function(a,d,e){return b(a,d,e)&&c(a,d,e)}}return function(d,e,f){return s[a](b(d,e,f),c(d,e,f))}},createConditionalExpression:function(a,b,c){return a=i(a),b=i(b),c=i(c),this.dynamicDeps=!0,function(d,e,f){return a(d,e,f)?b(d,e,f):c(d,e,f)}},createIdentifier:function(a){var b=new e(a);return b.type="Identifier",b},createMemberExpression:function(a,b,c){var d=new f(b,c,a);return d.dynamicDeps&&(this.dynamicDeps=!0),d},createCallExpression:function(a,b){if(!(a instanceof e))throw Error("Only identifier function invocations are allowed");var c=new g(a.name,b);return function(a,b,d){return c.transform(a,b,d,!1)}},createLiteral:function(a){return new d(a.value)},createArrayExpression:function(a){for(var b=0;b<a.length;b++)a[b]=i(a[b]);return function(b,c,d){for(var e=[],f=0;f<a.length;f++)e.push(a[f](b,c,d));return e}},createProperty:function(a,b,c){return{key:b instanceof e?b.name:b.value,value:c}},createObjectExpression:function(a){for(var b=0;b<a.length;b++)a[b].value=i(a[b].value);return function(b,c,d){for(var e={},f=0;f<a.length;f++)e[a[f].key]=a[f].value(b,c,d);return e}},createFilter:function(a,b){this.filters.push(new g(a,b))},createAsExpression:function(a,b){this.expression=a,this.scopeIdent=b},createInExpression:function(a,b,c){this.expression=c,this.scopeIdent=a,this.indexIdent=b},createTopLevel:function(a){this.expression=a},createThisExpression:h},k.prototype={open:function(){return this.value_},discardChanges:function(){return this.value_},deliver:function(){},close:function(){}},l.prototype={getBinding:function(a,b,c){function d(){if(h)return h=!1,g;i.dynamicDeps&&f.startReset();var c=i.getValue(a,i.dynamicDeps?f:void 0,b);return i.dynamicDeps&&f.finishReset(),c}function e(c){return i.setValue(a,c,b),c}if(c)return this.getValue(a,void 0,b);var f=new CompoundObserver,g=this.getValue(a,f,b),h=!0,i=this;return new ObserverTransform(f,d,e,!0)},getValue:function(a,b,c){for(var d=i(this.expression)(a,b,c),e=0;e<this.filters.length;e++)d=this.filters[e].transform(a,b,c,!1,[d]);return d},setValue:function(a,b,c){for(var d=this.filters?this.filters.length:0;d-->0;)b=this.filters[d].transform(a,void 0,c,!0,[b]);return this.expression.setValue?this.expression.setValue(a,b):void 0}};var t="@"+Math.random().toString(36).slice(2);p.prototype={styleObject:function(a){var b=[];for(var c in a)b.push(m(c)+": "+a[c]);return b.join("; ")},tokenList:function(a){var b=[];for(var c in a)a[c]&&b.push(c);return b.join(" ")},prepareInstancePositionChanged:function(a){var b=a.polymerExpressionIndexIdent_;if(b)return function(a,c){a.model[b]=c}},prepareBinding:function(a,c,d){var e=Path.get(a);{if(o(a)||!e.valid)return b(a,c,d,this);if(1==e.length)return function(a,b,c){if(c)return e.getValueFrom(a);var d=n(a,e[0]);return new PathObserver(d,e)}}},prepareInstanceModel:function(a){var b=a.polymerExpressionScopeIdent_;if(b){var c=a.templateInstance?a.templateInstance.model:a.model,d=a.polymerExpressionIndexIdent_;return function(a){return u(c,a,b,d)}}}};var u="__proto__"in{}?function(a,b,c,d){var e={};return e[c]=b,e[d]=void 0,e[t]=a,e.__proto__=a,e}:function(a,b,c,d){var e=Object.create(a);return Object.defineProperty(e,c,{value:b,configurable:!0,writable:!0}),Object.defineProperty(e,d,{value:void 0,configurable:!0,writable:!0}),Object.defineProperty(e,t,{value:a,configurable:!0,writable:!0}),e};a.PolymerExpressions=p,p.getExpression=c}(this),Polymer={version:"0.5.5"},"function"==typeof window.Polymer&&(Polymer={}),function(a){function b(a,b){return b=b||[],b.map||(b=[b]),a.apply(this,b.map(d))}function c(a,c,d){var e;switch(arguments.length){case 0:return;case 1:e=null;break;case 2:e=c.apply(this);break;default:e=b(d,c)}f[a]=e}function d(a){return f[a]}function e(a,c){HTMLImports.whenImportsReady(function(){b(c,a)})}var f={};a.marshal=d,a.modularize=c,a.using=e}(window),window.WebComponents||(window.WebComponents||(WebComponents={flush:function(){},flags:{log:{}}},Platform=WebComponents,CustomElements={useNative:!0,ready:!0,takeRecords:function(){},"instanceof":function(a,b){return a instanceof b}},HTMLImports={useNative:!0},addEventListener("HTMLImportsLoaded",function(){document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))}),ShadowDOMPolyfill=null,wrap=unwrap=function(a){return a}),window.HTMLImports=window.HTMLImports||{flags:{}},function(a){function b(a,b){b=b||o,d(function(){f(a,b)},b)}function c(a){return"complete"===a.readyState||a.readyState===r}function d(a,b){if(c(b))a&&a();else{var e=function(){("complete"===b.readyState||b.readyState===r)&&(b.removeEventListener(s,e),d(a,b))};b.addEventListener(s,e)}}function e(a){a.target.__loaded=!0}function f(a,b){function c(){h==i&&a&&a()}function d(a){e(a),h++,c()}var f=b.querySelectorAll("link[rel=import]"),h=0,i=f.length;if(i)for(var j,k=0;i>k&&(j=f[k]);k++)g(j)?d.call(j,{target:j}):(j.addEventListener("load",d),j.addEventListener("error",d));else c()}function g(a){return l?a.__loaded||a["import"]&&"loading"!==a["import"].readyState:a.__importParsed}function h(a){for(var b,c=0,d=a.length;d>c&&(b=a[c]);c++)i(b)&&j(b)}function i(a){return"link"===a.localName&&"import"===a.rel}function j(a){var b=a["import"];b?e({target:a}):(a.addEventListener("load",e),a.addEventListener("error",e))}var k="import",l=Boolean(k in document.createElement("link")),m=Boolean(window.ShadowDOMPolyfill),n=function(a){return m?ShadowDOMPolyfill.wrapIfNeeded(a):a},o=n(document),p={get:function(){var a=HTMLImports.currentScript||document.currentScript||("complete"!==document.readyState?document.scripts[document.scripts.length-1]:null);return n(a)},configurable:!0};Object.defineProperty(document,"_currentScript",p),Object.defineProperty(o,"_currentScript",p);var q=/Trident/.test(navigator.userAgent),r=q?"complete":"interactive",s="readystatechange";l&&(new MutationObserver(function(a){for(var b,c=0,d=a.length;d>c&&(b=a[c]);c++)b.addedNodes&&h(b.addedNodes)}).observe(document.head,{childList:!0}),function(){if("loading"===document.readyState)for(var a,b=document.querySelectorAll("link[rel=import]"),c=0,d=b.length;d>c&&(a=b[c]);c++)j(a)}()),b(function(){HTMLImports.ready=!0,HTMLImports.readyTime=(new Date).getTime(),o.dispatchEvent(new CustomEvent("HTMLImportsLoaded",{bubbles:!0}))}),a.IMPORT_LINK_TYPE=k,a.useNative=l,a.rootDocument=o,a.whenReady=b,a.isIE=q}(HTMLImports),function(){var a=document.createElement("style");a.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; } \n";var b=document.querySelector("head");b.insertBefore(a,b.firstChild)}(Platform)),function(a){"use strict";function b(){function a(a){b=a}if("function"!=typeof Object.observe||"function"!=typeof Array.observe)return!1;var b=[],c={},d=[];return Object.observe(c,a),Array.observe(d,a),c.id=1,c.id=2,delete c.id,d.push(1,2),d.length=0,Object.deliverChangeRecords(a),5!==b.length?!1:"add"!=b[0].type||"update"!=b[1].type||"delete"!=b[2].type||"splice"!=b[3].type||"splice"!=b[4].type?!1:(Object.unobserve(c,a),Array.unobserve(d,a),!0)}function c(){if("undefined"!=typeof chrome&&chrome.app&&chrome.app.runtime)return!1;if("undefined"!=typeof navigator&&navigator.getDeviceStorage)return!1;try{var a=new Function("","return true;");return a()}catch(b){return!1}}function d(a){return+a===a>>>0&&""!==a}function e(a){return+a}function f(a){return a===Object(a)}function g(a,b){return a===b?0!==a||1/a===1/b:R(a)&&R(b)?!0:a!==a&&b!==b}function h(a){if(void 0===a)return"eof";var b=a.charCodeAt(0);switch(b){case 91:case 93:case 46:case 34:case 39:case 48:return a;case 95:case 36:return"ident";case 32:case 9:case 10:case 13:case 160:case 65279:case 8232:case 8233:return"ws"}return b>=97&&122>=b||b>=65&&90>=b?"ident":b>=49&&57>=b?"number":"else"}function i(){}function j(a){function b(){if(!(m>=a.length)){var b=a[m+1];return"inSingleQuote"==n&&"'"==b||"inDoubleQuote"==n&&'"'==b?(m++,d=b,o.append(),!0):void 0}}for(var c,d,e,f,g,j,k,l=[],m=-1,n="beforePath",o={push:function(){void 0!==e&&(l.push(e),e=void 0)},append:function(){void 0===e?e=d:e+=d}};n;)if(m++,c=a[m],"\\"!=c||!b(n)){if(f=h(c),k=W[n],g=k[f]||k["else"]||"error","error"==g)return;if(n=g[0],j=o[g[1]]||i,d=void 0===g[2]?c:g[2],j(),"afterPath"===n)return l}}function k(a){return V.test(a)}function l(a,b){if(b!==X)throw Error("Use Path.get to retrieve path objects");for(var c=0;c<a.length;c++)this.push(String(a[c]));Q&&this.length&&(this.getValueFrom=this.compiledGetValueFromFn())}function m(a){if(a instanceof l)return a;if((null==a||0==a.length)&&(a=""),"string"!=typeof a){if(d(a.length))return new l(a,X);a=String(a)}var b=Y[a];if(b)return b;var c=j(a);if(!c)return Z;var b=new l(c,X);return Y[a]=b,b}function n(a){return d(a)?"["+a+"]":'["'+a.replace(/"/g,'\\"')+'"]'}function o(b){for(var c=0;_>c&&b.check_();)c++;return O&&(a.dirtyCheckCycleCount=c),c>0}function p(a){for(var b in a)return!1;return!0}function q(a){return p(a.added)&&p(a.removed)&&p(a.changed)}function r(a,b){var c={},d={},e={};for(var f in b){var g=a[f];(void 0===g||g!==b[f])&&(f in a?g!==b[f]&&(e[f]=g):d[f]=void 0)}for(var f in a)f in b||(c[f]=a[f]);return Array.isArray(a)&&a.length!==b.length&&(e.length=a.length),{added:c,removed:d,changed:e}}function s(){if(!ab.length)return!1;for(var a=0;a<ab.length;a++)ab[a]();return ab.length=0,!0}function t(){function a(a){b&&b.state_===fb&&!d&&b.check_(a)}var b,c,d=!1,e=!0;return{open:function(c){if(b)throw Error("ObservedObject in use");e||Object.deliverChangeRecords(a),b=c,e=!1},observe:function(b,d){c=b,d?Array.observe(c,a):Object.observe(c,a)},deliver:function(b){d=b,Object.deliverChangeRecords(a),d=!1},close:function(){b=void 0,Object.unobserve(c,a),cb.push(this)}}}function u(a,b,c){var d=cb.pop()||t();return d.open(a),d.observe(b,c),d}function v(){function a(b,f){b&&(b===d&&(e[f]=!0),h.indexOf(b)<0&&(h.push(b),Object.observe(b,c)),a(Object.getPrototypeOf(b),f))}function b(a){for(var b=0;b<a.length;b++){var c=a[b];if(c.object!==d||e[c.name]||"setPrototype"===c.type)return!1}return!0}function c(c){if(!b(c)){for(var d,e=0;e<g.length;e++)d=g[e],d.state_==fb&&d.iterateObjects_(a);for(var e=0;e<g.length;e++)d=g[e],d.state_==fb&&d.check_()}}var d,e,f=0,g=[],h=[],i={objects:h,get rootObject(){return d},set rootObject(a){d=a,e={}},open:function(b){g.push(b),f++,b.iterateObjects_(a)},close:function(){if(f--,!(f>0)){for(var a=0;a<h.length;a++)Object.unobserve(h[a],c),x.unobservedCount++;g.length=0,h.length=0,d=void 0,e=void 0,db.push(this),$===this&&($=null)}}};return i}function w(a,b){return $&&$.rootObject===b||($=db.pop()||v(),$.rootObject=b),$.open(a,b),$}function x(){this.state_=eb,this.callback_=void 0,this.target_=void 0,this.directObserver_=void 0,this.value_=void 0,this.id_=ib++}function y(a){x._allObserversCount++,kb&&jb.push(a)}function z(){x._allObserversCount--}function A(a){x.call(this),this.value_=a,this.oldObject_=void 0}function B(a){if(!Array.isArray(a))throw Error("Provided object is not an Array");A.call(this,a)}function C(a,b){x.call(this),this.object_=a,this.path_=m(b),this.directObserver_=void 0}function D(a){x.call(this),this.reportChangesOnOpen_=a,this.value_=[],this.directObserver_=void 0,this.observed_=[]}function E(a){return a}function F(a,b,c,d){this.callback_=void 0,this.target_=void 0,this.value_=void 0,this.observable_=a,this.getValueFn_=b||E,this.setValueFn_=c||E,this.dontPassThroughSet_=d}function G(a,b,c){for(var d={},e={},f=0;f<b.length;f++){var g=b[f];nb[g.type]?(g.name in c||(c[g.name]=g.oldValue),"update"!=g.type&&("add"!=g.type?g.name in d?(delete d[g.name],delete c[g.name]):e[g.name]=!0:g.name in e?delete e[g.name]:d[g.name]=!0)):(console.error("Unknown changeRecord type: "+g.type),console.error(g))}for(var h in d)d[h]=a[h];for(var h in e)e[h]=void 0;var i={};for(var h in c)if(!(h in d||h in e)){var j=a[h];c[h]!==j&&(i[h]=j)}return{added:d,removed:e,changed:i}}function H(a,b,c){return{index:a,removed:b,addedCount:c}}function I(){}function J(a,b,c,d,e,f){return sb.calcSplices(a,b,c,d,e,f)}function K(a,b,c,d){return c>b||a>d?-1:b==c||d==a?0:c>a?d>b?b-c:d-c:b>d?d-a:b-a}function L(a,b,c,d){for(var e=H(b,c,d),f=!1,g=0,h=0;h<a.length;h++){var i=a[h];if(i.index+=g,!f){var j=K(e.index,e.index+e.removed.length,i.index,i.index+i.addedCount);if(j>=0){a.splice(h,1),h--,g-=i.addedCount-i.removed.length,e.addedCount+=i.addedCount-j;var k=e.removed.length+i.removed.length-j;if(e.addedCount||k){var c=i.removed;if(e.index<i.index){var l=e.removed.slice(0,i.index-e.index);Array.prototype.push.apply(l,c),c=l}if(e.index+e.removed.length>i.index+i.addedCount){var m=e.removed.slice(i.index+i.addedCount-e.index);Array.prototype.push.apply(c,m)}e.removed=c,i.index<e.index&&(e.index=i.index)}else f=!0}else if(e.index<i.index){f=!0,a.splice(h,0,e),h++;var n=e.addedCount-e.removed.length;i.index+=n,g+=n}}}f||a.push(e)}function M(a,b){for(var c=[],f=0;f<b.length;f++){var g=b[f];switch(g.type){case"splice":L(c,g.index,g.removed.slice(),g.addedCount);break;case"add":case"update":case"delete":if(!d(g.name))continue;var h=e(g.name);if(0>h)continue;L(c,h,[g.oldValue],1);break;default:console.error("Unexpected record type: "+JSON.stringify(g))}}return c}function N(a,b){var c=[];return M(a,b).forEach(function(b){return 1==b.addedCount&&1==b.removed.length?void(b.removed[0]!==a[b.index]&&c.push(b)):void(c=c.concat(J(a,b.index,b.index+b.addedCount,b.removed,0,b.removed.length)))}),c}var O=a.testingExposeCycleCount,P=b(),Q=c(),R=a.Number.isNaN||function(b){return"number"==typeof b&&a.isNaN(b)},S="__proto__"in{}?function(a){return a}:function(a){var b=a.__proto__;if(!b)return a;var c=Object.create(b);return Object.getOwnPropertyNames(a).forEach(function(b){Object.defineProperty(c,b,Object.getOwnPropertyDescriptor(a,b))}),c},T="[$_a-zA-Z]",U="[$_a-zA-Z0-9]",V=new RegExp("^"+T+"+"+U+"*$"),W={beforePath:{ws:["beforePath"],ident:["inIdent","append"],"[":["beforeElement"],eof:["afterPath"]},inPath:{ws:["inPath"],".":["beforeIdent"],"[":["beforeElement"],eof:["afterPath"]},beforeIdent:{ws:["beforeIdent"],ident:["inIdent","append"]},inIdent:{ident:["inIdent","append"],0:["inIdent","append"],number:["inIdent","append"],ws:["inPath","push"],".":["beforeIdent","push"],"[":["beforeElement","push"],eof:["afterPath","push"]},beforeElement:{ws:["beforeElement"],0:["afterZero","append"],number:["inIndex","append"],"'":["inSingleQuote","append",""],'"':["inDoubleQuote","append",""]},afterZero:{ws:["afterElement","push"],"]":["inPath","push"]},inIndex:{0:["inIndex","append"],number:["inIndex","append"],ws:["afterElement"],"]":["inPath","push"]},inSingleQuote:{"'":["afterElement"],eof:["error"],"else":["inSingleQuote","append"]},inDoubleQuote:{'"':["afterElement"],eof:["error"],"else":["inDoubleQuote","append"]},afterElement:{ws:["afterElement"],"]":["inPath","push"]}},X={},Y={};l.get=m,l.prototype=S({__proto__:[],valid:!0,toString:function(){for(var a="",b=0;b<this.length;b++){var c=this[b];a+=k(c)?b?"."+c:c:n(c)}return a},getValueFrom:function(a){for(var b=0;b<this.length;b++){if(null==a)return;a=a[this[b]]}return a},iterateObjects:function(a,b){for(var c=0;c<this.length;c++){if(c&&(a=a[this[c-1]]),!f(a))return;b(a,this[c])}},compiledGetValueFromFn:function(){var a="",b="obj";a+="if (obj != null";for(var c,d=0;d<this.length-1;d++)c=this[d],b+=k(c)?"."+c:n(c),a+=" &&\n     "+b+" != null";a+=")\n";var c=this[d];return b+=k(c)?"."+c:n(c),a+="  return "+b+";\nelse\n  return undefined;",new Function("obj",a)},setValueFrom:function(a,b){if(!this.length)return!1;for(var c=0;c<this.length-1;c++){if(!f(a))return!1;a=a[this[c]]}return f(a)?(a[this[c]]=b,!0):!1}});var Z=new l("",X);Z.valid=!1,Z.getValueFrom=Z.setValueFrom=function(){};var $,_=1e3,ab=[],bb=P?function(){return function(a){return Promise.resolve().then(a)}}():function(){return function(a){ab.push(a)}}(),cb=[],db=[],eb=0,fb=1,gb=2,hb=3,ib=1;x.prototype={open:function(a,b){if(this.state_!=eb)throw Error("Observer has already been opened.");return y(this),this.callback_=a,this.target_=b,this.connect_(),this.state_=fb,this.value_},close:function(){this.state_==fb&&(z(this),this.disconnect_(),this.value_=void 0,this.callback_=void 0,this.target_=void 0,this.state_=gb)},deliver:function(){this.state_==fb&&o(this)},report_:function(a){try{this.callback_.apply(this.target_,a)}catch(b){x._errorThrownDuringCallback=!0,console.error("Exception caught during observer callback: "+(b.stack||b))}},discardChanges:function(){return this.check_(void 0,!0),this.value_}};var jb,kb=!P;x._allObserversCount=0,kb&&(jb=[]);var lb=!1;a.Platform=a.Platform||{},a.Platform.performMicrotaskCheckpoint=function(){if(!lb&&kb){lb=!0;var b,c,d=0;do{d++,c=jb,jb=[],b=!1;for(var e=0;e<c.length;e++){var f=c[e];f.state_==fb&&(f.check_()&&(b=!0),jb.push(f))}s()&&(b=!0)}while(_>d&&b);O&&(a.dirtyCheckCycleCount=d),lb=!1}},kb&&(a.Platform.clearObservers=function(){jb=[]}),A.prototype=S({__proto__:x.prototype,arrayObserve:!1,connect_:function(){P?this.directObserver_=u(this,this.value_,this.arrayObserve):this.oldObject_=this.copyObject(this.value_)},copyObject:function(a){var b=Array.isArray(a)?[]:{};for(var c in a)b[c]=a[c];return Array.isArray(a)&&(b.length=a.length),b},check_:function(a){var b,c;if(P){if(!a)return!1;c={},b=G(this.value_,a,c)}else c=this.oldObject_,b=r(this.value_,this.oldObject_);return q(b)?!1:(P||(this.oldObject_=this.copyObject(this.value_)),this.report_([b.added||{},b.removed||{},b.changed||{},function(a){return c[a]}]),!0)},disconnect_:function(){P?(this.directObserver_.close(),this.directObserver_=void 0):this.oldObject_=void 0},deliver:function(){this.state_==fb&&(P?this.directObserver_.deliver(!1):o(this))},discardChanges:function(){return this.directObserver_?this.directObserver_.deliver(!0):this.oldObject_=this.copyObject(this.value_),this.value_}}),B.prototype=S({__proto__:A.prototype,arrayObserve:!0,copyObject:function(a){return a.slice()},check_:function(a){var b;if(P){if(!a)return!1;b=N(this.value_,a)}else b=J(this.value_,0,this.value_.length,this.oldObject_,0,this.oldObject_.length);return b&&b.length?(P||(this.oldObject_=this.copyObject(this.value_)),this.report_([b]),!0):!1}}),B.applySplices=function(a,b,c){c.forEach(function(c){for(var d=[c.index,c.removed.length],e=c.index;e<c.index+c.addedCount;)d.push(b[e]),e++;Array.prototype.splice.apply(a,d)})},C.prototype=S({__proto__:x.prototype,get path(){return this.path_},connect_:function(){P&&(this.directObserver_=w(this,this.object_)),this.check_(void 0,!0)},disconnect_:function(){this.value_=void 0,this.directObserver_&&(this.directObserver_.close(this),this.directObserver_=void 0)},iterateObjects_:function(a){this.path_.iterateObjects(this.object_,a)},check_:function(a,b){var c=this.value_;return this.value_=this.path_.getValueFrom(this.object_),b||g(this.value_,c)?!1:(this.report_([this.value_,c,this]),!0)},setValue:function(a){this.path_&&this.path_.setValueFrom(this.object_,a)}});var mb={};D.prototype=S({__proto__:x.prototype,connect_:function(){if(P){for(var a,b=!1,c=0;c<this.observed_.length;c+=2)if(a=this.observed_[c],a!==mb){b=!0;break}b&&(this.directObserver_=w(this,a))}this.check_(void 0,!this.reportChangesOnOpen_)},disconnect_:function(){for(var a=0;a<this.observed_.length;a+=2)this.observed_[a]===mb&&this.observed_[a+1].close();this.observed_.length=0,this.value_.length=0,this.directObserver_&&(this.directObserver_.close(this),this.directObserver_=void 0)},addPath:function(a,b){if(this.state_!=eb&&this.state_!=hb)throw Error("Cannot add paths once started.");var b=m(b);if(this.observed_.push(a,b),this.reportChangesOnOpen_){var c=this.observed_.length/2-1;this.value_[c]=b.getValueFrom(a)}},addObserver:function(a){if(this.state_!=eb&&this.state_!=hb)throw Error("Cannot add observers once started.");if(this.observed_.push(mb,a),this.reportChangesOnOpen_){var b=this.observed_.length/2-1;this.value_[b]=a.open(this.deliver,this)}},startReset:function(){if(this.state_!=fb)throw Error("Can only reset while open");this.state_=hb,this.disconnect_()},finishReset:function(){if(this.state_!=hb)throw Error("Can only finishReset after startReset");return this.state_=fb,this.connect_(),this.value_},iterateObjects_:function(a){for(var b,c=0;c<this.observed_.length;c+=2)b=this.observed_[c],b!==mb&&this.observed_[c+1].iterateObjects(b,a)},check_:function(a,b){for(var c,d=0;d<this.observed_.length;d+=2){var e,f=this.observed_[d],h=this.observed_[d+1];if(f===mb){var i=h;e=this.state_===eb?i.open(this.deliver,this):i.discardChanges()}else e=h.getValueFrom(f);b?this.value_[d/2]=e:g(e,this.value_[d/2])||(c=c||[],c[d/2]=this.value_[d/2],this.value_[d/2]=e)}return c?(this.report_([this.value_,c,this.observed_]),!0):!1}}),F.prototype={open:function(a,b){return this.callback_=a,this.target_=b,this.value_=this.getValueFn_(this.observable_.open(this.observedCallback_,this)),this.value_},observedCallback_:function(a){if(a=this.getValueFn_(a),!g(a,this.value_)){var b=this.value_;this.value_=a,this.callback_.call(this.target_,this.value_,b)}},discardChanges:function(){return this.value_=this.getValueFn_(this.observable_.discardChanges()),this.value_},deliver:function(){return this.observable_.deliver()},setValue:function(a){return a=this.setValueFn_(a),!this.dontPassThroughSet_&&this.observable_.setValue?this.observable_.setValue(a):void 0},close:function(){this.observable_&&this.observable_.close(),this.callback_=void 0,this.target_=void 0,this.observable_=void 0,this.value_=void 0,this.getValueFn_=void 0,this.setValueFn_=void 0}};var nb={add:!0,update:!0,"delete":!0},ob=0,pb=1,qb=2,rb=3;I.prototype={calcEditDistances:function(a,b,c,d,e,f){for(var g=f-e+1,h=c-b+1,i=new Array(g),j=0;g>j;j++)i[j]=new Array(h),i[j][0]=j;for(var k=0;h>k;k++)i[0][k]=k;for(var j=1;g>j;j++)for(var k=1;h>k;k++)if(this.equals(a[b+k-1],d[e+j-1]))i[j][k]=i[j-1][k-1];else{var l=i[j-1][k]+1,m=i[j][k-1]+1;i[j][k]=m>l?l:m}return i},spliceOperationsFromEditDistances:function(a){for(var b=a.length-1,c=a[0].length-1,d=a[b][c],e=[];b>0||c>0;)if(0!=b)if(0!=c){var f,g=a[b-1][c-1],h=a[b-1][c],i=a[b][c-1];f=i>h?g>h?h:g:g>i?i:g,f==g?(g==d?e.push(ob):(e.push(pb),d=g),b--,c--):f==h?(e.push(rb),b--,d=h):(e.push(qb),c--,d=i)}else e.push(rb),b--;else e.push(qb),c--;return e.reverse(),e},calcSplices:function(a,b,c,d,e,f){var g=0,h=0,i=Math.min(c-b,f-e);if(0==b&&0==e&&(g=this.sharedPrefix(a,d,i)),c==a.length&&f==d.length&&(h=this.sharedSuffix(a,d,i-g)),b+=g,e+=g,c-=h,f-=h,c-b==0&&f-e==0)return[];if(b==c){for(var j=H(b,[],0);f>e;)j.removed.push(d[e++]);return[j]}if(e==f)return[H(b,[],c-b)];for(var k=this.spliceOperationsFromEditDistances(this.calcEditDistances(a,b,c,d,e,f)),j=void 0,l=[],m=b,n=e,o=0;o<k.length;o++)switch(k[o]){case ob:j&&(l.push(j),j=void 0),m++,n++;break;case pb:j||(j=H(m,[],0)),j.addedCount++,m++,j.removed.push(d[n]),n++;break;case qb:j||(j=H(m,[],0)),j.addedCount++,m++;break;case rb:j||(j=H(m,[],0)),j.removed.push(d[n]),n++}return j&&l.push(j),l},sharedPrefix:function(a,b,c){for(var d=0;c>d;d++)if(!this.equals(a[d],b[d]))return d;return c},sharedSuffix:function(a,b,c){for(var d=a.length,e=b.length,f=0;c>f&&this.equals(a[--d],b[--e]);)f++;return f},calculateSplices:function(a,b){return this.calcSplices(a,0,a.length,b,0,b.length)},equals:function(a,b){return a===b}};var sb=new I,tb=a;"undefined"==typeof exports||exports.nodeType||("undefined"!=typeof module&&module.exports&&(exports=module.exports),tb=exports),tb.Observer=x,tb.Observer.runEOM_=bb,tb.Observer.observerSentinel_=mb,tb.Observer.hasObjectObserve=P,tb.ArrayObserver=B,tb.ArrayObserver.calculateSplices=function(a,b){return sb.calculateSplices(a,b)},tb.ArraySplice=I,tb.ObjectObserver=A,tb.PathObserver=C,tb.CompoundObserver=D,tb.Path=l,tb.ObserverTransform=F}("undefined"!=typeof global&&global&&"undefined"!=typeof module&&module?global:this||window),function(){"use strict";function a(a){for(;a.parentNode;)a=a.parentNode;return"function"==typeof a.getElementById?a:null}function b(a,b,c){var d=a.bindings_;return d||(d=a.bindings_={}),d[b]&&c[b].close(),d[b]=c}function c(a,b,c){return c}function d(a){return null==a?"":a}function e(a,b){a.data=d(b)}function f(a){return function(b){return e(a,b)}}function g(a,b,c,e){return c?void(e?a.setAttribute(b,""):a.removeAttribute(b)):void a.setAttribute(b,d(e))}function h(a,b,c){return function(d){g(a,b,c,d)}}function i(a){switch(a.type){case"checkbox":return u;case"radio":case"select-multiple":case"select-one":return"change";case"range":if(/Trident|MSIE/.test(navigator.userAgent))return"change";default:return"input"}}function j(a,b,c,e){a[b]=(e||d)(c)}function k(a,b,c){return function(d){return j(a,b,d,c)}}function l(){}function m(a,b,c,d){function e(){var e="value"==b&&"number"==a.type;c.setValue(e?a.valueAsNumber:a[b]),c.discardChanges(),(d||l)(a),Platform.performMicrotaskCheckpoint()}var f=i(a);return a.addEventListener(f,e),{close:function(){a.removeEventListener(f,e),c.close()},observable_:c}}function n(a){return Boolean(a)}function o(b){if(b.form)return s(b.form.elements,function(a){return a!=b&&"INPUT"==a.tagName&&"radio"==a.type&&a.name==b.name});var c=a(b);if(!c)return[];var d=c.querySelectorAll('input[type="radio"][name="'+b.name+'"]');return s(d,function(a){return a!=b&&!a.form})}function p(a){"INPUT"===a.tagName&&"radio"===a.type&&o(a).forEach(function(a){var b=a.bindings_.checked;b&&b.observable_.setValue(!1)})}function q(a,b){var c,e,f,g=a.parentNode;g instanceof HTMLSelectElement&&g.bindings_&&g.bindings_.value&&(c=g,e=c.bindings_.value,f=c.value),a.value=d(b),c&&c.value!=f&&(e.observable_.setValue(c.value),e.observable_.discardChanges(),Platform.performMicrotaskCheckpoint())}function r(a){return function(b){q(a,b)}}var s=Array.prototype.filter.call.bind(Array.prototype.filter);Node.prototype.bind=function(a,b){console.error("Unhandled binding to Node: ",this,a,b)},Node.prototype.bindFinished=function(){};var t=c;Object.defineProperty(Platform,"enableBindingsReflection",{get:function(){return t===b},set:function(a){return t=a?b:c,a},configurable:!0}),Text.prototype.bind=function(a,b,c){if("textContent"!==a)return Node.prototype.bind.call(this,a,b,c);if(c)return e(this,b);var d=b;return e(this,d.open(f(this))),t(this,a,d)},Element.prototype.bind=function(a,b,c){var d="?"==a[a.length-1];if(d&&(this.removeAttribute(a),a=a.slice(0,-1)),c)return g(this,a,d,b);var e=b;return g(this,a,d,e.open(h(this,a,d))),t(this,a,e)};var u;!function(){var a=document.createElement("div"),b=a.appendChild(document.createElement("input"));b.setAttribute("type","checkbox");var c,d=0;b.addEventListener("click",function(){d++,c=c||"click"}),b.addEventListener("change",function(){d++,c=c||"change"});var e=document.createEvent("MouseEvent");e.initMouseEvent("click",!0,!0,window,0,0,0,0,0,!1,!1,!1,!1,0,null),b.dispatchEvent(e),u=1==d?"change":c}(),HTMLInputElement.prototype.bind=function(a,c,e){if("value"!==a&&"checked"!==a)return HTMLElement.prototype.bind.call(this,a,c,e);this.removeAttribute(a);var f="checked"==a?n:d,g="checked"==a?p:l;if(e)return j(this,a,c,f);var h=c,i=m(this,a,h,g);return j(this,a,h.open(k(this,a,f)),f),b(this,a,i)},HTMLTextAreaElement.prototype.bind=function(a,b,c){if("value"!==a)return HTMLElement.prototype.bind.call(this,a,b,c);if(this.removeAttribute("value"),c)return j(this,"value",b);var e=b,f=m(this,"value",e);return j(this,"value",e.open(k(this,"value",d))),t(this,a,f)},HTMLOptionElement.prototype.bind=function(a,b,c){if("value"!==a)return HTMLElement.prototype.bind.call(this,a,b,c);if(this.removeAttribute("value"),c)return q(this,b);var d=b,e=m(this,"value",d);
return q(this,d.open(r(this))),t(this,a,e)},HTMLSelectElement.prototype.bind=function(a,c,d){if("selectedindex"===a&&(a="selectedIndex"),"selectedIndex"!==a&&"value"!==a)return HTMLElement.prototype.bind.call(this,a,c,d);if(this.removeAttribute(a),d)return j(this,a,c);var e=c,f=m(this,a,e);return j(this,a,e.open(k(this,a))),b(this,a,f)}}(this),function(a){"use strict";function b(a){if(!a)throw new Error("Assertion failed")}function c(a){for(var b;b=a.parentNode;)a=b;return a}function d(a,b){if(b){for(var d,e="#"+b;!d&&(a=c(a),a.protoContent_?d=a.protoContent_.querySelector(e):a.getElementById&&(d=a.getElementById(b)),!d&&a.templateCreator_);)a=a.templateCreator_;return d}}function e(a){return"template"==a.tagName&&"http://www.w3.org/2000/svg"==a.namespaceURI}function f(a){return"TEMPLATE"==a.tagName&&"http://www.w3.org/1999/xhtml"==a.namespaceURI}function g(a){return Boolean(L[a.tagName]&&a.hasAttribute("template"))}function h(a){return void 0===a.isTemplate_&&(a.isTemplate_="TEMPLATE"==a.tagName||g(a)),a.isTemplate_}function i(a,b){var c=a.querySelectorAll(N);h(a)&&b(a),G(c,b)}function j(a){function b(a){HTMLTemplateElement.decorate(a)||j(a.content)}i(a,b)}function k(a,b){Object.getOwnPropertyNames(b).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))})}function l(a){var b=a.ownerDocument;if(!b.defaultView)return b;var c=b.templateContentsOwner_;if(!c){for(c=b.implementation.createHTMLDocument("");c.lastChild;)c.removeChild(c.lastChild);b.templateContentsOwner_=c}return c}function m(a){if(!a.stagingDocument_){var b=a.ownerDocument;if(!b.stagingDocument_){b.stagingDocument_=b.implementation.createHTMLDocument(""),b.stagingDocument_.isStagingDocument=!0;var c=b.stagingDocument_.createElement("base");c.href=document.baseURI,b.stagingDocument_.head.appendChild(c),b.stagingDocument_.stagingDocument_=b.stagingDocument_}a.stagingDocument_=b.stagingDocument_}return a.stagingDocument_}function n(a){var b=a.ownerDocument.createElement("template");a.parentNode.insertBefore(b,a);for(var c=a.attributes,d=c.length;d-->0;){var e=c[d];K[e.name]&&("template"!==e.name&&b.setAttribute(e.name,e.value),a.removeAttribute(e.name))}return b}function o(a){var b=a.ownerDocument.createElement("template");a.parentNode.insertBefore(b,a);for(var c=a.attributes,d=c.length;d-->0;){var e=c[d];b.setAttribute(e.name,e.value),a.removeAttribute(e.name)}return a.parentNode.removeChild(a),b}function p(a,b,c){var d=a.content;if(c)return void d.appendChild(b);for(var e;e=b.firstChild;)d.appendChild(e)}function q(a){P?a.__proto__=HTMLTemplateElement.prototype:k(a,HTMLTemplateElement.prototype)}function r(a){a.setModelFn_||(a.setModelFn_=function(){a.setModelFnScheduled_=!1;var b=z(a,a.delegate_&&a.delegate_.prepareBinding);w(a,b,a.model_)}),a.setModelFnScheduled_||(a.setModelFnScheduled_=!0,Observer.runEOM_(a.setModelFn_))}function s(a,b,c,d){if(a&&a.length){for(var e,f=a.length,g=0,h=0,i=0,j=!0;f>h;){var g=a.indexOf("{{",h),k=a.indexOf("[[",h),l=!1,m="}}";if(k>=0&&(0>g||g>k)&&(g=k,l=!0,m="]]"),i=0>g?-1:a.indexOf(m,g+2),0>i){if(!e)return;e.push(a.slice(h));break}e=e||[],e.push(a.slice(h,g));var n=a.slice(g+2,i).trim();e.push(l),j=j&&l;var o=d&&d(n,b,c);e.push(null==o?Path.get(n):null),e.push(o),h=i+2}return h===f&&e.push(""),e.hasOnePath=5===e.length,e.isSimplePath=e.hasOnePath&&""==e[0]&&""==e[4],e.onlyOneTime=j,e.combinator=function(a){for(var b=e[0],c=1;c<e.length;c+=4){var d=e.hasOnePath?a:a[(c-1)/4];void 0!==d&&(b+=d),b+=e[c+3]}return b},e}}function t(a,b,c,d){if(b.hasOnePath){var e=b[3],f=e?e(d,c,!0):b[2].getValueFrom(d);return b.isSimplePath?f:b.combinator(f)}for(var g=[],h=1;h<b.length;h+=4){var e=b[h+2];g[(h-1)/4]=e?e(d,c):b[h+1].getValueFrom(d)}return b.combinator(g)}function u(a,b,c,d){var e=b[3],f=e?e(d,c,!1):new PathObserver(d,b[2]);return b.isSimplePath?f:new ObserverTransform(f,b.combinator)}function v(a,b,c,d){if(b.onlyOneTime)return t(a,b,c,d);if(b.hasOnePath)return u(a,b,c,d);for(var e=new CompoundObserver,f=1;f<b.length;f+=4){var g=b[f],h=b[f+2];if(h){var i=h(d,c,g);g?e.addPath(i):e.addObserver(i)}else{var j=b[f+1];g?e.addPath(j.getValueFrom(d)):e.addPath(d,j)}}return new ObserverTransform(e,b.combinator)}function w(a,b,c,d){for(var e=0;e<b.length;e+=2){var f=b[e],g=b[e+1],h=v(f,g,a,c),i=a.bind(f,h,g.onlyOneTime);i&&d&&d.push(i)}if(a.bindFinished(),b.isTemplate){a.model_=c;var j=a.processBindingDirectives_(b);d&&j&&d.push(j)}}function x(a,b,c){var d=a.getAttribute(b);return s(""==d?"{{}}":d,b,a,c)}function y(a,c){b(a);for(var d=[],e=0;e<a.attributes.length;e++){for(var f=a.attributes[e],g=f.name,i=f.value;"_"===g[0];)g=g.substring(1);if(!h(a)||g!==J&&g!==H&&g!==I){var j=s(i,g,a,c);j&&d.push(g,j)}}return h(a)&&(d.isTemplate=!0,d["if"]=x(a,J,c),d.bind=x(a,H,c),d.repeat=x(a,I,c),!d["if"]||d.bind||d.repeat||(d.bind=s("{{}}",H,a,c))),d}function z(a,b){if(a.nodeType===Node.ELEMENT_NODE)return y(a,b);if(a.nodeType===Node.TEXT_NODE){var c=s(a.data,"textContent",a,b);if(c)return["textContent",c]}return[]}function A(a,b,c,d,e,f,g){for(var h=b.appendChild(c.importNode(a,!1)),i=0,j=a.firstChild;j;j=j.nextSibling)A(j,h,c,d.children[i++],e,f,g);return d.isTemplate&&(HTMLTemplateElement.decorate(h,a),f&&h.setDelegate_(f)),w(h,d,e,g),h}function B(a,b){var c=z(a,b);c.children={};for(var d=0,e=a.firstChild;e;e=e.nextSibling)c.children[d++]=B(e,b);return c}function C(a){var b=a.id_;return b||(b=a.id_=S++),b}function D(a,b){var c=C(a);if(b){var d=b.bindingMaps[c];return d||(d=b.bindingMaps[c]=B(a,b.prepareBinding)||[]),d}var d=a.bindingMap_;return d||(d=a.bindingMap_=B(a,void 0)||[]),d}function E(a){this.closed=!1,this.templateElement_=a,this.instances=[],this.deps=void 0,this.iteratedValue=[],this.presentValue=void 0,this.arrayObserver=void 0}var F,G=Array.prototype.forEach.call.bind(Array.prototype.forEach);a.Map&&"function"==typeof a.Map.prototype.forEach?F=a.Map:(F=function(){this.keys=[],this.values=[]},F.prototype={set:function(a,b){var c=this.keys.indexOf(a);0>c?(this.keys.push(a),this.values.push(b)):this.values[c]=b},get:function(a){var b=this.keys.indexOf(a);if(!(0>b))return this.values[b]},"delete":function(a){var b=this.keys.indexOf(a);return 0>b?!1:(this.keys.splice(b,1),this.values.splice(b,1),!0)},forEach:function(a,b){for(var c=0;c<this.keys.length;c++)a.call(b||this,this.values[c],this.keys[c],this)}});"function"!=typeof document.contains&&(Document.prototype.contains=function(a){return a===this||a.parentNode===this?!0:this.documentElement.contains(a)});var H="bind",I="repeat",J="if",K={template:!0,repeat:!0,bind:!0,ref:!0,"if":!0},L={THEAD:!0,TBODY:!0,TFOOT:!0,TH:!0,TR:!0,TD:!0,COLGROUP:!0,COL:!0,CAPTION:!0,OPTION:!0,OPTGROUP:!0},M="undefined"!=typeof HTMLTemplateElement;M&&!function(){var a=document.createElement("template"),b=a.content.ownerDocument,c=b.appendChild(b.createElement("html")),d=c.appendChild(b.createElement("head")),e=b.createElement("base");e.href=document.baseURI,d.appendChild(e)}();var N="template, "+Object.keys(L).map(function(a){return a.toLowerCase()+"[template]"}).join(", ");document.addEventListener("DOMContentLoaded",function(){j(document),Platform.performMicrotaskCheckpoint()},!1),M||(a.HTMLTemplateElement=function(){throw TypeError("Illegal constructor")});var O,P="__proto__"in{};"function"==typeof MutationObserver&&(O=new MutationObserver(function(a){for(var b=0;b<a.length;b++)a[b].target.refChanged_()})),HTMLTemplateElement.decorate=function(a,c){if(a.templateIsDecorated_)return!1;var d=a;d.templateIsDecorated_=!0;var h=f(d)&&M,i=h,k=!h,m=!1;if(h||(g(d)?(b(!c),d=n(a),d.templateIsDecorated_=!0,h=M,m=!0):e(d)&&(d=o(a),d.templateIsDecorated_=!0,h=M)),!h){q(d);var r=l(d);d.content_=r.createDocumentFragment()}return c?d.instanceRef_=c:k?p(d,a,m):i&&j(d.content),!0},HTMLTemplateElement.bootstrap=j;var Q=a.HTMLUnknownElement||HTMLElement,R={get:function(){return this.content_},enumerable:!0,configurable:!0};M||(HTMLTemplateElement.prototype=Object.create(Q.prototype),Object.defineProperty(HTMLTemplateElement.prototype,"content",R)),k(HTMLTemplateElement.prototype,{bind:function(a,b,c){if("ref"!=a)return Element.prototype.bind.call(this,a,b,c);var d=this,e=c?b:b.open(function(a){d.setAttribute("ref",a),d.refChanged_()});return this.setAttribute("ref",e),this.refChanged_(),c?void 0:(this.bindings_?this.bindings_.ref=b:this.bindings_={ref:b},b)},processBindingDirectives_:function(a){return this.iterator_&&this.iterator_.closeDeps(),a["if"]||a.bind||a.repeat?(this.iterator_||(this.iterator_=new E(this)),this.iterator_.updateDependencies(a,this.model_),O&&O.observe(this,{attributes:!0,attributeFilter:["ref"]}),this.iterator_):void(this.iterator_&&(this.iterator_.close(),this.iterator_=void 0))},createInstance:function(a,b,c){b?c=this.newDelegate_(b):c||(c=this.delegate_),this.refContent_||(this.refContent_=this.ref_.content);var d=this.refContent_;if(null===d.firstChild)return T;var e=D(d,c),f=m(this),g=f.createDocumentFragment();g.templateCreator_=this,g.protoContent_=d,g.bindings_=[],g.terminator_=null;for(var h=g.templateInstance_={firstNode:null,lastNode:null,model:a},i=0,j=!1,k=d.firstChild;k;k=k.nextSibling){null===k.nextSibling&&(j=!0);var l=A(k,g,f,e.children[i++],a,c,g.bindings_);l.templateInstance_=h,j&&(g.terminator_=l)}return h.firstNode=g.firstChild,h.lastNode=g.lastChild,g.templateCreator_=void 0,g.protoContent_=void 0,g},get model(){return this.model_},set model(a){this.model_=a,r(this)},get bindingDelegate(){return this.delegate_&&this.delegate_.raw},refChanged_:function(){this.iterator_&&this.refContent_!==this.ref_.content&&(this.refContent_=void 0,this.iterator_.valueChanged(),this.iterator_.updateIteratedValue(this.iterator_.getUpdatedValue()))},clear:function(){this.model_=void 0,this.delegate_=void 0,this.bindings_&&this.bindings_.ref&&this.bindings_.ref.close(),this.refContent_=void 0,this.iterator_&&(this.iterator_.valueChanged(),this.iterator_.close(),this.iterator_=void 0)},setDelegate_:function(a){this.delegate_=a,this.bindingMap_=void 0,this.iterator_&&(this.iterator_.instancePositionChangedFn_=void 0,this.iterator_.instanceModelFn_=void 0)},newDelegate_:function(a){function b(b){var c=a&&a[b];if("function"==typeof c)return function(){return c.apply(a,arguments)}}if(a)return{bindingMaps:{},raw:a,prepareBinding:b("prepareBinding"),prepareInstanceModel:b("prepareInstanceModel"),prepareInstancePositionChanged:b("prepareInstancePositionChanged")}},set bindingDelegate(a){if(this.delegate_)throw Error("Template must be cleared before a new bindingDelegate can be assigned");this.setDelegate_(this.newDelegate_(a))},get ref_(){var a=d(this,this.getAttribute("ref"));if(a||(a=this.instanceRef_),!a)return this;var b=a.ref_;return b?b:a}});var S=1;Object.defineProperty(Node.prototype,"templateInstance",{get:function(){var a=this.templateInstance_;return a?a:this.parentNode?this.parentNode.templateInstance:void 0}});var T=document.createDocumentFragment();T.bindings_=[],T.terminator_=null,E.prototype={closeDeps:function(){var a=this.deps;a&&(a.ifOneTime===!1&&a.ifValue.close(),a.oneTime===!1&&a.value.close())},updateDependencies:function(a,b){this.closeDeps();var c=this.deps={},d=this.templateElement_,e=!0;if(a["if"]){if(c.hasIf=!0,c.ifOneTime=a["if"].onlyOneTime,c.ifValue=v(J,a["if"],d,b),e=c.ifValue,c.ifOneTime&&!e)return void this.valueChanged();c.ifOneTime||(e=e.open(this.updateIfValue,this))}a.repeat?(c.repeat=!0,c.oneTime=a.repeat.onlyOneTime,c.value=v(I,a.repeat,d,b)):(c.repeat=!1,c.oneTime=a.bind.onlyOneTime,c.value=v(H,a.bind,d,b));var f=c.value;return c.oneTime||(f=f.open(this.updateIteratedValue,this)),e?void this.updateValue(f):void this.valueChanged()},getUpdatedValue:function(){var a=this.deps.value;return this.deps.oneTime||(a=a.discardChanges()),a},updateIfValue:function(a){return a?void this.updateValue(this.getUpdatedValue()):void this.valueChanged()},updateIteratedValue:function(a){if(this.deps.hasIf){var b=this.deps.ifValue;if(this.deps.ifOneTime||(b=b.discardChanges()),!b)return void this.valueChanged()}this.updateValue(a)},updateValue:function(a){this.deps.repeat||(a=[a]);var b=this.deps.repeat&&!this.deps.oneTime&&Array.isArray(a);this.valueChanged(a,b)},valueChanged:function(a,b){Array.isArray(a)||(a=[]),a!==this.iteratedValue&&(this.unobserve(),this.presentValue=a,b&&(this.arrayObserver=new ArrayObserver(this.presentValue),this.arrayObserver.open(this.handleSplices,this)),this.handleSplices(ArrayObserver.calculateSplices(this.presentValue,this.iteratedValue)))},getLastInstanceNode:function(a){if(-1==a)return this.templateElement_;var b=this.instances[a],c=b.terminator_;if(!c)return this.getLastInstanceNode(a-1);if(c.nodeType!==Node.ELEMENT_NODE||this.templateElement_===c)return c;var d=c.iterator_;return d?d.getLastTemplateNode():c},getLastTemplateNode:function(){return this.getLastInstanceNode(this.instances.length-1)},insertInstanceAt:function(a,b){var c=this.getLastInstanceNode(a-1),d=this.templateElement_.parentNode;this.instances.splice(a,0,b),d.insertBefore(b,c.nextSibling)},extractInstanceAt:function(a){for(var b=this.getLastInstanceNode(a-1),c=this.getLastInstanceNode(a),d=this.templateElement_.parentNode,e=this.instances.splice(a,1)[0];c!==b;){var f=b.nextSibling;f==c&&(c=b),e.appendChild(d.removeChild(f))}return e},getDelegateFn:function(a){return a=a&&a(this.templateElement_),"function"==typeof a?a:null},handleSplices:function(a){if(!this.closed&&a.length){var b=this.templateElement_;if(!b.parentNode)return void this.close();ArrayObserver.applySplices(this.iteratedValue,this.presentValue,a);var c=b.delegate_;void 0===this.instanceModelFn_&&(this.instanceModelFn_=this.getDelegateFn(c&&c.prepareInstanceModel)),void 0===this.instancePositionChangedFn_&&(this.instancePositionChangedFn_=this.getDelegateFn(c&&c.prepareInstancePositionChanged));for(var d=new F,e=0,f=0;f<a.length;f++){for(var g=a[f],h=g.removed,i=0;i<h.length;i++){var j=h[i],k=this.extractInstanceAt(g.index+e);k!==T&&d.set(j,k)}e-=g.addedCount}for(var f=0;f<a.length;f++)for(var g=a[f],l=g.index;l<g.index+g.addedCount;l++){var j=this.iteratedValue[l],k=d.get(j);k?d["delete"](j):(this.instanceModelFn_&&(j=this.instanceModelFn_(j)),k=void 0===j?T:b.createInstance(j,void 0,c)),this.insertInstanceAt(l,k)}d.forEach(function(a){this.closeInstanceBindings(a)},this),this.instancePositionChangedFn_&&this.reportInstancesMoved(a)}},reportInstanceMoved:function(a){var b=this.instances[a];b!==T&&this.instancePositionChangedFn_(b.templateInstance_,a)},reportInstancesMoved:function(a){for(var b=0,c=0,d=0;d<a.length;d++){var e=a[d];if(0!=c)for(;b<e.index;)this.reportInstanceMoved(b),b++;else b=e.index;for(;b<e.index+e.addedCount;)this.reportInstanceMoved(b),b++;c+=e.addedCount-e.removed.length}if(0!=c)for(var f=this.instances.length;f>b;)this.reportInstanceMoved(b),b++},closeInstanceBindings:function(a){for(var b=a.bindings_,c=0;c<b.length;c++)b[c].close()},unobserve:function(){this.arrayObserver&&(this.arrayObserver.close(),this.arrayObserver=void 0)},close:function(){if(!this.closed){this.unobserve();for(var a=0;a<this.instances.length;a++)this.closeInstanceBindings(this.instances[a]);this.instances.length=0,this.closeDeps(),this.templateElement_.iterator_=void 0,this.closed=!0}}},HTMLTemplateElement.forAllTemplatesFrom_=i}(this),function(a){"use strict";function b(a){return void 0!==m[a]}function c(){h.call(this),this._isInvalid=!0}function d(a){return""==a&&c.call(this),a.toLowerCase()}function e(a){var b=a.charCodeAt(0);return b>32&&127>b&&-1==[34,35,60,62,63,96].indexOf(b)?a:encodeURIComponent(a)}function f(a){var b=a.charCodeAt(0);return b>32&&127>b&&-1==[34,35,60,62,96].indexOf(b)?a:encodeURIComponent(a)}function g(a,g,h){function i(a){t.push(a)}var j=g||"scheme start",k=0,l="",r=!1,s=!1,t=[];a:for(;(a[k-1]!=o||0==k)&&!this._isInvalid;){var u=a[k];switch(j){case"scheme start":if(!u||!p.test(u)){if(g){i("Invalid scheme.");break a}l="",j="no scheme";continue}l+=u.toLowerCase(),j="scheme";break;case"scheme":if(u&&q.test(u))l+=u.toLowerCase();else{if(":"!=u){if(g){if(o==u)break a;i("Code point not allowed in scheme: "+u);break a}l="",k=0,j="no scheme";continue}if(this._scheme=l,l="",g)break a;b(this._scheme)&&(this._isRelative=!0),j="file"==this._scheme?"relative":this._isRelative&&h&&h._scheme==this._scheme?"relative or authority":this._isRelative?"authority first slash":"scheme data"}break;case"scheme data":"?"==u?(query="?",j="query"):"#"==u?(this._fragment="#",j="fragment"):o!=u&&"	"!=u&&"\n"!=u&&"\r"!=u&&(this._schemeData+=e(u));break;case"no scheme":if(h&&b(h._scheme)){j="relative";continue}i("Missing scheme."),c.call(this);break;case"relative or authority":if("/"!=u||"/"!=a[k+1]){i("Expected /, got: "+u),j="relative";continue}j="authority ignore slashes";break;case"relative":if(this._isRelative=!0,"file"!=this._scheme&&(this._scheme=h._scheme),o==u){this._host=h._host,this._port=h._port,this._path=h._path.slice(),this._query=h._query;break a}if("/"==u||"\\"==u)"\\"==u&&i("\\ is an invalid code point."),j="relative slash";else if("?"==u)this._host=h._host,this._port=h._port,this._path=h._path.slice(),this._query="?",j="query";else{if("#"!=u){var v=a[k+1],w=a[k+2];("file"!=this._scheme||!p.test(u)||":"!=v&&"|"!=v||o!=w&&"/"!=w&&"\\"!=w&&"?"!=w&&"#"!=w)&&(this._host=h._host,this._port=h._port,this._path=h._path.slice(),this._path.pop()),j="relative path";continue}this._host=h._host,this._port=h._port,this._path=h._path.slice(),this._query=h._query,this._fragment="#",j="fragment"}break;case"relative slash":if("/"!=u&&"\\"!=u){"file"!=this._scheme&&(this._host=h._host,this._port=h._port),j="relative path";continue}"\\"==u&&i("\\ is an invalid code point."),j="file"==this._scheme?"file host":"authority ignore slashes";break;case"authority first slash":if("/"!=u){i("Expected '/', got: "+u),j="authority ignore slashes";continue}j="authority second slash";break;case"authority second slash":if(j="authority ignore slashes","/"!=u){i("Expected '/', got: "+u);continue}break;case"authority ignore slashes":if("/"!=u&&"\\"!=u){j="authority";continue}i("Expected authority, got: "+u);break;case"authority":if("@"==u){r&&(i("@ already seen."),l+="%40"),r=!0;for(var x=0;x<l.length;x++){var y=l[x];if("	"!=y&&"\n"!=y&&"\r"!=y)if(":"!=y||null!==this._password){var z=e(y);null!==this._password?this._password+=z:this._username+=z}else this._password="";else i("Invalid whitespace in authority.")}l=""}else{if(o==u||"/"==u||"\\"==u||"?"==u||"#"==u){k-=l.length,l="",j="host";continue}l+=u}break;case"file host":if(o==u||"/"==u||"\\"==u||"?"==u||"#"==u){2!=l.length||!p.test(l[0])||":"!=l[1]&&"|"!=l[1]?0==l.length?j="relative path start":(this._host=d.call(this,l),l="",j="relative path start"):j="relative path";continue}"	"==u||"\n"==u||"\r"==u?i("Invalid whitespace in file host."):l+=u;break;case"host":case"hostname":if(":"!=u||s){if(o==u||"/"==u||"\\"==u||"?"==u||"#"==u){if(this._host=d.call(this,l),l="",j="relative path start",g)break a;continue}"	"!=u&&"\n"!=u&&"\r"!=u?("["==u?s=!0:"]"==u&&(s=!1),l+=u):i("Invalid code point in host/hostname: "+u)}else if(this._host=d.call(this,l),l="",j="port","hostname"==g)break a;break;case"port":if(/[0-9]/.test(u))l+=u;else{if(o==u||"/"==u||"\\"==u||"?"==u||"#"==u||g){if(""!=l){var A=parseInt(l,10);A!=m[this._scheme]&&(this._port=A+""),l=""}if(g)break a;j="relative path start";continue}"	"==u||"\n"==u||"\r"==u?i("Invalid code point in port: "+u):c.call(this)}break;case"relative path start":if("\\"==u&&i("'\\' not allowed in path."),j="relative path","/"!=u&&"\\"!=u)continue;break;case"relative path":if(o!=u&&"/"!=u&&"\\"!=u&&(g||"?"!=u&&"#"!=u))"	"!=u&&"\n"!=u&&"\r"!=u&&(l+=e(u));else{"\\"==u&&i("\\ not allowed in relative path.");var B;(B=n[l.toLowerCase()])&&(l=B),".."==l?(this._path.pop(),"/"!=u&&"\\"!=u&&this._path.push("")):"."==l&&"/"!=u&&"\\"!=u?this._path.push(""):"."!=l&&("file"==this._scheme&&0==this._path.length&&2==l.length&&p.test(l[0])&&"|"==l[1]&&(l=l[0]+":"),this._path.push(l)),l="","?"==u?(this._query="?",j="query"):"#"==u&&(this._fragment="#",j="fragment")}break;case"query":g||"#"!=u?o!=u&&"	"!=u&&"\n"!=u&&"\r"!=u&&(this._query+=f(u)):(this._fragment="#",j="fragment");break;case"fragment":o!=u&&"	"!=u&&"\n"!=u&&"\r"!=u&&(this._fragment+=u)}k++}}function h(){this._scheme="",this._schemeData="",this._username="",this._password=null,this._host="",this._port="",this._path=[],this._query="",this._fragment="",this._isInvalid=!1,this._isRelative=!1}function i(a,b){void 0===b||b instanceof i||(b=new i(String(b))),this._url=a,h.call(this);var c=a.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g,"");g.call(this,c,null,b)}var j=!1;if(!a.forceJURL)try{var k=new URL("b","http://a");k.pathname="c%20d",j="http://a/c%20d"===k.href}catch(l){}if(!j){var m=Object.create(null);m.ftp=21,m.file=0,m.gopher=70,m.http=80,m.https=443,m.ws=80,m.wss=443;var n=Object.create(null);n["%2e"]=".",n[".%2e"]="..",n["%2e."]="..",n["%2e%2e"]="..";var o=void 0,p=/[a-zA-Z]/,q=/[a-zA-Z0-9\+\-\.]/;i.prototype={get href(){if(this._isInvalid)return this._url;var a="";return(""!=this._username||null!=this._password)&&(a=this._username+(null!=this._password?":"+this._password:"")+"@"),this.protocol+(this._isRelative?"//"+a+this.host:"")+this.pathname+this._query+this._fragment},set href(a){h.call(this),g.call(this,a)},get protocol(){return this._scheme+":"},set protocol(a){this._isInvalid||g.call(this,a+":","scheme start")},get host(){return this._isInvalid?"":this._port?this._host+":"+this._port:this._host},set host(a){!this._isInvalid&&this._isRelative&&g.call(this,a,"host")},get hostname(){return this._host},set hostname(a){!this._isInvalid&&this._isRelative&&g.call(this,a,"hostname")},get port(){return this._port},set port(a){!this._isInvalid&&this._isRelative&&g.call(this,a,"port")},get pathname(){return this._isInvalid?"":this._isRelative?"/"+this._path.join("/"):this._schemeData},set pathname(a){!this._isInvalid&&this._isRelative&&(this._path=[],g.call(this,a,"relative path start"))},get search(){return this._isInvalid||!this._query||"?"==this._query?"":this._query},set search(a){!this._isInvalid&&this._isRelative&&(this._query="?","?"==a[0]&&(a=a.slice(1)),g.call(this,a,"query"))},get hash(){return this._isInvalid||!this._fragment||"#"==this._fragment?"":this._fragment},set hash(a){this._isInvalid||(this._fragment="#","#"==a[0]&&(a=a.slice(1)),g.call(this,a,"fragment"))},get origin(){var a;if(this._isInvalid||!this._scheme)return"";switch(this._scheme){case"data":case"file":case"javascript":case"mailto":return"null"}return a=this.host,a?this._scheme+"://"+a:""}};var r=a.URL;r&&(i.createObjectURL=function(){return r.createObjectURL.apply(r,arguments)},i.revokeObjectURL=function(a){r.revokeObjectURL(a)}),a.URL=i}}(this),function(a){function b(a){f.textContent=d++,e.push(a)}function c(){for(;e.length;)e.shift()()}var d=0,e=[],f=document.createTextNode("");new(window.MutationObserver||JsMutationObserver)(c).observe(f,{characterData:!0}),a.endOfMicrotask=b,Platform.endOfMicrotask=b}(Polymer),function(a){function b(){g||(g=!0,c(function(){g=!1,d.data&&console.group("flush"),Platform.performMicrotaskCheckpoint(),d.data&&console.groupEnd()}))}var c=a.endOfMicrotask,d=window.WebComponents?WebComponents.flags.log:{},e=document.createElement("style");e.textContent="template {display: none !important;} /* injected by platform.js */";var f=document.querySelector("head");f.insertBefore(e,f.firstChild);var g;if(Observer.hasObjectObserve)b=function(){};else{var h=125;window.addEventListener("WebComponentsReady",function(){b();var c=function(){"hidden"===document.visibilityState?a.flushPoll&&clearInterval(a.flushPoll):a.flushPoll=setInterval(b,h)};"string"==typeof document.visibilityState&&document.addEventListener("visibilitychange",c),c()})}if(window.CustomElements&&!CustomElements.useNative){var i=Document.prototype.importNode;Document.prototype.importNode=function(a,b){var c=i.call(this,a,b);return CustomElements.upgradeAll(c),c}}a.flush=b,Platform.flush=b}(window.Polymer),function(a){function b(a){var b=new URL(a.ownerDocument.baseURI);return b.search="",b.hash="",b}function c(a,b,c,e){return a.replace(e,function(a,e,f,g){var h=f.replace(/["']/g,"");return h=d(b,h,c),e+"'"+h+"'"+g})}function d(a,b,c){if(b&&"/"===b[0])return b;if(b&&"#"===b[0])return b;var d=new URL(b,a);return c?d.href:e(d.href)}function e(a){var c=b(document.documentElement),d=new URL(a,c);return d.host===c.host&&d.port===c.port&&d.protocol===c.protocol?f(c,d):a}function f(a,b){for(var c=a.pathname,d=b.pathname,e=c.split("/"),f=d.split("/");e.length&&e[0]===f[0];)e.shift(),f.shift();for(var g=0,h=e.length-1;h>g;g++)f.unshift("..");var i=b.href.slice(-1)===m?m:b.hash;return f.join("/")+b.search+i}var g={resolveDom:function(a,c){c=c||b(a),this.resolveAttributes(a,c),this.resolveStyles(a,c);var d=a.querySelectorAll("template");if(d)for(var e,f=0,g=d.length;g>f&&(e=d[f]);f++)e.content&&this.resolveDom(e.content,c)},resolveTemplate:function(a){this.resolveDom(a.content,b(a))},resolveStyles:function(a,b){var c=a.querySelectorAll("style");if(c)for(var d,e=0,f=c.length;f>e&&(d=c[e]);e++)this.resolveStyle(d,b)},resolveStyle:function(a,c){c=c||b(a),a.textContent=this.resolveCssText(a.textContent,c)},resolveCssText:function(a,b,d){return a=c(a,b,d,h),c(a,b,d,i)},resolveAttributes:function(a,b){a.hasAttributes&&a.hasAttributes()&&this.resolveElementAttributes(a,b);var c=a&&a.querySelectorAll(k);if(c)for(var d,e=0,f=c.length;f>e&&(d=c[e]);e++)this.resolveElementAttributes(d,b)},resolveElementAttributes:function(a,e){e=e||b(a),j.forEach(function(b){var f,g=a.attributes[b],i=g&&g.value;i&&i.search(l)<0&&(f="style"===b?c(i,e,!1,h):d(e,i),g.value=f)})}},h=/(url\()([^)]*)(\))/g,i=/(@import[\s]+(?!url\())([^;]*)(;)/g,j=["href","src","action","style","url"],k="["+j.join("],[")+"]",l="{{.*}}",m="#";a.urlResolver=g}(Polymer),function(a){function b(a){this.cache=Object.create(null),this.map=Object.create(null),this.requests=0,this.regex=a}var c=Polymer.endOfMicrotask;b.prototype={extractUrls:function(a,b){for(var c,d,e=[];c=this.regex.exec(a);)d=new URL(c[1],b),e.push({matched:c[0],url:d.href});return e},process:function(a,b,c){var d=this.extractUrls(a,b),e=c.bind(null,this.map);this.fetch(d,e)},fetch:function(a,b){var c=a.length;if(!c)return b();for(var d,e,f,g=function(){0===--c&&b()},h=0;c>h;h++)d=a[h],f=d.url,e=this.cache[f],e||(e=this.xhr(f),e.match=d,this.cache[f]=e),e.wait(g)},handleXhr:function(a){var b=a.match,c=b.url,d=a.response||a.responseText||"";this.map[c]=d,this.fetch(this.extractUrls(d,c),a.resolve)},xhr:function(a){this.requests++;var b=new XMLHttpRequest;return b.open("GET",a,!0),b.send(),b.onerror=b.onload=this.handleXhr.bind(this,b),b.pending=[],b.resolve=function(){for(var a=b.pending,c=0;c<a.length;c++)a[c]();b.pending=null},b.wait=function(a){b.pending?b.pending.push(a):c(a)},b}},a.Loader=b}(Polymer),function(a){function b(){this.loader=new d(this.regex)}var c=a.urlResolver,d=a.Loader;b.prototype={regex:/@import\s+(?:url)?["'\(]*([^'"\)]*)['"\)]*;/g,resolve:function(a,b,c){var d=function(d){c(this.flatten(a,b,d))}.bind(this);this.loader.process(a,b,d)},resolveNode:function(a,b,c){var d=a.textContent,e=function(b){a.textContent=b,c(a)};this.resolve(d,b,e)},flatten:function(a,b,d){for(var e,f,g,h=this.loader.extractUrls(a,b),i=0;i<h.length;i++)e=h[i],f=e.url,g=c.resolveCssText(d[f],f,!0),g=this.flatten(g,b,d),a=a.replace(e.matched,g);return a},loadStyles:function(a,b,c){function d(){f++,f===g&&c&&c()}for(var e,f=0,g=a.length,h=0;g>h&&(e=a[h]);h++)this.resolveNode(e,b,d)}};var e=new b;a.styleResolver=e}(Polymer),function(a){function b(a,b){return a&&b&&Object.getOwnPropertyNames(b).forEach(function(c){var d=Object.getOwnPropertyDescriptor(b,c);d&&(Object.defineProperty(a,c,d),"function"==typeof d.value&&(d.value.nom=c))}),a}function c(a){for(var b=a||{},c=1;c<arguments.length;c++){var e=arguments[c];try{for(var f in e)d(f,e,b)}catch(g){}}return b}function d(a,b,c){var d=e(b,a);Object.defineProperty(c,a,d)}function e(a,b){if(a){var c=Object.getOwnPropertyDescriptor(a,b);return c||e(Object.getPrototypeOf(a),b)}}a.extend=b,a.mixin=c,Platform.mixin=c}(Polymer),function(a){function b(a,b,d){return a?a.stop():a=new c(this),a.go(b,d),a}var c=function(a){this.context=a,this.boundComplete=this.complete.bind(this)};c.prototype={go:function(a,b){this.callback=a;var c;b?(c=setTimeout(this.boundComplete,b),this.handle=function(){clearTimeout(c)}):(c=requestAnimationFrame(this.boundComplete),this.handle=function(){cancelAnimationFrame(c)})},stop:function(){this.handle&&(this.handle(),this.handle=null)},complete:function(){this.handle&&(this.stop(),this.callback.call(this.context))}},a.job=b}(Polymer),function(a){function b(a,b,c){var d="string"==typeof a?document.createElement(a):a.cloneNode(!0);if(d.innerHTML=b,c)for(var e in c)d.setAttribute(e,c[e]);return d}var c={};HTMLElement.register=function(a,b){c[a]=b},HTMLElement.getPrototypeForTag=function(a){var b=a?c[a]:HTMLElement.prototype;return b||Object.getPrototypeOf(document.createElement(a))};var d=Event.prototype.stopPropagation;Event.prototype.stopPropagation=function(){this.cancelBubble=!0,d.apply(this,arguments)};var e=DOMTokenList.prototype.add,f=DOMTokenList.prototype.remove;DOMTokenList.prototype.add=function(){for(var a=0;a<arguments.length;a++)e.call(this,arguments[a])},DOMTokenList.prototype.remove=function(){for(var a=0;a<arguments.length;a++)f.call(this,arguments[a])},DOMTokenList.prototype.toggle=function(a,b){1==arguments.length&&(b=!this.contains(a)),b?this.add(a):this.remove(a)},DOMTokenList.prototype["switch"]=function(a,b){a&&this.remove(a),b&&this.add(b)};var g=function(){return Array.prototype.slice.call(this)},h=window.NamedNodeMap||window.MozNamedAttrMap||{};NodeList.prototype.array=g,h.prototype.array=g,HTMLCollection.prototype.array=g,a.createDOM=b}(Polymer),function(a){function b(a){var e=b.caller,g=e.nom,h=e._super;h||(g||(g=e.nom=c.call(this,e)),g||console.warn("called super() on a method not installed declaratively (has no .nom property)"),h=d(e,g,f(this)));var i=h[g];return i?(i._super||d(i,g,h),i.apply(this,a||[])):void 0}function c(a){for(var b=this.__proto__;b&&b!==HTMLElement.prototype;){for(var c,d=Object.getOwnPropertyNames(b),e=0,f=d.length;f>e&&(c=d[e]);e++){var g=Object.getOwnPropertyDescriptor(b,c);if("function"==typeof g.value&&g.value===a)return c}b=b.__proto__}}function d(a,b,c){var d=e(c,b,a);return d[b]&&(d[b].nom=b),a._super=d}function e(a,b,c){for(;a;){if(a[b]!==c&&a[b])return a;a=f(a)}return Object}function f(a){return a.__proto__}a["super"]=b}(Polymer),function(a){function b(a){return a}function c(a,b){var c=typeof b;return b instanceof Date&&(c="date"),d[c](a,b)}var d={string:b,undefined:b,date:function(a){return new Date(Date.parse(a)||Date.now())},"boolean":function(a){return""===a?!0:"false"===a?!1:!!a},number:function(a){var b=parseFloat(a);return 0===b&&(b=parseInt(a)),isNaN(b)?a:b},object:function(a,b){if(null===b)return a;try{return JSON.parse(a.replace(/'/g,'"'))}catch(c){return a}},"function":function(a,b){return b}};a.deserializeValue=c}(Polymer),function(a){var b=a.extend,c={};c.declaration={},c.instance={},c.publish=function(a,c){for(var d in a)b(c,a[d])},a.api=c}(Polymer),function(a){var b={async:function(a,b,c){Polymer.flush(),b=b&&b.length?b:[b];var d=function(){(this[a]||a).apply(this,b)}.bind(this),e=c?setTimeout(d,c):requestAnimationFrame(d);return c?e:~e},cancelAsync:function(a){0>a?cancelAnimationFrame(~a):clearTimeout(a)},fire:function(a,b,c,d,e){var f=c||this,b=null===b||void 0===b?{}:b,g=new CustomEvent(a,{bubbles:void 0!==d?d:!0,cancelable:void 0!==e?e:!0,detail:b});return f.dispatchEvent(g),g},asyncFire:function(){this.async("fire",arguments)},classFollows:function(a,b,c){b&&b.classList.remove(c),a&&a.classList.add(c)},injectBoundHTML:function(a,b){var c=document.createElement("template");c.innerHTML=a;var d=this.instanceTemplate(c);return b&&(b.textContent="",b.appendChild(d)),d}},c=function(){},d={};b.asyncMethod=b.async,a.api.instance.utils=b,a.nop=c,a.nob=d}(Polymer),function(a){var b=window.WebComponents?WebComponents.flags.log:{},c="on-",d={EVENT_PREFIX:c,addHostListeners:function(){var a=this.eventDelegates;
b.events&&Object.keys(a).length>0&&console.log("[%s] addHostListeners:",this.localName,a);for(var c in a){var d=a[c];PolymerGestures.addEventListener(this,c,this.element.getEventHandler(this,this,d))}},dispatchMethod:function(a,c,d){if(a){b.events&&console.group("[%s] dispatch [%s]",a.localName,c);var e="function"==typeof c?c:a[c];e&&e[d?"apply":"call"](a,d),b.events&&console.groupEnd(),Polymer.flush()}}};a.api.instance.events=d,a.addEventListener=function(a,b,c,d){PolymerGestures.addEventListener(wrap(a),b,c,d)},a.removeEventListener=function(a,b,c,d){PolymerGestures.removeEventListener(wrap(a),b,c,d)}}(Polymer),function(a){var b={copyInstanceAttributes:function(){var a=this._instanceAttributes;for(var b in a)this.hasAttribute(b)||this.setAttribute(b,a[b])},takeAttributes:function(){if(this._publishLC)for(var a,b=0,c=this.attributes,d=c.length;(a=c[b])&&d>b;b++)this.attributeToProperty(a.name,a.value)},attributeToProperty:function(b,c){var b=this.propertyForAttribute(b);if(b){if(c&&c.search(a.bindPattern)>=0)return;var d=this[b],c=this.deserializeValue(c,d);c!==d&&(this[b]=c)}},propertyForAttribute:function(a){var b=this._publishLC&&this._publishLC[a];return b},deserializeValue:function(b,c){return a.deserializeValue(b,c)},serializeValue:function(a,b){return"boolean"===b?a?"":void 0:"object"!==b&&"function"!==b&&void 0!==a?a:void 0},reflectPropertyToAttribute:function(a){var b=typeof this[a],c=this.serializeValue(this[a],b);void 0!==c?this.setAttribute(a,c):"boolean"===b&&this.removeAttribute(a)}};a.api.instance.attributes=b}(Polymer),function(a){function b(a,b){return a===b?0!==a||1/a===1/b:f(a)&&f(b)?!0:a!==a&&b!==b}function c(a,b){return void 0===b&&null===a?b:null===b||void 0===b?a:b}var d=window.WebComponents?WebComponents.flags.log:{},e={object:void 0,type:"update",name:void 0,oldValue:void 0},f=Number.isNaN||function(a){return"number"==typeof a&&isNaN(a)},g={createPropertyObserver:function(){var a=this._observeNames;if(a&&a.length){var b=this._propertyObserver=new CompoundObserver(!0);this.registerObserver(b);for(var c,d=0,e=a.length;e>d&&(c=a[d]);d++)b.addPath(this,c),this.observeArrayValue(c,this[c],null)}},openPropertyObserver:function(){this._propertyObserver&&this._propertyObserver.open(this.notifyPropertyChanges,this)},notifyPropertyChanges:function(a,b,c){var d,e,f={};for(var g in b)if(d=c[2*g+1],e=this.observe[d]){var h=b[g],i=a[g];this.observeArrayValue(d,i,h),f[e]||(void 0!==h&&null!==h||void 0!==i&&null!==i)&&(f[e]=!0,this.invokeMethod(e,[h,i,arguments]))}},invokeMethod:function(a,b){var c=this[a]||a;"function"==typeof c&&c.apply(this,b)},deliverChanges:function(){this._propertyObserver&&this._propertyObserver.deliver()},observeArrayValue:function(a,b,c){var e=this.observe[a];if(e&&(Array.isArray(c)&&(d.observe&&console.log("[%s] observeArrayValue: unregister observer [%s]",this.localName,a),this.closeNamedObserver(a+"__array")),Array.isArray(b))){d.observe&&console.log("[%s] observeArrayValue: register observer [%s]",this.localName,a,b);var f=new ArrayObserver(b);f.open(function(a){this.invokeMethod(e,[a])},this),this.registerNamedObserver(a+"__array",f)}},emitPropertyChangeRecord:function(a,c,d){if(!b(c,d)&&(this._propertyChanged(a,c,d),Observer.hasObjectObserve)){var f=this._objectNotifier;f||(f=this._objectNotifier=Object.getNotifier(this)),e.object=this,e.name=a,e.oldValue=d,f.notify(e)}},_propertyChanged:function(a){this.reflect[a]&&this.reflectPropertyToAttribute(a)},bindProperty:function(a,b,d){if(d)return void(this[a]=b);var e=this.element.prototype.computed;if(e&&e[a]){var f=a+"ComputedBoundObservable_";return void(this[f]=b)}return this.bindToAccessor(a,b,c)},bindToAccessor:function(a,c,d){function e(b,c){j[f]=b;var d=j[h];d&&"function"==typeof d.setValue&&d.setValue(b),j.emitPropertyChangeRecord(a,b,c)}var f=a+"_",g=a+"Observable_",h=a+"ComputedBoundObservable_";this[g]=c;var i=this[f],j=this,k=c.open(e);if(d&&!b(i,k)){var l=d(i,k);b(k,l)||(k=l,c.setValue&&c.setValue(k))}e(k,i);var m={close:function(){c.close(),j[g]=void 0,j[h]=void 0}};return this.registerObserver(m),m},createComputedProperties:function(){if(this._computedNames)for(var a=0;a<this._computedNames.length;a++){var b=this._computedNames[a],c=this.computed[b];try{var d=PolymerExpressions.getExpression(c),e=d.getBinding(this,this.element.syntax);this.bindToAccessor(b,e)}catch(f){console.error("Failed to create computed property",f)}}},registerObserver:function(a){return this._observers?void this._observers.push(a):void(this._observers=[a])},closeObservers:function(){if(this._observers){for(var a=this._observers,b=0;b<a.length;b++){var c=a[b];c&&"function"==typeof c.close&&c.close()}this._observers=[]}},registerNamedObserver:function(a,b){var c=this._namedObservers||(this._namedObservers={});c[a]=b},closeNamedObserver:function(a){var b=this._namedObservers;return b&&b[a]?(b[a].close(),b[a]=null,!0):void 0},closeNamedObservers:function(){if(this._namedObservers){for(var a in this._namedObservers)this.closeNamedObserver(a);this._namedObservers={}}}};a.api.instance.properties=g}(Polymer),function(a){var b=window.WebComponents?WebComponents.flags.log:{},c={instanceTemplate:function(a){HTMLTemplateElement.decorate(a);for(var b=this.syntax||!a.bindingDelegate&&this.element.syntax,c=a.createInstance(this,b),d=c.bindings_,e=0;e<d.length;e++)this.registerObserver(d[e]);return c},bind:function(a,b,c){var d=this.propertyForAttribute(a);if(d){var e=this.bindProperty(d,b,c);return Platform.enableBindingsReflection&&e&&(e.path=b.path_,this._recordBinding(d,e)),this.reflect[d]&&this.reflectPropertyToAttribute(d),e}return this.mixinSuper(arguments)},_recordBinding:function(a,b){this.bindings_=this.bindings_||{},this.bindings_[a]=b},bindFinished:function(){this.makeElementReady()},asyncUnbindAll:function(){this._unbound||(b.unbind&&console.log("[%s] asyncUnbindAll",this.localName),this._unbindAllJob=this.job(this._unbindAllJob,this.unbindAll,0))},unbindAll:function(){this._unbound||(this.closeObservers(),this.closeNamedObservers(),this._unbound=!0)},cancelUnbindAll:function(){return this._unbound?void(b.unbind&&console.warn("[%s] already unbound, cannot cancel unbindAll",this.localName)):(b.unbind&&console.log("[%s] cancelUnbindAll",this.localName),void(this._unbindAllJob&&(this._unbindAllJob=this._unbindAllJob.stop())))}},d=/\{\{([^{}]*)}}/;a.bindPattern=d,a.api.instance.mdv=c}(Polymer),function(a){function b(a){return a.hasOwnProperty("PolymerBase")}function c(){}var d={PolymerBase:!0,job:function(a,b,c){if("string"!=typeof a)return Polymer.job.call(this,a,b,c);var d="___"+a;this[d]=Polymer.job.call(this,this[d],b,c)},"super":Polymer["super"],created:function(){},ready:function(){},createdCallback:function(){this.templateInstance&&this.templateInstance.model&&console.warn("Attributes on "+this.localName+" were data bound prior to Polymer upgrading the element. This may result in incorrect binding types."),this.created(),this.prepareElement(),this.ownerDocument.isStagingDocument||this.makeElementReady()},prepareElement:function(){return this._elementPrepared?void console.warn("Element already prepared",this.localName):(this._elementPrepared=!0,this.shadowRoots={},this.createPropertyObserver(),this.openPropertyObserver(),this.copyInstanceAttributes(),this.takeAttributes(),void this.addHostListeners())},makeElementReady:function(){this._readied||(this._readied=!0,this.createComputedProperties(),this.parseDeclarations(this.__proto__),this.removeAttribute("unresolved"),this.ready())},attributeChangedCallback:function(a){"class"!==a&&"style"!==a&&this.attributeToProperty(a,this.getAttribute(a)),this.attributeChanged&&this.attributeChanged.apply(this,arguments)},attachedCallback:function(){this.cancelUnbindAll(),this.attached&&this.attached(),this.hasBeenAttached||(this.hasBeenAttached=!0,this.domReady&&this.async("domReady"))},detachedCallback:function(){this.preventDispose||this.asyncUnbindAll(),this.detached&&this.detached(),this.leftView&&this.leftView()},parseDeclarations:function(a){a&&a.element&&(this.parseDeclarations(a.__proto__),a.parseDeclaration.call(this,a.element))},parseDeclaration:function(a){var b=this.fetchTemplate(a);if(b){var c=this.shadowFromTemplate(b);this.shadowRoots[a.name]=c}},fetchTemplate:function(a){return a.querySelector("template")},shadowFromTemplate:function(a){if(a){var b=this.createShadowRoot(),c=this.instanceTemplate(a);return b.appendChild(c),this.shadowRootReady(b,a),b}},lightFromTemplate:function(a,b){if(a){this.eventController=this;var c=this.instanceTemplate(a);return b?this.insertBefore(c,b):this.appendChild(c),this.shadowRootReady(this),c}},shadowRootReady:function(a){this.marshalNodeReferences(a)},marshalNodeReferences:function(a){var b=this.$=this.$||{};if(a)for(var c,d=a.querySelectorAll("[id]"),e=0,f=d.length;f>e&&(c=d[e]);e++)b[c.id]=c},onMutation:function(a,b){var c=new MutationObserver(function(a){b.call(this,c,a),c.disconnect()}.bind(this));c.observe(a,{childList:!0,subtree:!0})}};c.prototype=d,d.constructor=c,a.Base=c,a.isBase=b,a.api.instance.base=d}(Polymer),function(a){function b(a){return a.__proto__}function c(a,b){var c="",d=!1;b&&(c=b.localName,d=b.hasAttribute("is"));var e=WebComponents.ShadowCSS.makeScopeSelector(c,d);return WebComponents.ShadowCSS.shimCssText(a,e)}var d=(window.WebComponents?WebComponents.flags.log:{},window.ShadowDOMPolyfill),e="element",f="controller",g={STYLE_SCOPE_ATTRIBUTE:e,installControllerStyles:function(){var a=this.findStyleScope();if(a&&!this.scopeHasNamedStyle(a,this.localName)){for(var c=b(this),d="";c&&c.element;)d+=c.element.cssTextForScope(f),c=b(c);d&&this.installScopeCssText(d,a)}},installScopeStyle:function(a,b,c){var c=c||this.findStyleScope(),b=b||"";if(c&&!this.scopeHasNamedStyle(c,this.localName+b)){var d="";if(a instanceof Array)for(var e,f=0,g=a.length;g>f&&(e=a[f]);f++)d+=e.textContent+"\n\n";else d=a.textContent;this.installScopeCssText(d,c,b)}},installScopeCssText:function(a,b,e){if(b=b||this.findStyleScope(),e=e||"",b){d&&(a=c(a,b.host));var g=this.element.cssTextToScopeStyle(a,f);Polymer.applyStyleToScope(g,b),this.styleCacheForScope(b)[this.localName+e]=!0}},findStyleScope:function(a){for(var b=a||this;b.parentNode;)b=b.parentNode;return b},scopeHasNamedStyle:function(a,b){var c=this.styleCacheForScope(a);return c[b]},styleCacheForScope:function(a){if(d){var b=a.host?a.host.localName:a.localName;return h[b]||(h[b]={})}return a._scopeStyles=a._scopeStyles||{}}},h={};a.api.instance.styles=g}(Polymer),function(a){function b(a,b){if("string"!=typeof a){var c=b||document._currentScript;if(b=a,a=c&&c.parentNode&&c.parentNode.getAttribute?c.parentNode.getAttribute("name"):"",!a)throw"Element name could not be inferred."}if(f(a))throw"Already registered (Polymer) prototype for element "+a;e(a,b),d(a)}function c(a,b){i[a]=b}function d(a){i[a]&&(i[a].registerWhenReady(),delete i[a])}function e(a,b){return j[a]=b||{}}function f(a){return j[a]}function g(a,b){if("string"!=typeof b)return!1;var c=HTMLElement.getPrototypeForTag(b),d=c&&c.constructor;return d?CustomElements["instanceof"]?CustomElements["instanceof"](a,d):a instanceof d:!1}var h=a.extend,i=(a.api,{}),j={};a.getRegisteredPrototype=f,a.waitingForPrototype=c,a.instanceOfType=g,window.Polymer=b,h(Polymer,a),WebComponents.consumeDeclarations&&WebComponents.consumeDeclarations(function(a){if(a)for(var c,d=0,e=a.length;e>d&&(c=a[d]);d++)b.apply(null,c)})}(Polymer),function(a){var b={resolveElementPaths:function(a){Polymer.urlResolver.resolveDom(a)},addResolvePathApi:function(){var a=this.getAttribute("assetpath")||"",b=new URL(a,this.ownerDocument.baseURI);this.prototype.resolvePath=function(a,c){var d=new URL(a,c||b);return d.href}}};a.api.declaration.path=b}(Polymer),function(a){function b(a,b){var c=new URL(a.getAttribute("href"),b).href;return"@import '"+c+"';"}function c(a,b){if(a){b===document&&(b=document.head),i&&(b=document.head);var c=d(a.textContent),e=a.getAttribute(h);e&&c.setAttribute(h,e);var f=b.firstElementChild;if(b===document.head){var g="style["+h+"]",j=document.head.querySelectorAll(g);j.length&&(f=j[j.length-1].nextElementSibling)}b.insertBefore(c,f)}}function d(a,b){b=b||document,b=b.createElement?b:b.ownerDocument;var c=b.createElement("style");return c.textContent=a,c}function e(a){return a&&a.__resource||""}function f(a,b){return q?q.call(a,b):void 0}var g=(window.WebComponents?WebComponents.flags.log:{},a.api.instance.styles),h=g.STYLE_SCOPE_ATTRIBUTE,i=window.ShadowDOMPolyfill,j="style",k="@import",l="link[rel=stylesheet]",m="global",n="polymer-scope",o={loadStyles:function(a){var b=this.fetchTemplate(),c=b&&this.templateContent();if(c){this.convertSheetsToStyles(c);var d=this.findLoadableStyles(c);if(d.length){var e=b.ownerDocument.baseURI;return Polymer.styleResolver.loadStyles(d,e,a)}}a&&a()},convertSheetsToStyles:function(a){for(var c,e,f=a.querySelectorAll(l),g=0,h=f.length;h>g&&(c=f[g]);g++)e=d(b(c,this.ownerDocument.baseURI),this.ownerDocument),this.copySheetAttributes(e,c),c.parentNode.replaceChild(e,c)},copySheetAttributes:function(a,b){for(var c,d=0,e=b.attributes,f=e.length;(c=e[d])&&f>d;d++)"rel"!==c.name&&"href"!==c.name&&a.setAttribute(c.name,c.value)},findLoadableStyles:function(a){var b=[];if(a)for(var c,d=a.querySelectorAll(j),e=0,f=d.length;f>e&&(c=d[e]);e++)c.textContent.match(k)&&b.push(c);return b},installSheets:function(){this.cacheSheets(),this.cacheStyles(),this.installLocalSheets(),this.installGlobalStyles()},cacheSheets:function(){this.sheets=this.findNodes(l),this.sheets.forEach(function(a){a.parentNode&&a.parentNode.removeChild(a)})},cacheStyles:function(){this.styles=this.findNodes(j+"["+n+"]"),this.styles.forEach(function(a){a.parentNode&&a.parentNode.removeChild(a)})},installLocalSheets:function(){var a=this.sheets.filter(function(a){return!a.hasAttribute(n)}),b=this.templateContent();if(b){var c="";if(a.forEach(function(a){c+=e(a)+"\n"}),c){var f=d(c,this.ownerDocument);b.insertBefore(f,b.firstChild)}}},findNodes:function(a,b){var c=this.querySelectorAll(a).array(),d=this.templateContent();if(d){var e=d.querySelectorAll(a).array();c=c.concat(e)}return b?c.filter(b):c},installGlobalStyles:function(){var a=this.styleForScope(m);c(a,document.head)},cssTextForScope:function(a){var b="",c="["+n+"="+a+"]",d=function(a){return f(a,c)},g=this.sheets.filter(d);g.forEach(function(a){b+=e(a)+"\n\n"});var h=this.styles.filter(d);return h.forEach(function(a){b+=a.textContent+"\n\n"}),b},styleForScope:function(a){var b=this.cssTextForScope(a);return this.cssTextToScopeStyle(b,a)},cssTextToScopeStyle:function(a,b){if(a){var c=d(a);return c.setAttribute(h,this.getAttribute("name")+"-"+b),c}}},p=HTMLElement.prototype,q=p.matches||p.matchesSelector||p.webkitMatchesSelector||p.mozMatchesSelector;a.api.declaration.styles=o,a.applyStyleToScope=c}(Polymer),function(a){var b=(window.WebComponents?WebComponents.flags.log:{},a.api.instance.events),c=b.EVENT_PREFIX,d={};["webkitAnimationStart","webkitAnimationEnd","webkitTransitionEnd","DOMFocusOut","DOMFocusIn","DOMMouseScroll"].forEach(function(a){d[a.toLowerCase()]=a});var e={parseHostEvents:function(){var a=this.prototype.eventDelegates;this.addAttributeDelegates(a)},addAttributeDelegates:function(a){for(var b,c=0;b=this.attributes[c];c++)this.hasEventPrefix(b.name)&&(a[this.removeEventPrefix(b.name)]=b.value.replace("{{","").replace("}}","").trim())},hasEventPrefix:function(a){return a&&"o"===a[0]&&"n"===a[1]&&"-"===a[2]},removeEventPrefix:function(a){return a.slice(f)},findController:function(a){for(;a.parentNode;){if(a.eventController)return a.eventController;a=a.parentNode}return a.host},getEventHandler:function(a,b,c){var d=this;return function(e){a&&a.PolymerBase||(a=d.findController(b));var f=[e,e.detail,e.currentTarget];a.dispatchMethod(a,c,f)}},prepareEventBinding:function(a,b){if(this.hasEventPrefix(b)){var c=this.removeEventPrefix(b);c=d[c]||c;var e=this;return function(b,d,f){function g(){return"{{ "+a+" }}"}var h=e.getEventHandler(void 0,d,a);return PolymerGestures.addEventListener(d,c,h),f?void 0:{open:g,discardChanges:g,close:function(){PolymerGestures.removeEventListener(d,c,h)}}}}}},f=c.length;a.api.declaration.events=e}(Polymer),function(a){var b=["attribute"],c={inferObservers:function(a){var b,c=a.observe;for(var d in a)"Changed"===d.slice(-7)&&(b=d.slice(0,-7),this.canObserveProperty(b)&&(c||(c=a.observe={}),c[b]=c[b]||d))},canObserveProperty:function(a){return b.indexOf(a)<0},explodeObservers:function(a){var b=a.observe;if(b){var c={};for(var d in b)for(var e,f=d.split(" "),g=0;e=f[g];g++)c[e]=b[d];a.observe=c}},optimizePropertyMaps:function(a){if(a.observe){var b=a._observeNames=[];for(var c in a.observe)for(var d,e=c.split(" "),f=0;d=e[f];f++)b.push(d)}if(a.publish){var b=a._publishNames=[];for(var c in a.publish)b.push(c)}if(a.computed){var b=a._computedNames=[];for(var c in a.computed)b.push(c)}},publishProperties:function(a,b){var c=a.publish;c&&(this.requireProperties(c,a,b),this.filterInvalidAccessorNames(c),a._publishLC=this.lowerCaseMap(c));var d=a.computed;d&&this.filterInvalidAccessorNames(d)},filterInvalidAccessorNames:function(a){for(var b in a)this.propertyNameBlacklist[b]&&(console.warn('Cannot define property "'+b+'" for element "'+this.name+'" because it has the same name as an HTMLElement property, and not all browsers support overriding that. Consider giving it a different name.'),delete a[b])},requireProperties:function(a,b){b.reflect=b.reflect||{};for(var c in a){var d=a[c];d&&void 0!==d.reflect&&(b.reflect[c]=Boolean(d.reflect),d=d.value),void 0!==d&&(b[c]=d)}},lowerCaseMap:function(a){var b={};for(var c in a)b[c.toLowerCase()]=c;return b},createPropertyAccessor:function(a,b){var c=this.prototype,d=a+"_",e=a+"Observable_";c[d]=c[a],Object.defineProperty(c,a,{get:function(){var a=this[e];return a&&a.deliver(),this[d]},set:function(c){if(b)return this[d];var f=this[e];if(f)return void f.setValue(c);var g=this[d];return this[d]=c,this.emitPropertyChangeRecord(a,c,g),c},configurable:!0})},createPropertyAccessors:function(a){var b=a._computedNames;if(b&&b.length)for(var c,d=0,e=b.length;e>d&&(c=b[d]);d++)this.createPropertyAccessor(c,!0);var b=a._publishNames;if(b&&b.length)for(var c,d=0,e=b.length;e>d&&(c=b[d]);d++)a.computed&&a.computed[c]||this.createPropertyAccessor(c)},propertyNameBlacklist:{children:1,"class":1,id:1,hidden:1,style:1,title:1}};a.api.declaration.properties=c}(Polymer),function(a){var b="attributes",c=/\s|,/,d={inheritAttributesObjects:function(a){this.inheritObject(a,"publishLC"),this.inheritObject(a,"_instanceAttributes")},publishAttributes:function(a){var d=this.getAttribute(b);if(d)for(var e,f=a.publish||(a.publish={}),g=d.split(c),h=0,i=g.length;i>h;h++)e=g[h].trim(),e&&void 0===f[e]&&(f[e]=void 0)},accumulateInstanceAttributes:function(){for(var a,b=this.prototype._instanceAttributes,c=this.attributes,d=0,e=c.length;e>d&&(a=c[d]);d++)this.isInstanceAttribute(a.name)&&(b[a.name]=a.value)},isInstanceAttribute:function(a){return!this.blackList[a]&&"on-"!==a.slice(0,3)},blackList:{name:1,"extends":1,constructor:1,noscript:1,assetpath:1,"cache-csstext":1}};d.blackList[b]=1,a.api.declaration.attributes=d}(Polymer),function(a){var b=a.api.declaration.events,c=new PolymerExpressions,d=c.prepareBinding;c.prepareBinding=function(a,e,f){return b.prepareEventBinding(a,e,f)||d.call(c,a,e,f)};var e={syntax:c,fetchTemplate:function(){return this.querySelector("template")},templateContent:function(){var a=this.fetchTemplate();return a&&a.content},installBindingDelegate:function(a){a&&(a.bindingDelegate=this.syntax)}};a.api.declaration.mdv=e}(Polymer),function(a){function b(a){if(!Object.__proto__){var b=Object.getPrototypeOf(a);a.__proto__=b,d(b)&&(b.__proto__=Object.getPrototypeOf(b))}}var c=a.api,d=a.isBase,e=a.extend,f=window.ShadowDOMPolyfill,g={register:function(a,b){this.buildPrototype(a,b),this.registerPrototype(a,b),this.publishConstructor()},buildPrototype:function(b,c){var d=a.getRegisteredPrototype(b),e=this.generateBasePrototype(c);this.desugarBeforeChaining(d,e),this.prototype=this.chainPrototypes(d,e),this.desugarAfterChaining(b,c)},desugarBeforeChaining:function(a,b){a.element=this,this.publishAttributes(a,b),this.publishProperties(a,b),this.inferObservers(a),this.explodeObservers(a)},chainPrototypes:function(a,c){this.inheritMetaData(a,c);var d=this.chainObject(a,c);return b(d),d},inheritMetaData:function(a,b){this.inheritObject("observe",a,b),this.inheritObject("publish",a,b),this.inheritObject("reflect",a,b),this.inheritObject("_publishLC",a,b),this.inheritObject("_instanceAttributes",a,b),this.inheritObject("eventDelegates",a,b)},desugarAfterChaining:function(a,b){this.optimizePropertyMaps(this.prototype),this.createPropertyAccessors(this.prototype),this.installBindingDelegate(this.fetchTemplate()),this.installSheets(),this.resolveElementPaths(this),this.accumulateInstanceAttributes(),this.parseHostEvents(),this.addResolvePathApi(),f&&WebComponents.ShadowCSS.shimStyling(this.templateContent(),a,b),this.prototype.registerCallback&&this.prototype.registerCallback(this)},publishConstructor:function(){var a=this.getAttribute("constructor");a&&(window[a]=this.ctor)},generateBasePrototype:function(a){var b=this.findBasePrototype(a);if(!b){var b=HTMLElement.getPrototypeForTag(a);b=this.ensureBaseApi(b),h[a]=b}return b},findBasePrototype:function(a){return h[a]},ensureBaseApi:function(a){if(a.PolymerBase)return a;var b=Object.create(a);return c.publish(c.instance,b),this.mixinMethod(b,a,c.instance.mdv,"bind"),b},mixinMethod:function(a,b,c,d){var e=function(a){return b[d].apply(this,a)};a[d]=function(){return this.mixinSuper=e,c[d].apply(this,arguments)}},inheritObject:function(a,b,c){var d=b[a]||{};b[a]=this.chainObject(d,c[a])},registerPrototype:function(a,b){var c={prototype:this.prototype},d=this.findTypeExtension(b);d&&(c["extends"]=d),HTMLElement.register(a,this.prototype),this.ctor=document.registerElement(a,c)},findTypeExtension:function(a){if(a&&a.indexOf("-")<0)return a;var b=this.findBasePrototype(a);return b.element?this.findTypeExtension(b.element["extends"]):void 0}},h={};g.chainObject=Object.__proto__?function(a,b){return a&&b&&a!==b&&(a.__proto__=b),a}:function(a,b){if(a&&b&&a!==b){var c=Object.create(b);a=e(c,a)}return a},c.declaration.prototype=g}(Polymer),function(a){function b(a){return document.contains(a)?j:i}function c(){return i.length?i[0]:j[0]}function d(a){f.waitToReady=!0,Polymer.endOfMicrotask(function(){HTMLImports.whenReady(function(){f.addReadyCallback(a),f.waitToReady=!1,f.check()})})}function e(a){if(void 0===a)return void f.ready();var b=setTimeout(function(){f.ready()},a);Polymer.whenReady(function(){clearTimeout(b)})}var f={wait:function(a){a.__queue||(a.__queue={},g.push(a))},enqueue:function(a,c,d){var e=a.__queue&&!a.__queue.check;return e&&(b(a).push(a),a.__queue.check=c,a.__queue.go=d),0!==this.indexOf(a)},indexOf:function(a){var c=b(a).indexOf(a);return c>=0&&document.contains(a)&&(c+=HTMLImports.useNative||HTMLImports.ready?i.length:1e9),c},go:function(a){var b=this.remove(a);b&&(a.__queue.flushable=!0,this.addToFlushQueue(b),this.check())},remove:function(a){var c=this.indexOf(a);if(0===c)return b(a).shift()},check:function(){var a=this.nextElement();return a&&a.__queue.check.call(a),this.canReady()?(this.ready(),!0):void 0},nextElement:function(){return c()},canReady:function(){return!this.waitToReady&&this.isEmpty()},isEmpty:function(){for(var a,b=0,c=g.length;c>b&&(a=g[b]);b++)if(a.__queue&&!a.__queue.flushable)return;return!0},addToFlushQueue:function(a){h.push(a)},flush:function(){if(!this.flushing){this.flushing=!0;for(var a;h.length;)a=h.shift(),a.__queue.go.call(a),a.__queue=null;this.flushing=!1}},ready:function(){var a=CustomElements.ready;CustomElements.ready=!1,this.flush(),CustomElements.useNative||CustomElements.upgradeDocumentTree(document),CustomElements.ready=a,Polymer.flush(),requestAnimationFrame(this.flushReadyCallbacks)},addReadyCallback:function(a){a&&k.push(a)},flushReadyCallbacks:function(){if(k)for(var a;k.length;)(a=k.shift())()},waitingFor:function(){for(var a,b=[],c=0,d=g.length;d>c&&(a=g[c]);c++)a.__queue&&!a.__queue.flushable&&b.push(a);return b},waitToReady:!0},g=[],h=[],i=[],j=[],k=[];a.elements=g,a.waitingFor=f.waitingFor.bind(f),a.forceReady=e,a.queue=f,a.whenReady=a.whenPolymerReady=d}(Polymer),function(a){function b(a){return Boolean(HTMLElement.getPrototypeForTag(a))}function c(a){return a&&a.indexOf("-")>=0}var d=a.extend,e=a.api,f=a.queue,g=a.whenReady,h=a.getRegisteredPrototype,i=a.waitingForPrototype,j=d(Object.create(HTMLElement.prototype),{createdCallback:function(){this.getAttribute("name")&&this.init()},init:function(){this.name=this.getAttribute("name"),this["extends"]=this.getAttribute("extends"),f.wait(this),this.loadResources(),this.registerWhenReady()},registerWhenReady:function(){this.registered||this.waitingForPrototype(this.name)||this.waitingForQueue()||this.waitingForResources()||f.go(this)},_register:function(){c(this["extends"])&&!b(this["extends"])&&console.warn("%s is attempting to extend %s, an unregistered element or one that was not registered with Polymer.",this.name,this["extends"]),this.register(this.name,this["extends"]),this.registered=!0},waitingForPrototype:function(a){return h(a)?void 0:(i(a,this),this.handleNoScript(a),!0)},handleNoScript:function(a){this.hasAttribute("noscript")&&!this.noscript&&(this.noscript=!0,Polymer(a))},waitingForResources:function(){return this._needsResources},waitingForQueue:function(){return f.enqueue(this,this.registerWhenReady,this._register)},loadResources:function(){this._needsResources=!0,this.loadStyles(function(){this._needsResources=!1,this.registerWhenReady()}.bind(this))}});e.publish(e.declaration,j),g(function(){document.body.removeAttribute("unresolved"),document.dispatchEvent(new CustomEvent("polymer-ready",{bubbles:!0}))}),document.registerElement("polymer-element",{prototype:j})}(Polymer),function(a){function b(a,b){a?(document.head.appendChild(a),d(b)):b&&b()}function c(a,c){if(a&&a.length){for(var d,e,f=document.createDocumentFragment(),g=0,h=a.length;h>g&&(d=a[g]);g++)e=document.createElement("link"),e.rel="import",e.href=d,f.appendChild(e);b(f,c)}else c&&c()}var d=a.whenReady;a["import"]=c,a.importElements=b}(Polymer),function(){var a=document.createElement("polymer-element");a.setAttribute("name","auto-binding"),a.setAttribute("extends","template"),a.init(),Polymer("auto-binding",{createdCallback:function(){this.syntax=this.bindingDelegate=this.makeSyntax(),Polymer.whenPolymerReady(function(){this.model=this,this.setAttribute("bind",""),this.async(function(){this.marshalNodeReferences(this.parentNode),this.fire("template-bound")})}.bind(this))},makeSyntax:function(){var a=Object.create(Polymer.api.declaration.events),b=this;a.findController=function(){return b.model};var c=new PolymerExpressions,d=c.prepareBinding;return c.prepareBinding=function(b,e,f){return a.prepareEventBinding(b,e,f)||d.call(c,b,e,f)},c}})}();
'use strict';

/**
 * The global object.
 * @type {!Object}
 * @const
 */
var global = this;

/** Platform, package, object property, and Event support. */
this.tr = (function() {
  if (global.tr) {
    console.warn('Base was multiply initialized. First init wins.');
    return global.tr;
  }

  /**
   * Builds an object structure for the provided namespace path,
   * ensuring that names that already exist are not overwritten. For
   * example:
   * 'a.b.c' -> a = {};a.b={};a.b.c={};
   * @param {string} name Name of the object that this file defines.
   * @private
   */
  function exportPath(name) {
    var parts = name.split('.');
    var cur = global;

    for (var part; parts.length && (part = parts.shift());) {
      if (part in cur) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
    return cur;
  };

  function isExported(name) {
    var parts = name.split('.');
    var cur = global;

    for (var part; parts.length && (part = parts.shift());) {
      if (part in cur) {
        cur = cur[part];
      } else {
        return false;
      }
    }
    return true;
  }

  function isDefined(name) {
    var parts = name.split('.');

    var curObject = global;

    for (var i = 0; i < parts.length; i++) {
      var partName = parts[i];
      var nextObject = curObject[partName];
      if (nextObject === undefined)
        return false;
      curObject = nextObject;
    }
    return true;
  }

  var panicElement = undefined;
  var rawPanicMessages = [];
  function showPanicElementIfNeeded() {
    if (panicElement)
      return;

    var panicOverlay = document.createElement('div');
    panicOverlay.style.backgroundColor = 'white';
    panicOverlay.style.border = '3px solid red';
    panicOverlay.style.boxSizing = 'border-box';
    panicOverlay.style.color = 'black';
    panicOverlay.style.display = '-webkit-flex';
    panicOverlay.style.height = '100%';
    panicOverlay.style.left = 0;
    panicOverlay.style.padding = '8px';
    panicOverlay.style.position = 'fixed';
    panicOverlay.style.top = 0;
    panicOverlay.style.webkitFlexDirection = 'column';
    panicOverlay.style.width = '100%';

    panicElement = document.createElement('div');
    panicElement.style.webkitFlex = '1 1 auto';
    panicElement.style.overflow = 'auto';
    panicOverlay.appendChild(panicElement);

    if (!document.body) {
      setTimeout(function() {
        document.body.appendChild(panicOverlay);
      }, 150);
    } else {
      document.body.appendChild(panicOverlay);
    }
  }

  function showPanic(panicTitle, panicDetails) {
    if (tr.isHeadless) {
      if (panicDetails instanceof Error)
        throw panicDetails;
      throw new Error('Panic: ' + panicTitle + ':\n' + panicDetails);
    }

    if (panicDetails instanceof Error)
      panicDetails = panicDetails.stack;

    showPanicElementIfNeeded();
    var panicMessageEl = document.createElement('div');
    panicMessageEl.innerHTML =
        '<h2 id="message"></h2>' +
        '<pre id="details"></pre>';
    panicMessageEl.querySelector('#message').textContent = panicTitle;
    panicMessageEl.querySelector('#details').textContent = panicDetails;
    panicElement.appendChild(panicMessageEl);

    rawPanicMessages.push({
      title: panicTitle,
      details: panicDetails
    });
  }

  function hasPanic() {
    return rawPanicMessages.length !== 0;
  }
  function getPanicText() {
    return rawPanicMessages.map(function(msg) {
      return msg.title;
    }).join(', ');
  }

  function exportTo(namespace, fn) {
    var obj = exportPath(namespace);
    var exports = fn();

    for (var propertyName in exports) {
      // Maybe we should check the prototype chain here? The current usage
      // pattern is always using an object literal so we only care about own
      // properties.
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,
                                                               propertyName);
      if (propertyDescriptor)
        Object.defineProperty(obj, propertyName, propertyDescriptor);
    }
  };

  /**
   * Initialization which must be deferred until run-time.
   */
  function initialize() {
    if (global.isVinn) {
      tr.isVinn = true;
    } else if (global.process && global.process.versions.node) {
      tr.isNode = true;
    } else {
      tr.isVinn = false;
      tr.isNode = false;
      tr.doc = document;

      tr.isMac = /Mac/.test(navigator.platform);
      tr.isWindows = /Win/.test(navigator.platform);
      tr.isChromeOS = /CrOS/.test(navigator.userAgent);
      tr.isLinux = /Linux/.test(navigator.userAgent);
    }
    tr.isHeadless = tr.isVinn || tr.isNode;
  }

  return {
    initialize: initialize,

    exportTo: exportTo,
    isExported: isExported,
    isDefined: isDefined,

    showPanic: showPanic,
    hasPanic: hasPanic,
    getPanicText: getPanicText
  };
})();

tr.initialize();


'use strict';

/**
 * @fileoverview Provides the Settings object.
 */
tr.exportTo('tr.b', function() {
  /**
   * Settings is a simple wrapper around local storage, to make it easier
   * to test classes that have settings.
   *
   * May be called as new tr.b.Settings() or simply tr.b.Settings()
   * @constructor
   */
  function Settings() {
    return Settings;
  };

  if (tr.b.unittest && tr.b.unittest.TestRunner) {
    tr.b.unittest.TestRunner.addEventListener(
        'tr-unittest-will-run',
        function() {
          if (tr.isHeadless)
            Settings.setAlternativeStorageInstance(new HeadlessStorage());
          else
            Settings.setAlternativeStorageInstance(global.sessionStorage);
        });
  }

  function SessionSettings() {
    return SessionSettings;
  }

  function AddStaticStorageFunctionsToClass_(input_class, storage) {
    input_class.storage_ = storage;

    /**
     * Get the setting with the given name.
     *
     * @param {string} key The name of the setting.
     * @param {string=} opt_default The default value to return if not set.
     * @param {string=} opt_namespace If set, the setting name will be prefixed
     * with this namespace, e.g. "categories.settingName". This is useful for
     * a set of related settings.
     */
    input_class.get = function(key, opt_default, opt_namespace) {
      key = input_class.namespace_(key, opt_namespace);
      var rawVal = input_class.storage_.getItem(key);
      if (rawVal === null || rawVal === undefined)
        return opt_default;

      // Old settings versions used to stringify objects instead of putting them
      // into JSON. If those are encountered, parse will fail. In that case,
      // "upgrade" the setting to the default value.
      try {
        return JSON.parse(rawVal).value;
      } catch (e) {
        input_class.storage_.removeItem(key);
        return opt_default;
      }
    };

    /**
     * Set the setting with the given name to the given value.
     *
     * @param {string} key The name of the setting.
     * @param {string} value The value of the setting.
     * @param {string=} opt_namespace If set, the setting name will be prefixed
     * with this namespace, e.g. "categories.settingName". This is useful for
     * a set of related settings.
     */
    input_class.set = function(key, value, opt_namespace) {
      if (value === undefined)
        throw new Error('Settings.set: value must not be undefined');
      var v = JSON.stringify({value: value});
      input_class.storage_.setItem(
          input_class.namespace_(key, opt_namespace), v);
    };

    /**
     * Return a list of all the keys, or all the keys in the given namespace
     * if one is provided.
     *
     * @param {string=} opt_namespace If set, only return settings which
     * begin with this prefix.
     */
    input_class.keys = function(opt_namespace) {
      var result = [];
      opt_namespace = opt_namespace || '';
      for (var i = 0; i < input_class.storage_.length; i++) {
        var key = input_class.storage_.key(i);
        if (input_class.isnamespaced_(key, opt_namespace))
          result.push(input_class.unnamespace_(key, opt_namespace));
      }
      return result;
    };

    input_class.isnamespaced_ = function(key, opt_namespace) {
      return key.indexOf(input_class.normalize_(opt_namespace)) == 0;
    };

    input_class.namespace_ = function(key, opt_namespace) {
      return input_class.normalize_(opt_namespace) + key;
    };

    input_class.unnamespace_ = function(key, opt_namespace) {
      return key.replace(input_class.normalize_(opt_namespace), '');
    };

    /**
     * All settings are prefixed with a global namespace to avoid collisions.
     * input_class may also be namespaced with an additional prefix passed into
     * the get, set, and keys methods in order to group related settings.
     * This method makes sure the two namespaces are always set properly.
     */
    input_class.normalize_ = function(opt_namespace) {
      return input_class.NAMESPACE + (opt_namespace ? opt_namespace + '.' : '');
    };

    input_class.setAlternativeStorageInstance = function(instance) {
      input_class.storage_ = instance;
    };

    input_class.getAlternativeStorageInstance = function() {
      if (!tr.isHeadless && input_class.storage_ === localStorage)
        return undefined;
      return input_class.storage_;
    };

    input_class.NAMESPACE = 'trace-viewer';
  };

  function HeadlessStorage() {
    this.length = 0;
    this.hasItem_ = {};
    this.items_ = {};
    this.itemsAsArray_ = undefined;
  }
  HeadlessStorage.prototype = {
    key: function(index) {
      return this.itemsAsArray[index];
    },

    get itemsAsArray() {
      if (this.itemsAsArray_ !== undefined)
        return this.itemsAsArray_;
      var itemsAsArray = [];
      for (var k in this.items_)
        itemsAsArray.push(k);
      this.itemsAsArray_ = itemsAsArray;
      return this.itemsAsArray_;
    },

    getItem: function(key) {
      if (!this.hasItem_[key])
        return null;
      return this.items_[key];
    },

    removeItem: function(key) {
      if (!this.hasItem_[key])
        return;
      var value = this.items_[key];
      delete this.hasItem_[key];
      delete this.items_[key];
      this.length--;
      this.itemsAsArray_ = undefined;
      return value;
    },

    setItem: function(key, value) {
      if (this.hasItem_[key]) {
        this.items_[key] = value;
        return;
      }
      this.items_[key] = value;
      this.hasItem_[key] = true;
      this.length++;
      this.itemsAsArray_ = undefined;
      return value;
    }
  };

  if (tr.isHeadless) {
    AddStaticStorageFunctionsToClass_(Settings, new HeadlessStorage());
    AddStaticStorageFunctionsToClass_(SessionSettings, new HeadlessStorage());
  } else {
    AddStaticStorageFunctionsToClass_(Settings, localStorage);
    AddStaticStorageFunctionsToClass_(SessionSettings, sessionStorage);
  }

  return {
    Settings: Settings,
    SessionSettings: SessionSettings
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  /**
   * Adds a {@code getInstance} static method that always return the same
   * instance object.
   * @param {!Function} ctor The constructor for the class to add the static
   *     method to.
   */
  function addSingletonGetter(ctor) {
    ctor.getInstance = function() {
      return ctor.instance_ || (ctor.instance_ = new ctor());
    };
  }

  function deepCopy(value) {
    if (!(value instanceof Object)) {
      if (value === undefined || value === null)
        return value;
      if (typeof value == 'string')
        return value.substring();
      if (typeof value == 'boolean')
        return value;
      if (typeof value == 'number')
        return value;
      throw new Error('Unrecognized: ' + typeof value);
    }

    var object = value;
    if (object instanceof Array) {
      var res = new Array(object.length);
      for (var i = 0; i < object.length; i++)
        res[i] = deepCopy(object[i]);
      return res;
    }

    if (object.__proto__ != Object.prototype)
      throw new Error('Can only clone simple types');
    var res = {};
    for (var key in object) {
      res[key] = deepCopy(object[key]);
    }
    return res;
  }

  function normalizeException(e) {
    if (e === undefined || e === null) {
      return {
        typeName: 'UndefinedError',
        message: 'Unknown: null or undefined exception',
        stack: 'Unknown'
      };
    }

    if (typeof(e) == 'string') {
      return {
        typeName: 'StringError',
        message: e,
        stack: [e]
      };
    }

    var typeName;
    if (e.name) {
      typeName = e.name;
    } else if (e.constructor) {
      if (e.constructor.name) {
        typeName = e.constructor.name;
      } else {
        typeName = 'AnonymousError';
      }
    } else {
      typeName = 'ErrorWithNoConstructor';
    }

    var msg = e.message ? e.message : 'Unknown';
    return {
      typeName: typeName,
      message: msg,
      stack: e.stack ? e.stack : [msg]
    };
  }

  function stackTraceAsString() {
    return new Error().stack + '';
  }
  function stackTrace() {
    var stack = stackTraceAsString();
    stack = stack.split('\n');
    return stack.slice(2);
  }

  function getUsingPath(path, from_dict) {
    var parts = path.split('.');
    var cur = from_dict;

    for (var part; parts.length && (part = parts.shift());) {
      if (!parts.length) {
        return cur[part];
      } else if (part in cur) {
        cur = cur[part];
      } else {
        return undefined;
      }
    }
    return undefined;
  }

  return {
    addSingletonGetter: addSingletonGetter,

    deepCopy: deepCopy,

    normalizeException: normalizeException,
    stackTrace: stackTrace,
    stackTraceAsString: stackTraceAsString,

    getUsingPath: getUsingPath
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  function asArray(arrayish) {
    var values = [];
    for (var i = 0; i < arrayish.length; i++)
      values.push(arrayish[i]);
    return values;
  }

  function compareArrays(x, y, elementCmp) {
    var minLength = Math.min(x.length, y.length);
    for (var i = 0; i < minLength; i++) {
      var tmp = elementCmp(x[i], y[i]);
      if (tmp)
        return tmp;
    }
    if (x.length == y.length)
      return 0;

    if (x[i] === undefined)
      return -1;

    return 1;
  }

  /**
   * Compares two values when one or both might be undefined. Undefined
   * values are sorted after defined.
   */
  function comparePossiblyUndefinedValues(x, y, cmp, opt_this) {
    if (x !== undefined && y !== undefined)
      return cmp.call(opt_this, x, y);
    if (x !== undefined)
      return -1;
    if (y !== undefined)
      return 1;
    return 0;
  }

  /**
   * Compares two numeric values when one or both might be undefined or NaNs.
   * Undefined / NaN values are sorted after others.
   */
  function compareNumericWithNaNs(x, y) {
    if (!isNaN(x) && !isNaN(y))
      return x - y;
    if (isNaN(x))
      return 1;
    if (isNaN(y))
      return -1;
    return 0;
  }

  function concatenateArrays(/*arguments*/) {
    var values = [];
    for (var i = 0; i < arguments.length; i++) {
      if (!(arguments[i] instanceof Array))
        throw new Error('Arguments ' + i + 'is not an array');
      values.push.apply(values, arguments[i]);
    }
    return values;
  }

  function concatenateObjects(/*arguments*/) {
    var result = {};
    for (var i = 0; i < arguments.length; i++) {
      var object = arguments[i];
      for (var j in object) {
        result[j] = object[j];
      }
    }
    return result;
  }

  function dictionaryKeys(dict) {
    var keys = [];
    for (var key in dict)
      keys.push(key);
    return keys;
  }

  function dictionaryValues(dict) {
    var values = [];
    for (var key in dict)
      values.push(dict[key]);
    return values;
  }

  function dictionaryLength(dict) {
    var n = 0;
    for (var key in dict)
      n++;
    return n;
  }

  /**
   * Returns a new dictionary with items grouped by the return value of the
   * specified function being called on each item.
   * @param {!Array.<Object>} ary The array being iterated through
   * @param {!Function} fn The mapping function between the array value and the
   * map key.
   */
  function group(ary, fn) {
    return ary.reduce(function(accumulator, curr) {
      var key = fn(curr);

      if (key in accumulator)
        accumulator[key].push(curr);
      else
        accumulator[key] = [curr];

      return accumulator;
    }, {});
  }

  function iterItems(dict, fn, opt_this) {
    opt_this = opt_this || this;
    var keys = Object.keys(dict);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      fn.call(opt_this, key, dict[key]);
    }
  }

  /**
   * Create a new dictionary with the same keys as the original dictionary
   * mapped to the results of the provided function called on the corresponding
   * entries in the original dictionary, i.e. result[key] = fn(key, dict[key])
   * for all keys in dict (own enumerable properties only).
   *
   * Example:
   *   var srcDict = {a: 10, b: 15};
   *   var dstDict = mapItems(srcDict, function(k, v) { return 2 * v; });
   *   // srcDict is unmodified and dstDict is now equal to {a: 20, b: 30}.
   */
  function mapItems(dict, fn, opt_this) {
    opt_this = opt_this || this;
    var result = {};
    var keys = Object.keys(dict);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      result[key] = fn.call(opt_this, key, dict[key]);
    }
    return result;
  }

  function filterItems(dict, predicate, opt_this) {
    opt_this = opt_this || this;
    var result = {};
    var keys = Object.keys(dict);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = dict[key];
      if (predicate.call(opt_this, key, value))
        result[key] = value;
    }
    return result;
  }

  function iterObjectFieldsRecursively(object, func) {
    if (!(object instanceof Object))
      return;

    if (object instanceof Array) {
      for (var i = 0; i < object.length; i++) {
        func(object, i, object[i]);
        iterObjectFieldsRecursively(object[i], func);
      }
      return;
    }

    for (var key in object) {
      var value = object[key];
      func(object, key, value);
      iterObjectFieldsRecursively(value, func);
    }
  }

  function identity(d) {
    return d;
  }

  function findFirstIndexInArray(ary, opt_func, opt_this) {
    var func = opt_func || identity;
    for (var i = 0; i < ary.length; i++) {
      if (func.call(opt_this, ary[i], i))
        return i;
    }
    return -1;
  }

  function findFirstInArray(ary, opt_func, opt_this) {
    var i = findFirstIndexInArray(ary, opt_func, opt_func);
    if (i === -1)
      return undefined;
    return ary[i];
  }

  function findFirstKeyInDictMatching(dict, opt_func, opt_this) {
    var func = opt_func || identity;
    for (var key in dict) {
      if (func.call(opt_this, key, dict[key]))
        return key;
    }
    return undefined;
  }

  return {
    asArray: asArray,
    concatenateArrays: concatenateArrays,
    concatenateObjects: concatenateObjects,
    compareArrays: compareArrays,
    comparePossiblyUndefinedValues: comparePossiblyUndefinedValues,
    compareNumericWithNaNs: compareNumericWithNaNs,
    dictionaryLength: dictionaryLength,
    dictionaryKeys: dictionaryKeys,
    dictionaryValues: dictionaryValues,
    group: group,
    iterItems: iterItems,
    mapItems: mapItems,
    filterItems: filterItems,
    iterObjectFieldsRecursively: iterObjectFieldsRecursively,
    identity: identity,
    findFirstIndexInArray: findFirstIndexInArray,
    findFirstInArray: findFirstInArray,
    findFirstKeyInDictMatching: findFirstKeyInDictMatching
  };
});


'use strict';

/**
 * @fileoverview This contains an implementation of the EventTarget interface
 * as defined by DOM Level 2 Events.
 */
tr.exportTo('tr.b', function() {

  /**
   * Creates a new EventTarget. This class implements the DOM level 2
   * EventTarget interface and can be used wherever those are used.
   * @constructor
   */
  function EventTarget() {
  }
  EventTarget.decorate = function(target) {
    for (var k in EventTarget.prototype) {
      if (k == 'decorate')
        continue;
      var v = EventTarget.prototype[k];
      if (typeof v !== 'function')
        continue;
      target[k] = v;
    }
  };

  EventTarget.prototype = {

    /**
     * Adds an event listener to the target.
     * @param {string} type The name of the event.
     * @param {!Function|{handleEvent:Function}} handler The handler for the
     *     event. This is called when the event is dispatched.
     */
    addEventListener: function(type, handler) {
      if (!this.listeners_)
        this.listeners_ = Object.create(null);
      if (!(type in this.listeners_)) {
        this.listeners_[type] = [handler];
      } else {
        var handlers = this.listeners_[type];
        if (handlers.indexOf(handler) < 0)
          handlers.push(handler);
      }
    },

    /**
     * Removes an event listener from the target.
     * @param {string} type The name of the event.
     * @param {!Function|{handleEvent:Function}} handler The handler for the
     *     event.
     */
    removeEventListener: function(type, handler) {
      if (!this.listeners_)
        return;
      if (type in this.listeners_) {
        var handlers = this.listeners_[type];
        var index = handlers.indexOf(handler);
        if (index >= 0) {
          // Clean up if this was the last listener.
          if (handlers.length == 1)
            delete this.listeners_[type];
          else
            handlers.splice(index, 1);
        }
      }
    },

    /**
     * Dispatches an event and calls all the listeners that are listening to
     * the type of the event.
     * @param {!cr.event.Event} event The event to dispatch.
     * @return {boolean} Whether the default action was prevented. If someone
     *     calls preventDefault on the event object then this returns false.
     */
    dispatchEvent: function(event) {
      if (!this.listeners_)
        return true;

      // Since we are using DOM Event objects we need to override some of the
      // properties and methods so that we can emulate this correctly.
      var self = this;
      event.__defineGetter__('target', function() {
        return self;
      });
      var realPreventDefault = event.preventDefault;
      event.preventDefault = function() {
        realPreventDefault.call(this);
        this.rawReturnValue = false;
      };

      var type = event.type;
      var prevented = 0;
      if (type in this.listeners_) {
        // Clone to prevent removal during dispatch
        var handlers = this.listeners_[type].concat();
        for (var i = 0, handler; handler = handlers[i]; i++) {
          if (handler.handleEvent)
            prevented |= handler.handleEvent.call(handler, event) === false;
          else
            prevented |= handler.call(this, event) === false;
        }
      }

      return !prevented && event.rawReturnValue;
    },

    hasEventListener: function(type) {
      return this.listeners_[type] !== undefined;
    }
  };

  var EventTargetHelper = {
    decorate: function(target) {
      for (var k in EventTargetHelper) {
        if (k == 'decorate')
          continue;
        var v = EventTargetHelper[k];
        if (typeof v !== 'function')
          continue;
        target[k] = v;
      }
      target.listenerCounts_ = {};
    },

    addEventListener: function(type, listener, useCapture) {
      this.__proto__.addEventListener.call(
          this, type, listener, useCapture);
      if (this.listenerCounts_[type] === undefined)
        this.listenerCounts_[type] = 0;
      this.listenerCounts_[type]++;
    },

    removeEventListener: function(type, listener, useCapture) {
      this.__proto__.removeEventListener.call(
          this, type, listener, useCapture);
      this.listenerCounts_[type]--;
    },

    hasEventListener: function(type) {
      return this.listenerCounts_[type] > 0;
    }
  };

  // Export
  return {
    EventTarget: EventTarget,
    EventTargetHelper: EventTargetHelper
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  function RegisteredTypeInfo(constructor, metadata) {
    this.constructor = constructor;
    this.metadata = metadata;
  };

  var BASIC_REGISTRY_MODE = 'BASIC_REGISTRY_MODE';
  var TYPE_BASED_REGISTRY_MODE = 'TYPE_BASED_REGISTRY_MODE';
  var ALL_MODES = {BASIC_REGISTRY_MODE: true, TYPE_BASED_REGISTRY_MODE: true};

  function ExtensionRegistryOptions(mode) {
    if (mode === undefined)
      throw new Error('Mode is required');
    if (!ALL_MODES[mode])
      throw new Error('Not a mode.');

    this.mode_ = mode;
    this.defaultMetadata_ = {};
    this.defaultConstructor_ = undefined;
    this.mandatoryBaseClass_ = undefined;
    this.defaultTypeInfo_ = undefined;
    this.frozen_ = false;
  }
  ExtensionRegistryOptions.prototype = {
    freeze: function() {
      if (this.frozen_)
        throw new Error('Frozen');
      this.frozen_ = true;
    },

    get mode() {
      return this.mode_;
    },

    get defaultMetadata() {
      return this.defaultMetadata_;
    },

    set defaultMetadata(defaultMetadata) {
      if (this.frozen_)
        throw new Error('Frozen');
      this.defaultMetadata_ = defaultMetadata;
      this.defaultTypeInfo_ = undefined;
    },

    get defaultConstructor() {
      return this.defaultConstructor_;
    },

    set defaultConstructor(defaultConstructor) {
      if (this.frozen_)
        throw new Error('Frozen');
      this.defaultConstructor_ = defaultConstructor;
      this.defaultTypeInfo_ = undefined;
    },

    get defaultTypeInfo() {
      if (this.defaultTypeInfo_ === undefined && this.defaultConstructor_) {
        this.defaultTypeInfo_ = new RegisteredTypeInfo(
            this.defaultConstructor,
            this.defaultMetadata);
      }
      return this.defaultTypeInfo_;
    },

    validateConstructor: function(constructor) {
      if (!this.mandatoryBaseClass)
        return;
      var curProto = constructor.prototype.__proto__;
      var ok = false;
      while (curProto) {
        if (curProto === this.mandatoryBaseClass.prototype) {
          ok = true;
          break;
        }
        curProto = curProto.__proto__;
      }
      if (!ok)
        throw new Error(constructor + 'must be subclass of ' + registry);
    }
  };

  return {
    BASIC_REGISTRY_MODE: BASIC_REGISTRY_MODE,
    TYPE_BASED_REGISTRY_MODE: TYPE_BASED_REGISTRY_MODE,

    ExtensionRegistryOptions: ExtensionRegistryOptions,
    RegisteredTypeInfo: RegisteredTypeInfo
  };
});



'use strict';

tr.exportTo('tr.b', function() {
  var Event;
  if (tr.isHeadless) {
    /**
     * Creates a new event to be used with tr.b.EventTarget or DOM EventTarget
     * objects.
     * @param {string} type The name of the event.
     * @param {boolean=} opt_bubbles Whether the event bubbles.
     *     Default is false.
     * @param {boolean=} opt_preventable Whether the default action of the event
     *     can be prevented.
     * @constructor
     * @extends {Event}
     */
    function HeadlessEvent(type, opt_bubbles, opt_preventable) {
      this.type = type;
      this.bubbles = (opt_bubbles !== undefined ?
          !!opt_bubbles : false);
      this.cancelable = (opt_preventable !== undefined ?
          !!opt_preventable : false);

      this.defaultPrevented = false;
      this.cancelBubble = false;
    };

    HeadlessEvent.prototype = {
      preventDefault: function() {
        this.defaultPrevented = true;
      },

      stopPropagation: function() {
        this.cancelBubble = true;
      }
    };
    Event = HeadlessEvent;
  } else {
    /**
     * Creates a new event to be used with tr.b.EventTarget or DOM EventTarget
     * objects.
     * @param {string} type The name of the event.
     * @param {boolean=} opt_bubbles Whether the event bubbles.
     *     Default is false.
     * @param {boolean=} opt_preventable Whether the default action of the event
     *     can be prevented.
     * @constructor
     * @extends {Event}
     */
    function TrEvent(type, opt_bubbles, opt_preventable) {
      var e = tr.doc.createEvent('Event');
      e.initEvent(type, !!opt_bubbles, !!opt_preventable);
      e.__proto__ = global.Event.prototype;
      return e;
    };

    TrEvent.prototype = {
      __proto__: global.Event.prototype
    };
    Event = TrEvent;
  }

  /**
   * Dispatches a simple event on an event target.
   * @param {!EventTarget} target The event target to dispatch the event on.
   * @param {string} type The type of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles or not.
   * @param {boolean=} opt_cancelable Whether the default action of the event
   *     can be prevented.
   * @return {boolean} If any of the listeners called {@code preventDefault}
   *     during the dispatch this will return false.
   */
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) {
    var e = new tr.b.Event(type, opt_bubbles, opt_cancelable);
    return target.dispatchEvent(e);
  }

  return {
    Event: Event,
    dispatchSimpleEvent: dispatchSimpleEvent
  };
});


'use strict';

tr.exportTo('tr.b', function() {

  var RegisteredTypeInfo = tr.b.RegisteredTypeInfo;
  var ExtensionRegistryOptions = tr.b.ExtensionRegistryOptions;

  function decorateBasicExtensionRegistry(registry, extensionRegistryOptions) {
    var savedStateStack = [];
    registry.registeredTypeInfos_ = [];

    registry.register = function(constructor,
                                 opt_metadata) {
      if (registry.findIndexOfRegisteredConstructor(
          constructor) !== undefined)
        throw new Error('Handler already registered for ' + constructor);

      extensionRegistryOptions.validateConstructor(constructor);

      var metadata = {};
      for (var k in extensionRegistryOptions.defaultMetadata)
        metadata[k] = extensionRegistryOptions.defaultMetadata[k];
      if (opt_metadata) {
        for (var k in opt_metadata)
          metadata[k] = opt_metadata[k];
      }

      var typeInfo = new RegisteredTypeInfo(
          constructor,
          metadata);

      var e = new tr.b.Event('will-register');
      e.typeInfo = typeInfo;
      registry.dispatchEvent(e);

      registry.registeredTypeInfos_.push(typeInfo);

      e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.pushCleanStateBeforeTest = function() {
      savedStateStack.push(registry.registeredTypeInfos_);
      registry.registeredTypeInfos_ = [];

      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };
    registry.popCleanStateAfterTest = function() {
      registry.registeredTypeInfos_ = savedStateStack[0];
      savedStateStack.splice(0, 1);

      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.findIndexOfRegisteredConstructor = function(constructor) {
      for (var i = 0; i < registry.registeredTypeInfos_.length; i++)
        if (registry.registeredTypeInfos_[i].constructor == constructor)
          return i;
      return undefined;
    };

    registry.unregister = function(constructor) {
      var foundIndex = registry.findIndexOfRegisteredConstructor(constructor);
      if (foundIndex === undefined)
        throw new Error(constructor + ' not registered');
      registry.registeredTypeInfos_.splice(foundIndex, 1);

      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.getAllRegisteredTypeInfos = function() {
      return registry.registeredTypeInfos_;
    };

    registry.findTypeInfo = function(constructor) {
      var foundIndex = this.findIndexOfRegisteredConstructor(constructor);
      if (foundIndex !== undefined)
        return this.registeredTypeInfos_[foundIndex];
      return undefined;
    };

    registry.findTypeInfoMatching = function(predicate, opt_this) {
      opt_this = opt_this ? opt_this : undefined;
      for (var i = 0; i < registry.registeredTypeInfos_.length; ++i) {
        var typeInfo = registry.registeredTypeInfos_[i];
        if (predicate.call(opt_this, typeInfo))
          return typeInfo;
      }
      return extensionRegistryOptions.defaultTypeInfo;
    };
  }

  return {
    _decorateBasicExtensionRegistry: decorateBasicExtensionRegistry
  };
});


'use strict';

/**
 * @fileoverview Helper code for working with tracing categories.
 *
 */
tr.exportTo('tr.b', function() {

  // Cached values for getCategoryParts.
  var categoryPartsFor = {};

  /**
   * Categories are stored in comma-separated form, e.g: 'a,b' meaning
   * that the event is part of the a and b category.
   *
   * This function returns the category split by string, caching the
   * array for performance.
   *
   * Do not mutate the returned array!!!!
   */
  function getCategoryParts(category) {
    var parts = categoryPartsFor[category];
    if (parts !== undefined)
      return parts;
    parts = category.split(',');
    categoryPartsFor[category] = parts;
    return parts;
  }

  return {
    getCategoryParts: getCategoryParts
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  var getCategoryParts = tr.b.getCategoryParts;

  var RegisteredTypeInfo = tr.b.RegisteredTypeInfo;
  var ExtensionRegistryOptions = tr.b.ExtensionRegistryOptions;


  function decorateTypeBasedExtensionRegistry(registry,
                                              extensionRegistryOptions) {
    var savedStateStack = [];

    registry.registeredTypeInfos_ = [];

    registry.categoryPartToTypeInfoMap_ = {};
    registry.typeNameToTypeInfoMap_ = {};

    registry.register = function(constructor,
                                 metadata) {

      extensionRegistryOptions.validateConstructor(constructor);

      var typeInfo = new RegisteredTypeInfo(
          constructor,
          metadata || extensionRegistryOptions.defaultMetadata);

      typeInfo.typeNames = [];
      typeInfo.categoryParts = [];
      if (metadata && metadata.typeName)
        typeInfo.typeNames.push(metadata.typeName);
      if (metadata && metadata.typeNames) {
        typeInfo.typeNames.push.apply(
          typeInfo.typeNames, metadata.typeNames);
      }
      if (metadata && metadata.categoryParts) {
        typeInfo.categoryParts.push.apply(
          typeInfo.categoryParts, metadata.categoryParts);
      }

      if (typeInfo.typeNames.length === 0 &&
          typeInfo.categoryParts.length === 0)
        throw new Error('typeName or typeNames must be provided');

      // Sanity checks...
      typeInfo.typeNames.forEach(function(typeName) {
        if (registry.typeNameToTypeInfoMap_[typeName])
          throw new Error('typeName ' + typeName + ' already registered');
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        if (registry.categoryPartToTypeInfoMap_[categoryPart]) {
          throw new Error('categoryPart ' + categoryPart +
                          ' already registered');
        }
      });

      var e = new tr.b.Event('will-register');
      e.typeInfo = typeInfo;
      registry.dispatchEvent(e);

      // Actual registration.
      typeInfo.typeNames.forEach(function(typeName) {
        registry.typeNameToTypeInfoMap_[typeName] = typeInfo;
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        registry.categoryPartToTypeInfoMap_[categoryPart] = typeInfo;
      });
      registry.registeredTypeInfos_.push(typeInfo);

      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.pushCleanStateBeforeTest = function() {
      savedStateStack.push({
        registeredTypeInfos: registry.registeredTypeInfos_,
        typeNameToTypeInfoMap: registry.typeNameToTypeInfoMap_,
        categoryPartToTypeInfoMap: registry.categoryPartToTypeInfoMap_
      });
      registry.registeredTypeInfos_ = [];
      registry.typeNameToTypeInfoMap_ = {};
      registry.categoryPartToTypeInfoMap_ = {};
      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.popCleanStateAfterTest = function() {
      var state = savedStateStack[0];
      savedStateStack.splice(0, 1);

      registry.registeredTypeInfos_ = state.registeredTypeInfos;
      registry.typeNameToTypeInfoMap_ = state.typeNameToTypeInfoMap;
      registry.categoryPartToTypeInfoMap_ = state.categoryPartToTypeInfoMap;
      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.unregister = function(constructor) {
      var typeInfoIndex = -1;
      for (var i = 0; i < registry.registeredTypeInfos_.length; i++) {
        if (registry.registeredTypeInfos_[i].constructor == constructor) {
          typeInfoIndex = i;
          break;
        }
      }
      if (typeInfoIndex === -1)
        throw new Error(constructor + ' not registered');

      var typeInfo = registry.registeredTypeInfos_[typeInfoIndex];
      registry.registeredTypeInfos_.splice(typeInfoIndex, 1);
      typeInfo.typeNames.forEach(function(typeName) {
        delete registry.typeNameToTypeInfoMap_[typeName];
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        delete registry.categoryPartToTypeInfoMap_[categoryPart];
      });
      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.getTypeInfo = function(category, typeName) {
      if (category) {
        var categoryParts = getCategoryParts(category);
        for (var i = 0; i < categoryParts.length; i++) {
          var categoryPart = categoryParts[i];
          if (registry.categoryPartToTypeInfoMap_[categoryPart])
            return registry.categoryPartToTypeInfoMap_[categoryPart];
        }
      }
      if (registry.typeNameToTypeInfoMap_[typeName])
        return registry.typeNameToTypeInfoMap_[typeName];

      return extensionRegistryOptions.defaultTypeInfo;
    };

    // TODO(nduca): Remove or rename.
    registry.getConstructor = function(category, typeName) {
      var typeInfo = registry.getTypeInfo(category, typeName);
      if (typeInfo)
        return typeInfo.constructor;
      return undefined;
    };
  }

  return {
    _decorateTypeBasedExtensionRegistry: decorateTypeBasedExtensionRegistry
  };
});


'use strict';

/**
 * @fileoverview Helper code for defining extension registries, which can be
 * used to make a part of trace-viewer extensible.
 *
 * This file provides two basic types of extension registries:
 * - Generic: register a type with metadata, query for those types based on
 *            a predicate
 *
 * - TypeName-based: register a type that handles some combination
 *                   of tracing categories or typeNames, then query
 *                   for it based on a category, typeName or both.
 *
 * Use these for pure-JS classes or ui.define'd classes. For polymer element
 * related registries, consult base/polymer_utils.html.
 *
 * When you register subtypes, you pass the constructor for the
 * subtype, and any metadata you want associated with the subtype. Use metadata
 * instead of stuffing fields onto the constructor. E.g.:
 *     registry.register(MySubclass, {titleWhenShownInTabStrip: 'MySub'})
 *
 * Some registries want a default object that is returned when a more precise
 * subtype has been registered. To provide one, set the defaultConstructor
 * option on the registry options.
 *
 * TODO: Extension registry used to make reference to mandatoryBaseType but it
 * was never enforced. We may want to add it back in the future in order to
 * enforce the types that can be put into a given registry.
 */
tr.exportTo('tr.b', function() {

  function decorateExtensionRegistry(registry, registryOptions) {
    if (registry.register)
      throw new Error('Already has registry');

    registryOptions.freeze();
    if (registryOptions.mode == tr.b.BASIC_REGISTRY_MODE) {
      tr.b._decorateBasicExtensionRegistry(registry, registryOptions);
    } else if (registryOptions.mode == tr.b.TYPE_BASED_REGISTRY_MODE) {
      tr.b._decorateTypeBasedExtensionRegistry(registry, registryOptions);
    } else {
      throw new Error('Unrecognized mode');
    }

    // Make it an event target.
    if (registry.addEventListener === undefined)
      tr.b.EventTarget.decorate(registry);
  }

  return {
    decorateExtensionRegistry: decorateExtensionRegistry
  };
});


'use strict';

tr.exportTo('tr.c', function() {
  function ScriptingObject() {
  }

  ScriptingObject.prototype = {
    onModelChanged: function() {
    }
  };

  return {
    ScriptingObject: ScriptingObject
  };
});


'use strict';

tr.exportTo('tr.c', function() {
  function ScriptingController(brushingStateController) {
    this.brushingStateController_ = brushingStateController;
    this.scriptObjectNames_ = [];
    this.scriptObjectValues_ = [];
    this.brushingStateController.addEventListener(
        'model-changed', this.onModelChanged_.bind(this));

    // Register all scripting objects.
    var typeInfos = ScriptingObjectRegistry.getAllRegisteredTypeInfos();
    typeInfos.forEach(function(typeInfo) {
      this.addScriptObject(typeInfo.metadata.name, typeInfo.constructor);
      // Also make the object available to the DevTools inspector.
      global[typeInfo.metadata.name] = typeInfo.constructor;
    }.bind(this));
  }

  function ScriptingObjectRegistry() {
  }
  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(ScriptingObjectRegistry, options);

  ScriptingController.prototype = {
    get brushingStateController() {
      return this.brushingStateController_;
    },

    onModelChanged_: function() {
      this.scriptObjectValues_.forEach(function(v) {
        if (v.onModelChanged)
          v.onModelChanged();
      });
    },

    addScriptObject: function(name, value) {
      this.scriptObjectNames_.push(name);
      this.scriptObjectValues_.push(value);
    },

    executeCommand: function(command) {
      var f = new Function(
          this.scriptObjectNames_, 'return eval(' + command + ')');
      return f.apply(null, this.scriptObjectValues_);
    }
  };

  return {
    ScriptingController: ScriptingController,
    ScriptingObjectRegistry: ScriptingObjectRegistry
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  var nextGUID = 1;
  var GUID = {
    allocate: function() {
      return nextGUID++;
    },

    getLastGuid: function() {
      return nextGUID - 1;
    }
  };

  return {
    GUID: GUID
  };
});


'use strict';

/**
 * @fileoverview Quick range computations.
 */
tr.exportTo('tr.b', function() {

  function Range() {
    this.isEmpty_ = true;
    this.min_ = undefined;
    this.max_ = undefined;
  };

  Range.prototype = {
    __proto__: Object.prototype,

    reset: function() {
      this.isEmpty_ = true;
      this.min_ = undefined;
      this.max_ = undefined;
    },

    get isEmpty() {
      return this.isEmpty_;
    },

    addRange: function(range) {
      if (range.isEmpty)
        return;
      this.addValue(range.min);
      this.addValue(range.max);
    },

    addValue: function(value) {
      if (this.isEmpty_) {
        this.max_ = value;
        this.min_ = value;
        this.isEmpty_ = false;
        return;
      }
      this.max_ = Math.max(this.max_, value);
      this.min_ = Math.min(this.min_, value);
    },

    set min(min) {
      this.isEmpty_ = false;
      this.min_ = min;
    },

    get min() {
      if (this.isEmpty_)
        return undefined;
      return this.min_;
    },

    get max() {
      if (this.isEmpty_)
        return undefined;
      return this.max_;
    },

    set max(max) {
      this.isEmpty_ = false;
      this.max_ = max;
    },

    get range() {
      if (this.isEmpty_)
        return undefined;
      return this.max_ - this.min_;
    },

    get center() {
      return (this.min_ + this.max_) * 0.5;
    },

    get duration() {
      if (this.isEmpty_)
        return 0;
      return this.max_ - this.min_;
    },

    equals: function(that) {
      if (this.isEmpty && that.isEmpty)
        return true;
      if (this.isEmpty != that.isEmpty)
        return false;
      return this.min === that.min &&
          this.max === that.max;
    },

    containsRange: function(range) {
      if (this.isEmpty || range.isEmpty)
        return false;

      return this.findIntersection(range).duration == range.duration;
    },

    containsExplicitRange: function(min, max) {
      return this.containsRange(Range.fromExplicitRange(min, max));
    },

    intersectsRange: function(range) {
      if (this.isEmpty || range.isEmpty)
        return false;

      return !this.findIntersection(range).isEmpty;
    },

    intersectsExplicitRange: function(min, max) {
      return this.intersectsRange(Range.fromExplicitRange(min, max));
    },

    findIntersection: function(range) {
      if (this.isEmpty || range.isEmpty)
        return new Range();

      var min = Math.max(this.min, range.min);
      var max = Math.min(this.max, range.max);

      if (max < min)
        return new Range();

      return Range.fromExplicitRange(min, max);
    },

    toJSON: function() {
      if (this.isEmpty_)
        return {isEmpty: true};
      return {
        isEmpty: false,
        max: this.max,
        min: this.min
      };
    },

    /**
     * Returns a slice of the input array that intersects with this range. If
     * the range does not have a min, it is treated as unbounded from below.
     * Similarly, if max is undefined, the range is unbounded from above.
     *
     * @param {Array} array The array of elements to be filtered.
     * @param {Funcation=} opt_keyFunc A function that extracts a numeric value,
     *        to be used in comparisons, from an element of the array. If not
     *        specified, array elements themselves will be used.
     * @param {Object=} opt_this An optional this argument to be passed to
     *        opt_keyFunc.
     */
    filterArray: function(array, opt_keyFunc, opt_this) {
      if (this.isEmpty_)
        return [];
      // Binary search. |test| is a function that should return true when we
      // need to explore the left branch and false to explore the right branch.
      function binSearch(test) {
        var i0 = 0;
        var i1 = array.length;
        while (i0 < i1 - 1) {
          var i = Math.trunc((i0 + i1) / 2);
          if (test(i))
            i1 = i;  // Explore the left branch.
          else
            i0 = i;  // Explore the right branch.
        }
        return i1;
      }

      var keyFunc = opt_keyFunc || tr.b.identity;
      function getValue(index) {
        return keyFunc.call(opt_this, array[index]);
      }

      var first = binSearch(function(i) {
        return this.min_ === undefined || this.min_ <= getValue(i);
      }.bind(this));
      var last = binSearch(function(i) {
        return this.max_ !== undefined && this.max_ < getValue(i);
      }.bind(this));
      return array.slice(first, last);
    }
  };

  Range.fromDict = function(d) {
    if (d.isEmpty === true) {
      return new Range();
    } else if (d.isEmpty === false) {
      var range = new Range();
      range.min = d.min;
      range.max = d.max;
      return range;
    } else {
      throw new Error('Not a range');
    }
  };

  Range.fromExplicitRange = function(min, max) {
    var range = new Range();
    range.min = min;
    range.max = max;
    return range;
  };

  Range.compareByMinTimes = function(a, b) {
    if (!a.isEmpty && !b.isEmpty)
      return a.min_ - b.min_;

    if (a.isEmpty && !b.isEmpty)
      return -1;

    if (!a.isEmpty && b.isEmpty)
      return 1;

    return 0;
  };

  return {
    Range: Range
  };
});


'use strict';

/**
 * @fileoverview Provides the EventRegistry class.
 */
tr.exportTo('tr.model', function() {
  // Create the type registry.
  function EventRegistry() {
  }

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(EventRegistry, options);

  // Enforce all options objects have the right fields.
  EventRegistry.addEventListener('will-register', function(e) {
    var metadata = e.typeInfo.metadata;

    if (metadata.name === undefined)
      throw new Error('Registered events must provide name metadata');
    var i = tr.b.findFirstInArray(
      EventRegistry.getAllRegisteredTypeInfos(),
      function(x) { return x.metadata.name === metadata.name; });
    if (i !== undefined)
      throw new Error('Event type with that name already registered');

    if (metadata.pluralName === undefined)
      throw new Error('Registered events must provide pluralName metadata');
    if (metadata.singleViewElementName === undefined) {
      throw new Error('Registered events must provide ' +
                      'singleViewElementName metadata');
    }
    if (metadata.multiViewElementName === undefined) {
      throw new Error('Registered events must provide ' +
                      'multiViewElementName metadata');
    }
  });

  // Helper: lookup Events indexed by type name.
  var eventsByTypeName = undefined;
  EventRegistry.getEventTypeInfoByTypeName = function(typeName) {
    if (eventsByTypeName === undefined) {
      eventsByTypeName = {};
      EventRegistry.getAllRegisteredTypeInfos().forEach(function(typeInfo) {
        eventsByTypeName[typeInfo.metadata.name] = typeInfo;
      });
    }
    return eventsByTypeName[typeName];
  }

  // Ensure eventsByTypeName stays current.
  EventRegistry.addEventListener('registry-changed', function() {
    eventsByTypeName = undefined;
  });

  function convertCamelCaseToTitleCase(name) {
    var result = name.replace(/[A-Z]/g, ' $&');
    result = result.charAt(0).toUpperCase() + result.slice(1);
    return result;
  }

  EventRegistry.getUserFriendlySingularName = function(typeName) {
    var typeInfo = EventRegistry.getEventTypeInfoByTypeName(typeName);
    var str = typeInfo.metadata.name;
    return convertCamelCaseToTitleCase(str);
  };

  EventRegistry.getUserFriendlyPluralName = function(typeName) {
    var typeInfo = EventRegistry.getEventTypeInfoByTypeName(typeName);
    var str = typeInfo.metadata.pluralName;
    return convertCamelCaseToTitleCase(str);
  };

  return {
    EventRegistry: EventRegistry
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  var EventRegistry = tr.model.EventRegistry;

  var RequestSelectionChangeEvent = tr.b.Event.bind(
      undefined, 'requestSelectionChange', true, false);

  /**
   * Represents a event set within a  and its associated set of tracks.
   * @constructor
   */
  function EventSet(opt_events) {
    this.bounds_dirty_ = true;
    this.bounds_ = new tr.b.Range();
    this.length_ = 0;
    this.guid_ = tr.b.GUID.allocate();
    this.pushed_guids_ = {};

    if (opt_events) {
      if (opt_events instanceof Array) {
        for (var i = 0; i < opt_events.length; i++)
          this.push(opt_events[i]);
      } else if (opt_events instanceof EventSet) {
        this.addEventSet(opt_events);
      } else {
        this.push(opt_events);
      }
    }
  }
  EventSet.prototype = {
    __proto__: Object.prototype,

    get bounds() {
      if (this.bounds_dirty_) {
        this.bounds_.reset();
        for (var i = 0; i < this.length_; i++)
          this[i].addBoundsToRange(this.bounds_);
        this.bounds_dirty_ = false;
      }
      return this.bounds_;
    },

    get duration() {
      if (this.bounds_.isEmpty)
        return 0;
      return this.bounds_.max - this.bounds_.min;
    },

    get length() {
      return this.length_;
    },

    get guid() {
      return this.guid_;
    },

    clear: function() {
      for (var i = 0; i < this.length_; ++i)
        delete this[i];
      this.length_ = 0;
      this.bounds_dirty_ = true;
    },

    // push pushes only unique events.
    // If an event has been already pushed, do nothing.
    push: function(event) {
      if (event.guid == undefined)
        throw new Error('Event must have a GUID');

      if (this.contains(event))
        return event;

      this.pushed_guids_[event.guid] = true;
      this[this.length_++] = event;
      this.bounds_dirty_ = true;
      return event;
    },

    contains: function(event) {
      return this.pushed_guids_[event.guid];
    },

    addEventSet: function(eventSet) {
      for (var i = 0; i < eventSet.length; i++)
        this.push(eventSet[i]);
    },

    subEventSet: function(index, count) {
      count = count || 1;

      var eventSet = new EventSet();
      eventSet.bounds_dirty_ = true;
      if (index < 0 || index + count > this.length_)
        throw new Error('Index out of bounds');

      for (var i = index; i < index + count; i++)
        eventSet.push(this[i]);

      return eventSet;
    },

    intersectionIsEmpty: function(otherEventSet) {
      return !this.some(function(event) {
        return otherEventSet.contains(event);
      });
    },

    equals: function(that) {
      if (this.length !== that.length)
        return false;
      for (var i = 0; i < this.length; i++) {
        var event = this[i];
        if (that.pushed_guids_[event.guid] === undefined)
          return false;
      }
      return true;
    },

    getEventsOrganizedByBaseType: function(opt_pruneEmpty) {
      var events = {};
      var allTypeInfos = EventRegistry.getAllRegisteredTypeInfos();
      allTypeInfos.forEach(function(eventTypeInfo) {
        events[eventTypeInfo.metadata.name] = new EventSet();
      }, this);

      this.forEach(function(event, i) {
        var maxEventIndex = -1;
        var maxEventTypeInfo = undefined;
        allTypeInfos.forEach(function(eventTypeInfo, eventIndex) {
          if (!(event instanceof eventTypeInfo.constructor))
            return;
          if (eventIndex > maxEventIndex) {
            maxEventIndex = eventIndex;
            maxEventTypeInfo = eventTypeInfo;
          }
        });
        if (maxEventIndex == -1) {
          console.log(event);
          throw new Error('Unrecognized event type');
        }
        events[maxEventTypeInfo.metadata.name].push(event);
      });
      if (opt_pruneEmpty) {
        var prunedEvents = {};
        for (var eventType in events) {
          if (events[eventType].length > 0)
            prunedEvents[eventType] = events[eventType];
        }
        return prunedEvents;
      } else {
        return events;
      }
    },

    getEventsOrganizedByTitle: function() {
      var eventsByTitle = {};
      for (var i = 0; i < this.length; i++) {
        var event = this[i];
        if (event.title === undefined)
          throw new Error('An event didn\'t have a title!');
        if (eventsByTitle[event.title] == undefined) {
          eventsByTitle[event.title] = [];
        }
        eventsByTitle[event.title].push(event);
      }
      return eventsByTitle;
    },

    enumEventsOfType: function(type, func) {
      for (var i = 0; i < this.length_; i++)
        if (this[i] instanceof type)
          func(this[i]);
    },

    get userFriendlyName() {
      if (this.length === 0) {
        throw new Error('Empty event set');
      }

      var eventsByBaseType = this.getEventsOrganizedByBaseType(true);
      var eventTypeName = tr.b.dictionaryKeys(eventsByBaseType)[0];

      if (this.length === 1) {
        var tmp = EventRegistry.getUserFriendlySingularName(eventTypeName);
        return this[0].userFriendlyName;
      }

      var numEventTypes = tr.b.dictionaryLength(eventsByBaseType);
      if (numEventTypes !== 1) {
        return this.length + ' events of various types';
      }

      var tmp = EventRegistry.getUserFriendlyPluralName(eventTypeName);
      return this.length + ' ' + tmp;
    },

    filter: function(fn, opt_this) {
      var res = new EventSet();

      this.forEach(function(slice) {
        if (fn.call(this, slice))
          res.push(slice);
      }, opt_this);

      return res;
    },

    toArray: function() {
      var ary = [];
      for (var i = 0; i < this.length; i++)
        ary.push(this[i]);
      return ary;
    },

    forEach: function(fn, opt_this) {
      for (var i = 0; i < this.length; i++)
        fn.call(opt_this, this[i], i);
    },

    map: function(fn, opt_this) {
      var res = [];
      for (var i = 0; i < this.length; i++)
        res.push(fn.call(opt_this, this[i], i));
      return res;
    },

    every: function(fn, opt_this) {
      for (var i = 0; i < this.length; i++)
        if (!fn.call(opt_this, this[i], i))
          return false;
      return true;
    },

    some: function(fn, opt_this) {
      for (var i = 0; i < this.length; i++)
        if (fn.call(opt_this, this[i], i))
          return true;
      return false;
    }
  };

  return {
    EventSet: EventSet,
    RequestSelectionChangeEvent: RequestSelectionChangeEvent
  };
});


  'use strict';
  Polymer('tr-ui-a-tab-view', {
    ready: function() {
      this.$.tshh.style.display = 'none';

                                                                                                      this.tabs_ = [];
      this.selectedTab_ = undefined;

            for (var i = 0; i < this.children.length; i++)
        this.processAddedChild_(this.children[i]);

                  this.childrenObserver_ = new MutationObserver(
          this.childrenUpdated_.bind(this));
      this.childrenObserver_.observe(this, { childList: 'true' });
    },

    get tabStripHeadingText() {
      return this.$.tsh.textContent;
    },

    set tabStripHeadingText(tabStripHeadingText) {
      this.$.tsh.textContent = tabStripHeadingText;
      if (!!tabStripHeadingText)
        this.$.tshh.style.display = '';
      else
        this.$.tshh.style.display = 'none';
    },

    get selectedTab() {
                  this.childrenUpdated_(
        this.childrenObserver_.takeRecords(), this.childrenObserver_);

                  if (this.selectedTab_)
        return this.selectedTab_.content;
      return undefined;
    },

    set selectedTab(content) {
                  this.childrenUpdated_(
        this.childrenObserver_.takeRecords(), this.childrenObserver_);

      if (content === undefined || content === null) {
        this.changeSelectedTabById_(undefined);
        return;
      }

                  var contentTabId = undefined;
      for (var i = 0; i < this.tabs_.length; i++)
        if (this.tabs_[i].content === content) {
          contentTabId = this.tabs_[i].id;
          break;
        }

      if (contentTabId === undefined)
        return;

      this.changeSelectedTabById_(contentTabId);
    },

    get tabsHidden() {
      var ts = this.shadowRoot.querySelector('tab-strip');
      return ts.hasAttribute('tabs-hidden');
    },

    set tabsHidden(tabsHidden) {
      tabsHidden = !!tabsHidden;
      var ts = this.shadowRoot.querySelector('tab-strip');
      if (tabsHidden)
        ts.setAttribute('tabs-hidden', true);
      else
        ts.removeAttribute('tabs-hidden');
    },

    get tabs() {
      return this.tabs_.map(function(tabObject) {
        return tabObject.content;
      });
    },

    
    processAddedChild_: function(child) {
      var observerAttributeSelected = new MutationObserver(
          this.childAttributesChanged_.bind(this));
      var observerAttributeTabLabel = new MutationObserver(
          this.childAttributesChanged_.bind(this));
      var tabObject = {
        id: this.tabs_.length,
        content: child,
        label: child.getAttribute('tab-label'),
        observers: {
          forAttributeSelected: observerAttributeSelected,
          forAttributeTabLabel: observerAttributeTabLabel
        }
      };

      this.tabs_.push(tabObject);
      if (child.hasAttribute('selected')) {
                                if (this.selectedTab_)
          child.removeAttribute('selected');
        else
          this.setSelectedTabById_(tabObject.id);
      }

                  var previousSelected = child.selected;

      var tabView = this;

      Object.defineProperty(
          child,
          'selected', {
            configurable: true,
            set: function(value) {
              if (value) {
                tabView.changeSelectedTabById_(tabObject.id);
                return;
              }

              var wasSelected = tabView.selectedTab_ === tabObject;
              if (wasSelected)
                tabView.changeSelectedTabById_(undefined);
            },
            get: function() {
              return this.hasAttribute('selected');
            }
          });

      if (previousSelected)
        child.selected = previousSelected;

      observerAttributeSelected.observe(child,
          { attributeFilter: ['selected'] });
      observerAttributeTabLabel.observe(child,
          { attributeFilter: ['tab-label'] });

    },

    
    processRemovedChild_: function(child) {
      for (var i = 0; i < this.tabs_.length; i++) {
                this.tabs_[i].id = i;
        if (this.tabs_[i].content === child) {
          this.tabs_[i].observers.forAttributeSelected.disconnect();
          this.tabs_[i].observers.forAttributeTabLabel.disconnect();
                    if (this.tabs_[i] === this.selectedTab_) {
            this.clearSelectedTab_();
            this.fire('selected-tab-change');
          }
          child.removeAttribute('selected');
          delete child.selected;
                    this.tabs_.splice(i, 1);
          i--;
        }
      }
    },


    
    childAttributesChanged_: function(mutations, observer) {
      var tabObject = undefined;
            for (var i = 0; i < this.tabs_.length; i++) {
        var observers = this.tabs_[i].observers;
        if (observers.forAttributeSelected === observer ||
            observers.forAttributeTabLabel === observer) {
            tabObject = this.tabs_[i];
            break;
        }
      }

                  if (!tabObject)
        return;

            for (var i = 0; i < mutations.length; i++) {
        var node = tabObject.content;
                if (mutations[i].attributeName === 'tab-label')
          tabObject.label = node.getAttribute('tab-label');
                if (mutations[i].attributeName === 'selected') {
                    var nodeIsSelected = node.hasAttribute('selected');
          if (nodeIsSelected)
            this.changeSelectedTabById_(tabObject.id);
          else
            this.changeSelectedTabById_(undefined);
        }
      }
    },

    
    childrenUpdated_: function(mutations, observer) {
      mutations.forEach(function(mutation) {
        for (var i = 0; i < mutation.removedNodes.length; i++)
          this.processRemovedChild_(mutation.removedNodes[i]);
        for (var i = 0; i < mutation.addedNodes.length; i++)
          this.processAddedChild_(mutation.addedNodes[i]);
      }, this);
    },

    
    tabButtonSelectHandler_: function(event, detail, sender) {
      this.changeSelectedTabById_(sender.getAttribute('button-id'));
    },

    
    changeSelectedTabById_: function(id) {
      var newTab = id !== undefined ? this.tabs_[id] : undefined;
      var changed = this.selectedTab_ !== newTab;
      this.saveCurrentTabScrollPosition_();
      this.clearSelectedTab_();
      if (id !== undefined) {
        this.setSelectedTabById_(id);
        this.restoreCurrentTabScrollPosition_();
      }

      if (changed)
        this.fire('selected-tab-change');
    },

    
    setSelectedTabById_: function(id) {
      this.selectedTab_ = this.tabs_[id];
            this.selectedTab_.observers.forAttributeSelected.disconnect();
      this.selectedTab_.content.setAttribute('selected', 'selected');
            this.selectedTab_.observers.forAttributeSelected.observe(
          this.selectedTab_.content, { attributeFilter: ['selected'] });

    },

    saveTabStates: function() {
            this.saveCurrentTabScrollPosition_();
    },

    saveCurrentTabScrollPosition_: function() {
      if (this.selectedTab_) {
        this.selectedTab_.content._savedScrollTop =
            this.$['content-container'].scrollTop;
        this.selectedTab_.content._savedScrollLeft =
            this.$['content-container'].scrollLeft;
      }
    },

    restoreCurrentTabScrollPosition_: function() {
      if (this.selectedTab_) {
        this.$['content-container'].scrollTop =
            this.selectedTab_.content._savedScrollTop || 0;
        this.$['content-container'].scrollLeft =
            this.selectedTab_.content._savedScrollLeft || 0;
      }
    },

    
    clearSelectedTab_: function() {
      if (this.selectedTab_) {
                this.selectedTab_.observers.forAttributeSelected.disconnect();
        this.selectedTab_.content.removeAttribute('selected');
                this.selectedTab_.observers.forAttributeSelected.observe(
            this.selectedTab_.content, { attributeFilter: ['selected'] });
        this.selectedTab_ = undefined;
      }
    }
  });
  

  'use strict';
  Polymer('tr-ui-a-sub-view', {
    set tabLabel(label) {
      return this.setAttribute('tab-label', label);
    },

    get tabLabel() {
      return this.getAttribute('tab-label');
    },

    get requiresTallView() {
      return false;
    },

    get relatedEventsToHighlight() {
      return undefined;
    },

    
    set selection(selection) {
      throw new Error('Not implemented!');
    },

    get selection() {
      throw new Error('Not implemented!');
    }
  });
  
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.1
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

!function(t,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define(n);else{var r=n();for(var a in r)("object"==typeof exports?exports:t)[a]=r[a]}}(this,function(){return function(t){function n(a){if(r[a])return r[a].exports;var e=r[a]={exports:{},id:a,loaded:!1};return t[a].call(e.exports,e,e.exports,n),e.loaded=!0,e.exports}var r={};return n.m=t,n.c=r,n.p="",n(0)}([function(t,n,r){n.glMatrix=r(1),n.mat2=r(2),n.mat2d=r(3),n.mat3=r(4),n.mat4=r(5),n.quat=r(6),n.vec2=r(9),n.vec3=r(7),n.vec4=r(8)},function(t,n,r){var a={};a.EPSILON=1e-6,a.ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,a.RANDOM=Math.random,a.setMatrixArrayType=function(t){GLMAT_ARRAY_TYPE=t};var e=Math.PI/180;a.toRadian=function(t){return t*e},t.exports=a},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},e.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},e.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},e.transpose=function(t,n){if(t===n){var r=n[1];t[1]=n[2],t[2]=r}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t},e.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*u-e*a;return o?(o=1/o,t[0]=u*o,t[1]=-a*o,t[2]=-e*o,t[3]=r*o,t):null},e.adjoint=function(t,n){var r=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=r,t},e.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},e.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],c=r[1],f=r[2],s=r[3];return t[0]=a*i+u*c,t[1]=e*i+o*c,t[2]=a*f+u*s,t[3]=e*f+o*s,t},e.mul=e.multiply,e.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),c=Math.cos(r);return t[0]=a*c+u*i,t[1]=e*c+o*i,t[2]=a*-i+u*c,t[3]=e*-i+o*c,t},e.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],c=r[1];return t[0]=a*i,t[1]=e*i,t[2]=u*c,t[3]=o*c,t},e.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t},e.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t},e.str=function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},e.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))},e.LDU=function(t,n,r,a){return t[2]=a[2]/a[0],r[0]=a[0],r[1]=a[1],r[3]=a[3]-t[2]*r[1],[t,n,r]},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(6);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},e.clone=function(t){var n=new a.ARRAY_TYPE(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t},e.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},e.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=r*u-a*e;return c?(c=1/c,t[0]=u*c,t[1]=-a*c,t[2]=-e*c,t[3]=r*c,t[4]=(e*i-u*o)*c,t[5]=(a*o-r*i)*c,t):null},e.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},e.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=r[0],s=r[1],h=r[2],M=r[3],l=r[4],v=r[5];return t[0]=a*f+u*s,t[1]=e*f+o*s,t[2]=a*h+u*M,t[3]=e*h+o*M,t[4]=a*l+u*v+i,t[5]=e*l+o*v+c,t},e.mul=e.multiply,e.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=Math.sin(r),s=Math.cos(r);return t[0]=a*s+u*f,t[1]=e*s+o*f,t[2]=a*-f+u*s,t[3]=e*-f+o*s,t[4]=i,t[5]=c,t},e.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=r[0],s=r[1];return t[0]=a*f,t[1]=e*f,t[2]=u*s,t[3]=o*s,t[4]=i,t[5]=c,t},e.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=r[0],s=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=a*f+u*s+i,t[5]=e*f+o*s+c,t},e.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t[4]=0,t[5]=0,t},e.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t},e.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t},e.str=function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},e.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},e.fromMat4=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t},e.clone=function(t){var n=new a.ARRAY_TYPE(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},e.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},e.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[5];t[1]=n[3],t[2]=n[6],t[3]=r,t[5]=n[7],t[6]=a,t[7]=e}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t},e.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8],h=s*o-i*f,M=-s*u+i*c,l=f*u-o*c,v=r*h+a*M+e*l;return v?(v=1/v,t[0]=h*v,t[1]=(-s*a+e*f)*v,t[2]=(i*a-e*o)*v,t[3]=M*v,t[4]=(s*r-e*c)*v,t[5]=(-i*r+e*u)*v,t[6]=l*v,t[7]=(-f*r+a*c)*v,t[8]=(o*r-a*u)*v,t):null},e.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8];return t[0]=o*s-i*f,t[1]=e*f-a*s,t[2]=a*i-e*o,t[3]=i*c-u*s,t[4]=r*s-e*c,t[5]=e*u-r*i,t[6]=u*f-o*c,t[7]=a*c-r*f,t[8]=r*o-a*u,t},e.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],c=t[7],f=t[8];return n*(f*u-o*c)+r*(-f*e+o*i)+a*(c*e-u*i)},e.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=r[0],l=r[1],v=r[2],m=r[3],p=r[4],d=r[5],A=r[6],R=r[7],w=r[8];return t[0]=M*a+l*o+v*f,t[1]=M*e+l*i+v*s,t[2]=M*u+l*c+v*h,t[3]=m*a+p*o+d*f,t[4]=m*e+p*i+d*s,t[5]=m*u+p*c+d*h,t[6]=A*a+R*o+w*f,t[7]=A*e+R*i+w*s,t[8]=A*u+R*c+w*h,t},e.mul=e.multiply,e.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=r[0],l=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=i,t[5]=c,t[6]=M*a+l*o+f,t[7]=M*e+l*i+s,t[8]=M*u+l*c+h,t},e.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=Math.sin(r),l=Math.cos(r);return t[0]=l*a+M*o,t[1]=l*e+M*i,t[2]=l*u+M*c,t[3]=l*o-M*a,t[4]=l*i-M*e,t[5]=l*c-M*u,t[6]=f,t[7]=s,t[8]=h,t},e.scale=function(t,n,r){var a=r[0],e=r[1];return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=e*n[3],t[4]=e*n[4],t[5]=e*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},e.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t},e.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=-r,t[4]=a,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},e.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},e.fromMat2d=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t},e.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,c=e+e,f=r*o,s=a*o,h=a*i,M=e*o,l=e*i,v=e*c,m=u*o,p=u*i,d=u*c;return t[0]=1-h-v,t[3]=s-d,t[6]=M+p,t[1]=s+d,t[4]=1-f-v,t[7]=l-m,t[2]=M-p,t[5]=l+m,t[8]=1-f-h,t},e.normalFromMat4=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8],h=n[9],M=n[10],l=n[11],v=n[12],m=n[13],p=n[14],d=n[15],A=r*i-a*o,R=r*c-e*o,w=r*f-u*o,q=a*c-e*i,Y=a*f-u*i,g=e*f-u*c,y=s*m-h*v,x=s*p-M*v,P=s*d-l*v,E=h*p-M*m,T=h*d-l*m,b=M*d-l*p,D=A*b-R*T+w*E+q*P-Y*x+g*y;return D?(D=1/D,t[0]=(i*b-c*T+f*E)*D,t[1]=(c*P-o*b-f*x)*D,t[2]=(o*T-i*P+f*y)*D,t[3]=(e*T-a*b-u*E)*D,t[4]=(r*b-e*P+u*x)*D,t[5]=(a*P-r*T-u*y)*D,t[6]=(m*g-p*Y+d*q)*D,t[7]=(p*w-v*g-d*R)*D,t[8]=(v*Y-m*w+d*A)*D,t):null},e.str=function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},e.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.clone=function(t){var n=new a.ARRAY_TYPE(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},e.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[3],u=n[6],o=n[7],i=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=r,t[6]=n[9],t[7]=n[13],t[8]=a,t[9]=u,t[11]=n[14],t[12]=e,t[13]=o,t[14]=i}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t},e.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8],h=n[9],M=n[10],l=n[11],v=n[12],m=n[13],p=n[14],d=n[15],A=r*i-a*o,R=r*c-e*o,w=r*f-u*o,q=a*c-e*i,Y=a*f-u*i,g=e*f-u*c,y=s*m-h*v,x=s*p-M*v,P=s*d-l*v,E=h*p-M*m,T=h*d-l*m,b=M*d-l*p,D=A*b-R*T+w*E+q*P-Y*x+g*y;return D?(D=1/D,t[0]=(i*b-c*T+f*E)*D,t[1]=(e*T-a*b-u*E)*D,t[2]=(m*g-p*Y+d*q)*D,t[3]=(M*Y-h*g-l*q)*D,t[4]=(c*P-o*b-f*x)*D,t[5]=(r*b-e*P+u*x)*D,t[6]=(p*w-v*g-d*R)*D,t[7]=(s*g-M*w+l*R)*D,t[8]=(o*T-i*P+f*y)*D,t[9]=(a*P-r*T-u*y)*D,t[10]=(v*Y-m*w+d*A)*D,t[11]=(h*w-s*Y-l*A)*D,t[12]=(i*x-o*E-c*y)*D,t[13]=(r*E-a*x+e*y)*D,t[14]=(m*R-v*q-p*A)*D,t[15]=(s*q-h*R+M*A)*D,t):null},e.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8],h=n[9],M=n[10],l=n[11],v=n[12],m=n[13],p=n[14],d=n[15];return t[0]=i*(M*d-l*p)-h*(c*d-f*p)+m*(c*l-f*M),t[1]=-(a*(M*d-l*p)-h*(e*d-u*p)+m*(e*l-u*M)),t[2]=a*(c*d-f*p)-i*(e*d-u*p)+m*(e*f-u*c),t[3]=-(a*(c*l-f*M)-i*(e*l-u*M)+h*(e*f-u*c)),t[4]=-(o*(M*d-l*p)-s*(c*d-f*p)+v*(c*l-f*M)),t[5]=r*(M*d-l*p)-s*(e*d-u*p)+v*(e*l-u*M),t[6]=-(r*(c*d-f*p)-o*(e*d-u*p)+v*(e*f-u*c)),t[7]=r*(c*l-f*M)-o*(e*l-u*M)+s*(e*f-u*c),t[8]=o*(h*d-l*m)-s*(i*d-f*m)+v*(i*l-f*h),t[9]=-(r*(h*d-l*m)-s*(a*d-u*m)+v*(a*l-u*h)),t[10]=r*(i*d-f*m)-o*(a*d-u*m)+v*(a*f-u*i),t[11]=-(r*(i*l-f*h)-o*(a*l-u*h)+s*(a*f-u*i)),t[12]=-(o*(h*p-M*m)-s*(i*p-c*m)+v*(i*M-c*h)),t[13]=r*(h*p-M*m)-s*(a*p-e*m)+v*(a*M-e*h),t[14]=-(r*(i*p-c*m)-o*(a*p-e*m)+v*(a*c-e*i)),t[15]=r*(i*M-c*h)-o*(a*M-e*h)+s*(a*c-e*i),t},e.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],c=t[7],f=t[8],s=t[9],h=t[10],M=t[11],l=t[12],v=t[13],m=t[14],p=t[15],d=n*o-r*u,A=n*i-a*u,R=n*c-e*u,w=r*i-a*o,q=r*c-e*o,Y=a*c-e*i,g=f*v-s*l,y=f*m-h*l,x=f*p-M*l,P=s*m-h*v,E=s*p-M*v,T=h*p-M*m;return d*T-A*E+R*P+w*x-q*y+Y*g},e.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=n[9],l=n[10],v=n[11],m=n[12],p=n[13],d=n[14],A=n[15],R=r[0],w=r[1],q=r[2],Y=r[3];return t[0]=R*a+w*i+q*h+Y*m,t[1]=R*e+w*c+q*M+Y*p,t[2]=R*u+w*f+q*l+Y*d,t[3]=R*o+w*s+q*v+Y*A,R=r[4],w=r[5],q=r[6],Y=r[7],t[4]=R*a+w*i+q*h+Y*m,t[5]=R*e+w*c+q*M+Y*p,t[6]=R*u+w*f+q*l+Y*d,t[7]=R*o+w*s+q*v+Y*A,R=r[8],w=r[9],q=r[10],Y=r[11],t[8]=R*a+w*i+q*h+Y*m,t[9]=R*e+w*c+q*M+Y*p,t[10]=R*u+w*f+q*l+Y*d,t[11]=R*o+w*s+q*v+Y*A,R=r[12],w=r[13],q=r[14],Y=r[15],t[12]=R*a+w*i+q*h+Y*m,t[13]=R*e+w*c+q*M+Y*p,t[14]=R*u+w*f+q*l+Y*d,t[15]=R*o+w*s+q*v+Y*A,t},e.mul=e.multiply,e.translate=function(t,n,r){var a,e,u,o,i,c,f,s,h,M,l,v,m=r[0],p=r[1],d=r[2];return n===t?(t[12]=n[0]*m+n[4]*p+n[8]*d+n[12],t[13]=n[1]*m+n[5]*p+n[9]*d+n[13],t[14]=n[2]*m+n[6]*p+n[10]*d+n[14],t[15]=n[3]*m+n[7]*p+n[11]*d+n[15]):(a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=n[9],l=n[10],v=n[11],t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=i,t[5]=c,t[6]=f,t[7]=s,t[8]=h,t[9]=M,t[10]=l,t[11]=v,t[12]=a*m+i*p+h*d+n[12],t[13]=e*m+c*p+M*d+n[13],t[14]=u*m+f*p+l*d+n[14],t[15]=o*m+s*p+v*d+n[15]),t},e.scale=function(t,n,r){var a=r[0],e=r[1],u=r[2];return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*u,t[9]=n[9]*u,t[10]=n[10]*u,t[11]=n[11]*u,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},e.rotate=function(t,n,r,e){var u,o,i,c,f,s,h,M,l,v,m,p,d,A,R,w,q,Y,g,y,x,P,E,T,b=e[0],D=e[1],L=e[2],_=Math.sqrt(b*b+D*D+L*L);return Math.abs(_)<a.EPSILON?null:(_=1/_,b*=_,D*=_,L*=_,u=Math.sin(r),o=Math.cos(r),i=1-o,c=n[0],f=n[1],s=n[2],h=n[3],M=n[4],l=n[5],v=n[6],m=n[7],p=n[8],d=n[9],A=n[10],R=n[11],w=b*b*i+o,q=D*b*i+L*u,Y=L*b*i-D*u,g=b*D*i-L*u,y=D*D*i+o,x=L*D*i+b*u,P=b*L*i+D*u,E=D*L*i-b*u,T=L*L*i+o,t[0]=c*w+M*q+p*Y,t[1]=f*w+l*q+d*Y,t[2]=s*w+v*q+A*Y,t[3]=h*w+m*q+R*Y,t[4]=c*g+M*y+p*x,t[5]=f*g+l*y+d*x,t[6]=s*g+v*y+A*x,t[7]=h*g+m*y+R*x,t[8]=c*P+M*E+p*T,t[9]=f*P+l*E+d*T,t[10]=s*P+v*E+A*T,t[11]=h*P+m*E+R*T,n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t)},e.rotateX=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[4],o=n[5],i=n[6],c=n[7],f=n[8],s=n[9],h=n[10],M=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=u*e+f*a,t[5]=o*e+s*a,t[6]=i*e+h*a,t[7]=c*e+M*a,t[8]=f*e-u*a,t[9]=s*e-o*a,t[10]=h*e-i*a,t[11]=M*e-c*a,t},e.rotateY=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],c=n[3],f=n[8],s=n[9],h=n[10],M=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=u*e-f*a,t[1]=o*e-s*a,t[2]=i*e-h*a,t[3]=c*e-M*a,t[8]=u*a+f*e,t[9]=o*a+s*e,t[10]=i*a+h*e,t[11]=c*a+M*e,t},e.rotateZ=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],c=n[3],f=n[4],s=n[5],h=n[6],M=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=u*e+f*a,t[1]=o*e+s*a,t[2]=i*e+h*a,t[3]=c*e+M*a,t[4]=f*e-u*a,t[5]=s*e-o*a,t[6]=h*e-i*a,t[7]=M*e-c*a,t},e.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},e.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.fromRotation=function(t,n,r){var e,u,o,i=r[0],c=r[1],f=r[2],s=Math.sqrt(i*i+c*c+f*f);return Math.abs(s)<a.EPSILON?null:(s=1/s,i*=s,c*=s,f*=s,e=Math.sin(n),u=Math.cos(n),o=1-u,t[0]=i*i*o+u,t[1]=c*i*o+f*e,t[2]=f*i*o-c*e,t[3]=0,t[4]=i*c*o-f*e,t[5]=c*c*o+u,t[6]=f*c*o+i*e,t[7]=0,t[8]=i*f*o+c*e,t[9]=c*f*o-i*e,t[10]=f*f*o+u,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},e.fromXRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.fromYRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.fromZRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=a,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.fromRotationTranslation=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=a+a,c=e+e,f=u+u,s=a*i,h=a*c,M=a*f,l=e*c,v=e*f,m=u*f,p=o*i,d=o*c,A=o*f;return t[0]=1-(l+m),t[1]=h+A,t[2]=M-d,t[3]=0,t[4]=h-A,t[5]=1-(s+m),t[6]=v+p,t[7]=0,t[8]=M+d,t[9]=v-p,t[10]=1-(s+l),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},e.fromRotationTranslationScale=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3],c=e+e,f=u+u,s=o+o,h=e*c,M=e*f,l=e*s,v=u*f,m=u*s,p=o*s,d=i*c,A=i*f,R=i*s,w=a[0],q=a[1],Y=a[2];return t[0]=(1-(v+p))*w,t[1]=(M+R)*w,t[2]=(l-A)*w,t[3]=0,t[4]=(M-R)*q,t[5]=(1-(h+p))*q,t[6]=(m+d)*q,t[7]=0,t[8]=(l+A)*Y,t[9]=(m-d)*Y,t[10]=(1-(h+v))*Y,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},e.fromRotationTranslationScaleOrigin=function(t,n,r,a,e){var u=n[0],o=n[1],i=n[2],c=n[3],f=u+u,s=o+o,h=i+i,M=u*f,l=u*s,v=u*h,m=o*s,p=o*h,d=i*h,A=c*f,R=c*s,w=c*h,q=a[0],Y=a[1],g=a[2],y=e[0],x=e[1],P=e[2];return t[0]=(1-(m+d))*q,t[1]=(l+w)*q,t[2]=(v-R)*q,t[3]=0,t[4]=(l-w)*Y,t[5]=(1-(M+d))*Y,t[6]=(p+A)*Y,t[7]=0,t[8]=(v+R)*g,t[9]=(p-A)*g,t[10]=(1-(M+m))*g,t[11]=0,t[12]=r[0]+y-(t[0]*y+t[4]*x+t[8]*P),t[13]=r[1]+x-(t[1]*y+t[5]*x+t[9]*P),t[14]=r[2]+P-(t[2]*y+t[6]*x+t[10]*P),t[15]=1,t},e.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,c=e+e,f=r*o,s=a*o,h=a*i,M=e*o,l=e*i,v=e*c,m=u*o,p=u*i,d=u*c;return t[0]=1-h-v,t[1]=s+d,t[2]=M-p,t[3]=0,t[4]=s-d,t[5]=1-f-v,t[6]=l+m,t[7]=0,t[8]=M+p,t[9]=l-m,t[10]=1-f-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.frustum=function(t,n,r,a,e,u,o){var i=1/(r-n),c=1/(e-a),f=1/(u-o);return t[0]=2*u*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*u*c,t[6]=0,t[7]=0,t[8]=(r+n)*i,t[9]=(e+a)*c,t[10]=(o+u)*f,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*u*2*f,t[15]=0,t},e.perspective=function(t,n,r,a,e){var u=1/Math.tan(n/2),o=1/(a-e);return t[0]=u/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(e+a)*o,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*e*a*o,t[15]=0,t},e.perspectiveFromFieldOfView=function(t,n,r,a){var e=Math.tan(n.upDegrees*Math.PI/180),u=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),i=Math.tan(n.rightDegrees*Math.PI/180),c=2/(o+i),f=2/(e+u);return t[0]=c,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=f,t[6]=0,t[7]=0,t[8]=-((o-i)*c*.5),t[9]=(e-u)*f*.5,t[10]=a/(r-a),t[11]=-1,t[12]=0,t[13]=0,t[14]=a*r/(r-a),t[15]=0,t},e.ortho=function(t,n,r,a,e,u,o){var i=1/(n-r),c=1/(a-e),f=1/(u-o);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*f,t[11]=0,t[12]=(n+r)*i,t[13]=(e+a)*c,t[14]=(o+u)*f,t[15]=1,t},e.lookAt=function(t,n,r,u){var o,i,c,f,s,h,M,l,v,m,p=n[0],d=n[1],A=n[2],R=u[0],w=u[1],q=u[2],Y=r[0],g=r[1],y=r[2];return Math.abs(p-Y)<a.EPSILON&&Math.abs(d-g)<a.EPSILON&&Math.abs(A-y)<a.EPSILON?e.identity(t):(M=p-Y,l=d-g,v=A-y,m=1/Math.sqrt(M*M+l*l+v*v),M*=m,l*=m,v*=m,o=w*v-q*l,i=q*M-R*v,c=R*l-w*M,m=Math.sqrt(o*o+i*i+c*c),m?(m=1/m,o*=m,i*=m,c*=m):(o=0,i=0,c=0),f=l*c-v*i,s=v*o-M*c,h=M*i-l*o,m=Math.sqrt(f*f+s*s+h*h),m?(m=1/m,f*=m,s*=m,h*=m):(f=0,s=0,h=0),t[0]=o,t[1]=f,t[2]=M,t[3]=0,t[4]=i,t[5]=s,t[6]=l,t[7]=0,t[8]=c,t[9]=h,t[10]=v,t[11]=0,t[12]=-(o*p+i*d+c*A),t[13]=-(f*p+s*d+h*A),t[14]=-(M*p+l*d+v*A),t[15]=1,t)},e.str=function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},e.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))},t.exports=e},function(t,n,r){var a=r(1),e=r(4),u=r(7),o=r(8),i={};i.create=function(){var t=new a.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},i.rotationTo=function(){var t=u.create(),n=u.fromValues(1,0,0),r=u.fromValues(0,1,0);return function(a,e,o){var c=u.dot(e,o);return-.999999>c?(u.cross(t,n,e),u.length(t)<1e-6&&u.cross(t,r,e),u.normalize(t,t),i.setAxisAngle(a,t,Math.PI),a):c>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(u.cross(t,e,o),a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=1+c,i.normalize(a,a))}}(),i.setAxes=function(){var t=e.create();return function(n,r,a,e){return t[0]=a[0],t[3]=a[1],t[6]=a[2],t[1]=e[0],t[4]=e[1],t[7]=e[2],t[2]=-r[0],t[5]=-r[1],t[8]=-r[2],i.normalize(n,i.fromMat3(n,t))}}(),i.clone=o.clone,i.fromValues=o.fromValues,i.copy=o.copy,i.set=o.set,i.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},i.setAxisAngle=function(t,n,r){r=.5*r;var a=Math.sin(r);return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=Math.cos(r),t},i.add=o.add,i.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],c=r[1],f=r[2],s=r[3];return t[0]=a*s+o*i+e*f-u*c,t[1]=e*s+o*c+u*i-a*f,t[2]=u*s+o*f+a*c-e*i,t[3]=o*s-a*i-e*c-u*f,t},i.mul=i.multiply,i.scale=o.scale,i.rotateX=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),c=Math.cos(r);return t[0]=a*c+o*i,t[1]=e*c+u*i,t[2]=u*c-e*i,t[3]=o*c-a*i,t},i.rotateY=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),c=Math.cos(r);return t[0]=a*c-u*i,t[1]=e*c+o*i,t[2]=u*c+a*i,t[3]=o*c-e*i,t},i.rotateZ=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),c=Math.cos(r);return t[0]=a*c+e*i,t[1]=e*c-a*i,t[2]=u*c+o*i,t[3]=o*c-u*i,t},i.calculateW=function(t,n){var r=n[0],a=n[1],e=n[2];return t[0]=r,t[1]=a,t[2]=e,t[3]=Math.sqrt(Math.abs(1-r*r-a*a-e*e)),t},i.dot=o.dot,i.lerp=o.lerp,i.slerp=function(t,n,r,a){var e,u,o,i,c,f=n[0],s=n[1],h=n[2],M=n[3],l=r[0],v=r[1],m=r[2],p=r[3];return u=f*l+s*v+h*m+M*p,0>u&&(u=-u,l=-l,v=-v,m=-m,p=-p),1-u>1e-6?(e=Math.acos(u),o=Math.sin(e),i=Math.sin((1-a)*e)/o,c=Math.sin(a*e)/o):(i=1-a,c=a),t[0]=i*f+c*l,t[1]=i*s+c*v,t[2]=i*h+c*m,t[3]=i*M+c*p,t},i.sqlerp=function(){var t=i.create(),n=i.create();return function(r,a,e,u,o,c){return i.slerp(t,a,o,c),i.slerp(n,e,u,c),i.slerp(r,t,n,2*c*(1-c)),r}}(),i.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u,i=o?1/o:0;return t[0]=-r*i,t[1]=-a*i,t[2]=-e*i,t[3]=u*i,t},i.conjugate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t},i.length=o.length,i.len=i.length,i.squaredLength=o.squaredLength,i.sqrLen=i.squaredLength,i.normalize=o.normalize,i.fromMat3=function(t,n){var r,a=n[0]+n[4]+n[8];if(a>0)r=Math.sqrt(a+1),t[3]=.5*r,r=.5/r,t[0]=(n[5]-n[7])*r,t[1]=(n[6]-n[2])*r,t[2]=(n[1]-n[3])*r;else{var e=0;n[4]>n[0]&&(e=1),n[8]>n[3*e+e]&&(e=2);var u=(e+1)%3,o=(e+2)%3;r=Math.sqrt(n[3*e+e]-n[3*u+u]-n[3*o+o]+1),t[e]=.5*r,r=.5/r,t[3]=(n[3*u+o]-n[3*o+u])*r,t[u]=(n[3*u+e]+n[3*e+u])*r,t[o]=(n[3*o+e]+n[3*e+o])*r}return t},i.str=function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},t.exports=i},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(3);return t[0]=0,t[1]=0,t[2]=0,t},e.clone=function(t){var n=new a.ARRAY_TYPE(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},e.fromValues=function(t,n,r){var e=new a.ARRAY_TYPE(3);return e[0]=t,e[1]=n,e[2]=r,e},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t},e.set=function(t,n,r,a){return t[0]=n,t[1]=r,t[2]=a,t},e.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t},e.subtract=function(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t},e.sub=e.subtract,e.multiply=function(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t},e.mul=e.multiply,e.divide=function(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t},e.div=e.divide,e.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t},e.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t},e.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t},e.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t},e.distance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return Math.sqrt(r*r+a*a+e*e)},e.dist=e.distance,e.squaredDistance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return r*r+a*a+e*e},e.sqrDist=e.squaredDistance,e.length=function(t){var n=t[0],r=t[1],a=t[2];return Math.sqrt(n*n+r*r+a*a)},e.len=e.length,e.squaredLength=function(t){var n=t[0],r=t[1],a=t[2];return n*n+r*r+a*a},e.sqrLen=e.squaredLength,e.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t},e.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t},e.normalize=function(t,n){var r=n[0],a=n[1],e=n[2],u=r*r+a*a+e*e;return u>0&&(u=1/Math.sqrt(u),t[0]=n[0]*u,t[1]=n[1]*u,t[2]=n[2]*u),t},e.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]},e.cross=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],c=r[2];return t[0]=e*c-u*i,t[1]=u*o-a*c,t[2]=a*i-e*o,t},e.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t},e.hermite=function(t,n,r,a,e,u){var o=u*u,i=o*(2*u-3)+1,c=o*(u-2)+u,f=o*(u-1),s=o*(3-2*u);return t[0]=n[0]*i+r[0]*c+a[0]*f+e[0]*s,t[1]=n[1]*i+r[1]*c+a[1]*f+e[1]*s,t[2]=n[2]*i+r[2]*c+a[2]*f+e[2]*s,t},e.bezier=function(t,n,r,a,e,u){var o=1-u,i=o*o,c=u*u,f=i*o,s=3*u*i,h=3*c*o,M=c*u;return t[0]=n[0]*f+r[0]*s+a[0]*h+e[0]*M,t[1]=n[1]*f+r[1]*s+a[1]*h+e[1]*M,t[2]=n[2]*f+r[2]*s+a[2]*h+e[2]*M,t},e.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI,e=2*a.RANDOM()-1,u=Math.sqrt(1-e*e)*n;return t[0]=Math.cos(r)*u,t[1]=Math.sin(r)*u,t[2]=e*n,t},e.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[3]*a+r[7]*e+r[11]*u+r[15];return o=o||1,t[0]=(r[0]*a+r[4]*e+r[8]*u+r[12])/o,t[1]=(r[1]*a+r[5]*e+r[9]*u+r[13])/o,t[2]=(r[2]*a+r[6]*e+r[10]*u+r[14])/o,t},e.transformMat3=function(t,n,r){var a=n[0],e=n[1],u=n[2];return t[0]=a*r[0]+e*r[3]+u*r[6],t[1]=a*r[1]+e*r[4]+u*r[7],t[2]=a*r[2]+e*r[5]+u*r[8],t},e.transformQuat=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],c=r[2],f=r[3],s=f*a+i*u-c*e,h=f*e+c*a-o*u,M=f*u+o*e-i*a,l=-o*a-i*e-c*u;return t[0]=s*f+l*-o+h*-c-M*-i,t[1]=h*f+l*-i+M*-o-s*-c,t[2]=M*f+l*-c+s*-i-h*-o,t},e.rotateX=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0],u[1]=e[1]*Math.cos(a)-e[2]*Math.sin(a),u[2]=e[1]*Math.sin(a)+e[2]*Math.cos(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},e.rotateY=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[2]*Math.sin(a)+e[0]*Math.cos(a),u[1]=e[1],u[2]=e[2]*Math.cos(a)-e[0]*Math.sin(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},e.rotateZ=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0]*Math.cos(a)-e[1]*Math.sin(a),u[1]=e[0]*Math.sin(a)+e[1]*Math.cos(a),u[2]=e[2],t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},e.forEach=function(){var t=e.create();return function(n,r,a,e,u,o){var i,c;for(r||(r=3),a||(a=0),c=e?Math.min(e*r+a,n.length):n.length,i=a;c>i;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2];return n}}(),e.angle=function(t,n){var r=e.fromValues(t[0],t[1],t[2]),a=e.fromValues(n[0],n[1],n[2]);e.normalize(r,r),e.normalize(a,a);var u=e.dot(r,a);return u>1?0:Math.acos(u)},e.str=function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t},e.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},e.fromValues=function(t,n,r,e){var u=new a.ARRAY_TYPE(4);return u[0]=t,u[1]=n,u[2]=r,u[3]=e,u},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},e.set=function(t,n,r,a,e){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t},e.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t},e.subtract=function(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t},e.sub=e.subtract,e.multiply=function(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t[3]=n[3]*r[3],t},e.mul=e.multiply,e.divide=function(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t[3]=n[3]/r[3],t},e.div=e.divide,e.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t[3]=Math.min(n[3],r[3]),t},e.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t[3]=Math.max(n[3],r[3]),t},e.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t},e.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t},e.distance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return Math.sqrt(r*r+a*a+e*e+u*u)},e.dist=e.distance,e.squaredDistance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return r*r+a*a+e*e+u*u},e.sqrDist=e.squaredDistance,e.length=function(t){var n=t[0],r=t[1],a=t[2],e=t[3];return Math.sqrt(n*n+r*r+a*a+e*e)},e.len=e.length,e.squaredLength=function(t){var n=t[0],r=t[1],a=t[2],e=t[3];return n*n+r*r+a*a+e*e},e.sqrLen=e.squaredLength,e.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t},e.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t},e.normalize=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u;return o>0&&(o=1/Math.sqrt(o),t[0]=r*o,t[1]=a*o,t[2]=e*o,t[3]=u*o),t},e.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]},e.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t[3]=i+a*(r[3]-i),t},e.random=function(t,n){return n=n||1,t[0]=a.RANDOM(),t[1]=a.RANDOM(),t[2]=a.RANDOM(),t[3]=a.RANDOM(),e.normalize(t,t),e.scale(t,t,n),t},e.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3];return t[0]=r[0]*a+r[4]*e+r[8]*u+r[12]*o,t[1]=r[1]*a+r[5]*e+r[9]*u+r[13]*o,t[2]=r[2]*a+r[6]*e+r[10]*u+r[14]*o,t[3]=r[3]*a+r[7]*e+r[11]*u+r[15]*o,t},e.transformQuat=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],c=r[2],f=r[3],s=f*a+i*u-c*e,h=f*e+c*a-o*u,M=f*u+o*e-i*a,l=-o*a-i*e-c*u;return t[0]=s*f+l*-o+h*-c-M*-i,t[1]=h*f+l*-i+M*-o-s*-c,t[2]=M*f+l*-c+s*-i-h*-o,t[3]=n[3],t},e.forEach=function(){var t=e.create();return function(n,r,a,e,u,o){var i,c;for(r||(r=4),a||(a=0),c=e?Math.min(e*r+a,n.length):n.length,i=a;c>i;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],t[3]=n[i+3],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2],n[i+3]=t[3];return n}}(),e.str=function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(2);return t[0]=0,t[1]=0,t},e.clone=function(t){var n=new a.ARRAY_TYPE(2);return n[0]=t[0],n[1]=t[1],n},e.fromValues=function(t,n){var r=new a.ARRAY_TYPE(2);return r[0]=t,r[1]=n,r},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t},e.set=function(t,n,r){return t[0]=n,t[1]=r,t},e.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t},e.subtract=function(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t},e.sub=e.subtract,e.multiply=function(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t},e.mul=e.multiply,e.divide=function(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t},e.div=e.divide,e.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t},e.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t},e.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t},e.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t},e.distance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1];return Math.sqrt(r*r+a*a)},e.dist=e.distance,e.squaredDistance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1];return r*r+a*a},e.sqrDist=e.squaredDistance,e.length=function(t){var n=t[0],r=t[1];return Math.sqrt(n*n+r*r)},e.len=e.length,e.squaredLength=function(t){var n=t[0],r=t[1];return n*n+r*r},e.sqrLen=e.squaredLength,e.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t},e.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t},e.normalize=function(t,n){var r=n[0],a=n[1],e=r*r+a*a;return e>0&&(e=1/Math.sqrt(e),t[0]=n[0]*e,t[1]=n[1]*e),t},e.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]},e.cross=function(t,n,r){var a=n[0]*r[1]-n[1]*r[0];return t[0]=t[1]=0,t[2]=a,t},e.lerp=function(t,n,r,a){var e=n[0],u=n[1];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t},e.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI;return t[0]=Math.cos(r)*n,t[1]=Math.sin(r)*n,t},e.transformMat2=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e,t[1]=r[1]*a+r[3]*e,t},e.transformMat2d=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e+r[4],t[1]=r[1]*a+r[3]*e+r[5],t},e.transformMat3=function(t,n,r){
var a=n[0],e=n[1];return t[0]=r[0]*a+r[3]*e+r[6],t[1]=r[1]*a+r[4]*e+r[7],t},e.transformMat4=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[4]*e+r[12],t[1]=r[1]*a+r[5]*e+r[13],t},e.forEach=function(){var t=e.create();return function(n,r,a,e,u,o){var i,c;for(r||(r=2),a||(a=0),c=e?Math.min(e*r+a,n.length):n.length,i=a;c>i;i+=r)t[0]=n[i],t[1]=n[i+1],u(t,t,o),n[i]=t[0],n[i+1]=t[1];return n}}(),e.str=function(t){return"vec2("+t[0]+", "+t[1]+")"},t.exports=e}])});

'use strict';

tr.exportTo('tr.b', function() {
  function clamp(x, lo, hi) {
    return Math.min(Math.max(x, lo), hi);
  }

  function lerp(percentage, lo, hi) {
    var range = hi - lo;
    return lo + percentage * range;
  }

  function normalize(value, lo, hi) {
    return (value - lo) / (hi - lo);
  }

  function deg2rad(deg) {
    return (Math.PI * deg) / 180.0;
  }

  var tmp_vec2 = vec2.create();
  var tmp_vec2b = vec2.create();
  var tmp_vec4 = vec4.create();
  var tmp_mat2d = mat2d.create();

  vec2.createFromArray = function(arr) {
    if (arr.length != 2)
      throw new Error('Should be length 2');
    var v = vec2.create();
    vec2.set(v, arr[0], arr[1]);
    return v;
  };

  vec2.createXY = function(x, y) {
    var v = vec2.create();
    vec2.set(v, x, y);
    return v;
  };

  vec2.toString = function(a) {
    return '[' + a[0] + ', ' + a[1] + ']';
  };

  vec2.addTwoScaledUnitVectors = function(out, u1, scale1, u2, scale2) {
    // out = u1 * scale1 + u2 * scale2
    vec2.scale(tmp_vec2, u1, scale1);
    vec2.scale(tmp_vec2b, u2, scale2);
    vec2.add(out, tmp_vec2, tmp_vec2b);
  };

  vec2.interpolatePiecewiseFunction = function(points, x) {
    if (x < points[0][0])
      return points[0][1];
    for (var i = 1; i < points.length; ++i) {
      if (x < points[i][0]) {
        var percent = normalize(x, points[i - 1][0], points[i][0]);
        return lerp(percent, points[i - 1][1], points[i][1]);
      }
    }
    return points[points.length - 1][1];
  };

  vec3.createXYZ = function(x, y, z) {
    var v = vec3.create();
    vec3.set(v, x, y, z);
    return v;
  };

  vec3.toString = function(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
  }

  mat2d.translateXY = function(out, x, y) {
    vec2.set(tmp_vec2, x, y);
    mat2d.translate(out, out, tmp_vec2);
  }

  mat2d.scaleXY = function(out, x, y) {
    vec2.set(tmp_vec2, x, y);
    mat2d.scale(out, out, tmp_vec2);
  }

  vec4.unitize = function(out, a) {
    out[0] = a[0] / a[3];
    out[1] = a[1] / a[3];
    out[2] = a[2] / a[3];
    out[3] = 1;
    return out;
  }

  vec2.copyFromVec4 = function(out, a) {
    vec4.unitize(tmp_vec4, a);
    vec2.copy(out, tmp_vec4);
  }

  return {
    clamp: clamp,
    lerp: lerp,
    normalize: normalize,
    deg2rad: deg2rad
  };

});


'use strict';

/**
 * @fileoverview 2D Rectangle math.
 */

tr.exportTo('tr.b', function() {

  /**
   * Tracks a 2D bounding box.
   * @constructor
   */
  function Rect() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  };
  Rect.fromXYWH = function(x, y, w, h) {
    var rect = new Rect();
    rect.x = x;
    rect.y = y;
    rect.width = w;
    rect.height = h;
    return rect;
  }
  Rect.fromArray = function(ary) {
    if (ary.length != 4)
      throw new Error('ary.length must be 4');
    var rect = new Rect();
    rect.x = ary[0];
    rect.y = ary[1];
    rect.width = ary[2];
    rect.height = ary[3];
    return rect;
  }

  Rect.prototype = {
    __proto__: Object.prototype,

    get left() {
      return this.x;
    },

    get top() {
      return this.y;
    },

    get right() {
      return this.x + this.width;
    },

    get bottom() {
      return this.y + this.height;
    },

    toString: function() {
      return 'Rect(' + this.x + ', ' + this.y + ', ' +
          this.width + ', ' + this.height + ')';
    },

    toArray: function() {
      return [this.x, this.y, this.width, this.height];
    },

    clone: function() {
      var rect = new Rect();
      rect.x = this.x;
      rect.y = this.y;
      rect.width = this.width;
      rect.height = this.height;
      return rect;
    },

    enlarge: function(pad) {
      var rect = new Rect();
      this.enlargeFast(rect, pad);
      return rect;
    },

    enlargeFast: function(out, pad) {
      out.x = this.x - pad;
      out.y = this.y - pad;
      out.width = this.width + 2 * pad;
      out.height = this.height + 2 * pad;
      return out;
    },

    size: function() {
      return {width: this.width, height: this.height};
    },

    scale: function(s) {
      var rect = new Rect();
      this.scaleFast(rect, s);
      return rect;
    },

    scaleSize: function(s) {
      return Rect.fromXYWH(this.x, this.y, this.width * s, this.height * s);
    },

    scaleFast: function(out, s) {
      out.x = this.x * s;
      out.y = this.y * s;
      out.width = this.width * s;
      out.height = this.height * s;
      return out;
    },

    translate: function(v) {
      var rect = new Rect();
      this.translateFast(rect, v);
      return rect;
    },

    translateFast: function(out, v) {
      out.x = this.x + v[0];
      out.y = this.x + v[1];
      out.width = this.width;
      out.height = this.height;
      return out;
    },

    asUVRectInside: function(containingRect) {
      var rect = new Rect();
      rect.x = (this.x - containingRect.x) / containingRect.width;
      rect.y = (this.y - containingRect.y) / containingRect.height;
      rect.width = this.width / containingRect.width;
      rect.height = this.height / containingRect.height;
      return rect;
    },

    intersects: function(that) {
      var ok = true;
      ok &= this.x < that.right;
      ok &= this.right > that.x;
      ok &= this.y < that.bottom;
      ok &= this.bottom > that.y;
      return ok;
    },

    equalTo: function(rect) {
      return rect &&
             (this.x === rect.x) &&
             (this.y === rect.y) &&
             (this.width === rect.width) &&
             (this.height === rect.height);
    }
  };

  return {
    Rect: Rect
  };

});



'use strict';

tr.exportTo('tr.b', function() {
  function _iterateElementDeeplyImpl(element, cb, thisArg, includeElement) {
    if (includeElement) {
      if (cb.call(thisArg, element))
        return true;
    }

    if (element.shadowRoot) {
      if (_iterateElementDeeplyImpl(element.shadowRoot, cb, thisArg, false))
        return true;
    }
    for (var i = 0; i < element.children.length; i++) {
      if (_iterateElementDeeplyImpl(element.children[i], cb, thisArg, true))
        return true;
    }
  }
  function iterateElementDeeply(element, cb, thisArg) {
    _iterateElementDeeplyImpl(element, cb, thisArg, false);
  }

  function findDeepElementMatchingPredicate(element, predicate) {
    var foundElement = undefined;
    function matches(element) {
      var match = predicate(element);
      if (!match)
        return false;
      foundElement = element;
      return true;
    }
    iterateElementDeeply(element, matches);
    return foundElement;
  }

  function findDeepElementsMatchingPredicate(element, predicate) {
    var foundElements = [];
    function matches(element) {
      var match = predicate(element);
      if (match) {
        foundElements.push(element);
      }
      return false;
    }
    iterateElementDeeply(element, matches);
    return foundElements;
  }

  function findDeepElementMatching(element, selector) {
    return findDeepElementMatchingPredicate(element, function(element) {
      return element.matches(selector);
    });
  }
  function findDeepElementsMatching(element, selector) {
    return findDeepElementsMatchingPredicate(element, function(element) {
      return element.matches(selector);
    });
  }
  function findDeepElementWithTextContent(element, re) {
    return findDeepElementMatchingPredicate(element, function(element) {
      if (element.children.length !== 0)
        return false;
      return re.test(element.textContent);
    });
  }
  return {
    iterateElementDeeply: iterateElementDeeply,
    findDeepElementMatching: findDeepElementMatching,
    findDeepElementsMatching: findDeepElementsMatching,
    findDeepElementMatchingPredicate: findDeepElementMatchingPredicate,
    findDeepElementsMatchingPredicate: findDeepElementsMatchingPredicate,
    findDeepElementWithTextContent: findDeepElementWithTextContent
  };
});


'use strict';

/**
 * @fileoverview Time currentDisplayUnit
 */
tr.exportTo('tr.b.u', function() {
  var msDisplayMode = {
    scale: 1e-3,
    suffix: 'ms',
    // Compares a < b with adjustments to precision errors.
    roundedLess: function(a, b) {
      return Math.round(a * 1000) < Math.round(b * 1000);
    },
    format: function(ts) {
      return new Number(ts)
          .toLocaleString(undefined, { minimumFractionDigits: 3 }) + ' ms';
    }
  };

  var nsDisplayMode = {
    scale: 1e-9,
    suffix: 'ns',
    // Compares a < b with adjustments to precision errors.
    roundedLess: function(a, b) {
      return Math.round(a * 1000000) < Math.round(b * 1000000);
    },
    format: function(ts) {
      return new Number(ts * 1000000)
          .toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' ns';
    }
  };

  var TimeDisplayModes = {
    ns: nsDisplayMode,
    ms: msDisplayMode
  };

  return {
    TimeDisplayModes: TimeDisplayModes
  };
});


'use strict';

tr.exportTo('tr.b.u', function() {
  /**
   * Scalar wrapper, representing a scalar value and its unit.
   */
  function Scalar(value, unit) {
    this.value = value;
    this.unit = unit;
  };

  Scalar.prototype = {
    toString: function() {
      return this.unit.format(this.value);
    }
  };

  return {
    Scalar: Scalar
  };
});


'use strict';

tr.exportTo('tr.b.u', function() {
  /**
   * Float wrapper, representing a time duration, capable of pretty-printing.
   */
  function TimeDuration(duration) {
    tr.b.u.Scalar.call(this, duration, tr.b.u.Units.timeDurationInMs);
  };

  TimeDuration.prototype = {
    __proto__: tr.b.u.Scalar.prototype,

    get duration() {
      return this.value;
    }
  };

  TimeDuration.format = function(duration) {
    return tr.b.u.Units.timeDurationInMs.format(duration);
  };

  return {
    TimeDuration: TimeDuration
  };
});


'use strict';

tr.exportTo('tr.b.u', function() {
  /**
   * Float wrapper, representing a time stamp, capable of pretty-printing.
   */
  function TimeStamp(timestamp) {
    tr.b.u.Scalar.call(this, timestamp, tr.b.u.Units.timeStampInMs);
  };

  TimeStamp.prototype = {
    __proto__: tr.b.u.Scalar.prototype,

    get timestamp() {
      return this.value;
    }
  };

  TimeStamp.format = function(timestamp) {
    return tr.b.u.Units.timeStampInMs.format(timestamp);
  };

  return {
    TimeStamp: TimeStamp
  };
});


'use strict';

/**
 * @fileoverview Provides the SelectionState class.
 */
tr.exportTo('tr.model', function() {

  /**
   * The SelectionState enum defines how selectable items are displayed in the
   * view.
   */
  var SelectionState = {
    NONE: 0,
    SELECTED: 1,
    HIGHLIGHTED: 2,
    DIMMED: 3
  };

  return {
    SelectionState: SelectionState
  };
});


'use strict';

/**
 * @fileoverview Provides the SelectableItem class.
 */
tr.exportTo('tr.model', function() {
  var SelectionState = tr.model.SelectionState;

  /**
   * A SelectableItem is the abstract base class for any non-container data that
   * has an associated model item in the trace model (possibly itself).
   *
   * Subclasses must provide a selectionState property (or getter).
   *
   * @constructor
   */
  function SelectableItem(modelItem) {
    this.modelItem_ = modelItem;
  }

  SelectableItem.prototype = {
    get modelItem() {
      return this.modelItem_;
    },

    get selected() {
      return this.selectionState === SelectionState.SELECTED;
    },

    addToSelection: function(selection) {
      var modelItem = this.modelItem_;
      if (!modelItem)
        return;
      selection.push(modelItem);
    },

    addToTrackMap: function(eventToTrackMap, track) {
      var modelItem = this.modelItem_;
      if (!modelItem)
        return;
      eventToTrackMap.addEvent(modelItem, track);
    }
  };

  return {
    SelectableItem: SelectableItem
  };
});


'use strict';

/**
 * @fileoverview Provides the Event class.
 */
tr.exportTo('tr.model', function() {
  var SelectableItem = tr.model.SelectableItem;
  var SelectionState = tr.model.SelectionState;

  /**
   * An Event is the base type for any non-container, selectable piece
   * of data in the trace model.
   *
   * @constructor
   * @extends {SelectableItem}
   */
  function Event() {
    SelectableItem.call(this, this /* modelItem */);
    this.guid_ = tr.b.GUID.allocate();
    this.selectionState = SelectionState.NONE;
    this.associatedAlerts = new tr.model.EventSet();
    this.info = undefined;
  }

  Event.prototype = {
    __proto__: SelectableItem.prototype,

    get guid() {
      return this.guid_;
    },

    /** Adds the range of timestamps for this event to the specified range. */
    addBoundsToRange: function(range) {
      throw new Error('Not implemented');
    }
  };

  return {
    Event: Event
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * A snapshot of an object instance, at a given moment in time.
   *
   * Initialization of snapshots and instances is three phased:
   *
   * 1. Instances and snapshots are constructed. This happens during event
   *    importing. Little should be done here, because the object's data
   *    are still being used by the importer to reconstruct object references.
   *
   * 2. Instances and snapshtos are preinitialized. This happens after implicit
   *    objects have been found, but before any references have been found and
   *    switched to direct references. Thus, every snapshot stands on its own.
   *    This is a good time to do global field renaming and type conversion,
   *    e.g. recognizing domain-specific types and converting from C++ naming
   *    convention to JS.
   *
   * 3. Instances and snapshtos are initialized. At this point, {id_ref:
   *    '0x1000'} fields have been converted to snapshot references. This is a
   *    good time to generic initialization steps and argument verification.
   *
   * @constructor
   */
  function ObjectSnapshot(objectInstance, ts, args) {
    tr.model.Event.call(this);
    this.objectInstance = objectInstance;
    this.ts = ts;
    this.args = args;
  }

  ObjectSnapshot.prototype = {
    __proto__: tr.model.Event.prototype,

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    preInitialize: function() {
    },

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    initialize: function() {
    },

    addBoundsToRange: function(range) {
      range.addValue(this.ts);
    },

    get userFriendlyName() {
      return 'Snapshot of ' +
             this.objectInstance.typeName + ' ' +
             this.objectInstance.id + ' @ ' +
             tr.b.u.TimeStamp.format(this.ts);
    }
  };

  tr.model.EventRegistry.register(
      ObjectSnapshot,
      {
        name: 'objectSnapshot',
        pluralName: 'objectSnapshots',
        singleViewElementName: 'tr-ui-a-single-object-snapshot-sub-view',
        multiViewElementName: 'tr-ui-a-multi-object-sub-view'
      });

  var options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  options.mandatoryBaseClass = ObjectSnapshot;
  options.defaultConstructor = ObjectSnapshot;
  tr.b.decorateExtensionRegistry(ObjectSnapshot, options);

  return {
    ObjectSnapshot: ObjectSnapshot
  };
});


'use strict';

/**
 * @fileoverview Helper functions for doing intersections and iteration
 * over sorted arrays and intervals.
 *
 */
tr.exportTo('tr.b', function() {
  /**
   * Finds the first index in the array whose value is >= loVal.
   *
   * The key for the search is defined by the mapFn. This array must
   * be prearranged such that ary.map(mapFn) would also be sorted in
   * ascending order.
   *
   * @param {Array} ary An array of arbitrary objects.
   * @param {function():*} mapFn Callback that produces a key value
   *     from an element in ary.
   * @param {number} loVal Value for which to search.
   * @return {Number} Offset o into ary where all ary[i] for i <= o
   *     are < loVal, or ary.length if loVal is greater than all elements in
   *     the array.
   */
  function findLowIndexInSortedArray(ary, mapFn, loVal) {
    if (ary.length == 0)
      return 1;

    var low = 0;
    var high = ary.length - 1;
    var i, comparison;
    var hitPos = -1;
    while (low <= high) {
      i = Math.floor((low + high) / 2);
      comparison = mapFn(ary[i]) - loVal;
      if (comparison < 0) {
        low = i + 1; continue;
      } else if (comparison > 0) {
        high = i - 1; continue;
      } else {
        hitPos = i;
        high = i - 1;
      }
    }
    // return where we hit, or failing that the low pos
    return hitPos != -1 ? hitPos : low;
  }

  /**
   * Finds an index in an array of intervals that either intersects
   * the provided loVal, or if no intersection is found, -1 or ary.length.
   *
   * The array of intervals is defined implicitly via two mapping functions
   * over the provided ary. mapLoFn determines the lower value of the interval,
   * mapWidthFn the width. Intersection is lower-inclusive, e.g. [lo,lo+w).
   *
   * The array of intervals formed by this mapping must be non-overlapping and
   * sorted in ascending order by loVal.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an  element in the array.
   * @param {function():*} mapWidthFn Callback that produces the width for the
   *     interval represented by an  element in the array.
   * @param {number} loVal The low value for the search.
   * @return {Number} An index in the array that intersects or is first-above
   *     loVal, -1 if none found and loVal is below than all the intervals,
   *     ary.length if loVal is greater than all the intervals.
   */
  function findIndexInSortedIntervals(ary, mapLoFn, mapWidthFn, loVal) {
    var first = findLowIndexInSortedArray(ary, mapLoFn, loVal);
    if (first == 0) {
      if (loVal >= mapLoFn(ary[0]) &&
          loVal < mapLoFn(ary[0]) + mapWidthFn(ary[0], 0)) {
        return 0;
      } else {
        return -1;
      }
    } else if (first < ary.length) {
      if (loVal >= mapLoFn(ary[first]) &&
          loVal < mapLoFn(ary[first]) + mapWidthFn(ary[first], first)) {
        return first;
      } else if (loVal >= mapLoFn(ary[first - 1]) &&
                 loVal < mapLoFn(ary[first - 1]) +
                 mapWidthFn(ary[first - 1], first - 1)) {
        return first - 1;
      } else {
        return ary.length;
      }
    } else if (first == ary.length) {
      if (loVal >= mapLoFn(ary[first - 1]) &&
          loVal < mapLoFn(ary[first - 1]) +
          mapWidthFn(ary[first - 1], first - 1)) {
        return first - 1;
      } else {
        return ary.length;
      }
    } else {
      return ary.length;
    }
  }

  /**
   * Finds an index in an array of sorted closed intervals that either
   * intersects the provided val, or if no intersection is found, -1 or
   *  ary.length.
   *
   * The array of intervals is defined implicitly via two mapping functions
   * over the provided ary. mapLoFn determines the lower value of the interval,
   * mapHiFn the high. Intersection is closed, e.g. [lo,hi], unlike with
   * findIndexInSortedIntervals, which is right-open.
   *
   * The array of intervals formed by this mapping must be non-overlapping, and
   * sorted in ascending order by val.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an  element in the array.
   * @param {function():*} mapHiFn Callback that produces the high for the
   *     interval represented by an  element in the array.
   * @param {number} val The value for the search.
   * @return {Number} An index in the array that intersects or is first-above
   *     val, -1 if none found and val is below than all the intervals,
   *     ary.length if val is greater than all the intervals.
   */
  function findIndexInSortedClosedIntervals(ary, mapLoFn, mapHiFn, val) {
    var i = findLowIndexInSortedArray(ary, mapLoFn, val);
    if (i === 0) {
      if (val >= mapLoFn(ary[0], 0) &&
          val <= mapHiFn(ary[0], 0)) {
        return 0;
      } else {
        return -1;
    }
    } else if (i < ary.length) {
      if (val >= mapLoFn(ary[i - 1], i - 1) &&
          val <= mapHiFn(ary[i - 1], i - 1)) {
        return i - 1;
      } else if (val >= mapLoFn(ary[i], i) &&
          val <= mapHiFn(ary[i], i)) {
        return i;
      } else {
        return ary.length;
      }
    } else if (i == ary.length) {
      if (val >= mapLoFn(ary[i - 1], i - 1) &&
          val <= mapHiFn(ary[i - 1], i - 1)) {
        return i - 1;
      } else {
        return ary.length;
      }
    } else {
      return ary.length;
    }
  }

  /**
   * Calls cb for all intervals in the implicit array of intervals
   * defnied by ary, mapLoFn and mapHiFn that intersect the range
   * [loVal,hiVal)
   *
   * This function uses the same scheme as findLowIndexInSortedArray
   * to define the intervals. The same restrictions on sortedness and
   * non-overlappingness apply.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   * nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   * interval represented by an element in the array.
   * @param {function():*} mapWidthFn Callback that produces the width for the
   * interval represented by an element in the array.
   * @param {number} loVal The low value for the search, inclusive.
   * @param {number} hiVal The high value for the search, non inclusive.
   * @param {function():*} cb The function to run for intersecting intervals.
   */
  function iterateOverIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal,
                                            hiVal, cb) {
    if (ary.length == 0)
      return;

    if (loVal > hiVal) return;

    var i = findLowIndexInSortedArray(ary, mapLoFn, loVal);
    if (i == -1) {
      return;
    }
    if (i > 0) {
      var hi = mapLoFn(ary[i - 1]) + mapWidthFn(ary[i - 1], i - 1);
      if (hi >= loVal) {
        cb(ary[i - 1], i - 1);
      }
    }
    if (i == ary.length) {
      return;
    }

    for (var n = ary.length; i < n; i++) {
      var lo = mapLoFn(ary[i]);
      if (lo >= hiVal)
        break;
      cb(ary[i], i);
    }
  }

  /**
   * Non iterative version of iterateOverIntersectingIntervals.
   *
   * @return {Array} Array of elements in ary that intersect loVal, hiVal.
   */
  function getIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal, hiVal) {
    var tmp = [];
    iterateOverIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal, hiVal,
                                     function(d) {
                                       tmp.push(d);
                                     });
    return tmp;
  }

  /**
   * Finds the element in the array whose value is closest to |val|.
   *
   * The same restrictions on sortedness as for findLowIndexInSortedArray apply.
   *
   * @param {Array} ary An array of arbitrary objects.
   * @param {function():*} mapFn Callback that produces a key value
   *     from an element in ary.
   * @param {number} val Value for which to search.
   * @param {number} maxDiff Maximum allowed difference in value between |val|
   *     and an element's value.
   * @return {object} Object in the array whose value is closest to |val|, or
   *     null if no object is within range.
   */
  function findClosestElementInSortedArray(ary, mapFn, val, maxDiff) {
    if (ary.length === 0)
      return null;

    var aftIdx = findLowIndexInSortedArray(ary, mapFn, val);
    var befIdx = aftIdx > 0 ? aftIdx - 1 : 0;

    if (aftIdx === ary.length)
      aftIdx -= 1;

    var befDiff = Math.abs(val - mapFn(ary[befIdx]));
    var aftDiff = Math.abs(val - mapFn(ary[aftIdx]));

    if (befDiff > maxDiff && aftDiff > maxDiff)
      return null;

    var idx = befDiff < aftDiff ? befIdx : aftIdx;
    return ary[idx];
  }

  /**
   * Finds the closest interval in the implicit array of intervals
   * defined by ary, mapLoFn and mapHiFn.
   *
   * This function uses the same scheme as findLowIndexInSortedArray
   * to define the intervals. The same restrictions on sortedness and
   * non-overlappingness apply.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapHiFn.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an element in the array.
   * @param {function():*} mapHiFn Callback that produces the high for the
   *     interval represented by an element in the array.
   * @param {number} val The value for the search.
   * @param {number} maxDiff Maximum allowed difference in value between |val|
   *     and an interval's low or high value.
   * @return {interval} Interval in the array whose high or low value is closest
   *     to |val|, or null if no interval is within range.
   */
  function findClosestIntervalInSortedIntervals(ary, mapLoFn, mapHiFn, val,
                                                maxDiff) {
    if (ary.length === 0)
      return null;

    var idx = findLowIndexInSortedArray(ary, mapLoFn, val);
    if (idx > 0)
      idx -= 1;

    var hiInt = ary[idx];
    var loInt = hiInt;

    if (val > mapHiFn(hiInt) && idx + 1 < ary.length)
      loInt = ary[idx + 1];

    var loDiff = Math.abs(val - mapLoFn(loInt));
    var hiDiff = Math.abs(val - mapHiFn(hiInt));

    if (loDiff > maxDiff && hiDiff > maxDiff)
      return null;

    if (loDiff < hiDiff)
      return loInt;
    else
      return hiInt;
  }

  return {
    findLowIndexInSortedArray: findLowIndexInSortedArray,
    findIndexInSortedIntervals: findIndexInSortedIntervals,
    findIndexInSortedClosedIntervals: findIndexInSortedClosedIntervals,
    iterateOverIntersectingIntervals: iterateOverIntersectingIntervals,
    getIntersectingIntervals: getIntersectingIntervals,
    findClosestElementInSortedArray: findClosestElementInSortedArray,
    findClosestIntervalInSortedIntervals: findClosestIntervalInSortedIntervals
  };
});


'use strict';

/**
 * @fileoverview Provides the ObjectSnapshot and ObjectHistory classes.
 */
tr.exportTo('tr.model', function() {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * An object with a specific id, whose state has been snapshotted several
   * times.
   *
   * @constructor
   */
  function ObjectInstance(
      parent, id, category, name, creationTs, opt_baseTypeName) {
    tr.model.Event.call(this);
    this.parent = parent;
    this.id = id;
    this.category = category;
    this.baseTypeName = opt_baseTypeName ? opt_baseTypeName : name;
    this.name = name;
    this.creationTs = creationTs;
    this.creationTsWasExplicit = false;
    this.deletionTs = Number.MAX_VALUE;
    this.deletionTsWasExplicit = false;
    this.colorId = 0;
    this.bounds = new tr.b.Range();
    this.snapshots = [];
    this.hasImplicitSnapshots = false;
  }

  ObjectInstance.prototype = {
    __proto__: tr.model.Event.prototype,

    get typeName() {
      return this.name;
    },

    addBoundsToRange: function(range) {
      range.addRange(this.bounds);
    },

    addSnapshot: function(ts, args, opt_name, opt_baseTypeName) {
      if (ts < this.creationTs)
        throw new Error('Snapshots must be >= instance.creationTs');
      if (ts >= this.deletionTs)
        throw new Error('Snapshots cannot be added after ' +
                        'an objects deletion timestamp.');

      var lastSnapshot;
      if (this.snapshots.length > 0) {
        lastSnapshot = this.snapshots[this.snapshots.length - 1];
        if (lastSnapshot.ts == ts)
          throw new Error('Snapshots already exists at this time!');
        if (ts < lastSnapshot.ts) {
          throw new Error(
              'Snapshots must be added in increasing timestamp order');
        }
      }

      // Update baseTypeName if needed.
      if (opt_name &&
          (this.name != opt_name)) {
        if (!opt_baseTypeName)
          throw new Error('Must provide base type name for name update');
        if (this.baseTypeName != opt_baseTypeName)
          throw new Error('Cannot update type name: base types dont match');
        this.name = opt_name;
      }

      var snapshotConstructor =
          tr.model.ObjectSnapshot.getConstructor(
              this.category, this.name);
      var snapshot = new snapshotConstructor(this, ts, args);
      this.snapshots.push(snapshot);
      return snapshot;
    },

    wasDeleted: function(ts) {
      var lastSnapshot;
      if (this.snapshots.length > 0) {
        lastSnapshot = this.snapshots[this.snapshots.length - 1];
        if (lastSnapshot.ts > ts)
          throw new Error(
              'Instance cannot be deleted at ts=' +
              ts + '. A snapshot exists that is older.');
      }
      this.deletionTs = ts;
      this.deletionTsWasExplicit = true;
    },

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    preInitialize: function() {
      for (var i = 0; i < this.snapshots.length; i++)
        this.snapshots[i].preInitialize();
    },

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    initialize: function() {
      for (var i = 0; i < this.snapshots.length; i++)
        this.snapshots[i].initialize();
    },

    getSnapshotAt: function(ts) {
      if (ts < this.creationTs) {
        if (this.creationTsWasExplicit)
          throw new Error('ts must be within lifetime of this instance');
        return this.snapshots[0];
      }
      if (ts > this.deletionTs)
        throw new Error('ts must be within lifetime of this instance');

      var snapshots = this.snapshots;
      var i = tr.b.findIndexInSortedIntervals(
          snapshots,
          function(snapshot) { return snapshot.ts; },
          function(snapshot, i) {
            if (i == snapshots.length - 1)
              return snapshots[i].objectInstance.deletionTs;
            return snapshots[i + 1].ts - snapshots[i].ts;
          },
          ts);
      if (i < 0) {
        // Note, this is a little bit sketchy: this lets early ts point at the
        // first snapshot, even before it is taken. We do this because raster
        // tasks usually post before their tile snapshots are dumped. This may
        // be a good line of code to re-visit if we start seeing strange and
        // confusing object references showing up in the traces.
        return this.snapshots[0];
      }
      if (i >= this.snapshots.length)
        return this.snapshots[this.snapshots.length - 1];
      return this.snapshots[i];
    },

    updateBounds: function() {
      this.bounds.reset();
      this.bounds.addValue(this.creationTs);
      if (this.deletionTs != Number.MAX_VALUE)
        this.bounds.addValue(this.deletionTs);
      else if (this.snapshots.length > 0)
        this.bounds.addValue(this.snapshots[this.snapshots.length - 1].ts);
    },

    shiftTimestampsForward: function(amount) {
      this.creationTs += amount;
      if (this.deletionTs != Number.MAX_VALUE)
        this.deletionTs += amount;
      this.snapshots.forEach(function(snapshot) {
        snapshot.ts += amount;
      });
    },

    get userFriendlyName() {
      return this.typeName + ' object ' + this.id;
    }
  };

  tr.model.EventRegistry.register(
    ObjectInstance,
    {
      name: 'objectInstance',
      pluralName: 'objectInstances',
      singleViewElementName: 'tr-ui-a-single-object-instance-sub-view',
      multiViewElementName: 'tr-ui-a-multi-object-sub-view'
    });

  var options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  options.mandatoryBaseClass = ObjectInstance;
  options.defaultConstructor = ObjectInstance;
  tr.b.decorateExtensionRegistry(ObjectInstance, options);

  return {
    ObjectInstance: ObjectInstance
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {

  /**
   * Decorates elements as an instance of a class.
   * @param {string|!Element} source The way to find the element(s) to decorate.
   *     If this is a string then {@code querySeletorAll} is used to find the
   *     elements to decorate.
   * @param {!Function} constr The constructor to decorate with. The constr
   *     needs to have a {@code decorate} function.
   */
  function decorate(source, constr) {
    var elements;
    if (typeof source == 'string')
      elements = tr.doc.querySelectorAll(source);
    else
      elements = [source];

    for (var i = 0, el; el = elements[i]; i++) {
      if (!(el instanceof constr))
        constr.decorate(el);
    }
  }

  /**
   * Defines a tracing UI component, a function that can be called to construct
   * the component.
   *
   * tr class:
   * var List = tr.ui.b.define('list');
   * List.prototype = {
   *   __proto__: HTMLUListElement.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   *
   * Derived class:
   * var CustomList = tr.ui.b.define('custom-list', List);
   * CustomList.prototype = {
   *   __proto__: List.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   *
   * @param {string} className The className of the newly created subtype. If
   *     subclassing by passing in opt_parentConstructor, this is used for
   *     debugging. If not subclassing, then it is the tag name that will be
   *     created by the component.

   * @param {function=} opt_parentConstructor The parent class for this new
   *     element, if subclassing is desired. If provided, the parent class must
   *     be also a function created by tr.ui.b.define.
   *
   * @param {string=} opt_tagNS The namespace in which to create the base
   *     element. Has no meaning when opt_parentConstructor is passed and must
   *     either be undefined or the same namespace as the parent class.
   *
   * @return {function(Object=):Element} The newly created component
   *     constructor.
   */
  function define(className, opt_parentConstructor, opt_tagNS) {
    if (typeof className == 'function') {
      throw new Error('Passing functions as className is deprecated. Please ' +
                      'use (className, opt_parentConstructor) to subclass');
    }

    var className = className.toLowerCase();
    if (opt_parentConstructor && !opt_parentConstructor.tagName)
      throw new Error('opt_parentConstructor was not ' +
                      'created by tr.ui.b.define');

    // Walk up the parent constructors until we can find the type of tag
    // to create.
    var tagName = className;
    var tagNS = undefined;
    if (opt_parentConstructor) {
      if (opt_tagNS)
        throw new Error('Must not specify tagNS if parentConstructor is given');
      var parent = opt_parentConstructor;
      while (parent && parent.tagName) {
        tagName = parent.tagName;
        tagNS = parent.tagNS;
        parent = parent.parentConstructor;
      }
    } else {
      tagNS = opt_tagNS;
    }

    /**
     * Creates a new UI element constructor.
     * Arguments passed to the constuctor are provided to the decorate method.
     * You will need to call the parent elements decorate method from within
     * your decorate method and pass any required parameters.
     * @constructor
     */
    function f() {
      if (opt_parentConstructor &&
          f.prototype.__proto__ != opt_parentConstructor.prototype) {
        throw new Error(
            className + ' prototye\'s __proto__ field is messed up. ' +
            'It MUST be the prototype of ' + opt_parentConstructor.tagName);
      }

      var el;
      if (tagNS === undefined)
        el = tr.doc.createElement(tagName);
      else
        el = tr.doc.createElementNS(tagNS, tagName);
      f.decorate.call(this, el, arguments);
      return el;
    }

    /**
     * Decorates an element as a UI element class.
     * @param {!Element} el The element to decorate.
     */
    f.decorate = function(el) {
      el.__proto__ = f.prototype;
      el.decorate.apply(el, arguments[1]);
      el.constructor = f;
    };

    f.className = className;
    f.tagName = tagName;
    f.tagNS = tagNS;
    f.parentConstructor = (opt_parentConstructor ? opt_parentConstructor :
                                                   undefined);
    f.toString = function() {
      if (!f.parentConstructor)
        return f.tagName;
      return f.parentConstructor.toString() + '::' + f.className;
    };

    return f;
  }

  function elementIsChildOf(el, potentialParent) {
    if (el == potentialParent)
      return false;

    var cur = el;
    while (cur.parentNode) {
      if (cur == potentialParent)
        return true;
      cur = cur.parentNode;
    }
    return false;
  };

  return {
    decorate: decorate,
    define: define,
    elementIsChildOf: elementIsChildOf
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  // Setting this to true will cause stack traces to get dumped into the
  // tasks. When an exception happens the original stack will be printed.
  //
  // NOTE: This should never be set committed as true.
  var recordRAFStacks = false;

  var pendingPreAFs = [];
  var pendingRAFs = [];
  var pendingIdleCallbacks = [];
  var currentRAFDispatchList = undefined;

  var rafScheduled = false;

  function scheduleRAF() {
    if (rafScheduled)
      return;
    rafScheduled = true;
    if (tr.isHeadless) {
      Promise.resolve().then(function() {
        processRequests(0);
      }, function(e) {
        console.log(e.stack);
        throw e;
      });
    } else {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(processRequests);
      } else {
        var delta = Date.now() - window.performance.now();
        window.webkitRequestAnimationFrame(function(domTimeStamp) {
          processRequests(domTimeStamp - delta);
        });
      }
    }
  }

  function onAnimationFrameError(e, opt_stack) {
    console.log(e.stack);
    if (tr.isHeadless)
      throw e;

    if (opt_stack)
      console.log(opt_stack);

    if (e.message)
      console.error(e.message, e.stack);
    else
      console.error(e);
  }

  function runTask(task, frameBeginTime) {
    try {
      task.callback.call(task.context, frameBeginTime);
    } catch (e) {
      tr.b.onAnimationFrameError(e, task.stack);
    }
  }

  function processRequests(frameBeginTime) {
    // We assume that we want to do a maximum of 10ms optional work per frame.
    // Hopefully rAF will eventually pass this in for us.
    var rafCompletionDeadline = frameBeginTime + 10;

    rafScheduled = false;


    var currentPreAFs = pendingPreAFs;
    currentRAFDispatchList = pendingRAFs;
    pendingPreAFs = [];
    pendingRAFs = [];
    var hasRAFTasks = currentPreAFs.length || currentRAFDispatchList.length;

    for (var i = 0; i < currentPreAFs.length; i++)
      runTask(currentPreAFs[i], frameBeginTime);

    while (currentRAFDispatchList.length > 0)
      runTask(currentRAFDispatchList.shift(), frameBeginTime);
    currentRAFDispatchList = undefined;

    if (!hasRAFTasks) {
      while (pendingIdleCallbacks.length > 0) {
        runTask(pendingIdleCallbacks.shift());
        // Check timer after running at least one idle task to avoid buggy
        // window.performance.now() on some platforms from blocking the idle
        // task queue.
        if (tr.isHeadless || window.performance.now() >= rafCompletionDeadline)
          break;
      }
    }

    if (pendingIdleCallbacks.length > 0)
      scheduleRAF();
  }

  function getStack_() {
    if (!recordRAFStacks)
      return '';

    var stackLines = tr.b.stackTrace();
    // Strip off getStack_.
    stackLines.shift();
    return stackLines.join('\n');
  }

  function requestPreAnimationFrame(callback, opt_this) {
    pendingPreAFs.push({
      callback: callback,
      context: opt_this || window,
      stack: getStack_()});
    scheduleRAF();
  }

  function requestAnimationFrameInThisFrameIfPossible(callback, opt_this) {
    if (!currentRAFDispatchList) {
      requestAnimationFrame(callback, opt_this);
      return;
    }
    currentRAFDispatchList.push({
      callback: callback,
      context: opt_this || window,
      stack: getStack_()});
    return;
  }

  function requestAnimationFrame(callback, opt_this) {
    pendingRAFs.push({
      callback: callback,
      context: opt_this || window,
      stack: getStack_()});
    scheduleRAF();
  }

  function requestIdleCallback(callback, opt_this) {
    pendingIdleCallbacks.push({
      callback: callback,
      context: opt_this || window,
      stack: getStack_()});
    scheduleRAF();
  }

  function forcePendingRAFTasksToRun(frameBeginTime) {
    if (!rafScheduled)
      return;
    processRequests(frameBeginTime);
  }

  return {
    onAnimationFrameError: onAnimationFrameError,
    requestPreAnimationFrame: requestPreAnimationFrame,
    requestAnimationFrame: requestAnimationFrame,
    requestAnimationFrameInThisFrameIfPossible:
        requestAnimationFrameInThisFrameIfPossible,
    requestIdleCallback: requestIdleCallback,
    forcePendingRAFTasksToRun: forcePendingRAFTasksToRun
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  /**
   * A task is a combination of a run callback, a set of subtasks, and an after
   * task.
   *
   * When executed, a task does the following things:
   * 1. Runs its callback
   * 2. Runs its subtasks
   * 3. Runs its after callback.
   *
   * The list of subtasks and after task can be mutated inside step #1 but as
   * soon as the task's callback returns, the subtask list and after task is
   * fixed and cannot be changed again.
   *
   * Use task.after().after().after() to describe the toplevel passes that make
   * up your computation. Then, use subTasks to add detail to each subtask as it
   * runs. For example:
   *    var pieces = [];
   *    taskA = new Task(function() { pieces = getPieces(); });
   *    taskA.after(function(taskA) {
   *      pieces.forEach(function(piece) {
   *        taskA.subTask(function(taskB) { piece.process(); }, this);
   *      });
   *    });
   *
   * @constructor
   */
  function Task(runCb, thisArg) {
    if (runCb !== undefined && thisArg === undefined)
      throw new Error('Almost certainly, you meant to pass a thisArg.');
    this.runCb_ = runCb;
    this.thisArg_ = thisArg;
    this.afterTask_ = undefined;
    this.subTasks_ = [];
  }

  Task.prototype = {
    /*
     * See constructor documentation on semantics of subtasks.
     */
    subTask: function(cb, thisArg) {
      if (cb instanceof Task)
        this.subTasks_.push(cb);
      else
        this.subTasks_.push(new Task(cb, thisArg));
      return this.subTasks_[this.subTasks_.length - 1];
    },

    /**
     * Runs the current task and returns the task that should be executed next.
     */
    run: function() {
      if (this.runCb_ !== undefined)
        this.runCb_.call(this.thisArg_, this);
      var subTasks = this.subTasks_;
      this.subTasks_ = undefined; // Prevent more subTasks from being posted.

      if (!subTasks.length)
        return this.afterTask_;

      // If there are subtasks, then we want to execute all the subtasks and
      // then this task's afterTask. To make this happen, we update the
      // afterTask of all the subtasks so the point upward to each other, e.g.
      // subTask[0].afterTask to subTask[1] and so on. Then, the last subTask's
      // afterTask points at this task's afterTask.
      for (var i = 1; i < subTasks.length; i++)
        subTasks[i - 1].afterTask_ = subTasks[i];
      subTasks[subTasks.length - 1].afterTask_ = this.afterTask_;
      return subTasks[0];
    },

    /*
     * See constructor documentation on semantics of after tasks.
     */
    after: function(cb, thisArg) {
      if (this.afterTask_)
        throw new Error('Has an after task already');
      if (cb instanceof Task)
        this.afterTask_ = cb;
      else
        this.afterTask_ = new Task(cb, thisArg);
      return this.afterTask_;
    },

    /*
     * Adds a task after the chain of tasks.
     */
    enqueue: function(cb, thisArg) {
      var lastTask = this;
      while (lastTask.afterTask_)
        lastTask = lastTask.afterTask_;
      return lastTask.after(cb, thisArg);
    }
  };

  Task.RunSynchronously = function(task) {
    var curTask = task;
    while (curTask)
      curTask = curTask.run();
  }

  /**
   * Runs a task using raf.requestIdleCallback, returning
   * a promise for its completion.
   */
  Task.RunWhenIdle = function(task) {
    return new Promise(function(resolve, reject) {
      var curTask = task;
      function runAnother() {
        try {
          curTask = curTask.run();
        } catch (e) {
          reject(e);
          console.error(e.stack);
          return;
        }

        if (curTask) {
          tr.b.requestIdleCallback(runAnother);
          return;
        }

        resolve();
      }
      tr.b.requestIdleCallback(runAnother);
    });
  }

  return {
    Task: Task
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  var EventSet = tr.model.EventSet;
  var SelectionState = tr.model.SelectionState;

  function BrushingState() {
    this.guid_ = tr.b.GUID.allocate();
    this.selection_ = new EventSet();
    this.findMatches_ = new EventSet();
    this.analysisViewRelatedEvents_ = new EventSet();
    this.analysisLinkHoveredEvents_ = new EventSet();
    this.appliedToModel_ = undefined;
    this.viewSpecificBrushingStates_ = {};
  }
  BrushingState.prototype = {
    get guid() {
      return this.guid_;
    },

    clone: function() {
      var that = new BrushingState();
      that.selection_ = this.selection_;
      that.findMatches_ = this.findMatches_;
      that.analysisViewRelatedEvents_ = this.analysisViewRelatedEvents_;
      that.analysisLinkHoveredEvents_ = this.analysisLinkHoveredEvents_;
      that.viewSpecificBrushingStates_ = this.viewSpecificBrushingStates_;

      return that;
    },

    equals: function(that) {
      if (!this.selection_.equals(that.selection_))
        return false;
      if (!this.findMatches_.equals(that.findMatches_))
        return false;
      if (!this.analysisViewRelatedEvents_.equals(
          that.analysisViewRelatedEvents_)) {
        return false;
      }
      if (!this.analysisLinkHoveredEvents_.equals(
          that.analysisLinkHoveredEvents_)) {
        return false;
      }
      // We currently do not take the view-specific brushing states into
      // account. If we did, every change of the view-specific brushing state
      // of any view would cause a redraw of the whole UI (see the
      // BrushingStateController.currentBrushingState setter).
      return true;
    },

    get selectionOfInterest() {
      if (this.selection_.length)
        return this.selection_;

      if (this.highlight_.length)
        return this.highlight_;

      if (this.analysisViewRelatedEvents_.length)
        return this.analysisViewRelatedEvents_;

      if (this.analysisLinkHoveredEvents_.length)
        return this.analysisLinkHoveredEvents_;

      return this.selection_;
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (this.appliedToModel_)
        throw new Error('Cannot mutate this state right now');
      if (selection === undefined)
        selection = new EventSet();
      this.selection_ = selection;
    },

    get findMatches() {
      return this.findMatches_;
    },

    set findMatches(findMatches) {
      if (this.appliedToModel_)
        throw new Error('Cannot mutate this state right now');
      if (findMatches === undefined)
        findMatches = new EventSet();
      this.findMatches_ = findMatches;
    },

    get analysisViewRelatedEvents() {
      return this.analysisViewRelatedEvents_;
    },

    set analysisViewRelatedEvents(analysisViewRelatedEvents) {
      if (this.appliedToModel_)
        throw new Error('Cannot mutate this state right now');
      if (analysisViewRelatedEvents === undefined)
        analysisViewRelatedEvents = new EventSet();
      this.analysisViewRelatedEvents_ = analysisViewRelatedEvents;
    },

    get analysisLinkHoveredEvents() {
      return this.analysisLinkHoveredEvents_;
    },

    set analysisLinkHoveredEvents(analysisLinkHoveredEvents) {
      if (this.appliedToModel_)
        throw new Error('Cannot mutate this state right now');
      if (analysisLinkHoveredEvents === undefined)
        analysisLinkHoveredEvents = new EventSet();
      this.analysisLinkHoveredEvents_ = analysisLinkHoveredEvents;
    },

    get isAppliedToModel() {
      return this.appliedToModel_ !== undefined;
    },

    get hasHighlight_() {
      return this.findMatches_.length > 0 ||
          this.analysisViewRelatedEvents_.length > 0 ||
          this.analysisLinkHoveredEvents_.length > 0;
    },

    get viewSpecificBrushingStates() {
      return this.viewSpecificBrushingStates_;
    },

    set viewSpecificBrushingStates(viewSpecificBrushingStates) {
      this.viewSpecificBrushingStates_ = viewSpecificBrushingStates;
    },

    applyToModelSelectionState: function(model) {
      this.appliedToModel_ = model;

      if (!this.hasHighlight_) {
        this.selection_.forEach(function(e) {
          e.selectionState = SelectionState.SELECTED;
        });
        return;
      }

      model.iterateAllEvents(function(e) {
        var selectionState;
        if (this.selection_.contains(e)) {
          selectionState = SelectionState.SELECTED;
        } else if (this.findMatches_.contains(e) ||
                   this.analysisViewRelatedEvents_.contains(e) ||
                   this.analysisLinkHoveredEvents_.contains(e)) {
          selectionState = SelectionState.HIGHLIGHTED;
        } else {
          selectionState = SelectionState.DIMMED;
        }
        e.selectionState = selectionState;
      }.bind(this));
    },

    transferModelOwnershipToClone: function(that) {
      if (!this.appliedToModel_)
        throw new Error('Not applied');
      // Assumes this.equals(that).
      that.appliedToModel_ = this.appliedToModel_;
      this.appliedToModel_ = undefined;
    },

    unapplyFromModelSelectionState: function() {
      if (!this.appliedToModel_)
        throw new Error('Not applied');
      var model = this.appliedToModel_;
      this.appliedToModel_ = undefined;

      if (!this.hasHighlight_) {
        this.selection_.forEach(function(e) {
          e.selectionState = SelectionState.NONE;
        });
        return;
      }

      model.iterateAllEvents(function(e) {
        e.selectionState = SelectionState.NONE;
      });
    }
  };

  return {
    BrushingState: BrushingState
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  /**
   * Represents a procedural animation that can be run by an
   * tr.ui.b.AnimationController.
   *
   * @constructor
   */
  function Animation() {
  }

  Animation.prototype = {

    /**
     * Called when an animation has been queued after a running animation.
     *
     * @return {boolean} True if the animation can take on the responsibilities
     * of the running animation. If true, takeOverFor will be called on the
     * animation.
     *
     * This can be used to build animations that accelerate as pairs of them are
     * queued.
     */
    canTakeOverFor: function(existingAnimation) {
      throw new Error('Not implemented');
    },

    /**
     * Called to take over responsiblities of an existingAnimation.
     *
     * At this point, the existingAnimation has been ticked one last time, then
     * stopped. This animation will be started after this returns and has the
     * job of finishing(or transitioning away from) the effect the existing
     * animation was trying to accomplish.
     */
    takeOverFor: function(existingAnimation, newStartTimestamp, target) {
      throw new Error('Not implemented');
    },

    start: function(timestamp, target) {
      throw new Error('Not implemented');
    },

    /**
     * Called when an animation is stopped before it finishes. The animation can
     * do what it wants here, usually nothing.
     *
     * @param {Number} timestamp When the animation was stopped.
     * @param {Object} target The object being animated. May be undefined, take
     * care.
     * @param {boolean} willBeTakenOverByAnotherAnimation Whether this animation
     * is going to be handed to another animation's takeOverFor function.
     */
    didStopEarly: function(timestamp, target,
                           willBeTakenOverByAnotherAnimation) {
    },

    /**
     * @return {boolean} true if the animation is finished.
     */
    tick: function(timestamp, target) {
      throw new Error('Not implemented');
    }
  };

  return {
    Animation: Animation
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  /**
   * Manages execution, queueing and blending of tr.ui.b.Animations against
   * a single target.
   *
   * Targets must have a cloneAnimationState() method that returns all the
   * animatable states of that target.
   *
   * @constructor
   * @extends {tr.b.EventTarget}
   */
  function AnimationController() {
    tr.b.EventTarget.call(this);

    this.target_ = undefined;

    this.activeAnimation_ = undefined;

    this.tickScheduled_ = false;
  }

  AnimationController.prototype = {
    __proto__: tr.b.EventTarget.prototype,

    get target() {
      return this.target_;
    },

    set target(target) {
      if (this.activeAnimation_)
        throw new Error('Cannot change target while animation is running.');
      if (target.cloneAnimationState === undefined ||
          typeof target.cloneAnimationState !== 'function')
        throw new Error('target must have a cloneAnimationState function');

      this.target_ = target;
    },

    get activeAnimation() {
      return this.activeAnimation_;
    },

    get hasActiveAnimation() {
      return !!this.activeAnimation_;
    },

    queueAnimation: function(animation, opt_now) {
      if (this.target_ === undefined)
        throw new Error('Cannot queue animations without a target');

      var now;
      if (opt_now !== undefined)
        now = opt_now;
      else
        now = window.performance.now();

      if (this.activeAnimation_) {
        // Must tick the animation before stopping it case its about to stop,
        // and to update the target with its final sets of edits up to this
        // point.
        var done = this.activeAnimation_.tick(now, this.target_);
        if (done)
          this.activeAnimation_ = undefined;
      }

      if (this.activeAnimation_) {
        if (animation.canTakeOverFor(this.activeAnimation_)) {
          this.activeAnimation_.didStopEarly(now, this.target_, true);
          animation.takeOverFor(this.activeAnimation_, now, this.target_);
        } else {
          this.activeAnimation_.didStopEarly(now, this.target_, false);
        }
      }
      this.activeAnimation_ = animation;
      this.activeAnimation_.start(now, this.target_);

      if (this.tickScheduled_)
        return;
      this.tickScheduled_ = true;
      tr.b.requestAnimationFrame(this.tickActiveAnimation_, this);
    },

    cancelActiveAnimation: function(opt_now) {
      if (!this.activeAnimation_)
        return;
      var now;
      if (opt_now !== undefined)
        now = opt_now;
      else
        now = window.performance.now();
      this.activeAnimation_.didStopEarly(now, this.target_, false);
      this.activeAnimation_ = undefined;
    },

    tickActiveAnimation_: function(frameBeginTime) {
      this.tickScheduled_ = false;
      if (!this.activeAnimation_)
        return;

      if (this.target_ === undefined) {
        this.activeAnimation_.didStopEarly(frameBeginTime, this.target_, false);
        return;
      }

      var oldTargetState = this.target_.cloneAnimationState();

      var done = this.activeAnimation_.tick(frameBeginTime, this.target_);
      if (done)
        this.activeAnimation_ = undefined;

      if (this.activeAnimation_) {
        this.tickScheduled_ = true;
        tr.b.requestAnimationFrame(this.tickActiveAnimation_, this);
      }

      if (oldTargetState) {
        var e = new tr.b.Event('didtick');
        e.oldTargetState = oldTargetState;
        this.dispatchEvent(e, false, false);
      }
    }
  };

  return {
    AnimationController: AnimationController
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {

  function createSpan(opt_dictionary) {
    var ownerDocument = document;
    if (opt_dictionary && opt_dictionary.ownerDocument)
      ownerDocument = opt_dictionary.ownerDocument;
    var spanEl = ownerDocument.createElement('span');
    if (opt_dictionary) {
      if (opt_dictionary.className)
        spanEl.className = opt_dictionary.className;
      if (opt_dictionary.textContent)
        spanEl.textContent = opt_dictionary.textContent;
      if (opt_dictionary.tooltip)
        spanEl.title = opt_dictionary.tooltip;
      if (opt_dictionary.parent)
        opt_dictionary.parent.appendChild(spanEl);
      if (opt_dictionary.bold)
        spanEl.style.fontWeight = 'bold';
      if (opt_dictionary.italic)
        spanEl.style.fontStyle = 'italic';
      if (opt_dictionary.marginLeft)
        spanEl.style.marginLeft = opt_dictionary.marginLeft;
      if (opt_dictionary.marginRight)
        spanEl.style.marginRight = opt_dictionary.marginRight;
      if (opt_dictionary.backgroundColor)
        spanEl.style.backgroundColor = opt_dictionary.backgroundColor;
      if (opt_dictionary.color)
        spanEl.style.color = opt_dictionary.color;
    }
    return spanEl;
  };

  function createDiv(opt_dictionary) {
    var divEl = document.createElement('div');
    if (opt_dictionary) {
      if (opt_dictionary.className)
        divEl.className = opt_dictionary.className;
      if (opt_dictionary.parent)
        opt_dictionary.parent.appendChild(divEl);
      if (opt_dictionary.textContent)
        divEl.textContent = opt_dictionary.textContent;
      if (opt_dictionary.maxWidth)
        divEl.style.maxWidth = opt_dictionary.maxWidth;
    }
    return divEl;
  };

  function createScopedStyle(styleContent) {
    var styleEl = document.createElement('style');
    styleEl.scoped = true;
    styleEl.innerHTML = styleContent;
    return styleEl;
  }

  function valuesEqual(a, b) {
    if (a instanceof Array && b instanceof Array)
      return a.length === b.length && JSON.stringify(a) === JSON.stringify(b);
    return a === b;
  }

  function createSelector(
      targetEl, targetElProperty,
      settingsKey, defaultValue,
      items, opt_namespace) {
    var defaultValueIndex;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (valuesEqual(item.value, defaultValue)) {
        defaultValueIndex = i;
        break;
      }
    }
    if (defaultValueIndex === undefined)
      throw new Error('defaultValue must be in the items list');

    var selectorEl = document.createElement('select');
    selectorEl.addEventListener('change', onChange);
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var optionEl = document.createElement('option');
      optionEl.textContent = item.label;
      optionEl.targetPropertyValue = item.value;
      selectorEl.appendChild(optionEl);
    }
    function onChange(e) {
      var value = selectorEl.selectedOptions[0].targetPropertyValue;
      tr.b.Settings.set(settingsKey, value, opt_namespace);
      targetEl[targetElProperty] = value;
    }
    var oldSetter = targetEl.__lookupSetter__('selectedIndex');
    selectorEl.__defineGetter__('selectedValue', function(v) {
      return selectorEl.children[selectorEl.selectedIndex].targetPropertyValue;
    });
    selectorEl.__defineSetter__('selectedValue', function(v) {
      for (var i = 0; i < selectorEl.children.length; i++) {
        var value = selectorEl.children[i].targetPropertyValue;
        if (valuesEqual(value, v)) {
          var changed = selectorEl.selectedIndex != i;
          if (changed) {
            selectorEl.selectedIndex = i;
            onChange();
          }
          return;
        }
      }
      throw new Error('Not a valid value');
    });

    var initialValue = tr.b.Settings.get(
        settingsKey, defaultValue, opt_namespace);
    var didSet = false;
    for (var i = 0; i < selectorEl.children.length; i++) {
      if (valuesEqual(selectorEl.children[i].targetPropertyValue,
          initialValue)) {
        didSet = true;
        targetEl[targetElProperty] = initialValue;
        selectorEl.selectedIndex = i;
        break;
      }
    }
    if (!didSet) {
      selectorEl.selectedIndex = defaultValueIndex;
      targetEl[targetElProperty] = defaultValue;
    }

    return selectorEl;
  }

  function createEditCategorySpan(optionGroupEl, targetEl) {
    var spanEl = createSpan({className: 'edit-categories'});
    spanEl.textContent = 'Edit categories';
    spanEl.classList.add('labeled-option');

    spanEl.addEventListener('click', function() {
      targetEl.onClickEditCategories();
    });
    return spanEl;
  }

  function createOptionGroup(targetEl, targetElProperty,
                             settingsKey, defaultValue,
                             items) {
    function onChange() {
      var value = [];
      if (this.value.length)
        value = this.value.split(',');
      tr.b.Settings.set(settingsKey, value);
      targetEl[targetElProperty] = value;
    }

    var optionGroupEl = createSpan({className: 'labeled-option-group'});
    var initialValue = tr.b.Settings.get(settingsKey, defaultValue);
    for (var i = 0; i < items.length; ++i) {
      var item = items[i];
      var id = 'category-preset-' + item.label.replace(/ /g, '-');

      var radioEl = document.createElement('input');
      radioEl.type = 'radio';
      radioEl.setAttribute('id', id);
      radioEl.setAttribute('name', 'category-presets-group');
      radioEl.setAttribute('value', item.value);
      radioEl.addEventListener('change', onChange.bind(radioEl, targetEl,
                                                       targetElProperty,
                                                       settingsKey));
      if (valuesEqual(initialValue, item.value))
        radioEl.checked = true;

      var labelEl = document.createElement('label');
      labelEl.textContent = item.label;
      labelEl.setAttribute('for', id);

      var spanEl = createSpan({className: 'labeled-option'});
      spanEl.appendChild(radioEl);
      spanEl.appendChild(labelEl);

      spanEl.__defineSetter__('checked', function(opt_bool) {
        var changed = radioEl.checked !== (!!opt_bool);
        if (!changed)
          return;

        radioEl.checked = !!opt_bool;
        onChange();
      });
      spanEl.__defineGetter__('checked', function() {
        return radioEl.checked;
      });

      optionGroupEl.appendChild(spanEl);
    }
    optionGroupEl.appendChild(createEditCategorySpan(optionGroupEl, targetEl));
    // Since this option group element is not yet added to the tree,
    // querySelector will fail during updateEditCategoriesStatus_ call.
    // Hence, creating the element with the 'expanded' classlist category
    // added, if last selected value was 'Manual' selection.
    if (!initialValue.length)
      optionGroupEl.classList.add('categories-expanded');
    targetEl[targetElProperty] = initialValue;

    return optionGroupEl;
  }

  var nextCheckboxId = 1;
  function createCheckBox(targetEl, targetElProperty,
                          settingsKey, defaultValue,
                          label, opt_changeCb) {
    var buttonEl = document.createElement('input');
    buttonEl.type = 'checkbox';

    var initialValue = tr.b.Settings.get(settingsKey, defaultValue);
    buttonEl.checked = !!initialValue;
    if (targetEl)
      targetEl[targetElProperty] = initialValue;

    function onChange() {
      tr.b.Settings.set(settingsKey, buttonEl.checked);
      if (targetEl)
        targetEl[targetElProperty] = buttonEl.checked;
      if (opt_changeCb)
        opt_changeCb.call();
    }

    buttonEl.addEventListener('change', onChange);

    var id = '#checkbox-' + nextCheckboxId++;

    var spanEl = createSpan({className: 'labeled-checkbox'});
    buttonEl.setAttribute('id', id);

    var labelEl = document.createElement('label');
    labelEl.textContent = label;
    labelEl.setAttribute('for', id);
    spanEl.appendChild(buttonEl);
    spanEl.appendChild(labelEl);

    spanEl.__defineSetter__('checked', function(opt_bool) {
      var changed = buttonEl.checked !== (!!opt_bool);
      if (!changed)
        return;

      buttonEl.checked = !!opt_bool;
      onChange();
    });
    spanEl.__defineGetter__('checked', function() {
      return buttonEl.checked;
    });

    return spanEl;
  }

  function isElementAttachedToDocument(el) {
    var cur = el;
    while (cur.parentNode)
      cur = cur.parentNode;
    return (cur === el.ownerDocument || cur.nodeName === '#document-fragment');
  }

  function asHTMLOrTextNode(value, opt_ownerDocument) {
    if (value instanceof Node)
      return value;
    var ownerDocument = opt_ownerDocument || document;
    return ownerDocument.createTextNode(value);
  }

  return {
    createSpan: createSpan,
    createDiv: createDiv,
    createScopedStyle: createScopedStyle,
    createSelector: createSelector,
    createOptionGroup: createOptionGroup,
    createCheckBox: createCheckBox,
    isElementAttachedToDocument: isElementAttachedToDocument,
    asHTMLOrTextNode: asHTMLOrTextNode
  };
});


'use strict';

/**
 * @fileoverview Provides color scheme related functions.
 */
tr.exportTo('tr.ui.b', function() {

  function boundChannel(v) {
    return Math.min(255, Math.max(0, Math.floor(v)));
  }

  function brightenColor(c) {
    var k;
    if (c.r >= 240 && c.g >= 240 && c.b >= 240)
      k = 0.80;
    else
      k = 1.45;

    return {
      r: boundChannel(c.r * k),
      g: boundChannel(c.g * k),
      b: boundChannel(c.b * k)
    };
  }
  function desaturateColor(c) {
    var value = boundChannel((c.r + c.g + c.b) / 3);
    return { r: value, g: value, b: value };
  }
  function colorToRGBString(c) {
    return 'rgb(' + c.r + ',' + c.g + ',' + c.b + ')';
  }
  function colorToRGBAString(c, a) {
    return 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + a + ')';
  }

  return {
    brightenColor: brightenColor,
    desaturateColor: desaturateColor,
    colorToRGBString: colorToRGBString,
    colorToRGBAString: colorToRGBAString
  };
});


'use strict';

/**
 * @fileoverview Provides color scheme related functions.
 */
tr.exportTo('tr.ui.b', function() {
  var colorToRGBString = tr.ui.b.colorToRGBString;
  var colorToRGBAString = tr.ui.b.colorToRGBAString;

  // Basic constants...

  var generalPurposeColors = [
    {r: 138, g: 113, b: 152},
    {r: 175, g: 112, b: 133},
    {r: 127, g: 135, b: 225},
    {r: 93, g: 81, b: 137},
    {r: 116, g: 143, b: 119},
    {r: 178, g: 214, b: 122},
    {r: 87, g: 109, b: 147},
    {r: 119, g: 155, b: 95},
    {r: 114, g: 180, b: 160},
    {r: 132, g: 85, b: 103},
    {r: 157, g: 210, b: 150},
    {r: 148, g: 94, b: 86},
    {r: 164, g: 108, b: 138},
    {r: 139, g: 191, b: 150},
    {r: 110, g: 99, b: 145},
    {r: 80, g: 129, b: 109},
    {r: 125, g: 140, b: 149},
    {r: 93, g: 124, b: 132},
    {r: 140, g: 85, b: 140},
    {r: 104, g: 163, b: 162},
    {r: 132, g: 141, b: 178},
    {r: 131, g: 105, b: 147},
    {r: 135, g: 183, b: 98},
    {r: 152, g: 134, b: 177},
    {r: 141, g: 188, b: 141},
    {r: 133, g: 160, b: 210},
    {r: 126, g: 186, b: 148},
    {r: 112, g: 198, b: 205},
    {r: 180, g: 122, b: 195},
    {r: 203, g: 144, b: 152}];

  var reservedColorsByName = {
    thread_state_iowait: {r: 182, g: 125, b: 143},
    thread_state_running: {r: 126, g: 200, b: 148},
    thread_state_runnable: {r: 133, g: 160, b: 210},
    thread_state_sleeping: {r: 240, g: 240, b: 240},
    thread_state_unknown: {r: 199, g: 155, b: 125},

    light_memory_dump: {r: 0, g: 0, b: 180},
    detailed_memory_dump: {r: 180, g: 0, b: 180},

    generic_work: {r: 125, g: 125, b: 125},

    good: {r: 0, g: 125, b: 0},
    bad: {r: 180, g: 125, b: 0},
    terrible: {r: 180, g: 0, b: 0},

    black: {r: 0, g: 0, b: 0},

    rail_response: {r: 67, g: 135, b: 253},
    rail_animate: {r: 244, g: 74, b: 63},
    rail_idle: {r: 238, g: 142, b: 0},
    rail_load: {r: 13, g: 168, b: 97},

    used_memory_column: {r: 0, g: 0, b: 255},
    older_used_memory_column: {r: 153, g: 204, b: 255},
    tracing_memory_column: {r: 153, g: 153, b: 153},

    cq_build_running: {r: 255, g: 255, b: 119},
    cq_build_passed: {r: 153, g: 238, b: 102},
    cq_build_failed: {r: 238, g: 136, b: 136},
    cq_build_abandoned: {r: 187, g: 187, b: 187},

    cq_build_attempt_running: {r: 222, g: 222, b: 75},
    cq_build_attempt_passed: {r: 103, g: 218, b: 35},
    cq_build_attempt_failed: {r: 197, g: 81, b: 81}
  };

  // Some constants we'll need for later lookups.
  var numGeneralPurposeColorIds = generalPurposeColors.length;
  var numReservedColorIds = tr.b.dictionaryLength(reservedColorsByName);

  // The color palette is split in half, with the upper
  // half of the palette being the "highlighted" verison
  // of the base color. So, color 7's highlighted form is
  // 7 + (palette.length / 2).
  //
  // These bright versions of colors are automatically generated
  // from the base colors.
  //
  // Within the color palette, there are "general purpose" colors,
  // which can be used for random color selection, and
  // reserved colors, which are used when specific colors
  // need to be used, e.g. where red is desired.
  var paletteRaw = (function() {
    var paletteBase = [];
    paletteBase.push.apply(paletteBase, generalPurposeColors);
    paletteBase.push.apply(paletteBase,
                           tr.b.dictionaryValues(reservedColorsByName));
    return paletteBase.concat(paletteBase.map(tr.ui.b.brightenColor),
                              paletteBase.map(tr.ui.b.desaturateColor));
  })();
  var palette = paletteRaw.map(colorToRGBString);

  var highlightIdBoost = paletteRaw.length / 3;
  var desaturateIdBoost = (paletteRaw.length / 3) * 2;

  // Build reservedColorNameToIdMap.
  var reservedColorNameToIdMap = (function() {
    var m = {};
    var i = generalPurposeColors.length;
    tr.b.iterItems(reservedColorsByName, function(key, value) {
      m[key] = i++;
    });
    return m;
  })();

  /**
   * Computes a simplistic hashcode of the provide name. Used to chose colors
   * for slices.
   * @param {string} name The string to hash.
   */
  function getStringHash(name) {
    var hash = 0;
    for (var i = 0; i < name.length; ++i)
      hash = (hash + 37 * hash + 11 * name.charCodeAt(i)) % 0xFFFFFFFF;
    return hash;
  }

  /**
   * Gets the color palette.
   */
  function getColorPalette() {
    return palette;
  }

  /**
   * Gets the raw color palette, where entries are still objects.
   */
  function getRawColorPalette() {
    return paletteRaw;
  }

  /**
   * @return {Number} The value to add to a color ID to get its highlighted
   * color ID. E.g. 7 + getPaletteHighlightIdBoost() yields a brightened form
   * of 7's base color.
   */
  function getColorPaletteHighlightIdBoost() {
    return highlightIdBoost;
  }
  /**
   * @return {Number} The value to add to a color ID to get its desaturated
   * color ID. E.g. 7 + getPaletteDesaturateIdBoost() yields a desaturate form
   * of 7's base color.
   */
  function getColorPaletteDesaturateIdBoost() {
    return desaturateIdBoost;
  }

  /**
   * @param {String} name The color name.
   * @return {Number} The color ID for the given color name.
   */
  function getColorIdForReservedName(name) {
    var id = reservedColorNameToIdMap[name];
    if (id === undefined)
      throw new Error('Unrecognized color ') + name;
    return id;
  }

  // Previously computed string color IDs. They are based on a stable hash, so
  // it is safe to save them throughout the program time.
  var stringColorIdCache = {};

  /**
   * @return {Number} A color ID that is stably associated to the provided via
   * the getStringHash method. The color ID will be chosen from the general
   * purpose ID space only, e.g. no reserved ID will be used.
   */
  function getColorIdForGeneralPurposeString(string) {
    if (stringColorIdCache[string] === undefined) {
      var hash = getStringHash(string);
      stringColorIdCache[string] = hash % numGeneralPurposeColorIds;
    }
    return stringColorIdCache[string];
  }

  var paletteProperties = {
    numGeneralPurposeColorIds: numGeneralPurposeColorIds,
    highlightIdBoost: highlightIdBoost,
    desaturateIdBoost: desaturateIdBoost
  };

  return {
    getRawColorPalette: getRawColorPalette,
    getColorPalette: getColorPalette,
    paletteProperties: paletteProperties,
    getColorPaletteHighlightIdBoost: getColorPaletteHighlightIdBoost,
    getColorPaletteDesaturateIdBoost: getColorPaletteDesaturateIdBoost,
    getColorIdForReservedName: getColorIdForReservedName,
    getStringHash: getStringHash,
    getColorIdForGeneralPurposeString: getColorIdForGeneralPurposeString
  };
});


'use strict';

/**
 * @fileoverview Provides color scheme related functions.
 */
tr.exportTo('tr.ui.b', function() {
  var paletteRaw = tr.ui.b.getRawColorPalette();
  var palette = tr.ui.b.getColorPalette();

  var SelectionState = tr.model.SelectionState;

  /**
   * Provides methods to get view values for events.
   */
  var EventPresenter = {
    getSelectableItemColor: function(item) {
      var colorId = item.colorId + this.getColorIdOffset_(item);
      return palette[colorId];
    },

    getColorIdOffset_: function(event) {
      if (event.selectionState === SelectionState.SELECTED)
        return tr.ui.b.paletteProperties.highlightIdBoost;
      else if (event.selectionState === SelectionState.DIMMED)
        return tr.ui.b.paletteProperties.desaturateIdBoost;
      return 0;
    },

    getTextColor: function(event) {
      if (event.selectionState === SelectionState.DIMMED)
        return 'rgb(60,60,60)';
      return 'rgb(0,0,0)';
    },

    getSliceColorId: function(slice) {
      return slice.colorId + this.getColorIdOffset_(slice);
    },

    getSliceAlpha: function(slice, async) {
      var alpha = 1;
      if (async)
        alpha *= 0.3;
      return alpha;
    },

    getInstantSliceColor: function(instant) {
      var colorId = instant.colorId + this.getColorIdOffset_(instant);
      return tr.ui.b.colorToRGBAString(paletteRaw[colorId], 1.0);
    },

    getObjectInstanceColor: function(instance) {
      var colorId = instance.colorId + this.getColorIdOffset_(instance);
      return tr.ui.b.colorToRGBAString(paletteRaw[colorId], 0.25);
    },

    getObjectSnapshotColor: function(snapshot) {
      var colorId =
          snapshot.objectInstance.colorId + this.getColorIdOffset_(snapshot);
      return palette[colorId];
    },

    getCounterSeriesColor: function(colorId, selectionState,
                                    opt_alphaMultiplier) {
      var event = {selectionState: selectionState};
      return tr.ui.b.colorToRGBAString(
          paletteRaw[colorId + this.getColorIdOffset_(event)],
              (opt_alphaMultiplier !== undefined ? opt_alphaMultiplier : 1.0));
    },

    getBarSnapshotColor: function(snapshot, offset) {
      var colorId =
          (snapshot.objectInstance.colorId + offset) %
          tr.ui.b.paletteProperties.numGeneralPurposeColorIds;
      colorId += this.getColorIdOffset_(snapshot);
      return tr.ui.b.colorToRGBAString(paletteRaw[colorId], 1.0);
    }
  };

  return {
    EventPresenter: EventPresenter
  };
});


'use strict';

/**
 * @fileoverview Provides a caching layer for elided text values.
 */
tr.exportTo('tr.ui.b', function() {
  /**
   * Cache for elided strings.
   * Moved from the ElidedTitleCache protoype to a "global" for speed
   * (variable reference is 100x faster).
   *   key: String we wish to elide.
   *   value: Another dict whose key is width
   *     and value is an ElidedStringWidthPair.
   */
  var elidedTitleCacheDict = {};
  var elidedTitleCache = new ElidedTitleCache();

  /**
   * A cache for elided strings.
   * @constructor
   */
  function ElidedTitleCache() {
    // TODO(jrg): possibly obsoleted with the elided string cache.
    // Consider removing.
    this.textWidthMap = {};
  }

  ElidedTitleCache.prototype = {
    /**
     * Return elided text.
     *
     * @param {ctx} Context The graphics context.
     * @param {pixWidth} Pixel width.
     * @param {title} Original title text.
     * @param {width} Drawn width in world coords.
     * @param {sliceDuration} Where the title must fit (in world coords).
     * @return {ElidedStringWidthPair} Elided string and width.
     */
    get: function(ctx, pixWidth, title, width, sliceDuration) {
      var elidedDict = elidedTitleCacheDict[title];
      if (!elidedDict) {
        elidedDict = {};
        elidedTitleCacheDict[title] = elidedDict;
      }

      var elidedDictForPixWidth = elidedDict[pixWidth];
      if (!elidedDictForPixWidth) {
        elidedDict[pixWidth] = {};
        elidedDictForPixWidth = elidedDict[pixWidth];
      }

      var stringWidthPair = elidedDictForPixWidth[sliceDuration];
      if (stringWidthPair === undefined) {
        var newtitle = title;
        var elided = false;
        while (this.labelWidthWorld(ctx, newtitle, pixWidth) > sliceDuration) {
          if (newtitle.length * 0.75 < 1)
            break;
          newtitle = newtitle.substring(0, newtitle.length * 0.75);
          elided = true;
        }

        if (elided && newtitle.length > 3)
          newtitle = newtitle.substring(0, newtitle.length - 3) + '...';

        stringWidthPair = new ElidedStringWidthPair(
            newtitle, this.labelWidth(ctx, newtitle));
        elidedDictForPixWidth[sliceDuration] = stringWidthPair;
      }
      return stringWidthPair;
    },

    quickMeasureText_: function(ctx, text) {
      var w = this.textWidthMap[text];
      if (!w) {
        w = ctx.measureText(text).width;
        this.textWidthMap[text] = w;
      }
      return w;
    },

    labelWidth: function(ctx, title) {
      return this.quickMeasureText_(ctx, title) + 2;
    },

    labelWidthWorld: function(ctx, title, pixWidth) {
      return this.labelWidth(ctx, title) * pixWidth;
    }
  };

  /**
   * A pair representing an elided string and world-coordinate width
   * to draw it.
   * @constructor
   */
  function ElidedStringWidthPair(string, width) {
    this.string = string;
    this.width = width;
  }

  return {
    ElidedTitleCache: ElidedTitleCache
  };
});


'use strict';

/**
 * @fileoverview Provides various helper methods for drawing to a provided
 * canvas.
 */
tr.exportTo('tr.ui.b', function() {
  var elidedTitleCache = new tr.ui.b.ElidedTitleCache();
  var palette = tr.ui.b.getColorPalette();
  var EventPresenter = tr.ui.b.EventPresenter;
  var blackColorId = tr.ui.b.getColorIdForReservedName('black');

  /**
   * This value is used to allow for consistent style UI elements.
   * Thread time visualisation uses a smaller rectangle that has this height.
   * @const
   */
  var THIN_SLICE_HEIGHT = 4;

  /**
   * This value is used to for performance considerations when drawing large
   * zoomed out traces that feature cpu time in the slices. If the waiting
   * width is less than the threshold, we only draw the rectangle as a solid.
   * @const
   */
  var SLICE_WAITING_WIDTH_DRAW_THRESHOLD = 3;

  /**
   * If the slice has mostly been waiting to be scheduled on the cpu, the
   * wall clock will be far greater than the cpu clock. Draw the slice
   * only as an idle slice, if the active width is not thicker than the
   * threshold.
   * @const
   */
  var SLICE_ACTIVE_WIDTH_DRAW_THRESHOLD = 1;

  /**
   * Should we elide text on trace labels?
   * Without eliding, text that is too wide isn't drawn at all.
   * Disable if you feel this causes a performance problem.
   * This is a default value that can be overridden in tracks for testing.
   * @const
   */
  var SHOULD_ELIDE_TEXT = true;

  /**
   * Draw the define line into |ctx|.
   *
   * @param {Context} ctx The context to draw into.
   * @param {float} x1 The start x position of the line.
   * @param {float} y1 The start y position of the line.
   * @param {float} x2 The end x position of the line.
   * @param {float} y2 The end y position of the line.
   */
  function drawLine(ctx, x1, y1, x2, y2) {
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
  }

  /**
   * Draw the defined triangle into |ctx|.
   *
   * @param {Context} ctx The context to draw into.
   * @param {float} x1 The first corner x.
   * @param {float} y1 The first corner y.
   * @param {float} x2 The second corner x.
   * @param {float} y2 The second corner y.
   * @param {float} x3 The third corner x.
   * @param {float} y3 The third corner y.
   */
  function drawTriangle(ctx, x1, y1, x2, y2, x3, y3) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
  }

  /**
   * Draw an arrow into |ctx|.
   *
   * @param {Context} ctx The context to draw into.
   * @param {float} x1 The shaft x.
   * @param {float} y1 The shaft y.
   * @param {float} x2 The head x.
   * @param {float} y2 The head y.
   * @param {float} arrowLength The length of the head.
   * @param {float} arrowWidth The width of the head.
   */
  function drawArrow(ctx, x1, y1, x2, y2, arrowLength, arrowWidth) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    var len = Math.sqrt(dx * dx + dy * dy);
    var perc = (len - arrowLength) / len;
    var bx = x1 + perc * dx;
    var by = y1 + perc * dy;
    var ux = dx / len;
    var uy = dy / len;
    var ax = uy * arrowWidth;
    var ay = -ux * arrowWidth;

    ctx.beginPath();
    drawLine(ctx, x1, y1, x2, y2);
    ctx.stroke();

    drawTriangle(ctx,
        bx + ax, by + ay,
        x2, y2,
        bx - ax, by - ay);
    ctx.fill();
  }

  /**
   * Draw the provided slices to the screen.
   *
   * Each of the elements in |slices| must provide the follow methods:
   *   * start
   *   * duration
   *   * colorId
   *   * selected
   *
   * @param {Context} ctx The canvas context.
   * @param {TimelineDrawTransform} dt The draw transform.
   * @param {float} viewLWorld The left most point of the world viewport.
   * @param {float} viewRWorld The right most point of the world viewport.
   * @param {float} viewHeight The height of the viewport.
   * @param {Array} slices The slices to draw.
   * @param {bool} async Whether the slices are drawn with async style.
   */
  function drawSlices(ctx, dt, viewLWorld, viewRWorld, viewHeight, slices,
                      async) {
    var pixelRatio = window.devicePixelRatio || 1;
    var pixWidth = dt.xViewVectorToWorld(1);
    var height = viewHeight * pixelRatio;

    var darkRectHeight = THIN_SLICE_HEIGHT * pixelRatio;

    // Not enough space for both colors, use light color only.
    if (height < darkRectHeight)
      darkRectHeight = 0;

    var lightRectHeight = height - darkRectHeight;

    // Begin rendering in world space.
    ctx.save();
    dt.applyTransformToCanvas(ctx);

    var rect = new tr.ui.b.FastRectRenderer(
        ctx, 2 * pixWidth, 2 * pixWidth, palette);
    rect.setYandH(0, height);

    var lowSlice = tr.b.findLowIndexInSortedArray(
        slices,
        function(slice) { return slice.start + slice.duration; },
        viewLWorld);

    var hadTopLevel = false;

    for (var i = lowSlice; i < slices.length; ++i) {
      var slice = slices[i];
      var x = slice.start;
      if (x > viewRWorld)
        break;

      var w = pixWidth;
      if (slice.duration > 0) {
        w = Math.max(slice.duration, 0.000001);
        if (w < pixWidth)
          w = pixWidth;
      }

      var colorId = EventPresenter.getSliceColorId(slice);
      var alpha = EventPresenter.getSliceAlpha(slice, async);
      var lightAlpha = alpha * 0.70;

      if (async && slice.isTopLevel) {
        rect.setYandH(3, height - 3);
        hadTopLevel = true;
      } else {
        rect.setYandH(0, height);
      }

      // If cpuDuration is available, draw rectangles proportional to the
      // amount of cpu time taken.
      if (!slice.cpuDuration) {
        // No cpuDuration available, draw using only one alpha.
        rect.fillRect(x, w, colorId, alpha);
        continue;
      }

      var activeWidth = w * (slice.cpuDuration / slice.duration);
      var waitingWidth = w - activeWidth;

      // Check if we have enough screen space to draw the whole slice, with
      // both color tones.
      //
      // Truncate the activeWidth to 0 if it is less than 'threshold' pixels.
      if (activeWidth < SLICE_ACTIVE_WIDTH_DRAW_THRESHOLD * pixWidth) {
        activeWidth = 0;
        waitingWidth = w;
      }

      // Truncate the waitingWidth to 0 if it is less than 'threshold' pixels.
      if (waitingWidth < SLICE_WAITING_WIDTH_DRAW_THRESHOLD * pixWidth) {
        activeWidth = w;
        waitingWidth = 0;
      }

      // We now draw the two rectangles making up the event slice.
      // NOTE: The if statements are necessary for performance considerations.
      // We do not want to force draws, if the width of the rectangle is 0.
      //
      // First draw the solid color, representing the 'active' part.
      if (activeWidth > 0) {
        rect.fillRect(x, activeWidth, colorId, alpha);
      }

      // Next draw the two toned 'idle' part.
      // NOTE: Substracting pixWidth and drawing one extra pixel is done to
      // prevent drawing artifacts. Without it, the two parts of the slice,
      // ('active' and 'idle') may appear split apart.
      if (waitingWidth > 0) {
        // First draw the light toned top part.
        rect.setYandH(0, lightRectHeight);
        rect.fillRect(x + activeWidth - pixWidth,
            waitingWidth + pixWidth, colorId, lightAlpha);
        // Then the solid bottom half.
        rect.setYandH(lightRectHeight, darkRectHeight);
        rect.fillRect(x + activeWidth - pixWidth,
            waitingWidth + pixWidth, colorId, alpha);
        // Reset for the next slice.
        rect.setYandH(0, height);
      }
    }
    rect.flush();

    if (async && hadTopLevel) {
      // Draw a top border over async slices in order to visually separate
      // them from events above it.
      // See https://github.com/google/trace-viewer/issues/725.
      rect.setYandH(2, 1);
      for (var i = lowSlice; i < slices.length; ++i) {
        var slice = slices[i];
        var x = slice.start;
        if (x > viewRWorld)
          break;

        if (!slice.isTopLevel)
          continue;

        var w = pixWidth;
        if (slice.duration > 0) {
          w = Math.max(slice.duration, 0.000001);
          if (w < pixWidth)
            w = pixWidth;
        }

        rect.fillRect(x, w, blackColorId, 0.7);
      }
      rect.flush();
    }

    ctx.restore();
  }

  /**
   * Draw the provided instant slices as lines to the screen.
   *
   * Each of the elements in |slices| must provide the follow methods:
   *   * start
   *   * duration with value of 0.
   *   * colorId
   *   * selected
   *
   * @param {Context} ctx The canvas context.
   * @param {TimelineDrawTransform} dt The draw transform.
   * @param {float} viewLWorld The left most point of the world viewport.
   * @param {float} viewRWorld The right most point of the world viewport.
   * @param {float} viewHeight The height of the viewport.
   * @param {Array} slices The slices to draw.
   * @param {Numer} lineWidthInPixels The width of the lines.
   */
  function drawInstantSlicesAsLines(
      ctx, dt, viewLWorld, viewRWorld, viewHeight, slices, lineWidthInPixels) {
    var pixelRatio = window.devicePixelRatio || 1;
    var height = viewHeight * pixelRatio;

    var pixWidth = dt.xViewVectorToWorld(1);

    // Begin rendering in world space.
    ctx.save();
    ctx.lineWidth = pixWidth * lineWidthInPixels * pixelRatio;
    dt.applyTransformToCanvas(ctx);
    ctx.beginPath();

    var lowSlice = tr.b.findLowIndexInSortedArray(
        slices,
        function(slice) { return slice.start; },
        viewLWorld);

    for (var i = lowSlice; i < slices.length; ++i) {
      var slice = slices[i];
      var x = slice.start;
      if (x > viewRWorld)
        break;

      ctx.strokeStyle = EventPresenter.getInstantSliceColor(slice);

      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
    ctx.restore();
  }

  /**
   * Draws the labels for the given slices.
   *
   * The |slices| array must contain objects with the following API:
   *   * start
   *   * duration
   *   * title
   *   * didNotFinish (optional)
   *
   * @param {Context} ctx The graphics context.
   * @param {TimelineDrawTransform} dt The draw transform.
   * @param {float} viewLWorld The left most point of the world viewport.
   * @param {float} viewRWorld The right most point of the world viewport.
   * @param {Array} slices The slices to label.
   * @param {bool} async Whether the slice labels are drawn with async style.
   * @param {float} fontSize The font size.
   * @param {float} yOffset The font offset.
   */
  function drawLabels(ctx, dt, viewLWorld, viewRWorld, slices, async,
                      fontSize, yOffset) {
    var pixelRatio = window.devicePixelRatio || 1;
    var pixWidth = dt.xViewVectorToWorld(1);

    ctx.save();

    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = (fontSize * pixelRatio) + 'px sans-serif';

    if (async)
      ctx.font = 'italic ' + ctx.font;

    var cY = yOffset * pixelRatio;

    var lowSlice = tr.b.findLowIndexInSortedArray(
        slices,
        function(slice) { return slice.start + slice.duration; },
        viewLWorld);

    // Don't render text until until it is 20px wide
    var quickDiscardThresshold = pixWidth * 20;
    for (var i = lowSlice; i < slices.length; ++i) {
      var slice = slices[i];
      if (slice.start > viewRWorld)
        break;

      if (slice.duration <= quickDiscardThresshold)
        continue;

      var title = slice.title +
          (slice.didNotFinish ? ' (Did Not Finish)' : '');

      var drawnTitle = title;
      var drawnWidth = elidedTitleCache.labelWidth(ctx, drawnTitle);
      var fullLabelWidth = elidedTitleCache.labelWidthWorld(
          ctx, drawnTitle, pixWidth);
      if (SHOULD_ELIDE_TEXT && fullLabelWidth > slice.duration) {
        var elidedValues = elidedTitleCache.get(
            ctx, pixWidth,
            drawnTitle, drawnWidth,
            slice.duration);
        drawnTitle = elidedValues.string;
        drawnWidth = elidedValues.width;
      }

      if (drawnWidth * pixWidth < slice.duration) {
        ctx.fillStyle = EventPresenter.getTextColor(slice);
        var cX = dt.xWorldToView(slice.start + 0.5 * slice.duration);
        ctx.fillText(drawnTitle, cX, cY, drawnWidth);
      }
    }
    ctx.restore();
  }

  return {
    drawSlices: drawSlices,
    drawInstantSlicesAsLines: drawInstantSlicesAsLines,
    drawLabels: drawLabels,

    drawLine: drawLine,
    drawTriangle: drawTriangle,
    drawArrow: drawArrow,

    elidedTitleCache_: elidedTitleCache,

    THIN_SLICE_HEIGHT: THIN_SLICE_HEIGHT
  };
});


'use strict';

tr.exportTo('tr.ui', function() {
  /**
   * @constructor
   */
  function SnapIndicator(y, height) {
    this.y = y;
    this.height = height;
  }

  /**
   * The interesting part of the world.
   *
   * @constructor
   */
  function TimelineInterestRange(vp) {
    this.viewport_ = vp;

    this.range_ = new tr.b.Range();

    this.leftSelected_ = false;
    this.rightSelected_ = false;

    this.leftSnapIndicator_ = undefined;
    this.rightSnapIndicator_ = undefined;
  }

  TimelineInterestRange.prototype = {
    get isEmpty() {
      return this.range_.isEmpty;
    },

    reset: function() {
      this.range_.reset();
      this.leftSelected_ = false;
      this.rightSelected_ = false;
      this.leftSnapIndicator_ = undefined;
      this.rightSnapIndicator_ = undefined;
      this.viewport_.dispatchChangeEvent();
    },

    get min() {
      return this.range_.min;
    },

    set min(min) {
      this.range_.min = min;
      this.viewport_.dispatchChangeEvent();
    },

    get max() {
      return this.range_.max;
    },

    set max(max) {
      this.range_.max = max;
      this.viewport_.dispatchChangeEvent();
    },

    set: function(range) {
      this.range_.reset();
      this.range_.addRange(range);
      this.viewport_.dispatchChangeEvent();
    },

    setMinAndMax: function(min, max) {
      this.range_.min = min;
      this.range_.max = max;
      this.viewport_.dispatchChangeEvent();
    },

    get range() {
      return this.range_.range;
    },

    asRangeObject: function() {
      var range = new tr.b.Range();
      range.addRange(this.range_);
      return range;
    },

    get leftSelected() {
      return this.leftSelected_;
    },

    set leftSelected(leftSelected) {
      if (this.leftSelected_ == leftSelected)
        return;
      this.leftSelected_ = leftSelected;
      this.viewport_.dispatchChangeEvent();
    },

    get rightSelected() {
      return this.rightSelected_;
    },

    set rightSelected(rightSelected) {
      if (this.rightSelected_ == rightSelected)
        return;
      this.rightSelected_ = rightSelected;
      this.viewport_.dispatchChangeEvent();
    },

    get leftSnapIndicator() {
      return this.leftSnapIndicator_;
    },

    set leftSnapIndicator(leftSnapIndicator) {
      this.leftSnapIndicator_ = leftSnapIndicator;
      this.viewport_.dispatchChangeEvent();
    },

    get rightSnapIndicator() {
      return this.rightSnapIndicator_;
    },

    set rightSnapIndicator(rightSnapIndicator) {
      this.rightSnapIndicator_ = rightSnapIndicator;
      this.viewport_.dispatchChangeEvent();
    },

    draw: function(ctx, viewLWorld, viewRWorld) {
      if (this.range_.isEmpty)
        return;
      var dt = this.viewport_.currentDisplayTransform;

      var markerLWorld = this.min;
      var markerRWorld = this.max;

      var markerLView = Math.round(dt.xWorldToView(markerLWorld));
      var markerRView = Math.round(dt.xWorldToView(markerRWorld));

      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      if (markerLWorld > viewLWorld) {
        ctx.fillRect(dt.xWorldToView(viewLWorld), 0,
            markerLView, ctx.canvas.height);
      }

      if (markerRWorld < viewRWorld) {
        ctx.fillRect(markerRView, 0,
            dt.xWorldToView(viewRWorld), ctx.canvas.height);
      }

      var pixelRatio = window.devicePixelRatio || 1;
      ctx.lineWidth = Math.round(pixelRatio);
      if (this.range_.range > 0) {
        this.drawLine_(ctx, viewLWorld, viewRWorld,
                       ctx.canvas.height, this.min, this.leftSelected_);
        this.drawLine_(ctx, viewLWorld, viewRWorld,
                       ctx.canvas.height, this.max, this.rightSelected_);
      } else {
        this.drawLine_(ctx, viewLWorld, viewRWorld,
                       ctx.canvas.height, this.min,
                       this.leftSelected_ || this.rightSelected_);
      }
      ctx.lineWidth = 1;
    },

    drawLine_: function(ctx, viewLWorld, viewRWorld, height, ts, selected) {
      if (ts < viewLWorld || ts >= viewRWorld)
        return;

      var dt = this.viewport_.currentDisplayTransform;
      var viewX = Math.round(dt.xWorldToView(ts));

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      ctx.save();
      ctx.translate((Math.round(ctx.lineWidth) % 2) / 2, 0);

      ctx.beginPath();
      tr.ui.b.drawLine(ctx, viewX, 0, viewX, height);
      if (selected)
        ctx.strokeStyle = 'rgb(255, 0, 0)';
      else
        ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.stroke();

      ctx.restore();
    },

    drawIndicators: function(ctx, viewLWorld, viewRWorld) {
      if (this.leftSnapIndicator_) {
        this.drawIndicator_(ctx, viewLWorld, viewRWorld,
                            this.range_.min,
                            this.leftSnapIndicator_,
                            this.leftSelected_);
      }
      if (this.rightSnapIndicator_) {
        this.drawIndicator_(ctx, viewLWorld, viewRWorld,
                            this.range_.max,
                            this.rightSnapIndicator_,
                            this.rightSelected_);
      }
    },

    drawIndicator_: function(ctx, viewLWorld, viewRWorld,
                             xWorld, si, selected) {
      var dt = this.viewport_.currentDisplayTransform;

      var viewX = Math.round(dt.xWorldToView(xWorld));

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      ctx.save();
      ctx.translate((Math.round(ctx.lineWidth) % 2) / 2, 0);

      var pixelRatio = window.devicePixelRatio || 1;
      var viewY = si.y * devicePixelRatio;
      var viewHeight = si.height * devicePixelRatio;
      var arrowSize = 4 * pixelRatio;

      if (selected)
        ctx.fillStyle = 'rgb(255, 0, 0)';
      else
        ctx.fillStyle = 'rgb(0, 0, 0)';
      tr.ui.b.drawTriangle(ctx,
          viewX - arrowSize * 0.75, viewY,
          viewX + arrowSize * 0.75, viewY,
          viewX, viewY + arrowSize);
      ctx.fill();
      tr.ui.b.drawTriangle(ctx,
          viewX - arrowSize * 0.75, viewY + viewHeight,
          viewX + arrowSize * 0.75, viewY + viewHeight,
          viewX, viewY + viewHeight - arrowSize);
      ctx.fill();

      ctx.restore();
    }
  };

  return {
    SnapIndicator: SnapIndicator,
    TimelineInterestRange: TimelineInterestRange
  };
});


'use strict';

tr.exportTo('tr.ui', function() {
  function TimelineDisplayTransform(opt_that) {
    if (opt_that) {
      this.set(opt_that);
      return;
    }
    this.scaleX = 1;
    this.panX = 0;
    this.panY = 0;
  }

  TimelineDisplayTransform.prototype = {
    set: function(that) {
      this.scaleX = that.scaleX;
      this.panX = that.panX;
      this.panY = that.panY;
    },

    clone: function() {
      return new TimelineDisplayTransform(this);
    },

    equals: function(that) {
      var eq = true;
      if (that === undefined || that === null)
        return false;
      eq &= this.panX === that.panX;
      eq &= this.panY === that.panY;
      eq &= this.scaleX === that.scaleX;
      return !!eq;
    },

    almostEquals: function(that) {
      var eq = true;
      if (that === undefined || that === null)
        return false;
      eq &= Math.abs(this.panX - that.panX) < 0.001;
      eq &= Math.abs(this.panY - that.panY) < 0.001;
      eq &= Math.abs(this.scaleX - that.scaleX) < 0.001;
      return !!eq;
    },

    incrementPanXInViewUnits: function(xDeltaView) {
      this.panX += this.xViewVectorToWorld(xDeltaView);
    },

    xPanWorldPosToViewPos: function(worldX, viewX, viewWidth) {
      if (typeof viewX == 'string') {
        if (viewX === 'left') {
          viewX = 0;
        } else if (viewX === 'center') {
          viewX = viewWidth / 2;
        } else if (viewX === 'right') {
          viewX = viewWidth - 1;
        } else {
          throw new Error('viewX must be left|center|right or number.');
        }
      }
      this.panX = (viewX / this.scaleX) - worldX;
    },

    xPanWorldBoundsIntoView: function(worldMin, worldMax, viewWidth) {
      if (this.xWorldToView(worldMin) < 0)
        this.xPanWorldPosToViewPos(worldMin, 'left', viewWidth);
      else if (this.xWorldToView(worldMax) > viewWidth)
        this.xPanWorldPosToViewPos(worldMax, 'right', viewWidth);
    },

    xSetWorldBounds: function(worldMin, worldMax, viewWidth) {
      var worldWidth = worldMax - worldMin;
      var scaleX = viewWidth / worldWidth;
      var panX = -worldMin;
      this.setPanAndScale(panX, scaleX);
    },

    setPanAndScale: function(p, s) {
      this.scaleX = s;
      this.panX = p;
    },

    xWorldToView: function(x) {
      return (x + this.panX) * this.scaleX;
    },

    xWorldVectorToView: function(x) {
      return x * this.scaleX;
    },

    xViewToWorld: function(x) {
      return (x / this.scaleX) - this.panX;
    },

    xViewVectorToWorld: function(x) {
      return x / this.scaleX;
    },

    applyTransformToCanvas: function(ctx) {
      ctx.transform(this.scaleX, 0, 0, 1, this.panX * this.scaleX, 0);
    }
  };

  return {
    TimelineDisplayTransform: TimelineDisplayTransform
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * ContainerToTrackMap is a class to handle building and accessing a map
   * between an EventContainer's stableId and its handling track.
   *
   * @constructor
   */
  function ContainerToTrackMap() {
    this.stableIdToTrackMap_ = {};
  }

  ContainerToTrackMap.prototype = {
    addContainer: function(container, track) {
      if (!track)
        throw new Error('Must provide a track.');
      this.stableIdToTrackMap_[container.stableId] = track;
    },

    clear: function() {
      this.stableIdToTrackMap_ = {};
    },

    getTrackByStableId: function(stableId) {
      return this.stableIdToTrackMap_[stableId];
    }
  };

  return {
    ContainerToTrackMap: ContainerToTrackMap
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * EventToTrackMap provides a mapping mechanism between events and the
   * tracks those events belong on.
   * @constructor
   */
  function EventToTrackMap() {}

  EventToTrackMap.prototype = {
    addEvent: function(event, track) {
      if (!track)
        throw new Error('Must provide a track.');
      this[event.guid] = track;
    }
  };

  return {
    EventToTrackMap: EventToTrackMap
  };
});


'use strict';

/**
 * @fileoverview Code for the viewport.
 */
tr.exportTo('tr.ui', function() {
  var TimelineDisplayTransform = tr.ui.TimelineDisplayTransform;
  var TimelineInterestRange = tr.ui.TimelineInterestRange;

  /**
   * The TimelineViewport manages the transform used for navigating
   * within the timeline. It is a simple transform:
   *   x' = (x+pan) * scale
   *
   * The timeline code tries to avoid directly accessing this transform,
   * instead using this class to do conversion between world and viewspace,
   * as well as the math for centering the viewport in various interesting
   * ways.
   *
   * @constructor
   * @extends {tr.b.EventTarget}
   */
  function TimelineViewport(parentEl) {
    this.parentEl_ = parentEl;
    this.modelTrackContainer_ = undefined;
    this.currentDisplayTransform_ = new TimelineDisplayTransform();
    this.initAnimationController_();

    // Flow events
    this.showFlowEvents_ = false;

    // Highlights.
    this.highlightVSync_ = false;

    // High details.
    this.highDetails_ = false;

    // Grid system.
    this.gridTimebase_ = 0;
    this.gridStep_ = 1000 / 60;
    this.gridEnabled_ = false;

    // Init logic.
    this.hasCalledSetupFunction_ = false;

    this.onResize_ = this.onResize_.bind(this);
    this.onModelTrackControllerScroll_ =
        this.onModelTrackControllerScroll_.bind(this);

    // The following code uses an interval to detect when the parent element
    // is attached to the document. That is a trigger to run the setup function
    // and install a resize listener.
    this.checkForAttachInterval_ = setInterval(
        this.checkForAttach_.bind(this), 250);

    this.majorMarkPositions = [];
    this.interestRange_ = new TimelineInterestRange(this);

    this.eventToTrackMap_ = new tr.ui.tracks.EventToTrackMap();
    this.containerToTrackMap = new tr.ui.tracks.ContainerToTrackMap();
  }

  TimelineViewport.prototype = {
    __proto__: tr.b.EventTarget.prototype,

    /**
     * Allows initialization of the viewport when the viewport's parent element
     * has been attached to the document and given a size.
     * @param {Function} fn Function to call when the viewport can be safely
     * initialized.
     */
    setWhenPossible: function(fn) {
      this.pendingSetFunction_ = fn;
    },

    /**
     * @return {boolean} Whether the current timeline is attached to the
     * document.
     */
    get isAttachedToDocumentOrInTestMode() {
      // Allow not providing a parent element, used by tests.
      if (this.parentEl_ === undefined)
        return;
      return tr.ui.b.isElementAttachedToDocument(this.parentEl_);
    },

    onResize_: function() {
      this.dispatchChangeEvent();
    },

    /**
     * Checks whether the parentNode is attached to the document.
     * When it is, it installs the iframe-based resize detection hook
     * and then runs the pendingSetFunction_, if present.
     */
    checkForAttach_: function() {
      if (!this.isAttachedToDocumentOrInTestMode || this.clientWidth == 0)
        return;

      if (!this.iframe_) {
        this.iframe_ = document.createElement('iframe');
        this.iframe_.style.cssText =
            'position:absolute;width:100%;height:0;border:0;visibility:hidden;';
        this.parentEl_.appendChild(this.iframe_);

        this.iframe_.contentWindow.addEventListener('resize', this.onResize_);
      }

      var curSize = this.parentEl_.clientWidth + 'x' +
          this.parentEl_.clientHeight;
      if (this.pendingSetFunction_) {
        this.lastSize_ = curSize;
        try {
          this.pendingSetFunction_();
        } catch (ex) {
          console.log('While running setWhenPossible:',
              ex.message ? ex.message + '\n' + ex.stack : ex.stack);
        }
        this.pendingSetFunction_ = undefined;
      }

      window.clearInterval(this.checkForAttachInterval_);
      this.checkForAttachInterval_ = undefined;
    },

    /**
     * Fires the change event on this viewport. Used to notify listeners
     * to redraw when the underlying model has been mutated.
     */
    dispatchChangeEvent: function() {
      tr.b.dispatchSimpleEvent(this, 'change');
    },

    detach: function() {
      if (this.checkForAttachInterval_) {
        window.clearInterval(this.checkForAttachInterval_);
        this.checkForAttachInterval_ = undefined;
      }
      if (this.iframe_) {
        this.iframe_.removeEventListener('resize', this.onResize_);
        this.parentEl_.removeChild(this.iframe_);
      }
    },

    initAnimationController_: function() {
      this.dtAnimationController_ = new tr.ui.b.AnimationController();
      this.dtAnimationController_.addEventListener(
          'didtick', function(e) {
            this.onCurentDisplayTransformChange_(e.oldTargetState);
          }.bind(this));

      var that = this;
      this.dtAnimationController_.target = {
        get panX() {
          return that.currentDisplayTransform_.panX;
        },

        set panX(panX) {
          that.currentDisplayTransform_.panX = panX;
        },

        get panY() {
          return that.currentDisplayTransform_.panY;
        },

        set panY(panY) {
          that.currentDisplayTransform_.panY = panY;
        },

        get scaleX() {
          return that.currentDisplayTransform_.scaleX;
        },

        set scaleX(scaleX) {
          that.currentDisplayTransform_.scaleX = scaleX;
        },

        cloneAnimationState: function() {
          return that.currentDisplayTransform_.clone();
        },

        xPanWorldPosToViewPos: function(xWorld, xView) {
          that.currentDisplayTransform_.xPanWorldPosToViewPos(
              xWorld, xView, that.modelTrackContainer_.canvas.clientWidth);
        }
      };
    },

    get currentDisplayTransform() {
      return this.currentDisplayTransform_;
    },

    setDisplayTransformImmediately: function(displayTransform) {
      this.dtAnimationController_.cancelActiveAnimation();

      var oldDisplayTransform =
          this.dtAnimationController_.target.cloneAnimationState();
      this.currentDisplayTransform_.set(displayTransform);
      this.onCurentDisplayTransformChange_(oldDisplayTransform);
    },

    queueDisplayTransformAnimation: function(animation) {
      if (!(animation instanceof tr.ui.b.Animation))
        throw new Error('animation must be instanceof tr.ui.b.Animation');
      this.dtAnimationController_.queueAnimation(animation);
    },

    onCurentDisplayTransformChange_: function(oldDisplayTransform) {
      // Ensure panY stays clamped in the track container's scroll range.
      if (this.modelTrackContainer_) {
        this.currentDisplayTransform.panY = tr.b.clamp(
            this.currentDisplayTransform.panY,
            0,
            this.modelTrackContainer_.scrollHeight -
                this.modelTrackContainer_.clientHeight);
      }

      var changed = !this.currentDisplayTransform.equals(oldDisplayTransform);
      var yChanged = this.currentDisplayTransform.panY !==
          oldDisplayTransform.panY;
      if (yChanged)
        this.modelTrackContainer_.scrollTop = this.currentDisplayTransform.panY;
      if (changed)
        this.dispatchChangeEvent();
    },

    onModelTrackControllerScroll_: function(e) {
      if (this.dtAnimationController_.activeAnimation &&
          this.dtAnimationController_.activeAnimation.affectsPanY)
        this.dtAnimationController_.cancelActiveAnimation();
      var panY = this.modelTrackContainer_.scrollTop;
      this.currentDisplayTransform_.panY = panY;
    },

    get modelTrackContainer() {
      return this.modelTrackContainer_;
    },

    set modelTrackContainer(m) {
      if (this.modelTrackContainer_)
        this.modelTrackContainer_.removeEventListener('scroll',
            this.onModelTrackControllerScroll_);

      this.modelTrackContainer_ = m;
      this.modelTrackContainer_.addEventListener('scroll',
          this.onModelTrackControllerScroll_);
    },

    get showFlowEvents() {
      return this.showFlowEvents_;
    },

    set showFlowEvents(showFlowEvents) {
      this.showFlowEvents_ = showFlowEvents;
      this.dispatchChangeEvent();
    },

    get highlightVSync() {
      return this.highlightVSync_;
    },

    set highlightVSync(highlightVSync) {
      this.highlightVSync_ = highlightVSync;
      this.dispatchChangeEvent();
    },

    get highDetails() {
      return this.highDetails_;
    },

    set highDetails(highDetails) {
      this.highDetails_ = highDetails;
      this.dispatchChangeEvent();
    },

    get gridEnabled() {
      return this.gridEnabled_;
    },

    set gridEnabled(enabled) {
      if (this.gridEnabled_ == enabled)
        return;

      this.gridEnabled_ = enabled && true;
      this.dispatchChangeEvent();
    },

    get gridTimebase() {
      return this.gridTimebase_;
    },

    set gridTimebase(timebase) {
      if (this.gridTimebase_ == timebase)
        return;
      this.gridTimebase_ = timebase;
      this.dispatchChangeEvent();
    },

    get gridStep() {
      return this.gridStep_;
    },

    get interestRange() {
      return this.interestRange_;
    },

    drawMajorMarkLines: function(ctx) {
      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      ctx.save();
      ctx.translate((Math.round(ctx.lineWidth) % 2) / 2, 0);

      ctx.beginPath();
      for (var idx in this.majorMarkPositions) {
        var x = Math.floor(this.majorMarkPositions[idx]);
        tr.ui.b.drawLine(ctx, x, 0, x, ctx.canvas.height);
      }
      ctx.strokeStyle = '#ddd';
      ctx.stroke();

      ctx.restore();
    },

    drawGridLines: function(ctx, viewLWorld, viewRWorld) {
      if (!this.gridEnabled)
        return;

      var dt = this.currentDisplayTransform;
      var x = this.gridTimebase;

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      ctx.save();
      ctx.translate((Math.round(ctx.lineWidth) % 2) / 2, 0);

      ctx.beginPath();
      while (x < viewRWorld) {
        if (x >= viewLWorld) {
          // Do conversion to viewspace here rather than on
          // x to avoid precision issues.
          var vx = Math.floor(dt.xWorldToView(x));
          tr.ui.b.drawLine(ctx, vx, 0, vx, ctx.canvas.height);
        }

        x += this.gridStep;
      }
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.25)';
      ctx.stroke();

      ctx.restore();
    },

    /**
     * Helper for selection previous or next.
     * @param {boolean} offset If positive, select one forward (next).
     *   Else, select previous.
     *
     * @return {boolean} true if current selection changed.
     */
    getShiftedSelection: function(selection, offset) {
      var newSelection = new tr.model.EventSet();
      for (var i = 0; i < selection.length; i++) {
        var event = selection[i];

        // If this is a flow event, then move to its slice based on the
        // offset direction.
        if (event instanceof tr.model.FlowEvent) {
          if (offset > 0) {
            newSelection.push(event.endSlice);
          } else if (offset < 0) {
            newSelection.push(event.startSlice);
          } else {
            /* Do nothing. Zero offsets don't do anything. */
          }
          continue;
        }

        var track = this.trackForEvent(event);
        track.addEventNearToProvidedEventToSelection(
            event, offset, newSelection);
      }

      if (newSelection.length == 0)
        return undefined;
      return newSelection;
    },

    rebuildEventToTrackMap: function() {
      // TODO(charliea): Make the event to track map have a similar interface
      // to the container to track map so that we can just clear() here.
      this.eventToTrackMap_ = new tr.ui.tracks.EventToTrackMap();
      this.modelTrackContainer_.addEventsToTrackMap(this.eventToTrackMap_);
    },

    rebuildContainerToTrackMap: function() {
      this.containerToTrackMap.clear();
      this.modelTrackContainer_.addContainersToTrackMap(
          this.containerToTrackMap);
    },

    trackForEvent: function(event) {
      return this.eventToTrackMap_[event.guid];
    }
  };

  return {
    TimelineViewport: TimelineViewport
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * YComponent is a class that handles storing the stableId and the percentage
   * offset in the y direction of all tracks within a specific viewX and viewY
   * coordinate.
   * @constructor
   */
  function YComponent(stableId, yPercentOffset) {
    this.stableId = stableId;
    this.yPercentOffset = yPercentOffset;
  }

  YComponent.prototype = {
    toDict: function() {
      return {
        stableId: this.stableId,
        yPercentOffset: this.yPercentOffset
      };
    }
  };

  /**
   * Location is a class that represents a spatial location on the timeline
   * that is specified by percent offsets within tracks rather than specific
   * points.
   *
   * @constructor
   */
  function Location(xWorld, yComponents) {
    this.xWorld_ = xWorld;
    this.yComponents_ = yComponents;
  };

  /**
   * Returns a new Location given by x and y coordinates with respect to
   * the timeline's drawing canvas.
   */
  Location.fromViewCoordinates = function(viewport, viewX, viewY) {
    var dt = viewport.currentDisplayTransform;
    var xWorld = dt.xViewToWorld(viewX);
    var yComponents = [];

    // Since we're given coordinates within the timeline canvas, we need to
    // convert them to document coordinates to get the element.
    var elem = document.elementFromPoint(
          viewX + viewport.modelTrackContainer.canvas.offsetLeft,
          viewY + viewport.modelTrackContainer.canvas.offsetTop);
    // Build yComponents by calculating percentage offset with respect to
    // each parent track.
    while (elem instanceof tr.ui.tracks.Track) {
      if (elem.eventContainer) {
        var boundRect = elem.getBoundingClientRect();
        var yPercentOffset = (viewY - boundRect.top) / boundRect.height;
        yComponents.push(
            new YComponent(elem.eventContainer.stableId, yPercentOffset));
      }
      elem = elem.parentElement;
    }

    if (yComponents.length == 0)
      return;
    return new Location(xWorld, yComponents);
  }

  Location.fromStableIdAndTimestamp = function(viewport, stableId, ts) {
    var xWorld = ts;
    var yComponents = [];

    // The y components' percentage offsets will be calculated with respect to
    // the boundingRect's top of containing track.
    var containerToTrack = viewport.containerToTrackMap;
    var elem = containerToTrack.getTrackByStableId(stableId);
    if (!elem)
      return;

    var firstY = elem.getBoundingClientRect().top;
    while (elem instanceof tr.ui.tracks.Track) {
      if (elem.eventContainer) {
        var boundRect = elem.getBoundingClientRect();
        var yPercentOffset = (firstY - boundRect.top) / boundRect.height;
        yComponents.push(
            new YComponent(elem.eventContainer.stableId, yPercentOffset));
      }
      elem = elem.parentElement;
    }

    if (yComponents.length == 0)
      return;
    return new Location(xWorld, yComponents);
  }

  Location.prototype = {

    get xWorld() {
      return this.xWorld_;
    },

    /**
     * Returns the first valid containing track based on the
     * internal yComponents.
     */
    getContainingTrack: function(viewport) {
      var containerToTrack = viewport.containerToTrackMap;
      for (var i in this.yComponents_) {
        var yComponent = this.yComponents_[i];
        var track = containerToTrack.getTrackByStableId(yComponent.stableId);
        if (track !== undefined)
          return track;
      }
    },

    /**
     * Calculates and returns x and y coordinates of the current location with
     * respect to the timeline's canvas.
     */
    toViewCoordinates: function(viewport) {
      var dt = viewport.currentDisplayTransform;
      var containerToTrack = viewport.containerToTrackMap;
      var viewX = dt.xWorldToView(this.xWorld_);

      var viewY = -1;
      for (var index in this.yComponents_) {
        var yComponent = this.yComponents_[index];
        var track = containerToTrack.getTrackByStableId(yComponent.stableId);
        if (track !== undefined) {
          var boundRect = track.getBoundingClientRect();
          viewY = yComponent.yPercentOffset * boundRect.height + boundRect.top;
          break;
        }
      }

      return {
        viewX: viewX,
        viewY: viewY
      };
    },

    toDict: function() {
      return {
        xWorld: this.xWorld_,
        yComponents: this.yComponents_
      };
    }
  };

  return {
    Location: Location
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  var Location = tr.model.Location;

  /**
   * UIState is a class that represents the current state of the timeline by
   * the Location of the point of interest and the current scaleX of the
   * timeline.
   *
   * @constructor
   */
  function UIState(location, scaleX) {
    this.location_ = location;
    this.scaleX_ = scaleX;
  };

  /**
   * Accepts a UIState string in the format of (timestamp)@(stableID)x(scaleX)
   * Returns undefined if string is not in this format, or throws an Error if
   * variables in a syntactically-correct stateString does not produce a valid
   * UIState. Otherwise returns a constructed UIState instance.
   */
  UIState.fromUserFriendlyString = function(model, viewport, stateString) {
    var navByFinderPattern = /^(-?\d+(\.\d+)?)@(.+)x(\d+(\.\d+)?)$/g;
    var match = navByFinderPattern.exec(stateString);
    if (!match)
      return;

    var timestamp = parseFloat(match[1]);
    var stableId = match[3];
    var scaleX = parseFloat(match[4]);

    if (scaleX <= 0)
      throw new Error('Invalid ScaleX value in UI State string.');

    if (!viewport.containerToTrackMap.getTrackByStableId(stableId))
      throw new Error('Invalid StableID given in UI State String.');

    var loc = tr.model.Location.fromStableIdAndTimestamp(
        viewport, stableId, timestamp);
    return new UIState(loc, scaleX);
  }

  UIState.prototype = {

    get location() {
      return this.location_;
    },

    get scaleX() {
      return this.scaleX_;
    },

    toUserFriendlyString: function(viewport) {
      var timestamp = this.location_.xWorld;
      var stableId =
          this.location_.getContainingTrack(viewport).eventContainer.stableId;
      var scaleX = this.scaleX_;
      return timestamp.toFixed(5) + '@' + stableId + 'x' + scaleX.toFixed(5);
    },

    toDict: function() {
      return {
        location: this.location_.toDict(),
        scaleX: this.scaleX_
      };
    }
  };

  return {
    UIState: UIState
  };
});


'use strict';

tr.exportTo('tr.c', function() {
  var BrushingState = tr.ui.b.BrushingState;
  var EventSet = tr.model.EventSet;
  var SelectionState = tr.model.SelectionState;
  var Viewport = tr.ui.TimelineViewport;

  function BrushingStateController(timelineView) {
    tr.b.EventTarget.call(this);

    this.timelineView_ = timelineView;
    this.currentBrushingState_ = new BrushingState();

    this.onPopState_ = this.onPopState_.bind(this);
    this.historyEnabled_ = false;
    this.selections_ = {};
  }

  BrushingStateController.prototype = {
    __proto__: tr.b.EventTarget.prototype,

    dispatchChangeEvent_: function() {
      var e = new tr.b.Event('change', false, false);
      this.dispatchEvent(e);
    },

    get model() {
      if (!this.timelineView_)
        return undefined;
      return this.timelineView_.model;
    },

    get trackView() {
      if (!this.timelineView_)
        return undefined;
      return this.timelineView_.trackView;
    },

    get viewport() {
      if (!this.timelineView_)
        return undefined;
      if (!this.timelineView_.trackView)
        return undefined;
      return this.timelineView_.trackView.viewport;
    },

    /* History system */
    get historyEnabled() {
      return this.historyEnabled_;
    },

    set historyEnabled(historyEnabled) {
      this.historyEnabled_ = !!historyEnabled;
      if (historyEnabled)
        window.addEventListener('popstate', this.onPopState_);
      else
        window.removeEventListener('popstate', this.onPopState_);
    },

    modelWillChange: function() {
      if (this.currentBrushingState_.isAppliedToModel)
        this.currentBrushingState_.unapplyFromModelSelectionState();
    },

    modelDidChange: function() {
      this.selections_ = {};

      this.currentBrushingState_ = new BrushingState();
      this.currentBrushingState_.applyToModelSelectionState(this.model);

      var e = new tr.b.Event('model-changed', false, false);
      this.dispatchEvent(e);

      this.dispatchChangeEvent_();
    },

    onUserInitiatedSelectionChange_: function() {
      var selection = this.selection;
      if (this.historyEnabled) {
        // Save the selection so that when back button is pressed,
        // it could be retrieved.
        this.selections_[selection.guid] = selection;
        var state = {
          selection_guid: selection.guid
        };

        window.history.pushState(state, document.title);
      }
    },

    onPopState_: function(e) {
      if (e.state === null)
        return;

      var selection = this.selections_[e.state.selection_guid];
      if (selection) {
        var newState = this.currentBrushingState_.clone();
        newState.selection = selection;
        this.currentBrushingState = newState;
      }
      e.stopPropagation();
    },

    get selection() {
      return this.currentBrushingState_.selection;
    },
    get findMatches() {
      return this.currentBrushingState_.findMatches;
    },

    get selectionOfInterest() {
      return this.currentBrushingState_.selectionOfInterest;
    },

    get currentBrushingState() {
      return this.currentBrushingState_;
    },

    set currentBrushingState(newBrushingState) {
      if (newBrushingState.isAppliedToModel)
        throw new Error('Cannot apply this state, it is applied');

      // This function uses value-equality on the states so that state can
      // changed to a clone of itself without causing a change event, while
      // still having the actual state object change to the new clone.
      var hasValueChanged = !this.currentBrushingState_.equals(
          newBrushingState);

      if (newBrushingState !== this.currentBrushingState_ && !hasValueChanged) {
        if (this.currentBrushingState_.isAppliedToModel) {
          this.currentBrushingState_.transferModelOwnershipToClone(
              newBrushingState);
        }
        this.currentBrushingState_ = newBrushingState;
        return;
      }

      if (this.currentBrushingState_.isAppliedToModel)
        this.currentBrushingState_.unapplyFromModelSelectionState();

      this.currentBrushingState_ = newBrushingState;

      if (this.model)
        this.currentBrushingState_.applyToModelSelectionState(this.model);

      this.dispatchChangeEvent_();
    },

    /**
     * @param {Filter} filter The filter to use for finding matches.
     * @param {Selection} selection The selection to add matches to.
     * @return {Task} which performs the filtering.
     */
    addAllEventsMatchingFilterToSelectionAsTask: function(filter, selection) {
      var timelineView = this.timelineView_.trackView;
      if (!timelineView)
        return new tr.b.Task();
      return timelineView.addAllEventsMatchingFilterToSelectionAsTask(
          filter, selection);
    },

    findTextChangedTo: function(allPossibleMatches) {
      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.findMatches = allPossibleMatches;
      this.currentBrushingState = newBrushingState;
    },

    findFocusChangedTo: function(currentFocus) {
      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = currentFocus;
      this.currentBrushingState = newBrushingState;

      this.onUserInitiatedSelectionChange_();
    },

    findTextCleared: function() {
      if (this.xNavStringMarker_ !== undefined) {
        this.model.removeAnnotation(this.xNavStringMarker_);
        this.xNavStringMarker_ = undefined;
      }

      if (this.guideLineAnnotation_ !== undefined) {
        this.model.removeAnnotation(this.guideLineAnnotation_);
        this.guideLineAnnotation_ = undefined;
      }

      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = new EventSet();
      newBrushingState.findMatches = new EventSet();
      this.currentBrushingState = newBrushingState;

      this.onUserInitiatedSelectionChange_();
    },

    uiStateFromString: function(string) {
      return tr.ui.b.UIState.fromUserFriendlyString(
          this.model, this.viewport, string);
    },

    navToPosition: function(uiState, showNavLine) {
      this.trackView.navToPosition(uiState, showNavLine);
    },

    changeSelectionFromTimeline: function(selection) {
      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = selection;
      newBrushingState.findMatches = new EventSet();
      this.currentBrushingState = newBrushingState;

      this.onUserInitiatedSelectionChange_();
    },

    showScriptControlSelection: function(selection) {
      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = selection;
      newBrushingState.findMatches = new EventSet();
      this.currentBrushingState = newBrushingState;
    },

    changeSelectionFromRequestSelectionChangeEvent: function(selection) {
      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = selection;
      newBrushingState.findMatches = new EventSet();
      this.currentBrushingState = newBrushingState;

      this.onUserInitiatedSelectionChange_();
    },

    changeAnalysisViewRelatedEvents: function(eventSet) {
      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.analysisViewRelatedEvents = eventSet;
      this.currentBrushingState = newBrushingState;
    },

    changeAnalysisLinkHoveredEvents: function(eventSet) {
      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.analysisLinkHoveredEvents = eventSet;
      this.currentBrushingState = newBrushingState;
    },

    getViewSpecificBrushingState: function(viewId) {
      return this.currentBrushingState.viewSpecificBrushingStates[viewId];
    },

    changeViewSpecificBrushingState: function(viewId, newState) {
      var oldStates = this.currentBrushingState_.viewSpecificBrushingStates;
      var newStates = {};
      for (var id in oldStates)
        newStates[id] = oldStates[id];
      if (newState === undefined)
        delete newStates[viewId];
      else
        newStates[viewId] = newState;

      var newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.viewSpecificBrushingStates = newStates;
      this.currentBrushingState = newBrushingState;
    }
  };

  BrushingStateController.getControllerForElement = function(element) {
    if (tr.isHeadless)
      throw new Error('Unsupported');
    var currentElement = element;
    while (currentElement) {
      if (currentElement.brushingStateController)
        return currentElement.brushingStateController;

      // Walk up the DOM.
      if (currentElement.parentElement) {
        currentElement = currentElement.parentElement;
        continue;
      }

      // Possibly inside a shadow DOM.
      var currentNode = currentElement;
      while (currentNode.parentNode)
        currentNode = currentNode.parentNode;
      currentElement = currentNode.host;
    }
    return undefined;
  };

  return {
    BrushingStateController: BrushingStateController
  };
});


  'use strict';
  Polymer('tr-ui-a-analysis-link', {
    ready: function() {
      this.selection_ = undefined;
    },

    attached: function() {
                  this.controller_ =
          tr.c.BrushingStateController.getControllerForElement(this);
    },

    detached: function() {
            this.clearHighlight_();
      this.controller_ = undefined;
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
            this.selection_ = selection;
      this.textContent = selection.userFriendlyName;
    },

    setSelectionAndContent: function(selection, opt_textContent) {
      this.selection_ = selection;
      if (opt_textContent)
        this.textContent = opt_textContent;
    },

    getCurrentSelection_: function() {
            if (typeof this.selection_ === 'function')
        return this.selection_();
      return this.selection_;
    },

    setHighlight_: function(opt_eventSet) {
      if (this.controller_)
        this.controller_.changeAnalysisLinkHoveredEvents(opt_eventSet);
    },

    clearHighlight_: function(opt_eventSet) {
      this.setHighlight_();
    },

    onClicked_: function() {
      if (!this.selection_)
        return;

      var event = new tr.model.RequestSelectionChangeEvent();
      event.selection = this.getCurrentSelection_();
      this.dispatchEvent(event);
    },

    onMouseEnter_: function() {
      this.setHighlight_(this.getCurrentSelection_());
    },

    onMouseLeave_: function() {
      this.clearHighlight_();
    }
  });
  

'use strict';

tr.exportTo('tr.ui.b', function() {
  function instantiateTemplate(selector, doc) {
    doc = doc || document;
    var el = doc.querySelector(selector);
    if (!el)
      throw new Error('Element not found');
    return el.createInstance();
  }

  function windowRectForElement(element) {
    var position = [element.offsetLeft, element.offsetTop];
    var size = [element.offsetWidth, element.offsetHeight];
    var node = element.offsetParent;
    while (node) {
      position[0] += node.offsetLeft;
      position[1] += node.offsetTop;
      node = node.offsetParent;
    }
    return tr.b.Rect.fromXYWH(position[0], position[1], size[0], size[1]);
  }

  function scrollIntoViewIfNeeded(el) {
    var pr = el.parentElement.getBoundingClientRect();
    var cr = el.getBoundingClientRect();
    if (cr.top < pr.top) {
      el.scrollIntoView(true);
    } else if (cr.bottom > pr.bottom) {
      el.scrollIntoView(false);
    }
  }

  return {
    instantiateTemplate: instantiateTemplate,
    windowRectForElement: windowRectForElement,
    scrollIntoViewIfNeeded: scrollIntoViewIfNeeded
  };
});


  'use strict';
  (function() {
    var RIGHT_ARROW = String.fromCharCode(0x25b6);
    var UNSORTED_ARROW = String.fromCharCode(0x25BF);
    var ASCENDING_ARROW = String.fromCharCode(0x25B4);
    var DESCENDING_ARROW = String.fromCharCode(0x25BE);
    var BASIC_INDENTATION = 8;

    Polymer('tr-ui-b-table', {
      created: function() {
        this.supportsSelection_ = false;
        this.cellSelectionMode_ = false;
        this.selectedTableRowInfo_ = undefined;
        this.selectedColumnIndex_ = undefined;

        this.tableColumns_ = [];
        this.tableRows_ = [];
        this.tableRowsInfo_ = [];
        this.tableFooterRows_ = [];
        this.sortColumnIndex_ = undefined;
        this.sortDescending_ = false;
        this.columnsWithExpandButtons_ = [];
        this.headerCells_ = [];
        this.showHeader_ = true;
        this.emptyValue_ = undefined;
        this.subRowsPropertyName_ = 'subRows';
        this.customizeTableRowCallback_ = undefined;
      },

      ready: function() {
        this.$.body.addEventListener(
            'keydown', this.onKeyDown_.bind(this), true);
      },

      clear: function() {
        this.supportsSelection_ = false;
        this.cellSelectionMode_ = false;
        this.selectedTableRowInfo_ = undefined;
        this.selectedColumnIndex_ = undefined;

        this.textContent = '';
        this.tableColumns_ = [];
        this.tableRows_ = [];
        this.tableRowsInfo_ = new WeakMap();
        this.tableFooterRows_ = [];
        this.tableFooterRowsInfo_ = new WeakMap();
        this.sortColumnIndex_ = undefined;
        this.sortDescending_ = false;
        this.columnsWithExpandButtons_ = [];
        this.headerCells_ = [];
        this.subRowsPropertyName_ = 'subRows';
      },

      get showHeader() {
        return this.showHeader_;
      },

      set showHeader(showHeader) {
        this.showHeader_ = showHeader;
        this.scheduleRebuildHeaders_();
      },

      set subRowsPropertyName(name) {
        this.subRowsPropertyName_ = name;
      },

      
      set customizeTableRowCallback(cb) {
        this.customizeTableRowCallback_ = cb;
        this.scheduleRebuildBody_();
      },

      get emptyValue() {
        return this.emptyValue_;
      },

      set emptyValue(emptyValue) {
        var previousEmptyValue = this.emptyValue_;
        this.emptyValue_ = emptyValue;
        if (this.tableRows_.length === 0 && emptyValue !== previousEmptyValue)
          this.scheduleRebuildBody_();
      },

      
      set tableColumns(columns) {
                var columnsWithExpandButtons = [];
        for (var i = 0; i < columns.length; i++) {
          if (columns[i].showExpandButtons)
            columnsWithExpandButtons.push(i);
        }
        if (columnsWithExpandButtons.length === 0) {
                    columnsWithExpandButtons = [0];
        }

                for (var i = 0; i < columns.length; i++) {
          var colInfo = columns[i];
          if (colInfo.width === undefined)
            continue;

          var hasExpandButton = columnsWithExpandButtons.indexOf(i) !== -1;

          var w = colInfo.width;
          if (w) {
            if (/\d+px/.test(w)) {
              continue;
            } else if (/\d+%/.test(w)) {
              if (hasExpandButton) {
                throw new Error('Columns cannot be %-sized and host ' +
                                ' an expand button');
              }
            } else {
              throw new Error('Unrecognized width string');
            }
          }
        }

                this.tableColumns_ = columns;
        this.headerCells_ = [];
        this.columnsWithExpandButtons_ = columnsWithExpandButtons;
        this.sortColumnIndex = undefined;
        this.scheduleRebuildHeaders_();

                this.tableRows = this.tableRows_;
      },

      get tableColumns() {
        return this.tableColumns_;
      },

      
      set tableRows(rows) {
        this.selectedTableRowInfo_ = undefined;
        this.selectedColumnIndex_ = undefined;
        this.maybeUpdateSelectedRow_();
        this.tableRows_ = rows;
        this.tableRowsInfo_ = new WeakMap();
        this.scheduleRebuildBody_();
      },

      get tableRows() {
        return this.tableRows_;
      },

      set footerRows(rows) {
        this.tableFooterRows_ = rows;
        this.tableFooterRowsInfo_ = new WeakMap();
        this.scheduleRebuildFooter_();
      },

      get footerRows() {
        return this.tableFooterRows_;
      },

      set sortColumnIndex(number) {
        if (number === undefined) {
          this.sortColumnIndex_ = undefined;
          this.updateHeaderArrows_();
          return;
        }

        if (this.tableColumns_.length <= number)
          throw new Error('Column number ' + number + ' is out of bounds.');
        if (!this.tableColumns_[number].cmp)
          throw new Error('Column ' + number + ' does not have a comparator.');

        this.sortColumnIndex_ = number;
        this.updateHeaderArrows_();
        this.scheduleRebuildBody_();
      },

      get sortColumnIndex() {
        return this.sortColumnIndex_;
      },

      set sortDescending(value) {
        var newValue = !!value;

        if (newValue !== this.sortDescending_) {
          this.sortDescending_ = newValue;
          this.updateHeaderArrows_();
          this.scheduleRebuildBody_();
        }
      },

      get sortDescending() {
        return this.sortDescending_;
      },

      updateHeaderArrows_: function() {
        for (var i = 0; i < this.headerCells_.length; i++) {
          if (!this.tableColumns_[i].cmp) {
            this.headerCells_[i].sideContent = '';
            continue;
          }
          if (i !== this.sortColumnIndex_) {
            this.headerCells_[i].sideContent = UNSORTED_ARROW;
            continue;
          }
          this.headerCells_[i].sideContent = this.sortDescending_ ?
            DESCENDING_ARROW : ASCENDING_ARROW;
        }
      },

      sortRows_: function(rows) {
        rows.sort(function(rowA, rowB) {
          if (this.sortDescending_)
            return this.tableColumns_[this.sortColumnIndex_].cmp(
                rowB.userRow, rowA.userRow);
          return this.tableColumns_[this.sortColumnIndex_].cmp(
                rowA.userRow, rowB.userRow);
        }.bind(this));
                for (var i = 0; i < rows.length; i++) {
          if (rows[i].isExpanded)
            this.sortRows_(rows[i][this.subRowsPropertyName_]);
        }
      },

      generateHeaderColumns_: function() {
        this.headerCells_ = [];
        this.$.head.textContent = '';
        if (!this.showHeader_)
          return;

        var tr = this.appendNewElement_(this.$.head, 'tr');
        for (var i = 0; i < this.tableColumns_.length; i++) {
          var td = this.appendNewElement_(tr, 'td');

          var headerCell = document.createElement('tr-ui-b-table-header-cell');

          if (this.showHeader)
            headerCell.cellTitle = this.tableColumns_[i].title;
          else
            headerCell.cellTitle = '';

                              if (this.tableColumns_[i].cmp) {
            td.classList.add('sensitive');
            headerCell.tapCallback = this.createSortCallback_(i);
                        if (this.sortColumnIndex_ === i)
              headerCell.sideContent = this.sortDescending_ ?
                DESCENDING_ARROW : ASCENDING_ARROW;
            else
              headerCell.sideContent = UNSORTED_ARROW;
          }

          td.appendChild(headerCell);
          this.headerCells_.push(headerCell);
        }
      },

      applySizes_: function() {
        if (this.tableRows_.length === 0 && !this.showHeader)
          return;
        var rowToRemoveSizing;
        var rowToSize;
        if (this.showHeader) {
          rowToSize = this.$.head.children[0];
          rowToRemoveSizing = this.$.body.children[0];
        } else {
          rowToSize = this.$.body.children[0];
          rowToRemoveSizing = this.$.head.children[0];
        }
        for (var i = 0; i < this.tableColumns_.length; i++) {
          if (rowToRemoveSizing && rowToRemoveSizing.children[i]) {
            var tdToRemoveSizing = rowToRemoveSizing.children[i];
            tdToRemoveSizing.style.minWidth = '';
            tdToRemoveSizing.style.width = '';
          }

                    var td = rowToSize.children[i];

          var delta;
          if (this.columnsWithExpandButtons_.indexOf(i) !== -1) {
            td.style.paddingLeft = BASIC_INDENTATION + 'px';
            delta = BASIC_INDENTATION + 'px';
          } else {
            delta = undefined;
          }

          function calc(base, delta) {
            if (delta)
              return 'calc(' + base + ' - ' + delta + ')';
            else
              return base;
          }

          var w = this.tableColumns_[i].width;
          if (w) {
            if (/\d+px/.test(w)) {
              td.style.minWidth = calc(w, delta);
            } else if (/\d+%/.test(w)) {
              td.style.width = w;
            } else {
              throw new Error('Unrecognized width string: ' + w);
            }
          }
        }
      },

      createSortCallback_: function(columnNumber) {
        return function() {
          var previousIndex = this.sortColumnIndex;
          this.sortColumnIndex = columnNumber;
          if (previousIndex !== columnNumber)
            this.sortDescending = false;
          else
            this.sortDescending = !this.sortDescending;
        }.bind(this);
      },

      generateTableRowNodes_: function(tableSection, userRows, rowInfoMap,
                                       indentation, lastAddedRow,
                                       parentRowInfo) {
        if (this.sortColumnIndex_ !== undefined &&
            tableSection === this.$.body) {
          userRows = userRows.slice();           userRows.sort(function(rowA, rowB) {
            var c = this.tableColumns_[this.sortColumnIndex_].cmp(
                  rowA, rowB);
            if (this.sortDescending_)
              c = -c;
            return c;
          }.bind(this));
        }

        for (var i = 0; i < userRows.length; i++) {
          var userRow = userRows[i];
          var rowInfo = this.getOrCreateRowInfoFor_(rowInfoMap, userRow,
                                                    parentRowInfo);
          var htmlNode = this.getHTMLNodeForRowInfo_(
              tableSection, rowInfo, rowInfoMap, indentation);

          if (lastAddedRow === undefined) {
                        tableSection.insertBefore(htmlNode, tableSection.firstChild);
          } else {
                        var nextSiblingOfLastAdded = lastAddedRow.nextSibling;
            tableSection.insertBefore(htmlNode, nextSiblingOfLastAdded);
          }
          this.updateTabIndexForTableRowNode_(htmlNode);

          lastAddedRow = htmlNode;
          if (!rowInfo.isExpanded)
            continue;

                    lastAddedRow = this.generateTableRowNodes_(
              tableSection, userRow[this.subRowsPropertyName_], rowInfoMap,
              indentation + 1, lastAddedRow, rowInfo);
        }
        return lastAddedRow;
      },

      getOrCreateRowInfoFor_: function(rowInfoMap, userRow, parentRowInfo) {
        if (rowInfoMap.has(userRow))
          return rowInfoMap.get(userRow);

        var rowInfo = {
          userRow: userRow,
          htmlNode: undefined,
          isExpanded: userRow.isExpanded || false,
          parentRowInfo: parentRowInfo
        };
        rowInfoMap.set(userRow, rowInfo);
        return rowInfo;
      },

      customizeTableRow_: function(userRow, trElement) {
        if (!this.customizeTableRowCallback_)
          return;
        this.customizeTableRowCallback_(userRow, trElement);
      },

      getHTMLNodeForRowInfo_: function(tableSection, rowInfo,
                                       rowInfoMap, indentation) {
        if (rowInfo.htmlNode) {
          this.customizeTableRow_(rowInfo.userRow, rowInfo.htmlNode);
          return rowInfo.htmlNode;
        }

        var INDENT_SPACE = indentation * 16;
        var INDENT_SPACE_NO_BUTTON = indentation * 16 + BASIC_INDENTATION;
        var trElement = this.ownerDocument.createElement('tr');
        rowInfo.htmlNode = trElement;
        rowInfo.indentation = indentation;
        trElement.rowInfo = rowInfo;
        this.customizeTableRow_(rowInfo.userRow, trElement);

        for (var i = 0; i < this.tableColumns_.length;) {
          var td = this.appendNewElement_(trElement, 'td');
          td.columnIndex = i;

          var column = this.tableColumns_[i];
          var value = column.value(rowInfo.userRow);
          var colSpan = column.colSpan ? column.colSpan : 1;
          td.style.colSpan = colSpan;
          if (column.textAlign) {
            td.style.textAlign = column.textAlign;
          }

          if (this.doesColumnIndexSupportSelection(i))
            td.classList.add('supports-selection');

          if (this.columnsWithExpandButtons_.indexOf(i) != -1) {
            if (rowInfo.userRow[this.subRowsPropertyName_] &&
                rowInfo.userRow[this.subRowsPropertyName_].length > 0) {
              td.style.paddingLeft = INDENT_SPACE + 'px';
              var expandButton = this.appendNewElement_(td,
                  'expand-button');
              expandButton.textContent = RIGHT_ARROW;
              if (rowInfo.isExpanded)
                expandButton.classList.add('button-expanded');
            } else {
              td.style.paddingLeft = INDENT_SPACE_NO_BUTTON + 'px';
            }
          }

          if (value !== undefined)
            td.appendChild(tr.ui.b.asHTMLOrTextNode(value, this.ownerDocument));

          i += colSpan;
        }

        var needsClickListener = false;
        if (this.columnsWithExpandButtons_.length)
          needsClickListener = true;
        else if (tableSection == this.$.body)
          needsClickListener = true;

        if (needsClickListener) {
          trElement.addEventListener('click', function(e) {
            e.stopPropagation();
            if (e.target.tagName == 'EXPAND-BUTTON') {
              this.setExpandedForUserRow_(
                  tableSection, rowInfoMap,
                  rowInfo.userRow, !rowInfo.isExpanded);
              return;
            }

            function getTD(cur) {
              if (cur === trElement)
                throw new Error('woah');
              if (cur.parentElement === trElement)
                return cur;
              return getTD(cur.parentElement);
            }

            if (this.supportsSelection_) {
              var isAlreadySelected = false;
              var tdThatWasClicked = getTD(e.target);
              if (!this.cellSelectionMode_) {
                isAlreadySelected = this.selectedTableRowInfo_ === rowInfo;
              } else {
                isAlreadySelected = this.selectedTableRowInfo_ === rowInfo;
                isAlreadySelected &= (this.selectedColumnIndex_ ===
                                      tdThatWasClicked.columnIndex);
              }
              if (isAlreadySelected) {
                if (rowInfo.userRow[this.subRowsPropertyName_] &&
                    rowInfo.userRow[this.subRowsPropertyName_].length) {
                  this.setExpandedForUserRow_(
                      tableSection, rowInfoMap,
                      rowInfo.userRow, !rowInfo.isExpanded);
                }
              } else {
                this.didTableRowInfoGetClicked_(
                    rowInfo, tdThatWasClicked.columnIndex);
              }
            } else {
              if (rowInfo.userRow[this.subRowsPropertyName_] &&
                  rowInfo.userRow[this.subRowsPropertyName_].length) {
                this.setExpandedForUserRow_(
                    tableSection, rowInfoMap,
                    rowInfo.userRow, !rowInfo.isExpanded);
              }
            }
          }.bind(this));
        }

        return rowInfo.htmlNode;
      },

      removeSubNodes_: function(tableSection, rowInfo, rowInfoMap) {
        if (rowInfo.userRow[this.subRowsPropertyName_] === undefined)
          return;
        for (var i = 0;
             i < rowInfo.userRow[this.subRowsPropertyName_].length; i++) {
          var subRow = rowInfo.userRow[this.subRowsPropertyName_][i];
          var subRowInfo = rowInfoMap.get(subRow);
          if (!subRowInfo)
            continue;

          var subNode = subRowInfo.htmlNode;
          if (subNode && subNode.parentNode === tableSection) {
            tableSection.removeChild(subNode);
            this.removeSubNodes_(tableSection, subRowInfo, rowInfoMap);
          }
        }
      },

      scheduleRebuildHeaders_: function() {
        this.headerDirty_ = true;
        this.scheduleRebuild_();
      },

      scheduleRebuildBody_: function() {
        this.bodyDirty_ = true;
        this.scheduleRebuild_();
      },

      scheduleRebuildFooter_: function() {
        this.footerDirty_ = true;
        this.scheduleRebuild_();
      },

      scheduleRebuild_: function() {
        if (this.rebuildPending_)
          return;
        this.rebuildPending_ = true;
        setTimeout(function() {
          this.rebuildPending_ = false;
          this.rebuild();
        }.bind(this), 0);
      },

      rebuildIfNeeded_: function() {
        this.rebuild();
      },

      rebuild: function() {
        var wasBodyOrHeaderDirty = this.headerDirty_ || this.bodyDirty_;

        if (this.headerDirty_) {
          this.generateHeaderColumns_();
          this.headerDirty_ = false;
        }
        if (this.bodyDirty_) {
          this.$.body.textContent = '';
          this.generateTableRowNodes_(
              this.$.body,
              this.tableRows_, this.tableRowsInfo_, 0,
              undefined, undefined);
          if (this.tableRows_.length === 0 && this.emptyValue_ !== undefined) {
            var trElement = this.ownerDocument.createElement('tr');
            this.$.body.appendChild(trElement);
            trElement.classList.add('empty-row');
            var td = this.ownerDocument.createElement('td');
            trElement.appendChild(td);
            td.colSpan = this.tableColumns_.length;
            var emptyValue = this.emptyValue_;
            td.appendChild(
                tr.ui.b.asHTMLOrTextNode(emptyValue, this.ownerDocument));
          }
          this.bodyDirty_ = false;
        }

        if (wasBodyOrHeaderDirty)
          this.applySizes_();

        if (this.footerDirty_) {
          this.$.foot.textContent = '';
          this.generateTableRowNodes_(
              this.$.foot,
              this.tableFooterRows_, this.tableFooterRowsInfo_, 0,
              undefined, undefined);
          if (this.tableFooterRowsInfo_.length) {
            this.$.body.classList.add('has-footer');
          } else {
            this.$.body.classList.remove('has-footer');
          }
          this.footerDirty_ = false;
        }
      },

      appendNewElement_: function(parent, tagName) {
        var element = parent.ownerDocument.createElement(tagName);
        parent.appendChild(element);
        return element;
      },

      getExpandedForTableRow: function(userRow) {
        this.rebuildIfNeeded_();
        var rowInfo = this.tableRowsInfo_.get(userRow);
        if (rowInfo === undefined)
          throw new Error('Row has not been seen, must expand its parents');
        return rowInfo.isExpanded;
      },

      setExpandedForTableRow: function(userRow, expanded) {
        this.rebuildIfNeeded_();
        var rowInfo = this.tableRowsInfo_.get(userRow);
        if (rowInfo === undefined)
          throw new Error('Row has not been seen, must expand its parents');
        return this.setExpandedForUserRow_(this.$.body, this.tableRowsInfo_,
                                           userRow, expanded);
      },

      setExpandedForUserRow_: function(tableSection, rowInfoMap,
                                       userRow, expanded) {
        this.rebuildIfNeeded_();

        var rowInfo = rowInfoMap.get(userRow);
        if (rowInfo === undefined)
          throw new Error('Row has not been seen, must expand its parents');

        rowInfo.isExpanded = !!expanded;
                if (rowInfo.htmlNode === undefined)
          return;

                if (rowInfo.htmlNode.parentElement !== tableSection)
          return;

                var expandButton = rowInfo.htmlNode.querySelector('expand-button');
        if (rowInfo.isExpanded) {
          expandButton.classList.add('button-expanded');
          var lastAddedRow = rowInfo.htmlNode;
          if (rowInfo.userRow[this.subRowsPropertyName_]) {
            this.generateTableRowNodes_(
                tableSection,
                rowInfo.userRow[this.subRowsPropertyName_], rowInfoMap,
                rowInfo.indentation + 1,
                lastAddedRow, rowInfo);
          }
        } else {
          expandButton.classList.remove('button-expanded');
          this.removeSubNodes_(tableSection, rowInfo, rowInfoMap);
        }

        this.maybeUpdateSelectedRow_();
      },

      get supportsSelection() {
        return this.supportsSelection_;
      },

      set supportsSelection(supportsSelection) {
        this.rebuildIfNeeded_();
        this.supportsSelection_ = !!supportsSelection;
        this.didSelectionStateChange_();
      },

      get cellSelectionMode() {
        return this.cellSelectionMode_;
      },

      set cellSelectionMode(cellSelectionMode) {
        this.rebuildIfNeeded_();
        this.cellSelectionMode_ = !!cellSelectionMode;
        this.didSelectionStateChange_();
      },

      get rowHighlightEnabled() {
        return this.rowHighlightEnabled_;
      },

      set rowHighlightEnabled(rowHighlightEnabled) {
        this.rebuildIfNeeded_();
        this.rowHighlightEnabled_ = !!rowHighlightEnabled;
        this.didSelectionStateChange_();
      },

      didSelectionStateChange_: function() {
        if (!this.supportsSelection_) {
                    this.$.body.classList.remove('cell-selection-mode');
          this.$.body.classList.remove('row-selection-mode');
          this.$.body.classList.remove('row-highlight-enabled');
        } else if (!this.cellSelectionMode_) {
                    this.$.body.classList.remove('cell-selection-mode');
          this.$.body.classList.add('row-selection-mode');
          this.$.body.classList.remove('row-highlight-enabled');
        } else {
                    this.$.body.classList.add('cell-selection-mode');
          this.$.body.classList.remove('row-selection-mode');
          if (this.rowHighlightEnabled_)
            this.$.body.classList.add('row-highlight-enabled');
          else
            this.$.body.classList.remove('row-highlight-enabled');
        }
        for (var i = 0; i < this.$.body.children.length; i++)
          this.updateTabIndexForTableRowNode_(this.$.body.children[i]);
        this.maybeUpdateSelectedRow_();
      },

      maybeUpdateSelectedRow_: function() {
        if (this.selectedTableRowInfo_ === undefined)
          return;

                if (!this.supportsSelection_) {
          this.removeSelectedState_();
          this.selectedTableRowInfo_ = undefined;
          return;
        }

                function isVisible(rowInfo) {
          if (!rowInfo.htmlNode)
            return false;
          return !!rowInfo.htmlNode.parentElement;
        }
        if (isVisible(this.selectedTableRowInfo_)) {
          this.updateSelectedState_();
          return;
        }

        this.removeSelectedState_();
        var curRowInfo = this.selectedTableRowInfo_;
        while (curRowInfo && !isVisible(curRowInfo))
          curRowInfo = curRowInfo.parentRowInfo;

        this.selectedTableRowInfo_ = curRowInfo;
        if (this.selectedTableRowInfo_)
          this.updateSelectedState_();
      },

      didTableRowInfoGetClicked_: function(rowInfo, columnIndex) {
        if (!this.supportsSelection_)
          return;

        if (this.cellSelectionMode_) {
          if (!this.doesColumnIndexSupportSelection(columnIndex))
            return;
        }

        if (this.selectedTableRowInfo_ !== rowInfo)
          this.selectedTableRow = rowInfo.userRow;

        if (this.selectedColumnIndex !== columnIndex)
          this.selectedColumnIndex = columnIndex;
      },

      get selectedTableRow() {
        if (!this.selectedTableRowInfo_)
          return undefined;
        return this.selectedTableRowInfo_.userRow;
      },

      set selectedTableRow(userRow) {
        this.rebuildIfNeeded_();
        if (!this.supportsSelection_)
          throw new Error('Selection is off. Set supportsSelection=true.');

        var rowInfo = this.tableRowsInfo_.get(userRow);
        if (rowInfo === undefined)
          throw new Error('Row has not been seen, must expand its parents');

        var e = this.prepareToChangeSelection_();
        this.selectedTableRowInfo_ = rowInfo;
        if (this.cellSelectionMode_) {
          if (this.selectedTableRowInfo_ &&
              this.selectedColumnIndex_ === undefined) {
            var i = this.getFirstSelectableColumnIndex_();
            if (i == -1)
              throw new Error('nope');
            this.selectedColumnIndex_ = i;
          }
        } else {
          this.selectedColumnIndex_ = undefined;
        }

        this.updateSelectedState_();

        this.dispatchEvent(e);
      },

      updateTabIndexForTableRowNode_: function(row) {
        if (this.supportsSelection_) {
          if (!this.cellSelectionMode_) {
            row.tabIndex = 0;
          } else {
            for (var i = 0; i < this.tableColumns_.length; i++) {
              if (!this.doesColumnIndexSupportSelection(i))
                continue;
              row.children[i].tabIndex = 0;
            }
          }
        } else {
          if (!this.cellSelectionMode_) {
            row.removeAttribute('tabIndex');
          } else {
            for (var i = 0; i < this.tableColumns_.length; i++) {
              if (!this.doesColumnIndexSupportSelection(i))
                continue;
              row.children[i].removeAttribute('tabIndex');
            }
          }
        }
      },

      prepareToChangeSelection_: function() {
        var e = new tr.b.Event('selection-changed');
        var previousSelectedRowInfo = this.selectedTableRowInfo_;
        if (previousSelectedRowInfo)
          e.previousSelectedTableRow = previousSelectedRowInfo.userRow;
        else
          e.previousSelectedTableRow = undefined;

        this.removeSelectedState_();

        return e;
      },

      removeSelectedState_: function() {
        this.setSelectedState_(false);
      },

      updateSelectedState_: function() {
        this.setSelectedState_(true);
      },

      setSelectedState_: function(select) {
        if (this.selectedTableRowInfo_ === undefined)
          return;
        var tableRowNode = this.selectedTableRowInfo_.htmlNode;

                if (this.cellSelectionMode_ && this.rowHighlightEnabled_) {
          if (select)
            tableRowNode.classList.add('highlighted-row');
          else
            tableRowNode.classList.remove('highlighted-row');
        }

                var node = this.getSelectableNodeGivenTableRowNode_(tableRowNode);
        if (select)
          node.setAttribute('selected', true);
        else
          node.removeAttribute('selected');
      },

      doesColumnIndexSupportSelection: function(columnIndex) {
        var columnInfo = this.tableColumns_[columnIndex];
        var scs = columnInfo.supportsCellSelection;
        if (scs === false)
          return false;
        return true;
      },

      getFirstSelectableColumnIndex_: function() {
        for (var i = 0; i < this.tableColumns_.length; i++) {
          if (this.doesColumnIndexSupportSelection(i))
            return i;
        }
        return -1;
      },

      getSelectableNodeGivenTableRowNode_: function(htmlNode) {
        if (!this.cellSelectionMode_) {
          return htmlNode;
        } else {
          return htmlNode.children[this.selectedColumnIndex_];
        }
      },

      get selectedColumnIndex() {
        if (!this.supportsSelection_)
          return undefined;
        if (!this.cellSelectionMode_)
          return undefined;
        return this.selectedColumnIndex_;
      },

      set selectedColumnIndex(selectedColumnIndex) {
        this.rebuildIfNeeded_();
        if (!this.supportsSelection_)
          throw new Error('Selection is off. Set supportsSelection=true.');
        if (selectedColumnIndex < 0 ||
            selectedColumnIndex >= this.tableColumns_.length)
          throw new Error('Invalid index');
        if (!this.doesColumnIndexSupportSelection(selectedColumnIndex))
          throw new Error('Selection is not supported on this column');

        var e = this.prepareToChangeSelection_();
        this.selectedColumnIndex_ = selectedColumnIndex;
        if (this.selectedColumnIndex_ === undefined)
          this.selectedTableRowInfo_ = undefined;
        this.updateSelectedState_();

        this.dispatchEvent(e);
      },

      onKeyDown_: function(e) {
        if (this.supportsSelection_ === false)
          return;
        if (this.selectedTableRowInfo_ === undefined)
          return;

        var code_to_command_names = {
          37: 'ARROW_LEFT',
          38: 'ARROW_UP',
          39: 'ARROW_RIGHT',
          40: 'ARROW_DOWN'
        };
        var cmdName = code_to_command_names[e.keyCode];
        if (cmdName === undefined)
          return;

        e.stopPropagation();
        e.preventDefault();
        this.performKeyCommand_(cmdName);
      },

      performKeyCommand_: function(cmdName) {
        this.rebuildIfNeeded_();

        var rowInfo = this.selectedTableRowInfo_;
        var htmlNode = rowInfo.htmlNode;
        if (cmdName === 'ARROW_UP') {
          var prev = htmlNode.previousElementSibling;
          if (prev) {
            tr.ui.b.scrollIntoViewIfNeeded(prev);
            this.selectedTableRow = prev.rowInfo.userRow;
            this.focusSelected_();
            return;
          }
          return;
        }

        if (cmdName === 'ARROW_DOWN') {
          var next = htmlNode.nextElementSibling;
          if (next) {
            tr.ui.b.scrollIntoViewIfNeeded(next);
            this.selectedTableRow = next.rowInfo.userRow;
            this.focusSelected_();
            return;
          }
          return;
        }

        if (cmdName === 'ARROW_RIGHT') {
          if (this.cellSelectionMode_) {
            var newIndex = this.selectedColumnIndex_ + 1;
            if (newIndex >= this.tableColumns_.length)
              return;
            if (!this.doesColumnIndexSupportSelection(newIndex))
              return;
            this.selectedColumnIndex = newIndex;
            this.focusSelected_();
            return;

          } else {
            if (rowInfo.userRow[this.subRowsPropertyName_] === undefined)
              return;
            if (rowInfo.userRow[this.subRowsPropertyName_].length === 0)
              return;

            if (!rowInfo.isExpanded)
              this.setExpandedForTableRow(rowInfo.userRow, true);
            this.selectedTableRow =
              rowInfo.userRow[this.subRowsPropertyName_][0];
            this.focusSelected_();
            return;
          }
        }

        if (cmdName === 'ARROW_LEFT') {
          if (this.cellSelectionMode_) {
            var newIndex = this.selectedColumnIndex_ - 1;
            if (newIndex < 0)
              return;
            if (!this.doesColumnIndexSupportSelection(newIndex))
              return;
            this.selectedColumnIndex = newIndex;
            this.focusSelected_();
            return;

          } else {
            if (rowInfo.isExpanded) {
              this.setExpandedForTableRow(rowInfo.userRow, false);
              this.focusSelected_();
              return;
            }

                        var parentRowInfo = rowInfo.parentRowInfo;
            if (parentRowInfo) {
              this.selectedTableRow = parentRowInfo.userRow;
              this.focusSelected_();
              return;
            }
            return;
          }
        }
        throw new Error('Unrecognized command');
      },

      focusSelected_: function() {
        if (!this.selectedTableRowInfo_)
          return;
        var node = this.getSelectableNodeGivenTableRowNode_(
            this.selectedTableRowInfo_.htmlNode);
        node.focus();
      }
    });
  })();
  

  'use strict';

  Polymer('tr-ui-b-table-header-cell', {
    created: function() {
      this.tapCallback_ = undefined;
      this.cellTitle_ = '';
    },

    set cellTitle(value) {
      this.cellTitle_ = value;

      var titleNode = tr.ui.b.asHTMLOrTextNode(
          this.cellTitle_, this.ownerDocument);

      this.$.title.innerText = '';
      this.$.title.appendChild(titleNode);
    },

    get cellTitle() {
      return this.cellTitle_;
    },

    clearSideContent: function() {
      this.$.side.textContent = '';
    },

    set sideContent(content) {
      this.$.side.textContent = content;
    },

    get sideContent() {
      return this.$.side.textContent;
    },

    set tapCallback(callback) {
      this.style.cursor = 'pointer';
      this.tapCallback_ = callback;
    },

    get tapCallback() {
      return this.tapCallback_;
    },

    onTap_: function() {
      if (this.tapCallback_)
        this.tapCallback_();
    }
  });


'use strict';

/**
 * @fileoverview Helper code for working with Polymer.
 */
tr.exportTo('tr.ui.b', function() {

  Object.observe(Polymer.elements, clearPolymerElementCaches);

  var elementsByName = undefined;
  var elementsThatExtend = undefined;
  var elementSubclasses = undefined;
  function clearPolymerElementCaches() {
    elementsByName = {};
    elementsThatExtend = undefined;
    elementSubclasses = {};
  }

  function buildElementMapsIfNeeded() {
    if (elementsThatExtend !== undefined && elementsByName !== undefined)
      return;
    elementsByName = {};
    elementsThatExtend = {};
    Polymer.elements.forEach(function(element) {
      if (elementsByName[element.name])
        throw new Error('Something is strange: dupe polymer element names');

      elementsByName[element.name] = element;

      if (element.extends) {
        if (elementsThatExtend[element.extends] === undefined)
          elementsThatExtend[element.extends] = [];
        elementsThatExtend[element.extends].push(element.name);
      }
    });
  }

  function getPolymerElementNamed(tagName) {
    buildElementMapsIfNeeded();
    return elementsByName[tagName];
  }

  function getPolymerElementsThatSubclass(tagName) {
    if (Polymer.waitingFor().length) {
      throw new Error('There are unresolved polymer elements. ' +
        'Wait until Polymer.whenReady');
    }

    buildElementMapsIfNeeded();

    var element = getPolymerElementNamed(tagName);
    if (!element)
      throw new Error(tagName + ' is not a polymer element');

    if (elementSubclasses === undefined)
      elementSubclasses = {};

    if (elementSubclasses[tagName] === undefined) {
      var immediateSubElements = elementsThatExtend[element.name];
      var allSubElements = [];
      if (immediateSubElements !== undefined && immediateSubElements.length) {
        immediateSubElements.forEach(function(subElement) {
          allSubElements.push(subElement);
          allSubElements.push.apply(
            allSubElements, getPolymerElementsThatSubclass(subElement));
        });
      }
      elementSubclasses[tagName] = allSubElements;
    }
    return elementSubclasses[tagName];
  }

  return {
    getPolymerElementNamed: getPolymerElementNamed,
    getPolymerElementsThatSubclass: getPolymerElementsThatSubclass
  };
});


'use strict';

tr.exportTo('tr.b.u', function() {
  var TimeDisplayModes = tr.b.u.TimeDisplayModes;

  function max(a, b) {
    if (a === undefined)
      return b;
    if (b === undefined)
      return a;
    return a.scale > b.scale ? a : b;
  }

  var Units = {
    reset: function() {
      this.currentTimeDisplayMode = TimeDisplayModes.ms;
    },

    timestampFromUs: function(us) {
      return us / 1000;
    },

    maybeTimestampFromUs: function(us) {
      return us === undefined ? undefined : us / 1000;
    },

    get currentTimeDisplayMode() {
      return this.currentTimeDisplayMode_;
    },

    // Use tr-ui-u-preferred-display-unit element instead of directly setting.
    set currentTimeDisplayMode(value) {
      if (this.currentTimeDisplayMode_ == value)
        return;

      this.currentTimeDisplayMode_ = value;
      this.dispatchEvent(new tr.b.Event('display-mode-changed'));
    },

    didPreferredTimeDisplayUnitChange: function() {
      var largest = undefined;
      var els = tr.b.findDeepElementsMatching(document.body,
          'tr-ui-u-preferred-display-unit');
      els.forEach(function(el) {
        largest = max(largest, el.preferredTimeDisplayMode);
      });

      this.currentDisplayUnit = largest === undefined ?
          TimeDisplayModes.ms : largest;
    },

    unitsByJSONName: {},

    fromJSON: function(object) {
      var u = this.unitsByJSONName[object];
      if (u) {
        return u;
      }
      throw new Error('Unrecognized unit');
    }
  };

  tr.b.EventTarget.decorate(Units);
  Units.reset();

  // Known display units follow.
  //////////////////////////////////////////////////////////////////////////////
  Units.timeDurationInMs = {
    asJSON: function() { return 'ms'; },
    format: function(value) {
      return Units.currentTimeDisplayMode_.format(value);
    }
  };
  Units.unitsByJSONName['ms'] = Units.timeDurationInMs;

  Units.timeStampInMs = {
    asJSON: function() { return 'tsMs'; },
    format: function(value) {
      return Units.currentTimeDisplayMode_.format(value);
    }
  };
  Units.unitsByJSONName['tsMs'] = Units.timeStampInMs;

  Units.normalizedPercentage = {
    asJSON: function() { return 'n%'; },
    format: function(value) {
      var tmp = new Number(Math.round(value * 100));
      return tmp.toLocaleString(undefined, {minimumFractionDigits: 3}) + '%';
    }
  };
  Units.unitsByJSONName['n%'] = Units.normalizedPercentage;

  var SIZE_UNIT_PREFIXES = ['', 'Ki', 'Mi', 'Gi', 'Ti'];
  Units.sizeInBytes = {
    asJSON: function() { return 'sizeInBytes'; },
    format: function(value) {
      var signPrefix = '';
      if (value < 0) {
        signPrefix = '-';
        value = -value;
      }

      var i = 0;
      while (value >= 1024 && i < SIZE_UNIT_PREFIXES.length - 1) {
        value /= 1024;
        i++;
      }

      return signPrefix + value.toFixed(1) + ' ' + SIZE_UNIT_PREFIXES[i] + 'B';
    }
  };
  Units.unitsByJSONName['sizeInBytes'] = Units.sizeInBytes;

  Units.energyInJoules = {
    asJSON: function() { return 'J'; },
    format: function(value) {
      return value
          .toLocaleString(undefined, { minimumFractionDigits: 3 }) + ' J';
    }
  };
  Units.unitsByJSONName['J'] = Units.energyInJoules;

  Units.powerInWatts = {
    asJSON: function() { return 'W'; },
    format: function(value) {
      return (value * 1000.0)
          .toLocaleString(undefined, { minimumFractionDigits: 3 }) + ' mW';
    }
  };
  Units.unitsByJSONName['W'] = Units.powerInWatts;

  Units.unitlessNumber = {
    asJSON: function() { return 'unitless'; },
    format: function(value) {
      return value.toLocaleString(
          undefined, {
            minimumFractionDigits: 3,
            maximumFractionDigits: 3});
    }
  };
  Units.unitsByJSONName['unitless'] = Units.unitlessNumber;

  return {
    Units: Units
  };
});


'use strict';
tr.exportTo('tr.ui.units', function() {
  function createScalarSpan(value, opt_config) {
    if (value === undefined)
      return '';
    var config = opt_config || {};
    var ownerDocument = config.ownerDocument || document;
    var span = ownerDocument.createElement('tr-ui-u-scalar-span');
    span.value = value;
    return span;
  }

  tr.b.u.Units.addEventListener('display-mode-changed', function(e) {
    var subclassNames = tr.ui.b.getPolymerElementsThatSubclass(
        'tr-ui-u-scalar-span');
    var isSubclass = {};
    subclassNames.forEach(function(n) {
      isSubclass[n.toUpperCase()] = true;
    });

    var m = tr.b.findDeepElementsMatchingPredicate(
        document.body,
        function(el) {
         return isSubclass[el.tagName];
        });
    m.forEach(function(el) {
      el.updateContent_();
    });
  });

  return {
    createScalarSpan: createScalarSpan
  };
});


  'use strict';

  Polymer('tr-ui-u-scalar-span', {
    ready: function() {
      this.value_ = undefined;
      this.unit_ = undefined;

      this.warning_ = undefined;
      this.percentage_ = undefined;
    },

    set contentTextDecoration(deco) {
      this.$.content.style.textDecoration = deco;
    },

    get value() {
      return this.value_;
    },

    set value(value) {
      if (value instanceof tr.b.u.Scalar) {
        this.value_ = value.value;
        this.unit_ = value.unit;
      } else {
        this.value_ = value;
      }
      this.updateContent_();
    },

    get unit() {
      return this.unit_;
    },

    set unit(unit) {
      this.unit_ = unit;
      this.updateContent_();
    },

    setValueAndUnit: function(value, unit) {
      this.value_ = value;
      this.unit_ = unit;
      this.updateContent_();
    },

    get percentage() {
      return this.percentage_;
    },

    set percentage(percentage) {
      this.percentage_ = percentage;
      this.updateSparkline_();
    },

    get rightAlign() {
      return this.$.content.classList.contains('right-align');
    },

    set rightAlign(rightAlign) {
      if (rightAlign)
        this.$.content.classList.add('right-align');
      else
        this.$.content.classList.remove('right-align');
    },

    updateSparkline_: function() {
      if (this.percentage_ === undefined) {
        this.$.sparkline.style.display = 'none';
        this.$.sparkline.style.width = '0';
      } else {
        this.$.sparkline.style.display = 'block';
        this.$.sparkline.style.width = (this.percentage_ * 100) + '%';
      }
    },

    updateContent_: function() {
      if (this.unit_ === undefined) {
        this.$.content.textContent = '';
        return;
      }
      var content = this.unit_.format(this.value);
      this.$.content.textContent = content;
    },

    get warning() {
      return this.warning_;
    },

    set warning(warning) {
      this.warning_ = warning;
      var warningEl = this.$.warning;
      if (this.warning_) {
        warningEl.title = warning;
        warningEl.style.display = '';
      } else {
        warningEl.title = '';
        warningEl.style.display = 'none';
      }
    }
  });
  

'use strict';

// TODO(petrcermak): Similarly to base/units/time_duration.html and
// base/units/time_stamp.html, the classes defined in this file are almost
// identical to the ones defined in time_stamp_span. Consider sharing more
// code between the two files.
tr.exportTo('tr.ui.units', function() {
  function createTimeDurationSpan(duration, opt_config) {
    if (duration === undefined)
      return '';
    var config = opt_config || {};
    var ownerDocument = config.ownerDocument || document;
    var span = ownerDocument.createElement('tr-ui-u-time-duration-span');
    span.setValueAndUnit(duration, tr.b.u.Units.timeDurationInMs);
    if (config.total)
      span.percentage = duration / config.total;
    span.duration = duration;
    // TODO(petrcermak): Get rid of this boolean once we've cleaned up units.
    if (config.rightAlign)
      span.rightAlign = true;
    return span;
  }

  return {
    createTimeDurationSpan: createTimeDurationSpan
  };
});


  'use strict';

  Polymer('tr-ui-u-time-duration-span', {
    get duration() {
      return this.value;
    },

    set duration(duration) {
      if (duration instanceof tr.b.u.TimeDuration) {
        this.value = duration;
        return;
      }
      this.setValueAndUnit(duration, tr.b.u.Units.timeDurationInMs);
    }
  });
  

'use strict';
tr.exportTo('tr.ui.units', function() {
  function createTimeStampSpan(timestamp, opt_config) {
    if (timestamp === undefined)
      return '';
    var config = opt_config || {};
    var ownerDocument = config.ownerDocument || document;
    var span = ownerDocument.createElement('tr-ui-u-time-stamp-span');
    span.timestamp = timestamp;
    return span;
  }

  return {
    createTimeStampSpan: createTimeStampSpan
  };
});


  'use strict';

  Polymer('tr-ui-u-time-stamp-span', {
    get timestamp() {
      return this.value;
    },

    set timestamp(timestamp) {
      if (timestamp instanceof tr.b.u.TimeStamp) {
        this.value = timestamp;
        return;
      }
      this.setValueAndUnit(timestamp, tr.b.u.Units.timeStampInMs);
    }
  });
  

  'use strict';

  function isTable(object) {
    if (!(object instanceof Array) ||
        (object.length < 2)) return false;
    for (var colName in object[0]) {
      if (typeof colName !== 'string') return false;
    }
    for (var i = 0; i < object.length; ++i) {
      if (!(object[i] instanceof Object)) return false;
      for (var colName in object[i]) {
        if (i && (object[0][colName] === undefined)) return false;
        var cellType = typeof object[i][colName];
        if (cellType !== 'string' && cellType != 'number') return false;
      }
      if (i) {
        for (var colName in object[0]) {
          if (object[i][colName] === undefined) return false;
        }
      }
    }
    return true;
  }

  Polymer('tr-ui-a-generic-object-view', {
    ready: function() {
      this.object_ = undefined;
    },

    get object() {
      return this.object_;
    },

    set object(object) {
      this.object_ = object;
      this.updateContents_();
    },

    updateContents_: function() {
      this.$.content.textContent = '';
      this.appendElementsForType_('', this.object_, 0, 0, 5, '');
    },

    appendElementsForType_: function(
        label, object, indent, depth, maxDepth, suffix) {
      if (depth > maxDepth) {
        this.appendSimpleText_(
            label, indent, '<recursion limit reached>', suffix);
        return;
      }

      if (object === undefined) {
        this.appendSimpleText_(label, indent, 'undefined', suffix);
        return;
      }

      if (object === null) {
        this.appendSimpleText_(label, indent, 'null', suffix);
        return;
      }

      if (!(object instanceof Object)) {
        var type = typeof object;
        if (type == 'string') {
          var objectReplaced = false;
          if ((object[0] == '{' && object[object.length - 1] == '}') ||
              (object[0] == '[' && object[object.length - 1] == ']')) {
            try {
              object = JSON.parse(object);
              objectReplaced = true;
            } catch (e) {
            }
          }
          if (!objectReplaced) {
            if (object.indexOf('\n') !== -1) {
              var lines = object.split('\n');
              lines.forEach(function(line, i) {
                var text, ioff, ll, ss;
                if (i == 0) {
                  text = '"' + line;
                  ioff = 0;
                  ll = label;
                  ss = '';
                } else if (i < lines.length - 1) {
                  text = line;
                  ioff = 1;
                  ll = '';
                  ss = '';
                } else {
                  text = line + '"';
                  ioff = 1;
                  ll = '';
                  ss = suffix;
                }

                var el = this.appendSimpleText_(
                    ll, indent + ioff * label.length + ioff, text, ss);
                el.style.whiteSpace = 'pre';
                return el;
              }, this);
              return;
            } else {
              this.appendSimpleText_(
                  label, indent, '"' + object + '"', suffix);
              return;
            }
          }
          else {
            
          }
        } else {
          return this.appendSimpleText_(label, indent, object, suffix);
        }
      }

      if (object instanceof tr.model.ObjectSnapshot) {
        var link = document.createElement('tr-ui-a-analysis-link');
        link.selection = new tr.model.EventSet(object);
        this.appendElementWithLabel_(label, indent, link, suffix);
        return;
      }

      if (object instanceof tr.model.ObjectInstance) {
        var link = document.createElement('tr-ui-a-analysis-link');
        link.selection = new tr.model.EventSet(object);
        this.appendElementWithLabel_(label, indent, link, suffix);
        return;
      }

      if (object instanceof tr.b.Rect) {
        this.appendSimpleText_(label, indent, object.toString(), suffix);
        return;
      }

      if (object instanceof tr.b.u.Scalar) {
        var el = this.ownerDocument.createElement('tr-ui-u-scalar-span');
        el.value = object;
        this.appendElementWithLabel_(label, indent, el, suffix);
        return;
      }

      if (object instanceof Array) {
        this.appendElementsForArray_(
            label, object, indent, depth, maxDepth, suffix);
        return;
      }

      this.appendElementsForObject_(
          label, object, indent, depth, maxDepth, suffix);
    },

    appendElementsForArray_: function(
        label, object, indent, depth, maxDepth, suffix) {
      if (object.length == 0) {
        this.appendSimpleText_(label, indent, '[]', suffix);
        return;
      }

      if (isTable(object)) {
        var table = document.createElement('tr-ui-b-table');
        var columns = [];
        tr.b.iterItems(object[0], function(colName) {
          columns.push({title: colName, value: function(row) {
            return row[colName];
          }});
        });
        table.tableColumns = columns;
        table.tableRows = object;
        this.appendElementWithLabel_(label, indent, table, suffix);
        table.rebuild();
        return;
      }

      this.appendElementsForType_(
          label + '[',
          object[0],
          indent, depth + 1, maxDepth,
          object.length > 1 ? ',' : ']' + suffix);
      for (var i = 1; i < object.length; i++) {
        this.appendElementsForType_(
            '',
            object[i],
            indent + label.length + 1, depth + 1, maxDepth,
            i < object.length - 1 ? ',' : ']' + suffix);
      }
      return;
    },

    appendElementsForObject_: function(
        label, object, indent, depth, maxDepth, suffix) {
      var keys = tr.b.dictionaryKeys(object);
      if (keys.length == 0) {
        this.appendSimpleText_(label, indent, '{}', suffix);
        return;
      }

      this.appendElementsForType_(
          label + '{' + keys[0] + ': ',
          object[keys[0]],
          indent, depth, maxDepth,
          keys.length > 1 ? ',' : '}' + suffix);
      for (var i = 1; i < keys.length; i++) {
        this.appendElementsForType_(
            keys[i] + ': ',
            object[keys[i]],
            indent + label.length + 1, depth + 1, maxDepth,
            i < keys.length - 1 ? ',' : '}' + suffix);
      }
    },

    appendElementWithLabel_: function(label, indent, dataElement, suffix) {
      var row = document.createElement('div');

      var indentSpan = document.createElement('span');
      indentSpan.style.whiteSpace = 'pre';
      for (var i = 0; i < indent; i++)
        indentSpan.textContent += ' ';
      row.appendChild(indentSpan);

      var labelSpan = document.createElement('span');
      labelSpan.textContent = label;
      row.appendChild(labelSpan);

      row.appendChild(dataElement);
      var suffixSpan = document.createElement('span');
      suffixSpan.textContent = suffix;
      row.appendChild(suffixSpan);

      row.dataElement = dataElement;
      this.$.content.appendChild(row);
    },

    appendSimpleText_: function(label, indent, text, suffix) {
      var el = this.ownerDocument.createElement('span');
      el.textContent = text;
      this.appendElementWithLabel_(label, indent, el, suffix);
      return el;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-generic-object-view-with-label', {
    ready: function() {
      this.labelEl_ = document.createElement('div');
      this.genericObjectView_ =
          document.createElement('tr-ui-a-generic-object-view');
      this.shadowRoot.appendChild(this.labelEl_);
      this.shadowRoot.appendChild(this.genericObjectView_);
    },

    get label() {
      return this.labelEl_.textContent;
    },

    set label(label) {
      this.labelEl_.textContent = label;
    },

    get object() {
      return this.genericObjectView_.object;
    },

    set object(object) {
      this.genericObjectView_.object = object;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-stack-frame', {
    ready: function() {
      this.stackFrame_ = undefined;
      this.$.table.tableColumns = [];
      this.$.table.showHeader = true;
    },

    get stackFrame() {
      return this.stackFrame_;
    },

    set stackFrame(stackFrame) {
      var table = this.$.table;

      this.stackFrame_ = stackFrame;
      if (stackFrame === undefined) {
        table.tableColumns = [];
        table.tableRows = [];
        table.rebuild();
        return;
      }

      var hasCategory = false;
      var hasName = false;
      var hasTitle = false;

      table.tableRows = stackFrame.stackTrace;
      table.tableRows.forEach(function(row) {
        hasCategory |= row.category !== undefined;
        hasName |= row.name !== undefined;
        hasTitle |= row.title !== undefined;
      });

      var cols = [];
      if (hasCategory) {
        cols.push({
          title: 'Category',
          value: function(row) { return row.category; }
        });
      }

      if (hasName) {
        cols.push({
          title: 'Name',
          value: function(row) { return row.name; }
        });
      }

      if (hasTitle) {
        cols.push({
          title: 'Title',
          value: function(row) { return row.title; }
        });
      }

      table.tableColumns = cols;
      table.rebuild();
    },

    tableForTesting: function() {
      return this.$.table;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-event-sub-view', {
    ready: function() {
      this.currentSelection_ = undefined;
      this.$.table.tableColumns = [
        {
          title: 'Label',
          value: function(row) { return row.name; },
          width: '150px'
        },
        {
          title: 'Value',
          width: '100%',
          value: function(row) { return row.value; }
        }
      ];
      this.$.table.showHeader = false;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      if (selection.length !== 1)
        throw new Error('Only supports single slices');
      this.setSelectionWithoutErrorChecks(selection);
    },

    setSelectionWithoutErrorChecks: function(selection) {
      this.currentSelection_ = selection;
      this.updateContents_();
    },

    getEventRows_: function(event) {
      var rows = [];

      if (event.error)
        rows.push({ name: 'Error', value: event.error });

      if (event.title)
        rows.push({ name: 'Title', value: event.title });

      if (event.category)
        rows.push({ name: 'Category', value: event.category });

      if (event.name)
        rows.push({ name: 'Name', value: event.name });

      var startEl = document.createElement('tr-ui-u-time-stamp-span');
      startEl.timestamp = event.start;
      rows.push({ name: 'Start', value: startEl });

      if (event.duration) {
        var wallDurationEl = document.createElement(
            'tr-ui-u-time-duration-span');
        wallDurationEl.duration = event.duration;
        rows.push({ name: 'Wall Duration', value: wallDurationEl });
      }

      if (event.cpuDuration) {
        var cpuDurationEl = document.createElement(
            'tr-ui-u-time-duration-span');
        cpuDurationEl.duration = event.cpuDuration;
        rows.push({ name: 'CPU Duration', value: cpuDurationEl });
      }

      if (event.subSlices !== undefined && event.subSlices.length !== 0) {
        if (event.selfTime) {
          var selfTimeEl = document.createElement('tr-ui-u-time-duration-span');
          selfTimeEl.duration = event.selfTime;
          rows.push({ name: 'Self Time', value: selfTimeEl });
        }

        if (event.cpuSelfTime) {
          var cpuSelfTimeEl = document.createElement(
              'tr-ui-u-time-duration-span');
          cpuSelfTimeEl.duration = event.cpuSelfTime;
          if (event.cpuSelfTime > event.selfTime) {
            cpuSelfTimeEl.warning =
                ' Note that CPU Self Time is larger than Self Time. ' +
                'This is a known limitation of this system, which occurs ' +
                'due to several subslices, rounding issues, and imprecise ' +
                'time at which we get cpu- and real-time.';
          }
          rows.push({name: 'CPU Self Time',
                     value: cpuSelfTimeEl});
        }
      }

      if (event.durationInUserTime) {
        var durationInUserTimeEl = document.createElement(
            'tr-ui-u-time-duration-span');
        durationInUserTimeEl.duration = event.durationInUserTime;
        rows.push({ name: 'Duration (U)', value: durationInUserTimeEl });
      }

      function createStackFrameEl(sf) {
        var sfEl = document.createElement('tr-ui-a-stack-frame');
        sfEl.stackFrame = sf;
        return sfEl;
      }
      if (event.startStackFrame && event.endStackFrame) {
        if (event.startStackFrame === event.endStackFrame) {
          rows.push({name: 'Start+End Stack Trace',
              value: createStackFrameEl(event.startStackFrame)});

        } else {
          rows.push({ name: 'Start Stack Trace',
              value: createStackFrameEl(event.startStackFrame)});
          rows.push({ name: 'End Stack Trace',
              value: createStackFrameEl(event.endStackFrame)});
        }
      } else if (event.startStackFrame) {
        rows.push({ name: 'Start Stack Trace',
            value: createStackFrameEl(event.startStackFrame)});

      } else if (event.endStackFrame) {
        rows.push({ name: 'End Stack Trace',
            value: createStackFrameEl(event.endStackFrame)});
      }

      if (event.info) {
        var descriptionEl = tr.ui.b.createDiv({
            textContent: event.info.description,
            maxWidth: '300px'
        });
        rows.push({
          name: 'Description',
          value: descriptionEl
        });


        if (event.info.docLinks) {
          event.info.docLinks.forEach(function(linkObject) {
            var linkEl = document.createElement('a');
            linkEl.target = '_blank';
            linkEl.href = linkObject.href;
            linkEl.textContent = linkObject.textContent;
            rows.push({
              name: linkObject.label,
              value: linkEl
            });
          });
        }
      }

      if (event.associatedAlerts.length) {
        var alertSubRows = [];
        event.associatedAlerts.forEach(function(alert) {
          var linkEl = document.createElement('tr-ui-a-analysis-link');
          linkEl.setSelectionAndContent(function() {
            return new tr.model.EventSet(alert);
          }, alert.info.description);
          alertSubRows.push({
            name: alert.title,
            value: linkEl
          });
        });

        rows.push({
          name: 'Alerts', value: '',
          isExpanded: true, subRows: alertSubRows
        });
      }
      return rows;
    },

    addArgsToRows_: function(rows, args) {
      var n = 0;
      for (var argName in args) {
        n += 1;
      }
      if (n > 0) {
        var subRows = [];
        for (var argName in args) {
          var argView =
              document.createElement('tr-ui-a-generic-object-view');
          argView.object = args[argName];
          subRows.push({ name: argName,
                      value: argView});
        }
        rows.push({
          name: 'Args', value: '',
          isExpanded: true, subRows: subRows
        });
      }
      return rows;
    },

    updateContents_: function() {
      if (this.currentSelection_ === undefined) {
        this.$.table.rows = [];
        this.$.table.rebuild();
        return;
      }

      var event = this.currentSelection_[0];

      var rows = this.getEventRows_(event);
      if (event.argsStripped)
        rows.push({ name: 'Args', value: 'Stripped' });
      else
        this.addArgsToRows_(rows, event.args);

      this.$.table.tableRows = rows;
      this.$.table.rebuild();
    }
  });
  

'use strict';

tr.exportTo('tr.ui.analysis', function() {
  var FLOW_IN = 0x1;
  var FLOW_OUT = 0x2;
  var FLOW_IN_OUT = FLOW_IN | FLOW_OUT;

  function FlowClassifier() {
    this.numEvents_ = 0;
    this.eventsByGUID_ = {};
  }

  FlowClassifier.prototype = {
    getFS_: function(event) {
      var fs = this.eventsByGUID_[event.guid];
      if (fs === undefined) {
        this.numEvents_++;
        fs = {
          state: 0,
          event: event
        };
        this.eventsByGUID_[event.guid] = fs;
      }
      return fs;
    },

    addInFlow: function(event) {
      var fs = this.getFS_(event);
      fs.state |= FLOW_IN;
      return event;
    },

    addOutFlow: function(event) {
      var fs = this.getFS_(event);
      fs.state |= FLOW_OUT;
      return event;
    },

    hasEvents: function() {
      return this.numEvents_ > 0;
    },

    get inFlowEvents() {
      var selection = new tr.model.EventSet();
      for (var guid in this.eventsByGUID_) {
        var fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_IN)
          selection.push(fs.event);
      }
      return selection;
    },

    get outFlowEvents() {
      var selection = new tr.model.EventSet();
      for (var guid in this.eventsByGUID_) {
        var fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_OUT)
          selection.push(fs.event);
      }
      return selection;
    },

    get internalFlowEvents() {
      var selection = new tr.model.EventSet();
      for (var guid in this.eventsByGUID_) {
        var fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_IN_OUT)
          selection.push(fs.event);
      }
      return selection;
    }
  };

  return {
    FlowClassifier: FlowClassifier
  };
});


  'use strict';

  Polymer('tr-ui-a-related-events', {
    ready: function() {
      this.eventGroups_ = [];
      this.cancelFunctions_ = [];

      this.$.table.tableColumns = [
        {
          title: 'Event(s)',
          value: function(row) {
            var typeEl = document.createElement('span');
            typeEl.innerText = row.type;
            if (row.tooltip)
              typeEl.title = row.tooltip;
            return typeEl;
          },
          width: '150px'
        },
        {
          title: 'Link',
          width: '100%',
          value: function(row) {
            var linkEl = document.createElement('tr-ui-a-analysis-link');
            if (row.name)
              linkEl.setSelectionAndContent(row.selection, row.name);
            else
              linkEl.selection = row.selection;
            return linkEl;
          }
        }
      ];
    },

    hasRelatedEvents: function() {
      return (this.eventGroups_ && this.eventGroups_.length > 0);
    },

    setRelatedEvents: function(eventSet) {
      this.cancelAllTasks_();
      this.eventGroups_ = [];
      this.addConnectedFlows_(eventSet);
      this.addConnectedEvents_(eventSet);
      this.addOverlappingSamples_(eventSet);
      this.updateContents_();
    },

    addConnectedFlows_: function(eventSet) {
      var classifier = new tr.ui.analysis.FlowClassifier();
      eventSet.forEach(function(slice) {
        if (slice.inFlowEvents) {
          slice.inFlowEvents.forEach(function(flow) {
            classifier.addInFlow(flow);
          });
        }
        if (slice.outFlowEvents) {
          slice.outFlowEvents.forEach(function(flow) {
            classifier.addOutFlow(flow);
          });
        }
      });
      if (!classifier.hasEvents())
        return;

      var addToEventGroups = function(type, flowEvent) {
        this.eventGroups_.push({
          type: type,
          selection: new tr.model.EventSet(flowEvent),
          name: flowEvent.title
        });
      };

      classifier.inFlowEvents.forEach(
          addToEventGroups.bind(this, 'Incoming flow'));
      classifier.outFlowEvents.forEach(
          addToEventGroups.bind(this, 'Outgoing flow'));
      classifier.internalFlowEvents.forEach(
          addToEventGroups.bind(this, 'Internal flow'));
    },

    cancelAllTasks_: function() {
      this.cancelFunctions_.forEach(function(cancelFunction) {
        cancelFunction();
      });
      this.cancelFunctions_ = [];
    },

    addConnectedEvents_: function(eventSet) {
      this.cancelFunctions_.push(this.createEventsLinkIfNeeded_(
          'Preceding events',
          'Add all events that have led to the selected one(s), connected by ' +
              'flow arrows or by call stack.',
          eventSet,
          function(event, events) {
            this.addInFlowEvents_(event, events);
            this.addAncestors_(event, events);
            if (event.startSlice)
              events.push(event.startSlice);
          }.bind(this)));
      this.cancelFunctions_.push(this.createEventsLinkIfNeeded_(
          'Following events',
          'Add all events that have been caused by the selected one(s), ' +
              'connected by flow arrows or by call stack.',
          eventSet,
          function(event, events) {
            this.addOutFlowEvents_(event, events);
            this.addDescendents_(event, events);
            if (event.endSlice)
              events.push(event.endSlice);
          }.bind(this)));
      this.cancelFunctions_.push(this.createEventsLinkIfNeeded_(
          'All connected events',
          'Add all events connected to the selected one(s) by flow arrows or ' +
              'by call stack.',
          eventSet,
          function(event, events) {
            this.addInFlowEvents_(event, events);
            this.addOutFlowEvents_(event, events);
            this.addAncestors_(event, events);
            this.addDescendents_(event, events);
            if (event.startSlice)
              events.push(event.startSlice);
            if (event.endSlice)
              events.push(event.endSlice);
          }.bind(this)));
    },

    createEventsLinkIfNeeded_: function(title, tooltip, events, addFunction) {
      events = new tr.model.EventSet(events);
      var lengthBefore = events.length;
      var task;
      var isCanceled = false;
      function addEventsUntilTimeout(startingIndex) {
        if (isCanceled)
          return;
        var startingTime = window.performance.now();
        while (startingIndex < events.length) {
          addFunction(events[startingIndex], events);
          startingIndex++;
                    if (window.performance.now() - startingTime > 8) {
            var newTask = new tr.b.Task(
                addEventsUntilTimeout.bind(this, startingIndex), this);
            task.after(newTask);
            task = newTask;
            return;
          }
        }
                if (lengthBefore === events.length)
          return;
        this.eventGroups_.push({
          type: title,
          tooltip: tooltip,
          selection: events
        });
        this.updateContents_();
      };
      function cancelTask() {
        isCanceled = true;
      }
      task = new tr.b.Task(addEventsUntilTimeout.bind(this, 0), this);
      tr.b.Task.RunWhenIdle(task);
      return cancelTask;
    },

    addInFlowEvents_: function(event, eventSet) {
      if (!event.inFlowEvents)
        return;
      event.inFlowEvents.forEach(function(e) {
        eventSet.push(e);
      });
    },

    addOutFlowEvents_: function(event, eventSet) {
      if (!event.outFlowEvents)
        return;
      event.outFlowEvents.forEach(function(e) {
        eventSet.push(e);
      });
    },

    addAncestors_: function(event, eventSet) {
      if (!event.iterateAllAncestors)
        return;
      event.iterateAllAncestors(function(e) {
        eventSet.push(e);
      });
    },

    addDescendents_: function(event, eventSet) {
      if (!event.iterateAllDescendents)
        return;
      event.iterateAllDescendents(function(e) {
        eventSet.push(e);
      });
    },

    addOverlappingSamples_: function(eventSet) {
      var samples = new tr.model.EventSet;
      eventSet.forEach(function(slice) {
        if (!slice.parentContainer || !slice.parentContainer.samples)
          return;
        var candidates = slice.parentContainer.samples;
        var range = tr.b.Range.fromExplicitRange(
            slice.start, slice.start + slice.duration);
        var filteredSamples = range.filterArray(
            candidates, function(value) {return value.start;});
        filteredSamples.forEach(function(sample) {
          samples.push(sample);
        });
      }.bind(this));
      if (samples.length > 0) {
        this.eventGroups_.push({
          type: 'Overlapping samples',
          tooltip: 'All samples overlapping the selected slice(s).',
          selection: samples
        });
      }
    },

    updateContents_: function() {
      var table = this.$.table;
      if (this.eventGroups_ === undefined)
        table.tableRows = [];
      else
        table.tableRows = this.eventGroups_.slice();
      table.rebuild();
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-thread-slice-sub-view', {
    get selection() {
      return this.$.content.selection;
    },

    set selection(selection) {
      this.$.content.selection = selection;
      this.$.relatedEvents.setRelatedEvents(selection);
      if (this.$.relatedEvents.hasRelatedEvents())
        this.$.relatedEvents.style.display = '';
      else
        this.$.relatedEvents.style.display = 'none';
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-selection-summary-table', {
    created: function() {
      this.selection_ = new tr.b.Range();
    },

    ready: function() {
      this.$.table.showHeader = false;
      this.$.table.tableColumns = [
        {
          title: 'Name',
          value: function(row) { return row.title; },
          width: '350px'
        },
        {
          title: 'Value',
          width: '100%',
          value: function(row) {
            return row.value;
          }
        }
      ];
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      this.selection_ = selection;
      this.updateContents_();
    },

    updateContents_: function() {
      var selection = this.selection_;
      var rows = [];
      var hasRange;
      if (this.selection_ && (!selection.bounds.isEmpty))
        hasRange = true;
      else
        hasRange = false;

      var timeSpanConfig = {ownerDocument: this.ownerDocument};

      rows.push({
        title: 'Selection start',
        value: hasRange ? tr.ui.units.createTimeStampSpan(
            selection.bounds.min, timeSpanConfig) : '<empty>'
      });
      rows.push({
        title: 'Selection extent',
        value: hasRange ? tr.ui.units.createTimeDurationSpan(
            selection.bounds.range, timeSpanConfig) : '<empty>'
      });

      this.$.table.tableRows = rows;
      this.$.table.rebuild();
    }
  });
  

'use strict';

tr.exportTo('tr.b', function() {

  function identity(d) {
    return d;
  }

  function Statistics() {
  }

  /* Returns the quotient, or zero if the denominator is zero.*/
  Statistics.divideIfPossibleOrZero = function(numerator, denominator) {
    if (denominator === 0)
      return 0;
    return numerator / denominator;
  }

  Statistics.sum = function(ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var ret = 0;
    for (var i = 0; i < ary.length; i++)
      ret += func.call(opt_this, ary[i], i);
    return ret;
  };

  Statistics.mean = function(ary, opt_func, opt_this) {
    return Statistics.sum(ary, opt_func, opt_this) / ary.length;
  };

  Statistics.variance = function(ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var mean = Statistics.mean(ary, func, opt_this);
    var sumOfSquaredDistances = Statistics.sum(
        ary,
        function(d, i) {
          var v = func.call(this, d, i) - mean;
          return v * v;
        },
        opt_this);
    return sumOfSquaredDistances / (ary.length - 1);
  };

  Statistics.stddev = function(ary, opt_func, opt_this) {
    return Math.sqrt(
        Statistics.variance(ary, opt_func, opt_this));
  };

  Statistics.max = function(ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var ret = -Infinity;
    for (var i = 0; i < ary.length; i++)
      ret = Math.max(ret, func.call(opt_this, ary[i], i));
    return ret;
  };

  Statistics.min = function(ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var ret = Infinity;
    for (var i = 0; i < ary.length; i++)
      ret = Math.min(ret, func.call(opt_this, ary[i], i));
    return ret;
  };

  Statistics.range = function(ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var ret = new tr.b.Range();
    for (var i = 0; i < ary.length; i++)
      ret.addValue(func.call(opt_this, ary[i], i));
    return ret;
  }

  Statistics.percentile = function(ary, percent, opt_func, opt_this) {
    if (!(percent >= 0 && percent <= 1))
      throw new Error('percent must be [0,1]');

    var func = opt_func || identity;
    var tmp = new Array(ary.length);
    for (var i = 0; i < ary.length; i++)
      tmp[i] = func.call(opt_this, ary[i], i);
    tmp.sort();
    var idx = Math.floor((ary.length - 1) * percent);
    return tmp[idx];
  };

  /* Clamp a value between some low and high value. */
  Statistics.clamp = function(value, opt_low, opt_high) {
    opt_low = opt_low || 0.0;
    opt_high = opt_high || 1.0;
    return Math.min(Math.max(value, opt_low), opt_high);
  }

  /**
   * Sorts the samples, and map them linearly to the range [0,1].
   *
   * They're mapped such that for the N samples, the first sample is 0.5/N and
   * the last sample is (N-0.5)/N.
   *
   * Background: The discrepancy of the sample set i/(N-1); i=0, ..., N-1 is
   * 2/N, twice the discrepancy of the sample set (i+1/2)/N; i=0, ..., N-1. In
   * our case we don't want to distinguish between these two cases, as our
   * original domain is not bounded (it is for Monte Carlo integration, where
   * discrepancy was first used).
   **/
  Statistics.normalizeSamples = function(samples) {
    if (samples.length === 0) {
      return {
        normalized_samples: samples,
        scale: 1.0
      };
    }
    // Create a copy to make sure that we don't mutate original |samples| input.
    samples = samples.slice().sort(
      function(a, b) {
        return a - b;
      }
    );
    var low = Math.min.apply(null, samples);
    var high = Math.max.apply(null, samples);
    var new_low = 0.5 / samples.length;
    var new_high = (samples.length - 0.5) / samples.length;
    if (high - low === 0.0) {
      // Samples is an array of 0.5 in this case.
      samples = Array.apply(null, new Array(samples.length)).map(
        function() { return 0.5;});
      return {
        normalized_samples: samples,
        scale: 1.0
      };
    }
    var scale = (new_high - new_low) / (high - low);
    for (var i = 0; i < samples.length; i++) {
      samples[i] = (samples[i] - low) * scale + new_low;
    }
    return {
      normalized_samples: samples,
      scale: scale
    };
  }

  /**
   * Computes the discrepancy of a set of 1D samples from the interval [0,1].
   *
   * The samples must be sorted. We define the discrepancy of an empty set
   * of samples to be zero.
   *
   * http://en.wikipedia.org/wiki/Low-discrepancy_sequence
   * http://mathworld.wolfram.com/Discrepancy.html
   */
  Statistics.discrepancy = function(samples, opt_location_count) {
    if (samples.length === 0)
      return 0.0;

    var max_local_discrepancy = 0;
    var inv_sample_count = 1.0 / samples.length;
    var locations = [];
    // For each location, stores the number of samples less than that location.
    var count_less = [];
    // For each location, stores the number of samples less than or equal to
    // that location.
    var count_less_equal = [];

    if (opt_location_count !== undefined) {
      // Generate list of equally spaced locations.
      var sample_index = 0;
      for (var i = 0; i < opt_location_count; i++) {
        var location = i / (opt_location_count - 1);
        locations.push(location);
        while (sample_index < samples.length &&
          samples[sample_index] < location) {
          sample_index += 1;
        }
        count_less.push(sample_index);
        while (sample_index < samples.length &&
            samples[sample_index] <= location) {
          sample_index += 1;
        }
        count_less_equal.push(sample_index);
      }
    } else {
      // Populate locations with sample positions. Append 0 and 1 if necessary.
      if (samples[0] > 0.0) {
        locations.push(0.0);
        count_less.push(0);
        count_less_equal.push(0);
      }
      for (var i = 0; i < samples.length; i++) {
        locations.push(samples[i]);
        count_less.push(i);
        count_less_equal.push(i + 1);
      }
      if (samples[-1] < 1.0) {
        locations.push(1.0);
        count_less.push(samples.length);
        count_less_equal.push(samples.length);
      }
    }
    // Iterate over the intervals defined by any pair of locations.
    for (var i = 0; i < locations.length; i++) {
      for (var j = i + 1; j < locations.length; j++) {
        // Length of interval
        var length = locations[j] - locations[i];

        // Local discrepancy for closed interval
        var count_closed = count_less_equal[j] - count_less[i];
        var local_discrepancy_closed = Math.abs(
          count_closed * inv_sample_count - length);
        var max_local_discrepancy = Math.max(
          local_discrepancy_closed, max_local_discrepancy);

        // Local discrepancy for open interval
        var count_open = count_less[j] - count_less_equal[i];
        var local_discrepancy_open = Math.abs(
          count_open * inv_sample_count - length);
        var max_local_discrepancy = Math.max(
          local_discrepancy_open, max_local_discrepancy);
      }
    }
    return max_local_discrepancy;
  };

  /**
   * A discrepancy based metric for measuring timestamp jank.
   *
   * timestampsDiscrepancy quantifies the largest area of jank observed in a
   * series of timestamps.  Note that this is different from metrics based on
   * the max_time_interval. For example, the time stamp series A = [0,1,2,3,5,6]
   *  and B = [0,1,2,3,5,7] have the same max_time_interval = 2, but
   * Discrepancy(B) > Discrepancy(A).
   *
   * Two variants of discrepancy can be computed:
   *
   * Relative discrepancy is following the original definition of
   * discrepancy. It characterized the largest area of jank, relative to the
   * duration of the entire time stamp series.  We normalize the raw results,
   * because the best case discrepancy for a set of N samples is 1/N (for
   * equally spaced samples), and we want our metric to report 0.0 in that
   * case.
   *
   * Absolute discrepancy also characterizes the largest area of jank, but its
   * value wouldn't change (except for imprecisions due to a low
   * |interval_multiplier|) if additional 'good' intervals were added to an
   * exisiting list of time stamps.  Its range is [0,inf] and the unit is
   * milliseconds.
   *
   * The time stamp series C = [0,2,3,4] and D = [0,2,3,4,5] have the same
   * absolute discrepancy, but D has lower relative discrepancy than C.
   *
   * |timestamps| may be a list of lists S = [S_1, S_2, ..., S_N], where each
   * S_i is a time stamp series. In that case, the discrepancy D(S) is:
   * D(S) = max(D(S_1), D(S_2), ..., D(S_N))
   **/
  Statistics.timestampsDiscrepancy = function(timestamps, opt_absolute,
                            opt_location_count) {
    if (timestamps.length === 0)
      return 0.0;

    if (opt_absolute === undefined)
      opt_absolute = true;

    if (Array.isArray(timestamps[0])) {
      var range_discrepancies = timestamps.map(function(r) {
        return Statistics.timestampsDiscrepancy(r);
      });
      return Math.max.apply(null, range_discrepancies);
    }

    var s = Statistics.normalizeSamples(timestamps);
    var samples = s.normalized_samples;
    var sample_scale = s.scale;
    var discrepancy = Statistics.discrepancy(samples, opt_location_count);
    var inv_sample_count = 1.0 / samples.length;
    if (opt_absolute === true) {
      // Compute absolute discrepancy
      discrepancy /= sample_scale;
    } else {
      // Compute relative discrepancy
      discrepancy = Statistics.clamp(
        (discrepancy - inv_sample_count) / (1.0 - inv_sample_count));
    }
    return discrepancy;
  };

  /**
   * A discrepancy based metric for measuring duration jank.
   *
   * DurationsDiscrepancy computes a jank metric which measures how irregular a
   * given sequence of intervals is. In order to minimize jank, each duration
   * should be equally long. This is similar to how timestamp jank works,
   * and we therefore reuse the timestamp discrepancy function above to compute
   * a similar duration discrepancy number.
   *
   * Because timestamp discrepancy is defined in terms of timestamps, we first
   * convert the list of durations to monotonically increasing timestamps.
   *
   * Args:
   *  durations: List of interval lengths in milliseconds.
   *  absolute: See TimestampsDiscrepancy.
   *  opt_location_count: See TimestampsDiscrepancy.
   **/
  Statistics.durationsDiscrepancy = function(
    durations, opt_absolute, opt_location_count) {
      if (durations.length === 0)
      return 0.0;

    var timestamps = durations.reduce(function(prev, curr, index, array) {
      prev.push(prev[prev.length - 1] + curr);
      return prev;
    }, [0]);
    return Statistics.timestampsDiscrepancy(
      timestamps, opt_absolute, opt_location_count);
  }

  return {
    Statistics: Statistics
  };
});


'use strict';
tr.exportTo('tr.ui.analysis', function() {
  function MultiEventSummary(title, events) {
    this.title = title;
    this.duration_ = undefined;
    this.selfTime_ = undefined;
    this.events_ = events;

    this.cpuTimesComputed_ = false;
    this.cpuSelfTime_ = undefined;
    this.cpuDuration_ = undefined;

    this.maxDuration_ = undefined;
    this.maxCpuDuration_ = undefined;
    this.maxSelfTime_ = undefined;
    this.maxCpuSelfTime_ = undefined;

    this.untotallableArgs_ = [];
    this.totalledArgs_ = undefined;
  };
  MultiEventSummary.prototype = {

    set title(title) {
      if (title == 'Totals')
        this.totalsRow = true;
      this.title_ = title;
    },

    get title() {
      return this.title_;
    },

    get duration() {
      if (this.duration_ === undefined) {
        this.duration_ = tr.b.Statistics.sum(
            this.events_, function(event) {
                return event.duration;
            });
      }
      return this.duration_;
    },

    get cpuSelfTime() {
      this.computeCpuTimesIfNeeded_();
      return this.cpuSelfTime_;
    },

    get cpuDuration() {
      this.computeCpuTimesIfNeeded_();
      return this.cpuDuration_;
    },

    computeCpuTimesIfNeeded_: function() {
      if (this.cpuTimesComputed_)
        return;
      this.cpuTimesComputed_ = true;

      var cpuSelfTime = 0;
      var cpuDuration = 0;
      var hasCpuData = false;
      for (var i = 0; i < this.events_.length; i++) {
        var event = this.events_[i];
        if (event.cpuDuration !== undefined) {
          cpuDuration += event.cpuDuration;
          hasCpuData = true;
        }

        if (event.cpuSelfTime !== undefined) {
          cpuSelfTime += event.cpuSelfTime;
          hasCpuData = true;
        }
      }
      if (hasCpuData) {
        this.cpuDuration_ = cpuDuration;
        this.cpuSelfTime_ = cpuSelfTime;
      }
    },

    get selfTime() {
      if (this.selfTime_ === undefined) {
        this.selfTime_ = 0;
        for (var i = 0; i < this.events_.length; i++) {
          if (this.events_[i].selfTime !== undefined)
            this.selfTime_ += this.events[i].selfTime;
        }
      }
      return this.selfTime_;
    },

    get events() {
      return this.events_;
    },

    get numEvents() {
      return this.events_.length;
    },

    get numAlerts() {
      if (this.numAlerts_ === undefined) {
        this.numAlerts_ = tr.b.Statistics.sum(this.events_, function(event) {
          return event.associatedAlerts.length;
        });
      }
      return this.numAlerts_;
    },

    get untotallableArgs() {
      this.updateArgsIfNeeded_();
      return this.untotallableArgs_;
    },

    get totalledArgs() {
      this.updateArgsIfNeeded_();
      return this.totalledArgs_;
    },


    get maxDuration() {
      if (this.maxDuration_ === undefined) {
        this.maxDuration_ = tr.b.Statistics.max(
            this.events_, function(event) {
                return event.duration;
            });
      }
      return this.maxDuration_;
    },


    get maxCpuDuration() {
      if (this.maxCpuDuration_ === undefined) {
        this.maxCpuDuration_ = tr.b.Statistics.max(
            this.events_, function(event) {
                return event.cpuDuration;
            });
      }
      return this.maxCpuDuration_;
    },


    get maxSelfTime() {
      if (this.maxSelfTime_ === undefined) {
        this.maxSelfTime_ = tr.b.Statistics.max(
            this.events_, function(event) {
                return event.selfTime;
            });
      }
      return this.maxSelfTime_;
    },


    get maxCpuSelfTime() {
      if (this.maxCpuSelfTime_ === undefined) {
        this.maxCpuSelfTime_ = tr.b.Statistics.max(
            this.events_, function(event) {
                return event.cpuSelfTime;
            });
      }
      return this.maxCpuSelfTime_;
    },


    updateArgsIfNeeded_: function() {
      if (this.totalledArgs_ !== undefined)
        return;

      var untotallableArgs = {};
      var totalledArgs = {};
      for (var i = 0; i < this.events_.length; i++) {
        var event = this.events_[i];
        for (var argName in event.args) {
          var argVal = event.args[argName];
          var type = typeof argVal;
          if (type !== 'number') {
            untotallableArgs[argName] = true;
            delete totalledArgs[argName];
            continue;
          }
          if (untotallableArgs[argName]) {
            continue;
          }

          if (totalledArgs[argName] === undefined)
            totalledArgs[argName] = 0;
          totalledArgs[argName] += argVal;
        }
      }
      this.untotallableArgs_ = tr.b.dictionaryKeys(untotallableArgs);
      this.totalledArgs_ = totalledArgs;
    }
  };

  return {
    MultiEventSummary: MultiEventSummary
  };
});


  'use strict';

  Polymer('tr-ui-a-multi-event-summary-table', {
    ready: function() {
      this.showTotals_ = false;
      this.eventsHaveDuration_ = true;
      this.eventsHaveSubRows_ = true;
      this.eventsByTitle_ = undefined;
    },

    updateTableColumns_: function(rows, maxValues) {
      var hasCpuData = false;
      var hasAlerts = false;
      rows.forEach(function(row) {
        if (row.cpuDuration !== undefined)
          hasCpuData = true;
        if (row.cpuSelfTime !== undefined)
          hasCpuData = true;
        if (row.numAlerts)
          hasAlerts = true;
      });

      var ownerDocument = this.ownerDocument;

      var columns = [];

      columns.push({
        title: 'Name',
        value: function(row) {
          if (row.title === 'Totals')
            return 'Totals';

          var linkEl = document.createElement('tr-ui-a-analysis-link');
          linkEl.setSelectionAndContent(function() {
            return new tr.model.EventSet(row.events);
          }, row.title);
          return linkEl;
        },
        width: '350px',
        cmp: function(rowA, rowB) {
          return rowA.title.localeCompare(rowB.title);
        }
      });
      if (this.eventsHaveDuration_) {
        columns.push({
          title: 'Wall Duration',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(row.duration, {
              total: row.totalsRow ? undefined : maxValues.duration,
              ownerDocument: ownerDocument,
              rightAlign: true
            });
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.duration - rowB.duration;
          }
        });
      }

      if (this.eventsHaveDuration_ && hasCpuData) {
        columns.push({
          title: 'CPU Duration',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(row.cpuDuration, {
              total: row.totalsRow ? undefined : maxValues.cpuDuration,
              ownerDocument: ownerDocument,
              rightAlign: true
            });
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.cpuDuration - rowB.cpuDuration;
          }
        });
      }

      if (this.eventsHaveSubRows_ && this.eventsHaveDuration_) {
        columns.push({
          title: 'Self time',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(row.selfTime, {
              total: row.totalsRow ? undefined : maxValues.selfTime,
              ownerDocument: ownerDocument,
              rightAlign: true
            });
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.selfTime - rowB.selfTime;
          }
        });
      }

      if (this.eventsHaveSubRows_ && this.eventsHaveDuration_ && hasCpuData) {
        columns.push({
          title: 'CPU Self Time',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(row.cpuSelfTime, {
              total: row.totalsRow ? undefined : maxValues.cpuSelfTime,
              ownerDocument: ownerDocument,
              rightAlign: true
            });
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.cpuSelfTime - rowB.cpuSelfTime;
          }
        });
      }
      columns.push({
        title: 'Occurrences',
        value: function(row) {
          return row.numEvents;
        },
        width: '<upated further down>',
        cmp: function(rowA, rowB) {
          return rowA.numEvents - rowB.numEvents;
        }
      });

      var alertsColumnIndex;
      if (hasAlerts) {
        columns.push({
          title: 'Num Alerts',
          value: function(row) {
            return row.numAlerts;
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.numAlerts - rowB.numAlerts;
          }
        });
        alertsColumnIndex = columns.length - 1;
      }
      var colWidthPercentage;
      if (columns.length == 1)
        colWidthPercentage = '100%';
      else
        colWidthPercentage = (100 / (columns.length - 1)).toFixed(3) + '%';

      for (var i = 1; i < columns.length; i++)
        columns[i].width = colWidthPercentage;

      this.$.table.tableColumns = columns;

      if (hasAlerts) {
        this.$.table.sortColumnIndex = alertsColumnIndex;
        this.$.table.sortDescending = true;
      }
    },

    configure: function(config) {
      if (config.eventsByTitle === undefined)
        throw new Error('Required: eventsByTitle');

      if (config.showTotals !== undefined)
        this.showTotals_ = config.showTotals;
      else
        this.showTotals_ = true;

      if (config.eventsHaveDuration !== undefined)
        this.eventsHaveDuration_ = config.eventsHaveDuration;
      else
        this.eventsHaveDuration_ = true;

      if (config.eventsHaveSubRows !== undefined)
        this.eventsHaveSubRows_ = config.eventsHaveSubRows;
      else
        this.eventsHaveSubRows_ = true;

      this.eventsByTitle_ = config.eventsByTitle;
      this.updateContents_();
    },

    get showTotals() {
      return this.showTotals_;
    },

    set showTotals(showTotals) {
      this.showTotals_ = showTotals;
      this.updateContents_();
    },

    get eventsHaveDuration() {
      return this.eventsHaveDuration_;
    },

    set eventsHaveDuration(eventsHaveDuration) {
      this.eventsHaveDuration_ = eventsHaveDuration;
      this.updateContents_();
    },

    get eventsHaveSubRows() {
      return this.eventsHaveSubRows_;
    },

    set eventsHaveSubRows(eventsHaveSubRows) {
      this.eventsHaveSubRows_ = eventsHaveSubRows;
      this.updateContents_();
    },

    get eventsByTitle() {
      return this.eventsByTitle_;
    },

    set eventsByTitle(eventsByTitle) {
      this.eventsByTitle_ = eventsByTitle;
      this.updateContents_();
    },

    get selectionBounds() {
      return this.selectionBounds_;
    },

    set selectionBounds(selectionBounds) {
      this.selectionBounds_ = selectionBounds;
      this.updateContents_();
    },

    updateContents_: function() {
      var eventsByTitle;
      if (this.eventsByTitle_ !== undefined)
        eventsByTitle = this.eventsByTitle_;
      else
        eventsByTitle = [];

      var allEvents = [];
      var rows = [];
      tr.b.iterItems(
          eventsByTitle,
          function(title, eventsOfSingleTitle) {
            allEvents.push.apply(allEvents, eventsOfSingleTitle);
            var row = new tr.ui.analysis.MultiEventSummary(
              title, eventsOfSingleTitle);
            rows.push(row);
          });

      this.updateTableColumns_(rows);
      this.$.table.tableRows = rows;

      var maxValues = {
        duration: undefined,
        selfTime: undefined,
        cpuSelfTime: undefined,
        cpuDuration: undefined
      };

      if (this.eventsHaveDuration) {
        for (var column in maxValues) {
          maxValues[column] = tr.b.Statistics.max(rows, function(event) {
                  return event[column];
          });
        }
      }

      var footerRows = [];

      if (this.showTotals_) {
        var multiEventSummary = new tr.ui.analysis.MultiEventSummary(
          'Totals', allEvents);
        footerRows.push(multiEventSummary);
      }


      this.updateTableColumns_(rows, maxValues);
      this.$.table.tableRows = rows;

      
      
      this.$.table.footerRows = footerRows;
      this.$.table.rebuild();
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-event-details-table', {
    created: function() {
      this.selection_ = undefined;
      this.eventsHaveDuration_ = true;
      this.eventsHaveSubRows_ = true;
    },

    ready: function() {
      this.initTitleTable_();
    },

    get eventsHaveDuration() {
      return this.eventsHaveDuration_;
    },

    set eventsHaveDuration(eventsHaveDuration) {
      this.eventsHaveDuration_ = eventsHaveDuration;
      this.updateContents_();
    },

    get eventsHaveSubRows() {
      return this.eventsHaveSubRows_;
    },

    set eventsHaveSubRows(eventsHaveSubRows) {
      this.eventsHaveSubRows_ = eventsHaveSubRows;
      this.updateContents_();
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      this.selection_ = selection;
      this.updateContents_();
    },

    updateContents_: function() {
      var selection = this.selection_;

      this.updateTitleTable_();

      if (this.selection_ === undefined) {
        this.$.table.tableRows = [];
        this.$.table.tableFooterRows = [];
        this.$.table.rebuild();
        return;
      }

      var summary = new tr.ui.analysis.MultiEventSummary(
          'Totals', this.selection_);
      this.updateColumns_(summary);
      this.updateRows_(summary);
      this.$.table.rebuild();
    },

    initTitleTable_: function() {
      var table = this.$.titletable;

      table.showHeader = false;
      table.tableColumns = [
        {
          title: 'Title',
          value: function(row) { return row.title; },
          width: '350px'
        },
        {
          title: 'Value',
          width: '100%',
          value: function(row) {
            return row.value;
          }
        }
      ];
    },

    updateTitleTable_: function() {
      var title;
      if (this.selection_ && this.selection_.length)
        title = this.selection_[0].title;
      else
        title = '<No selection>';

      var table = this.$.titletable;
      table.tableRows = [{
        title: 'Title',
        value: title
      }];
    },

    updateColumns_: function(summary) {
      var hasCpuData;
      if (summary.cpuDuration !== undefined)
        hasCpuData = true;
      if (summary.cpuSelfTime !== undefined)
        hasCpuData = true;

      var colWidthPercentage;
      if (hasCpuData)
        colWidthPercentage = '20%';
      else
        colWidthPercentage = '33.3333%';

      var timeSpanConfig = {ownerDocument: this.ownerDocument};
      var columns = [];

      columns.push({
        title: 'Start',
        value: function(row) {
          if (row.__proto__ === tr.ui.analysis.MultiEventSummary.prototype) {
            return row.title;
          }

          var linkEl = document.createElement('tr-ui-a-analysis-link');
          linkEl.setSelectionAndContent(function() {
              return new tr.model.EventSet(row.event);
          });
          linkEl.appendChild(tr.ui.units.createTimeStampSpan(
              row.start, timeSpanConfig));
          return linkEl;
        },
        width: '350px',
        cmp: function(rowA, rowB) {
          return rowA.start - rowB.start;
        }
      });

      if (this.eventsHaveDuration_) {
        columns.push({
          title: 'Wall Duration (ms)',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(
                row.duration, timeSpanConfig);
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.duration - rowB.duration;
          }
        });
      }

      if (this.eventsHaveDuration_ && hasCpuData) {
        columns.push({
          title: 'CPU Duration (ms)',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(
                row.cpuDuration, timeSpanConfig);
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.cpuDuration - rowB.cpuDuration;
          }
        });
      }

      if (this.eventsHaveSubRows_ && this.eventsHaveDuration_) {
        columns.push({
          title: 'Self time (ms)',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(
                row.selfTime, timeSpanConfig);
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.selfTime - rowB.selfTime;
          }
        });
      }

      if (this.eventsHaveSubRows_ && this.eventsHaveDuration_ && hasCpuData) {
        columns.push({
          title: 'CPU Self Time (ms)',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(
                row.cpuSelfTime, timeSpanConfig);
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            return rowA.cpuSelfTime - rowB.cpuSelfTime;
          }
        });
      }

      var argKeys = tr.b.dictionaryKeys(summary.totalledArgs);
      argKeys.sort();

      var otherKeys = summary.untotallableArgs.slice(0);
      otherKeys.sort();

      argKeys.push.apply(argKeys, otherKeys);
      var keysWithColumns = argKeys.slice(0, 4);
      var keysInOtherColumn = argKeys.slice(4);

      keysWithColumns.forEach(function(argKey) {

        var hasTotal = summary.totalledArgs[argKey];
        var colDesc = {
          title: 'Arg: ' + argKey,
          value: function(row) {
            if (row.__proto__ !== tr.ui.analysis.MultiEventSummary.prototype) {
              var argView =
                  document.createElement('tr-ui-a-generic-object-view');
              argView.object = row.args[argKey];
              return argView;
            }
            if (hasTotal)
              return row.totalledArgs[argKey];
            return '';
          },
          width: '<upated further down>'
        };
        if (hasTotal) {
          colDesc.cmp = function(rowA, rowB) {
            return rowA.args[argKey] - rowB.args[argKey];
          }
        }
        columns.push(colDesc);
      });

      if (keysInOtherColumn.length) {
        columns.push({
          title: 'Other Args',
          value: function(row) {
            if (row.__proto__ === tr.ui.analysis.MultiEventSummary.prototype)
              return '';
            var argView =
                document.createElement('tr-ui-a-generic-object-view');
            var obj = {};
            for (var i = 0; i < keysInOtherColumn.length; i++)
              obj[keysInOtherColumn[i]] = row.args[keysInOtherColumn[i]];
            argView.object = obj;
            return argView;
          },
          width: '<upated further down>'
        });
      }

      var colWidthPercentage;
      if (columns.length == 1)
        colWidthPercentage = '100%';
      else
        colWidthPercentage = (100 / (columns.length - 1)).toFixed(3) + '%';

      for (var i = 1; i < columns.length; i++)
        columns[i].width = colWidthPercentage;

      this.$.table.tableColumns = columns;
    },

    updateRows_: function(summary) {
      this.$.table.sortColumnIndex = 0;
      function Row(event) {
        this.event = event;
      }
      Row.prototype = {
        get start() { return this.event.start; },
        get duration() { return this.event.duration; },
        get cpuDuration() { return this.event.cpuDuration; },
        get selfTime() { return this.event.selfTime; },
        get cpuSelfTime() { return this.event.cpuSelfTime; },
        get args() { return this.event.args; }
      };

      this.$.table.tableRows = this.selection_.map(function(event) {
        return new Row(event);
      });
      this.$.table.footerRows = [summary];
    }
  });


  'use strict';

  Polymer('tr-ui-a-multi-event-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
      this.eventsHaveDuration_ = true;
      this.eventsHaveSubRows_ = true;
    },

    set selection(selection) {
      if (selection.length <= 1)
        throw new Error('Only supports multiple items');
      this.setSelectionWithoutErrorChecks(selection);
    },

    get selection() {
      return this.currentSelection_;
    },

    setSelectionWithoutErrorChecks: function(selection) {
      this.currentSelection_ = selection;
      this.updateContents_();
    },

    get eventsHaveDuration() {
      return this.eventsHaveDuration_;
    },

    set eventsHaveDuration(eventsHaveDuration) {
      this.eventsHaveDuration_ = eventsHaveDuration;
      this.updateContents_();
    },

    get eventsHaveSubRows() {
      return this.eventsHaveSubRows_;
    },

    set eventsHaveSubRows(eventsHaveSubRows) {
      this.eventsHaveSubRows_ = eventsHaveSubRows;
      this.updateContents_();
    },

    updateContents_: function() {
      var selection = this.currentSelection_;

      this.$.content.textContent = '';
      if (!selection)
        return;

      var eventsByTitle = selection.getEventsOrganizedByTitle();
      var numTitles = tr.b.dictionaryLength(eventsByTitle);

      var summaryTableEl = document.createElement(
          'tr-ui-a-multi-event-summary-table');
      summaryTableEl.configure({
        showTotals: numTitles > 1,
        eventsByTitle: eventsByTitle,
        eventsHaveDuration: this.eventsHaveDuration_,
        eventsHaveSubRows: this.eventsHaveSubRows_
      });
      this.$.content.appendChild(summaryTableEl);

      var selectionSummaryTableEl = document.createElement(
          'tr-ui-a-selection-summary-table');
      selectionSummaryTableEl.selection = this.currentSelection_;
      this.$.content.appendChild(selectionSummaryTableEl);

      if (numTitles === 1) {
        var detailsTableEl = document.createElement(
            'tr-ui-a-multi-event-details-table');
        detailsTableEl.eventsHaveDuration = this.eventsHaveDuration_;
        detailsTableEl.eventsHaveSubRows = this.eventsHaveSubRows_;
        detailsTableEl.selection = selection;
        this.$.content.appendChild(detailsTableEl);
      }
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-thread-slice-sub-view', {
    created: function() {
      this.selection_ = undefined;
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      this.selection_ = selection;

                              if (tr.isExported('tr.ui.e.chrome.cc.RasterTaskSelection')) {
        if (tr.ui.e.chrome.cc.RasterTaskSelection.supports(selection)) {
          var ltvSelection = new tr.ui.e.chrome.cc.RasterTaskSelection(
              selection);

          var ltv = new tr.ui.e.chrome.cc.LayerTreeHostImplSnapshotView();
          ltv.objectSnapshot = ltvSelection.containingSnapshot;
          ltv.selection = ltvSelection;
          ltv.extraHighlightsByLayerId = ltvSelection.extraHighlightsByLayerId;

          this.$.content.textContent = '';
          this.$.content.appendChild(ltv);

          this.requiresTallView_ = true;
          return;
        }
      }

      this.$.content.textContent = '';

      var mesv = document.createElement('tr-ui-a-multi-event-sub-view');
      mesv.selection = selection;
      this.$.content.appendChild(mesv);

      var relatedEvents = document.createElement('tr-ui-a-related-events');
      relatedEvents.setRelatedEvents(selection);

      if (relatedEvents.hasRelatedEvents()) {
        this.$.content.appendChild(relatedEvents);
      }
    },

    get requiresTallView() {
      if (this.$.content.children.length === 0)
        return false;
      var childTagName = this.$.content.children[0].tagName;
      if (childTagName === 'TR-UI-A-MULTI-EVENT-SUB-VIEW')
        return false;

            return true;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-async-slice-sub-view', {
    getEventRows_: function(event) {
            var rows = this.__proto__.__proto__.getEventRows_(event);

            rows.splice(0, 0, {
        name: 'ID',
        value: event.id
      });
      return rows;
    },

    get relatedEventsToHighlight() {
      if (!this.currentSelection_)
        return undefined;
      return this.currentSelection_[0].associatedEvents;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-async-slice-sub-view', {
    get selection() {
      return this.$.content.selection;
    },

    set selection(selection) {
      this.$.content.selection = selection;
    },

    get relatedEventsToHighlight() {
      if (!this.$.content.selection)
        return undefined;
      var selection = new tr.model.EventSet();
      this.$.content.selection.forEach(function(asyncEvent) {
        if (!asyncEvent.associatedEvents)
          return;
        asyncEvent.associatedEvents.forEach(function(event) {
          selection.push(event);
        });
      });
      if (selection.length)
        return selection;
      return undefined;
    }
  });
  

  'use strict';
  Polymer('tr-ui-a-single-cpu-slice-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      if (selection.length !== 1)
        throw new Error('Only supports single slices');
      if (!(selection[0] instanceof tr.model.CpuSlice))
        throw new Error('Only supports thread time slices');

      this.currentSelection_ = selection;

      var cpuSlice = selection[0];
      var thread = cpuSlice.threadThatWasRunning;

      var shadowRoot = this.shadowRoot;
      if (thread) {
        shadowRoot.querySelector('#process-name').textContent =
            thread.parent.userFriendlyName;
        shadowRoot.querySelector('#thread-name').textContent =
            thread.userFriendlyName;
      } else {
        shadowRoot.querySelector('#process-name').parentElement.style.display =
            'none';
        shadowRoot.querySelector('#thread-name').textContent = cpuSlice.title;
      }

      shadowRoot.querySelector('#start').timestamp = cpuSlice.start;
      shadowRoot.querySelector('#duration').duration = cpuSlice.duration;

      var runningThreadEl = shadowRoot.querySelector('#running-thread');

      var timeSlice = cpuSlice.getAssociatedTimeslice();
      if (!timeSlice) {
        runningThreadEl.parentElement.style.display = 'none';
      } else {
        var threadLink = document.createElement('tr-ui-a-analysis-link');
        threadLink.selection = new tr.model.EventSet(timeSlice);
        threadLink.textContent = 'Click to select';
        runningThreadEl.parentElement.style.display = '';
        runningThreadEl.textContent = '';
        runningThreadEl.appendChild(threadLink);
      }

      shadowRoot.querySelector('#args').object = cpuSlice.args;

    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-cpu-slice-sub-view', {
    ready: function() {
      this.$.content.eventsHaveSubRows = false;
    },

    get selection() {
      return this.$.content.selection;
    },

    set selection(selection) {
      this.$.content.setSelectionWithoutErrorChecks(selection);
    }
  });
  

'use strict';

tr.exportTo('tr.b', function() {
  function max(a, b) {
    if (a === undefined)
      return b;
    if (b === undefined)
      return a;
    return Math.max(a, b);
  }

  /**
   * This class implements an interval tree.
   *    See: http://wikipedia.org/wiki/Interval_tree
   *
   * Internally the tree is a Red-Black tree. The insertion/colour is done using
   * the Left-leaning Red-Black Trees algorithm as described in:
   *       http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
   *
   * @param {function} beginPositionCb Callback to retrieve the begin position.
   * @param {function} endPositionCb Callback to retrieve the end position.
   *
   * @constructor
   */
  function IntervalTree(beginPositionCb, endPositionCb) {
    this.beginPositionCb_ = beginPositionCb;
    this.endPositionCb_ = endPositionCb;

    this.root_ = undefined;
    this.size_ = 0;
  }

  IntervalTree.prototype = {
    /**
     * Insert events into the interval tree.
     *
     * @param {Object} datum The object to insert.
     */
    insert: function(datum) {
      var startPosition = this.beginPositionCb_(datum);
      var endPosition = this.endPositionCb_(datum);

      var node = new IntervalTreeNode(datum,
                                      startPosition, endPosition);
      this.size_++;

      this.root_ = this.insertNode_(this.root_, node);
      this.root_.colour = Colour.BLACK;
      return datum;
    },

    insertNode_: function(root, node) {
      if (root === undefined)
        return node;

      if (root.leftNode && root.leftNode.isRed &&
          root.rightNode && root.rightNode.isRed)
        this.flipNodeColour_(root);

      if (node.key < root.key)
        root.leftNode = this.insertNode_(root.leftNode, node);
      else if (node.key === root.key)
        root.merge(node);
      else
        root.rightNode = this.insertNode_(root.rightNode, node);

      if (root.rightNode && root.rightNode.isRed &&
          (root.leftNode === undefined || !root.leftNode.isRed))
        root = this.rotateLeft_(root);

      if (root.leftNode && root.leftNode.isRed &&
          root.leftNode.leftNode && root.leftNode.leftNode.isRed)
        root = this.rotateRight_(root);

      return root;
    },

    rotateRight_: function(node) {
      var sibling = node.leftNode;
      node.leftNode = sibling.rightNode;
      sibling.rightNode = node;
      sibling.colour = node.colour;
      node.colour = Colour.RED;
      return sibling;
    },

    rotateLeft_: function(node) {
      var sibling = node.rightNode;
      node.rightNode = sibling.leftNode;
      sibling.leftNode = node;
      sibling.colour = node.colour;
      node.colour = Colour.RED;
      return sibling;
    },

    flipNodeColour_: function(node) {
      node.colour = this.flipColour_(node.colour);
      node.leftNode.colour = this.flipColour_(node.leftNode.colour);
      node.rightNode.colour = this.flipColour_(node.rightNode.colour);
    },

    flipColour_: function(colour) {
      return colour === Colour.RED ? Colour.BLACK : Colour.RED;
    },

    /* The high values are used to find intersection. It should be called after
     * all of the nodes are inserted. Doing it each insert is _slow_. */
    updateHighValues: function() {
      this.updateHighValues_(this.root_);
    },

    /* There is probably a smarter way to do this by starting from the inserted
     * node, but need to handle the rotations correctly. Went the easy route
     * for now. */
    updateHighValues_: function(node) {
      if (node === undefined)
        return undefined;

      node.maxHighLeft = this.updateHighValues_(node.leftNode);
      node.maxHighRight = this.updateHighValues_(node.rightNode);

      return max(max(node.maxHighLeft, node.highValue), node.maxHighRight);
    },

    validateFindArguments_: function(queryLow, queryHigh) {
      if (queryLow === undefined || queryHigh === undefined)
        throw new Error('queryLow and queryHigh must be defined');
      if ((typeof queryLow !== 'number') || (typeof queryHigh !== 'number'))
        throw new Error('queryLow and queryHigh must be numbers');
    },

    /**
     * Retrieve all overlapping intervals.
     *
     * @param {number} queryLow The low value for the intersection interval.
     * @param {number} queryHigh The high value for the intersection interval.
     * @return {Array} All [begin, end] pairs inside intersecting intervals.
     */
    findIntersection: function(queryLow, queryHigh) {
      this.validateFindArguments_(queryLow, queryHigh);
      if (this.root_ === undefined)
        return [];

      var ret = [];
      this.root_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      return ret;
    },

    /**
     * Returns the number of nodes in the tree.
     */
    get size() {
      return this.size_;
    },

    /**
     * Returns the root node in the tree.
     */
    get root() {
      return this.root_;
    },

    /**
     * Dumps out the [lowValue, highValue] pairs for each node in depth-first
     * order.
     */
    dump_: function() {
      if (this.root_ === undefined)
        return [];
      return this.root_.dump();
    }
  };

  var Colour = {
    RED: 'red',
    BLACK: 'black'
  };

  function IntervalTreeNode(datum, lowValue, highValue) {
    this.lowValue_ = lowValue;

    this.data_ = [{
      datum: datum,
      high: highValue,
      low: lowValue
    }];

    this.colour_ = Colour.RED;

    this.parentNode_ = undefined;
    this.leftNode_ = undefined;
    this.rightNode_ = undefined;

    this.maxHighLeft_ = undefined;
    this.maxHighRight_ = undefined;
  }

  IntervalTreeNode.prototype = {
    appendIntersectionsInto_: function(ret, queryLow, queryHigh) {
      /* This node starts has a start point at or further right then queryHigh
       * so we know this node is out and all right children are out. Just need
       * to check left */
      if (this.lowValue_ >= queryHigh) {
        if (!this.leftNode_)
          return;
        return this.leftNode_.appendIntersectionsInto_(
            ret, queryLow, queryHigh);
      }

      /* If we have a maximum left high value that is bigger then queryLow we
       * need to check left for matches */
      if (this.maxHighLeft_ > queryLow) {
        this.leftNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      }

      /* We know that this node starts before queryHigh, if any of it's data
       * ends after queryLow we need to add those nodes */
      if (this.highValue > queryLow) {
        for (var i = (this.data.length - 1); i >= 0; --i) {
          /* data nodes are sorted by high value, so as soon as we see one
           * before low value we're done. */
          if (this.data[i].high < queryLow)
            break;

          ret.push(this.data[i].datum);
        }
      }

      /* check for matches in the right tree */
      if (this.rightNode_) {
        this.rightNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      }
    },

    get colour() {
      return this.colour_;
    },

    set colour(colour) {
      this.colour_ = colour;
    },

    get key() {
      return this.lowValue_;
    },

    get lowValue() {
      return this.lowValue_;
    },

    get highValue() {
      return this.data_[this.data_.length - 1].high;
    },

    set leftNode(left) {
      this.leftNode_ = left;
    },

    get leftNode() {
      return this.leftNode_;
    },

    get hasLeftNode() {
      return this.leftNode_ !== undefined;
    },

    set rightNode(right) {
      this.rightNode_ = right;
    },

    get rightNode() {
      return this.rightNode_;
    },

    get hasRightNode() {
      return this.rightNode_ !== undefined;
    },

    set parentNode(parent) {
      this.parentNode_ = parent;
    },

    get parentNode() {
      return this.parentNode_;
    },

    get isRootNode() {
      return this.parentNode_ === undefined;
    },

    set maxHighLeft(high) {
      this.maxHighLeft_ = high;
    },

    get maxHighLeft() {
      return this.maxHighLeft_;
    },

    set maxHighRight(high) {
      this.maxHighRight_ = high;
    },

    get maxHighRight() {
      return this.maxHighRight_;
    },

    get data() {
      return this.data_;
    },

    get isRed() {
      return this.colour_ === Colour.RED;
    },

    merge: function(node) {
      for (var i = 0; i < node.data.length; i++)
        this.data_.push(node.data[i]);
      this.data_.sort(function(a, b) {
        return a.high - b.high;
      });
    },

    dump: function() {
      var ret = {};
      if (this.leftNode_)
        ret['left'] = this.leftNode_.dump();

      ret['data'] = this.data_.map(function(d) { return [d.low, d.high]; });

      if (this.rightNode_)
        ret['right'] = this.rightNode_.dump();

      return ret;
    }
  };

  return {
    IntervalTree: IntervalTree
  };
});


'use strict';

/**
 * @fileoverview Base class for auditors.
 */
tr.exportTo('tr.c', function() {
  function Auditor(model) {
    this.model_ = model;
  }

  Auditor.prototype = {
    __proto__: Object.prototype,

    get model() {
      return this.model_;
    },

    /**
     * Called by the Model after baking slices. May modify model.
     */
    runAnnotate: function() {
    },

    /**
     * Called by the Model after importing. Should not modify model, except
     * for adding interaction ranges and audits.
     */
    runAudit: function() {
    }
  };

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Auditor;
  tr.b.decorateExtensionRegistry(Auditor, options);

  return {
    Auditor: Auditor
  };
});


'use strict';

tr.exportTo('tr.c', function() {
  function makeCaseInsensitiveRegex(pattern) {
    // See https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/
    // Regular_Expressions.
    pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return new RegExp(pattern, 'i');
  }

  /**
   * @constructor The generic base class for filtering a Model based on
   * various rules. The base class returns true for everything.
   */
  function Filter() { }

  Filter.prototype = {
    __proto__: Object.prototype,

    matchCounter: function(counter) {
      return true;
    },

    matchCpu: function(cpu) {
      return true;
    },

    matchProcess: function(process) {
      return true;
    },

    matchSlice: function(slice) {
      return true;
    },

    matchThread: function(thread) {
      return true;
    }
  };

  /**
   * @constructor A filter that matches objects by their name or category
   * case insensitive.
   * .findAllObjectsMatchingFilter
   */
  function TitleOrCategoryFilter(text) {
    Filter.call(this);
    this.regex_ = makeCaseInsensitiveRegex(text);

    if (!text.length)
      throw new Error('Filter text is empty.');
  }
  TitleOrCategoryFilter.prototype = {
    __proto__: Filter.prototype,

    matchSlice: function(slice) {
      if (slice.title === undefined && slice.category === undefined)
        return false;

      return this.regex_.test(slice.title) ||
          (!!slice.category && this.regex_.test(slice.category));
    }
  };

  /**
   * @constructor A filter that matches objects with the exact given title.
   */
  function ExactTitleFilter(text) {
    Filter.call(this);
    this.text_ = text;

    if (!text.length)
      throw new Error('Filter text is empty.');
  }
  ExactTitleFilter.prototype = {
    __proto__: Filter.prototype,

    matchSlice: function(slice) {
      return slice.title === this.text_;
    }
  };

  /**
   * @constructor A filter that matches objects by their full text contents
   * (title, category, args). Note that for performance this filter applies a
   * regex against all the keys of the slice arguments instead of recursing
   * through any embedded sub-objects.
   */
  function FullTextFilter(text) {
    Filter.call(this);
    this.regex_ = makeCaseInsensitiveRegex(text);
    this.titleOrCategoryFilter_ = new TitleOrCategoryFilter(text);
  }
  FullTextFilter.prototype = {
    __proto__: Filter.prototype,

    matchObject_: function(obj) {
      for (var key in obj) {
        if (!obj.hasOwnProperty(key))
          continue;
        if (this.regex_.test(key))
          return true;
        if (this.regex_.test(obj[key]))
          return true;
      }
      return false;
    },

    matchSlice: function(slice) {
      if (this.titleOrCategoryFilter_.matchSlice(slice))
        return true;
      return this.matchObject_(slice.args);
    }
  };

  return {
    Filter: Filter,
    TitleOrCategoryFilter: TitleOrCategoryFilter,
    ExactTitleFilter: ExactTitleFilter,
    FullTextFilter: FullTextFilter
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  /**
   * EventInfo is an annotation added to Events in order to document
   * what they represent, and override their title/colorId values.
   *
   * TODO(ccraik): eventually support more complex structure/paragraphs.
   *
   * @param {string} title A user-visible title for the event.
   * @param {string} description A user-visible description of the event.
   * @param {Array} docLinks A list of Objects, each of the form
   * {label: str, textContent: str, href: str}
   *
   * @constructor
   */
  function EventInfo(title, description, docLinks) {
    this.title = title;
    this.description = description;
    this.docLinks = docLinks;
    this.colorId = tr.ui.b.getColorIdForGeneralPurposeString(title);
  }

  return {
    EventInfo: EventInfo
  };
});


'use strict';

/**
 * @fileoverview Provides the TimedEvent class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A TimedEvent is the base type for any piece of data in the trace model with
   * a specific start and duration.
   *
   * @constructor
   */
  function TimedEvent(start) {
    tr.model.Event.call(this);
    this.start = start;
    this.duration = 0;
    this.cpuStart = undefined;
    this.cpuDuration = undefined;
  }

  TimedEvent.prototype = {
    __proto__: tr.model.Event.prototype,

    get end() {
      return this.start + this.duration;
    },

    addBoundsToRange: function(range) {
      range.addValue(this.start);
      range.addValue(this.end);
    },

    // bounds returns whether that TimedEvent happens within this timed event
    bounds: function(that, precisionUnit) {
      if (precisionUnit === undefined) {
        precisionUnit = tr.b.u.TimeDisplayModes.ms;
      }
      var startsBefore = precisionUnit.roundedLess(that.start, this.start);
      var endsAfter = precisionUnit.roundedLess(this.end, that.end);
      return !startsBefore && !endsAfter;
    }
  };

  return {
    TimedEvent: TimedEvent
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  function Alert(info, start, opt_associatedEvents, opt_args) {
    tr.model.TimedEvent.call(this, start);
    this.info = info;
    this.args = opt_args || {};
    this.associatedEvents = new tr.model.EventSet(opt_associatedEvents);
    this.associatedEvents.forEach(function(event) {
      event.associatedAlerts.push(this);
    }, this);
  }

  Alert.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get title() {
      return this.info.title;
    },

    get colorId() {
      return this.info.colorId;
    },

    get userFriendlyName() {
      return 'Alert ' + this.title + ' at ' +
          tr.b.u.TimeStamp.format(this.start);
    }
  };

  tr.model.EventRegistry.register(
      Alert,
      {
        name: 'alert',
        pluralName: 'alerts',
        singleViewElementName: 'tr-ui-a-alert-sub-view',
        multiViewElementName: 'tr-ui-a-alert-sub-view'
      });

  return {
    Alert: Alert
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  /**
   * EventContainer is a base class for any class in the trace model that
   * contains child events or child EventContainers.
   *
   * For all EventContainers, updateBounds() must be called after modifying the
   * container's events if an up-to-date bounds is expected.
   *
   * @constructor
   */
  function EventContainer() {
    this.guid_ = tr.b.GUID.allocate();
    this.important = true;
    this.bounds_ = new tr.b.Range();
  }

  EventContainer.prototype = {
    get guid() {
      return this.guid_;
    },

    /**
     * @return {String} A stable and unique identifier that describes this
     * container's position in the event tree relative to the root. If an event
     * container 'B' is a child to another event container 'A', then container
     * B's stable ID would be 'A.B'.
     */
    get stableId() {
      throw new Error('Not implemented');
    },

    /**
     * Returns the bounds of the event container, which describe the range
     * of timestamps for all ancestor events.
     */
    get bounds() {
      return this.bounds_;
    },

    // TODO(charliea): A default implementation of this method could likely be
    // provided that uses 'iterateAllEvents'.
    /**
     * Updates the bounds of the event container. After updating, this.bounds
     * will describe the range of timestamps of all ancestor events.
     */
    updateBounds: function() {
      throw new Error('Not implemented');
    },

    // TODO(charliea): A default implementation of this method could likely be
    // provided that uses 'iterateAllEvents'.
    /**
     * Shifts the timestamps for ancestor events by 'amount' milliseconds.
     */
    shiftTimestampsForward: function(amount) {
      throw new Error('Not implemented');
    },

    /**
     * Iterates over all child events.
     */
    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      throw new Error('Not implemented');
    },

    /**
     * Iterates over all child containers.
     */
    iterateAllChildEventContainers: function(callback, opt_this) {
      throw new Error('Not implemented');
    },

    /**
     * Iterates over all ancestor events.
     */
    iterateAllEvents: function(callback, opt_this) {
      this.iterateAllEventContainers(function(ec) {
        ec.iterateAllEventsInThisContainer(
            function(eventType) { return true; },
            callback, opt_this);
      });
    },

    /**
     * Iterates over this container and all ancestor containers.
     */
    iterateAllEventContainers: function(callback, opt_this) {
      function visit(ec) {
        callback.call(opt_this, ec);
        ec.iterateAllChildEventContainers(visit);
      }
      visit(this);
    }
  };

  return {
    EventContainer: EventContainer
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  var Event = tr.model.Event;
  var EventRegistry = tr.model.EventRegistry;

  /**
   * A sample that contains a power measurement (in mW).
   *
   * @constructor
   * @extends {Event}
   */
  function PowerSample(series, start, power) {
    Event.call(this);

    this.series_ = series;
    this.start_ = start;
    this.power_ = power;
  }

  PowerSample.prototype = {
    __proto__: Event.prototype,

    get series() {
      return this.series_;
    },

    get start() {
      return this.start_;
    },

    set start(value) {
      this.start_ = value;
    },

    get power() {
      return this.power_;
    },

    set power(value) {
      this.power_ = value;
    },

    addBoundsToRange: function(range) {
      range.addValue(this.start);
    }
  };

  EventRegistry.register(
      PowerSample,
      {
        name: 'powerSample',
        pluralName: 'powerSamples',
        singleViewElementName: 'tr-ui-a-single-power-sample-sub-view',
        multiViewElementName: 'tr-ui-a-multi-power-sample-sub-view'
      });

  return {
    PowerSample: PowerSample
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  var PowerSample = tr.model.PowerSample;

  /**
   * A container holding a time series of power samples.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function PowerSeries(device) {
    tr.model.EventContainer.call(this);

    this.device_ = device;
    this.samples_ = [];
  }

  PowerSeries.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get device() {
      return this.device_;
    },

    get samples() {
      return this.samples_;
    },

    get stableId() {
      return this.device_.stableId + '.PowerSeries';
    },

    /**
     * Adds a power sample to the series and returns it.
     *
     * Note: Samples must be added in chronological order.
     */
    addPowerSample: function(ts, val) {
      var sample = new PowerSample(this, ts, val);
      this.samples_.push(sample);
      return sample;
    },

    /**
     * Returns the total energy (in Joules) consumed between the specified
     * start and end timestamps (in milliseconds).
     */
    getEnergyConsumed: function(start, end) {
      var measurementRange = tr.b.Range.fromExplicitRange(start, end);

      var energyConsumed = 0;
      for (var i = 0; i < this.samples.length; i++) {
        var sample = this.samples[i];
        var nextSample = this.samples[i + 1];

        var sampleRange = new tr.b.Range();
        sampleRange.addValue(sample.start);
        sampleRange.addValue(nextSample ? nextSample.start : Infinity);

        var timeIntersection = measurementRange.findIntersection(sampleRange);

        // Divide by 1000 to convert milliseconds to seconds.
        energyConsumed += timeIntersection.duration / 1000 * sample.power;
      }

      return energyConsumed;
    },

    shiftTimestampsForward: function(amount) {
      for (var i = 0; i < this.samples_.length; ++i)
        this.samples_[i].start += amount;
    },

    updateBounds: function() {
      this.bounds.reset();

      if (this.samples_.length === 0)
        return;

      this.bounds.addValue(this.samples_[0].start);
      this.bounds.addValue(this.samples_[this.samples_.length - 1].start);
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate, callback,
                                              opt_this) {
      if (eventTypePredicate.call(opt_this, PowerSample))
        this.samples_.forEach(callback, opt_this);
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
    }
  };

  return {
    PowerSeries: PowerSeries
  };
});


'use strict';

/**
 * @fileoverview Provides the Device class.
 */
tr.exportTo('tr.model', function() {

  /**
   * Device represents the device-level objects in the model.
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function Device(model) {
    if (!model)
      throw new Error('Must provide a model.');

    tr.model.EventContainer.call(this);

    this.powerSeries_ = undefined;
    this.vSyncTimestamps_ = [];
  };

  Device.compare = function(x, y) {
    return x.guid - y.guid;
  };

  Device.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    compareTo: function(that) {
      return Device.compare(this, that);
    },

    get userFriendlyName() {
      return 'Device';
    },

    get userFriendlyDetails() {
      return 'Device';
    },

    get stableId() {
      return 'Device';
    },

    getSettingsKey: function() {
      return 'device';
    },

    get powerSeries() {
      return this.powerSeries_;
    },

    set powerSeries(powerSeries) {
      this.powerSeries_ = powerSeries;
    },

    get vSyncTimestamps() {
      return this.vSyncTimestamps_;
    },

    set vSyncTimestamps(value) {
      this.vSyncTimestamps_ = value;
    },

    updateBounds: function() {
      this.bounds.reset();

      this.iterateAllChildEventContainers(function(child) {
        child.updateBounds();
        this.bounds.addRange(child.bounds);
      }, this);
    },

    shiftTimestampsForward: function(amount) {
      this.iterateAllChildEventContainers(function(child) {
        child.shiftTimestampsForward(amount);
      });

      for (var i = 0; i < this.vSyncTimestamps_.length; i++)
        this.vSyncTimestamps_[i] += amount;
    },

    addCategoriesToDict: function(categoriesDict) {
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
      if (this.powerSeries_)
        callback.call(opt_this, this.powerSeries_);
    }
  };

  return {
    Device: Device
  };
});


'use strict';

/**
 * @fileoverview Provides the Flow class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A Flow represents an interval of time plus parameters associated
   * with that interval.
   *
   * @constructor
   */
  function FlowEvent(category, id, title, colorId, start, args, opt_duration) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.start = start;
    this.args = args;

    this.id = id;

    this.startSlice = undefined;
    this.endSlice = undefined;

    this.startStackFrame = undefined;
    this.endStackFrame = undefined;

    if (opt_duration !== undefined)
      this.duration = opt_duration;
  }

  FlowEvent.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get userFriendlyName() {
      return 'Flow event named ' + this.title + ' at ' +
          tr.b.u.TimeStamp.format(this.timestamp);
    }
  };

  tr.model.EventRegistry.register(
      FlowEvent,
      {
        name: 'flowEvent',
        pluralName: 'flowEvents',
        singleViewElementName: 'tr-ui-a-single-flow-event-sub-view',
        multiViewElementName: 'tr-ui-a-multi-flow-event-sub-view'
      });

  return {
    FlowEvent: FlowEvent
  };
});


'use strict';

/**
 * @fileoverview Class describing rendered frames.
 *
 * Because a frame is produced by multiple threads, it does not inherit from
 * TimedEvent, and has no duration.
 */
tr.exportTo('tr.model', function() {
  var Statistics = tr.b.Statistics;

  var FRAME_PERF_CLASS = {
    GOOD: 'good',
    BAD: 'bad',
    TERRIBLE: 'terrible',
    NEUTRAL: 'generic_work'
  };

  /**
   * @constructor
   * @param {Array} associatedEvents Selection of events composing the frame.
   * @param {Array} threadTimeRanges Array of {thread, start, end}
   * for each thread, describing the critical path of the frame.
   */
  function Frame(associatedEvents, threadTimeRanges, opt_args) {
    tr.model.Event.call(this);

    this.threadTimeRanges = threadTimeRanges;
    this.associatedEvents = new tr.model.EventSet(associatedEvents);
    this.args = opt_args || {};

    this.title = 'Frame';
    this.start = Statistics.min(
        threadTimeRanges, function(x) { return x.start; });
    this.end = Statistics.max(
        threadTimeRanges, function(x) { return x.end; });
    this.totalDuration = Statistics.sum(
        threadTimeRanges, function(x) { return x.end - x.start; });

    this.perfClass = FRAME_PERF_CLASS.NEUTRAL;
  };

  Frame.prototype = {
    __proto__: tr.model.Event.prototype,

    set perfClass(perfClass) {
      this.colorId = tr.ui.b.getColorIdForReservedName(perfClass);
      this.perfClass_ = perfClass;
    },

    get perfClass() {
      return this.perfClass_;
    },

    shiftTimestampsForward: function(amount) {
      this.start += amount;
      this.end += amount;

      for (var i = 0; i < this.threadTimeRanges.length; i++) {
        this.threadTimeRanges[i].start += amount;
        this.threadTimeRanges[i].end += amount;
      }
    },

    addBoundsToRange: function(range) {
      range.addValue(this.start);
      range.addValue(this.end);
    }
  };

  tr.model.EventRegistry.register(
      Frame,
      {
        name: 'frame',
        pluralName: 'frames',
        singleViewElementName: 'tr-ui-a-single-frame-sub-view',
        multiViewElementName: 'tr-ui-a-multi-frame-sub-view'
      });

  return {
    Frame: Frame,
    FRAME_PERF_CLASS: FRAME_PERF_CLASS
  };
});


'use strict';

/**
 * @fileoverview Provides the Attribute class.
 */
tr.exportTo('tr.model', function() {

  /**
   * @constructor
   */
  function Attribute(units) {
    this.units = units;

    // AttributeInfo(s) about the attribute (e.g. information about how it was
    // calculated).
    this.infos = [];
  }

  Attribute.fromDictIfPossible = function(dict, opt_model) {
    var typeInfo = Attribute.findTypeInfoMatching(function(typeInfo) {
      return typeInfo.metadata.type === dict.type;
    });

    if (typeInfo === undefined) {
      if (opt_model) {
        opt_model.importWarning({
          type: 'attribute_parse_error',
          message: 'Unknown attribute type \'' + dict.type + '\'.'
        });
      }
      return UnknownAttribute.fromDict(dict, opt_model);
    }

    return typeInfo.constructor.fromDict(dict, opt_model);
  };

  /**
   * Find the common constructor and units of a list of attribute values. If
   * they have different types (e.g. ScalarAttribute and UnknownAttribute) or
   * units (e.g. 'ms' and 'Hz'), the common constructor will be
   * UnknownAttribute and the common units will be undefined.
   *
   * Undefined attribute values are skipped. This function will return undefined
   * if the list of attribute values contains no defined attribute values.
   */
  Attribute.findCommonTraits = function(attributes, opt_model) {
    var commonTraits;
    for (var i = 0; i < attributes.length; i++) {
      var attribute = attributes[i];
      if (attribute === undefined)
        continue;

      var attributeConstructor = attribute.constructor;
      var attributeUnits = attribute.units;

      if (commonTraits === undefined) {
        commonTraits = {
          constructor: attributeConstructor,
          units: attributeUnits
        };
      } else if (attributeConstructor !== commonTraits.constructor) {
        if (opt_model) {
          opt_model.importWarning({
            type: 'attribute_parse_error',
            message: 'Attribute with different types: ' +
                commonTraits.constructor + ' and ' + attributeConstructor + '.'
          });
        }
        commonTraits = {
          constructor: UnknownAttribute,
          units: undefined
        };
        break;
      } else if (attributeUnits !== commonTraits.units) {
        if (opt_model) {
          opt_model.importWarning({
            type: 'attribute_parse_error',
            message: 'Attribute with different units: ' + commonTraits.units +
                ' and ' + attributeUnits + '.'
          });
        }
        commonTraits = {
          constructor: UnknownAttribute,
          units: undefined
        };
        break;
      }
    }
    return commonTraits;
  };

  /**
   * Aggregate a list of child attribute values with an existing attribute
   * value. The individual values can be undefined, in which case they are
   * ignored.
   */
  Attribute.aggregate = function(childAttributes, existingParentAttribute,
                                 opt_model) {
    var definedChildAttributes = childAttributes.filter(
        function(childAttribute) {
      return childAttribute !== undefined;
    });

    // If all child attribute values were undefined, return the existing parent
    // attribute value (possibly undefined).
    var traits = Attribute.findCommonTraits(definedChildAttributes, opt_model);
    if (traits === undefined)
      return existingParentAttribute;

    var constructor = traits.constructor;

    // If the common type does not support merging child attribute values,
    // return the existing parent attribute value (possibly undefined).
    if (constructor.merge === undefined)
      return existingParentAttribute;

    var mergedAttribute = constructor.merge(
        definedChildAttributes, traits.units, opt_model);

    // If there is no existing parent attribute value, use the merged value
    // (possibly undefined).
    if (existingParentAttribute === undefined)
      return mergedAttribute;

    // Leave it up to the existing parent attribute value to decide if/how it
    // will use the merged value (e.g. generate an import warning if the
    // existing and merged attribute value types differ).
    existingParentAttribute.useMergedAttribute(mergedAttribute, opt_model);

    return existingParentAttribute;
  }

  Attribute.fromTraceValue = function(dict, opt_model) {
    throw new Error('Not implemented');
  };

  Attribute.prototype.useMergedAttribute = function(mergedAttribute,
                                                    opt_model) {
    if (mergedAttribute.constructor !== this.constructor) {
      if (opt_model) {
        opt_model.importWarning({
          type: 'attribute_parse_error',
          message: 'Attribute with different types: ' + this.constructor +
              ' and ' + mergedAttribute.constructor + '.'
        });
      }
    } else if (mergedAttribute.units !== this.units) {
      if (opt_model) {
        opt_model.importWarning({
          type: 'attribute_parse_error',
          message: 'Attribute with different units: ' + this.units +
              ' and ' + mergedAttribute.units + '.'
        });
      }
    }
  };

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(Attribute, options);

  Attribute.addEventListener('will-register', function(e) {
    if (!e.typeInfo.constructor.hasOwnProperty('fromDict'))
      throw new Error('Attributes must have fromDict method');

    if (!e.typeInfo.metadata.type)
      throw new Error('Attributes must provide type');

    if (e.typeInfo.constructor.prototype.constructor !== e.typeInfo.constructor)
      throw new Error('Attribute prototypes must provide constructor.');
  });

  /**
   * @constructor
   */
  function ScalarAttribute(units, value) {
    Attribute.call(this, units);
    this.value = value;
  }

  ScalarAttribute.fromDict = function(dict) {
    return new ScalarAttribute(dict.units, parseInt(dict.value, 16));
  };

  ScalarAttribute.merge = function(childAttributes, units) {
    var sum = 0;
    childAttributes.forEach(function(childAttribute) {
      sum += childAttribute.value;
    });
    return new ScalarAttribute(units, sum);
  }

  ScalarAttribute.prototype.__proto__ = Attribute.prototype;

  Attribute.register(ScalarAttribute, {type: 'scalar'});

  /**
   * @constructor
   */
  function StringAttribute(units, value) {
    Attribute.call(this, units);
    this.value = value;
  }

  StringAttribute.fromDict = function(dict) {
    return new StringAttribute(dict.units, dict.value);
  };

  Attribute.register(StringAttribute, {type: 'string'});

  /**
   * @constructor
   */
  function UnknownAttribute(units, opt_value) {
    Attribute.call(this, units, opt_value);
    this.value = opt_value;
  }

  UnknownAttribute.fromDict = function(dict) {
    return new UnknownAttribute(dict.units);
  };

  UnknownAttribute.prototype.__proto__ = Attribute.prototype;

  /**
   * @constructor
   */
  function AttributeInfo(type, message) {
    this.type = type;
    this.message = message;
  }

  /**
   * The type of AttributeInfo.
   * @enum
   */
  var AttributeInfoType = {
    // Generic information (e.g. how the attribute was calculated).
    INFORMATION: 0,

    // Warning (e.g. inconsistent attribute values provided).
    WARNING: 1,

    // Attribute source (e.g. attribute refers to an older dump's attribute).
    LINK: 2,

    // Corresponding memory allocator dump owns another MAD.
    // TODO(petrcermak): Figure out if there's a better place to store this.
    MEMORY_OWNER: 3,

    // Corresponding memory allocator dump is owned by another MAD.
    // TODO(petrcermak): Figure out if there's a better place to store this.
    MEMORY_OWNED: 4,

    // Overall value (e.g. peak value since start process).
    OVERALL_VALUE: 5,

    // Recent value (e.g. peak value since the previous memory dump).
    RECENT_VALUE: 6
  };

  return {
    Attribute: Attribute,
    ScalarAttribute: ScalarAttribute,
    StringAttribute: StringAttribute,
    UnknownAttribute: UnknownAttribute,
    AttributeInfo: AttributeInfo,
    AttributeInfoType: AttributeInfoType
  };
});


'use strict';

/**
 * @fileoverview Provides the ContainerMemoryDump class.
 */
tr.exportTo('tr.model', function() {
  /**
   * The ContainerMemoryDump represents an abstract container memory dump.
   * @constructor
   */
  function ContainerMemoryDump(start) {
    tr.model.TimedEvent.call(this, start);

    // 'light' or 'detailed' memory dump. See
    // base::trace_event::MemoryDumpLevelOfDetail in the Chromium
    // repository.
    this.levelOfDetail = undefined;

    this.memoryAllocatorDumps_ = undefined;
    this.memoryAllocatorDumpsByFullName_ = undefined;
  };

  ContainerMemoryDump.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    shiftTimestampsForward: function(amount) {
      this.start += amount;
    },

    get memoryAllocatorDumps() {
      return this.memoryAllocatorDumps_;
    },

    set memoryAllocatorDumps(memoryAllocatorDumps) {
      this.memoryAllocatorDumps_ = memoryAllocatorDumps;

      // Clear the index and generate it lazily.
      this.memoryAllocatorDumpsByFullName_ = undefined;
    },

    getMemoryAllocatorDumpByFullName: function(fullName) {
      if (this.memoryAllocatorDumps_ === undefined)
        return undefined;

      // Lazily generate the index if necessary.
      if (this.memoryAllocatorDumpsByFullName_ === undefined) {
        var index = {};
        function addDumpsToIndex(dumps) {
          dumps.forEach(function(dump) {
            index[dump.fullName] = dump;
            addDumpsToIndex(dump.children);
          });
        };
        addDumpsToIndex(this.memoryAllocatorDumps_);
        this.memoryAllocatorDumpsByFullName_ = index;
      }

      return this.memoryAllocatorDumpsByFullName_[fullName];
    }
  };

  return {
    ContainerMemoryDump: ContainerMemoryDump
  };
});


'use strict';

/**
 * @fileoverview Provides the MemoryAllocatorDump class.
 */
tr.exportTo('tr.model', function() {
  /**
   * @constructor
   */
  function MemoryAllocatorDump(containerMemoryDump, fullName, opt_guid) {
    this.fullName = fullName;
    this.parent = undefined;
    this.children = [];
    this.attributes = {};

    // The associated container memory dump.
    this.containerMemoryDump = containerMemoryDump;

    // Ownership relationship between memory allocator dumps.
    this.owns = undefined;
    this.ownedBy = [];

    // Retention relationship between memory allocator dumps.
    this.retains = [];
    this.retainedBy = [];

    // For debugging purposes.
    this.guid = opt_guid;
  };

  /**
   * Size attribute names. Please refer to the Memory Dump Graph Metric
   * Calculation design document for more details (https://goo.gl/fKg0dt).
   */
  MemoryAllocatorDump.SIZE_ATTRIBUTE_NAME = 'size';
  MemoryAllocatorDump.EFFECTIVE_SIZE_ATTRIBUTE_NAME = 'effective_size';
  MemoryAllocatorDump.DISPLAYED_SIZE_ATTRIBUTE_NAME =
      MemoryAllocatorDump.EFFECTIVE_SIZE_ATTRIBUTE_NAME;

  MemoryAllocatorDump.prototype = {
    get name() {
      return this.fullName.substring(this.fullName.lastIndexOf('/') + 1);
    },

    get quantifiedName() {
      return '\'' + this.fullName + '\' in ' +
          this.containerMemoryDump.containerName;
    },

    isDescendantOf: function(otherDump) {
      var dump = this;
      while (dump !== undefined) {
        if (dump === otherDump)
          return true;
        dump = dump.parent;
      }
      return false;
    },

    addAttribute: function(name, value) {
      if (name in this.attributes)
        throw new Error('Duplicate attribute name: ' + name + '.');
      this.attributes[name] = value;
    },

    aggregateAttributes: function(opt_model) {
      var attributes = {};

      this.children.forEach(function(child) {
        child.aggregateAttributes(opt_model);
        tr.b.iterItems(child.attributes, function(name) {
          attributes[name] = true;
        }, this);
      }, this);

      tr.b.iterItems(attributes, function(name) {
        var childAttributes = this.children.map(function(child) {
          return child.attributes[name];
        }, this);
        var currentAttribute = this.attributes[name];
        this.attributes[name] = tr.model.Attribute.aggregate(
            childAttributes, currentAttribute, opt_model);
      }, this);
    },

    getValidSizeAttributeOrUndefined: function(sizeAttrName, opt_model) {
      var sizeAttr = this.attributes[sizeAttrName];
      if (sizeAttr === undefined)
        return undefined;

      if (!(sizeAttr instanceof tr.model.ScalarAttribute)) {
        if (opt_model !== undefined) {
          opt_model.importWarning({
            type: 'memory_dump_parse_error',
            message: '\'' + sizeAttrName + '\' attribute of memory allocator ' +
                'dump \'' + memoryAllocatorDump.fullName + '\' is not a scalar.'
          });
        }
        return undefined;
      }

      return sizeAttr;
    }
  };

  /**
   * @constructor
   */
  function MemoryAllocatorDumpLink(source, target, opt_importance) {
    this.source = source;
    this.target = target;
    this.importance = opt_importance;
  }

  return {
    MemoryAllocatorDump: MemoryAllocatorDump,
    MemoryAllocatorDumpLink: MemoryAllocatorDumpLink
  };
});


'use strict';

/**
 * @fileoverview Provides the GlobalMemoryDump class.
 */
tr.exportTo('tr.model', function() {
  /**
   * The GlobalMemoryDump represents a simultaneous memory dump of all
   * processes.
   * @constructor
   */
  function GlobalMemoryDump(model, start) {
    tr.model.ContainerMemoryDump.call(this, start);
    this.model = model;
    this.processMemoryDumps = {};
  }

  var SIZE_ATTRIBUTE_NAME = tr.model.MemoryAllocatorDump.SIZE_ATTRIBUTE_NAME;
  var EFFECTIVE_SIZE_ATTRIBUTE_NAME =
      tr.model.MemoryAllocatorDump.EFFECTIVE_SIZE_ATTRIBUTE_NAME;

  function getSize(dump) {
    var attr = dump.attributes[SIZE_ATTRIBUTE_NAME];
    if (attr === undefined)
      return 0;
    return attr.value;
  }

  function hasSize(dump) {
    return dump.attributes[SIZE_ATTRIBUTE_NAME] !== undefined;
  }

  function optional(value, defaultValue) {
    if (value === undefined)
      return defaultValue;
    return value;
  }

  function ownershipToUserFriendlyString(dump, importance) {
    return dump.quantifiedName + ' (importance: ' +
        optional(importance, 0) + ')';
  }

  GlobalMemoryDump.prototype = {
    __proto__: tr.model.ContainerMemoryDump.prototype,

    get userFriendlyName() {
      return 'Global memory dump at ' + tr.b.u.TimeStamp.format(this.start);
    },

    get containerName() {
      return 'global space';
    },

    calculateGraphAttributes: function() {
      // 1. Calculate the sizes of all memory allocator dumps (MADs).
      this.calculateSizes();

      // 2. Calculate the effective sizes of all MADs. This step requires that
      // the sizes of all MADs have already been calculated (step 1).
      this.calculateEffectiveSizes();

      // 3. Aggregate all other attributes of all MADs. This step must be
      // carried out after the sizes of all MADs were calculated (step 1).
      // Otherwise, the sizes of all MADs would be aggregated as a direct sums
      // of their children, which would most likely lead to double-counting.
      this.aggregateAttributes();

      // 4. Discount tracing from VM regions stats and malloc or winheap
      // allocator stats. This steps requires that the sizes (step 1),
      // effective sizes (step 2), and resident sizes (step 3) of the relevant
      // MADs have already been calculated.
      this.discountTracingOverhead();
    },

    /**
     * Calculate the size of all memory allocator dumps in the dump graph.
     *
     * The size refers to the allocated size of a (sub)component. It is a
     * natural extension of the optional size attribute provided by
     * MemoryAllocatorDump(s):
     *
     *   - If a MAD provides a size attribute, then its size is assumed to be
     *     equal to it.
     *   - If a MAD does not provide a size attribute, then its size is assumed
     *     to be the maximum of (1) the size of the largest owner of the MAD
     *     and (2) the aggregated size of the MAD's children.
     *
     * Metric motivation: "How big is a (sub)system?"
     *
     * Please refer to the Memory Dump Graph Metric Calculation design document
     * for more details (https://goo.gl/fKg0dt).
     */
    calculateSizes: function() {
      this.traverseAllocatorDumpsInDepthFirstPostOrder(
          this.calculateMemoryAllocatorDumpSize_.bind(this));
    },

    /**
     * Calculate the size of the given MemoryAllocatorDump. This method assumes
     * that the size of both the children and owners of the dump has already
     * been calculated.
     */
    calculateMemoryAllocatorDumpSize_: function(dump) {
      // This flag becomes true if the size attribute of the current dump
      // should be defined, i.e. if (1) the current dump's size attribute is
      // defined, (2) the size of at least one of its children is defined or
      // (3) the size of at least one of its owners is defined.
      var shouldDefineSize = false;

      // This helper function returns the numeric value of the size attribute
      // of the given dependent memory allocator dump. If the attribute is
      // defined, the shouldDefineSize flag above is also set to true (because
      // condition (2) or (3) is satisfied). Otherwise, zero is returned (and
      // the flag is left unchanged).
      function getDependencySize(dependencyDump) {
        var attr = dependencyDump.attributes[SIZE_ATTRIBUTE_NAME];
        if (attr === undefined)
          return 0;
        shouldDefineSize = true;
        return attr.value;
      }

      // 1. Get the size provided by the dump. If present, define a function
      // for checking dependent size consistency (a dump must always be bigger
      // than all its children aggregated together and/or its largest owner).
      var sizeAttribute = dump.getValidSizeAttributeOrUndefined(
          SIZE_ATTRIBUTE_NAME, this.model);
      var size = 0;
      var infos = [];
      var checkDependentSizeIsConsistent = function() { /* no-op */ };
      if (sizeAttribute !== undefined) {
        size = sizeAttribute.value;
        shouldDefineSize = true;
        checkDependentSizeIsConsistent = function(dependentSize,
            dependentName) {
          if (size >= dependentSize)
            return;
          var messageSuffix = ' (' + tr.b.u.Units.sizeInBytes.format(size) +
              ') is less than ' + dependentName + ' (' +
                tr.b.u.Units.sizeInBytes.format(dependentSize) + ').';
          this.model.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Size provided by memory allocator dump \'' +
                dump.fullName + '\'' + messageSuffix
          });
          infos.push(new tr.model.AttributeInfo(
              tr.model.AttributeInfoType.WARNING,
              'Size provided by this memory allocator dump' + messageSuffix));
        }.bind(this);
      }

      // 2. Aggregate size of children. The recursive function traverses all
      // descendants and ensures that double-counting due to ownership within a
      // subsystem is avoided.
      var aggregatedChildrenSize = 0;
      // Owned child dump name -> (Owner child dump name -> overlapping size).
      var allOverlaps = {};
      dump.children.forEach(function(childDump) {
        function aggregateDescendantDump(descendantDump) {
          // Don't count this descendant dump if it owns another descendant of
          // the current dump (would cause double-counting).
          var ownedDumpLink = descendantDump.owns;
          if (ownedDumpLink !== undefined &&
              ownedDumpLink.target.isDescendantOf(dump)) {
            // If the target owned dump is a descendant of a *different* child
            // of the the current dump (i.e. not childDump), then we remember
            // the ownership so that we could explain why the size of the
            // current dump is not equal to the sum of its children.
            var ownedDescendantDump = ownedDumpLink.target;
            var ownedChildDump = ownedDescendantDump;
            while (ownedChildDump.parent !== dump)
              ownedChildDump = ownedChildDump.parent;
            if (childDump !== ownedChildDump) {
              var overlap = getDependencySize(descendantDump);
              if (overlap > 0) {
                // Owner child dump -> total overlapping size.
                var ownedChildOverlaps = allOverlaps[ownedChildDump.name];
                if (ownedChildOverlaps === undefined)
                  allOverlaps[ownedChildDump.name] = ownedChildOverlaps = {};
                var previousTotalOverlap =
                    ownedChildOverlaps[childDump.name] || 0;
                var updatedTotalOverlap = previousTotalOverlap + overlap;
                ownedChildOverlaps[childDump.name] = updatedTotalOverlap;
              }
            }
            return;
          }

          // If this descendant dump is a leaf node, add its size to the
          // aggregated size.
          if (descendantDump.children.length === 0) {
            aggregatedChildrenSize += getDependencySize(descendantDump);
            return;
          }

          // If this descendant dump is an intermediate node, recurse down into
          // its children. Note that the dump's size is NOT added because it is
          // an aggregate of its children (would cause double-counting).
          descendantDump.children.forEach(aggregateDescendantDump);
        }
        aggregateDescendantDump(childDump);
      });
      // If the size of the dump is not equal to the sum of its children, add
      // infos to its children explaining the difference.
      dump.children.forEach(function(childDump) {
        var childOverlaps = allOverlaps[childDump.name];
        if (childOverlaps === undefined)
          return;

        var message = tr.b.dictionaryValues(tr.b.mapItems(childOverlaps,
            function(ownerChildName, overlap) {
          return 'overlaps with its sibling \'' + ownerChildName + '\' (' +
              tr.b.u.Units.sizeInBytes.format(overlap) + ')';
        })).join(' ');

        childDump.attributes[SIZE_ATTRIBUTE_NAME].infos.push(
            new tr.model.AttributeInfo(
                tr.model.AttributeInfoType.INFORMATION, message));
      });
      checkDependentSizeIsConsistent(
          aggregatedChildrenSize, 'the aggregated size of its children');

      // 3. Calculate the largest owner size.
      var largestOwnerSize = 0;
      dump.ownedBy.forEach(function(ownershipLink) {
        var owner = ownershipLink.source;
        var ownerSize = getDependencySize(owner);
        largestOwnerSize = Math.max(largestOwnerSize, ownerSize);
      });
      checkDependentSizeIsConsistent(
          largestOwnerSize, 'the size of its largest owner');

      // If neither the dump nor any of its dependencies (children and owners)
      // provide a size, do NOT add a zero size attribute.
      if (!shouldDefineSize) {
        // The rest of the pipeline relies on size being either a valid
        // ScalarAttribute, or undefined.
        dump.attributes[SIZE_ATTRIBUTE_NAME] = undefined;
        return;
      }

      // A dump must always be bigger than all its children aggregated
      // together and/or its largest owner.
      size = Math.max(size, aggregatedChildrenSize, largestOwnerSize);

      var sizeAttribute = new tr.model.ScalarAttribute('bytes', size);
      sizeAttribute.infos = infos;
      dump.attributes[SIZE_ATTRIBUTE_NAME] = sizeAttribute;

      // Add a virtual child to make up for extra size of the dump with
      // respect to its children (if applicable).
      if (aggregatedChildrenSize < size &&
          dump.children !== undefined && dump.children.length > 0) {
        var virtualChild = new tr.model.MemoryAllocatorDump(
            dump.containerMemoryDump, dump.fullName + '/<unspecified>');
        virtualChild.parent = dump;
        dump.children.unshift(virtualChild);
        virtualChild.attributes[SIZE_ATTRIBUTE_NAME] =
            new tr.model.ScalarAttribute(
                'bytes', size - aggregatedChildrenSize);
      }
    },

    /**
     * Calculate the effective size of all memory allocator dumps in the dump
     * graph.
     *
     * The effective size refers to the amount of memory a particular component
     * is using/consuming. In other words, every (reported) byte of used memory
     * is uniquely attributed to exactly one component. Consequently, unlike
     * size, effective size is cumulative, i.e. the sum of the effective sizes
     * of (top-level) components is equal to the total amount of (reported)
     * used memory.
     *
     * Metric motivation: "How much memory does a (sub)system use?" or "For how
     * much memory should a (sub)system be 'charged'?"
     *
     * Please refer to the Memory Dump Graph Metric Calculation design document
     * for more details (https://goo.gl/fKg0dt).
     *
     * This method assumes that the size of all contained memory allocator
     * dumps has already been calculated [see calculateSizes()].
     */
    calculateEffectiveSizes: function() {
      // 1. Calculate not-owned and not-owning sub-sizes of all MADs
      // (depth-first post-order traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(
          this.calculateDumpSubSizes_.bind(this));

      // 2. Calculate owned and owning coefficients of owned and owner MADs
      // respectively (arbitrary traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(
          this.calculateDumpOwnershipCoefficient_.bind(this));

      // 3. Calculate cumulative owned and owning coefficients of all MADs
      // (depth-first pre-order traversal).
      this.traverseAllocatorDumpsInDepthFirstPreOrder(
          this.calculateDumpCumulativeOwnershipCoefficient_.bind(this));

      // 4. Calculate the effective sizes of all MADs (depth-first post-order
      // traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(
          this.calculateDumpEffectiveSize_.bind(this));
    },

    /**
     * Calculate not-owned and not-owning sub-sizes of a memory allocator dump
     * from its children's (sub-)sizes.
     *
     * Not-owned sub-size refers to the aggregated memory of all children which
     * is not owned by other MADs. Conversely, not-owning sub-size is the
     * aggregated memory of all children which do not own another MAD. The
     * diagram below illustrates these two concepts:
     *
     *     ROOT 1                         ROOT 2
     *     size: 4                        size: 5
     *     not-owned sub-size: 4          not-owned sub-size: 1 (!)
     *     not-owning sub-size: 0 (!)     not-owning sub-size: 5
     *
     *      ^                              ^
     *      |                              |
     *
     *     PARENT 1   ===== owns =====>   PARENT 2
     *     size: 4                        size: 5
     *     not-owned sub-size: 4          not-owned sub-size: 5
     *     not-owning sub-size: 4         not-owning sub-size: 5
     *
     *      ^                              ^
     *      |                              |
     *
     *     CHILD 1                        CHILD 2
     *     size [given]: 4                size [given]: 5
     *     not-owned sub-size: 4          not-owned sub-size: 5
     *     not-owning sub-size: 4         not-owning sub-size: 5
     *
     * This method assumes that (1) the size of the dump, its children, and its
     * owners [see calculateSizes()] and (2) the not-owned and not-owning
     * sub-sizes of both the children and owners of the dump have already been
     * calculated [depth-first post-order traversal].
     */
    calculateDumpSubSizes_: function(dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump))
        return;

      // If the dump is a leaf node, then both sub-sizes are equal to the size.
      if (dump.children === undefined || dump.children.length === 0) {
        var size = getSize(dump);
        dump.notOwningSubSize_ = size;
        dump.notOwnedSubSize_ = size;
        return;
      }

      // Calculate this dump's not-owning sub-size by summing up the not-owning
      // sub-sizes of children MADs which do not own another MAD.
      var notOwningSubSize = 0;
      dump.children.forEach(function(childDump) {
        if (childDump.owns !== undefined)
          return;
        notOwningSubSize += optional(childDump.notOwningSubSize_, 0);
      });
      dump.notOwningSubSize_ = notOwningSubSize;

      // Calculate this dump's not-owned sub-size.
      var notOwnedSubSize = 0;
      dump.children.forEach(function(childDump) {
        // If the child dump is not owned, then add its not-owned sub-size.
        if (childDump.ownedBy.length === 0) {
          notOwnedSubSize += optional(childDump.notOwnedSubSize_, 0);
          return;
        }
        // If the child dump is owned, then add the difference between its size
        // and the largest owner.
        var largestChildOwnerSize = 0;
        childDump.ownedBy.forEach(function(ownershipLink) {
          largestChildOwnerSize = Math.max(
              largestChildOwnerSize, getSize(ownershipLink.source));
        });
        notOwnedSubSize += getSize(childDump) - largestChildOwnerSize;
      });
      dump.notOwnedSubSize_ = notOwnedSubSize;
    },

    /**
     * Calculate owned and owning coefficients of a memory allocator dump and
     * its owners.
     *
     * The owning coefficient refers to the proportion of a dump's not-owning
     * sub-size which is attributed to the dump (only relevant to owning MADs).
     * Conversely, the owned coefficient is the proportion of a dump's
     * not-owned sub-size, which is attributed to it (only relevant to owned
     * MADs).
     *
     * The not-owned size of the owned dump is split among its owners in the
     * order of the ownership importance as demonstrated by the following
     * example:
     *
     *                                          memory allocator dumps
     *                                   OWNED  OWNER1  OWNER2  OWNER3  OWNER4
     *       not-owned sub-size [given]     10       -       -       -       -
     *      not-owning sub-size [given]      -       6       7       5       8
     *               importance [given]      -       2       2       1       0
     *    attributed not-owned sub-size      2       -       -       -       -
     *   attributed not-owning sub-size      -       3       4       0       1
     *                owned coefficient   2/10       -       -       -       -
     *               owning coefficient      -     3/6     4/7     0/5     1/8
     *
     * Explanation: Firstly, 6 bytes are split equally among OWNER1 and OWNER2
     * (highest importance). OWNER2 owns one more byte, so its attributed
     * not-owning sub-size is 6/2 + 1 = 4 bytes. OWNER3 is attributed no size
     * because it is smaller than the owners with higher priority. However,
     * OWNER4 is larger, so it's attributed the difference 8 - 7 = 1 byte.
     * Finally, 2 bytes remain unattributed and are hence kept in the OWNED
     * dump as attributed not-owned sub-size. The coefficients are then
     * directly calculated as fractions of the sub-sizes and corresponding
     * attributed sub-sizes.
     *
     * Note that we always assume that all ownerships of a dump overlap (e.g.
     * OWNER3 is subsumed by both OWNER1 and OWNER2). Hence, the table could
     * be alternatively represented as follows:
     *
     *                                 owned memory range
     *              0   1   2    3    4    5    6        7        8   9  10
     *   Priority 2 |  OWNER1 + OWNER2 (split)  | OWNER2 |
     *   Priority 1 | (already attributed) |
     *   Priority 0 | - - -  (already attributed)  - - - | OWNER4 |
     *    Remainder | - - - - - (already attributed) - - - - - -  | OWNED |
     *
     * This method assumes that (1) the size of the dump [see calculateSizes()]
     * and (2) the not-owned size of the dump and not-owning sub-sizes of its
     * owners [see the first step of calculateEffectiveSizes()] have already
     * been calculated. Note that the method doesn't make any assumptions about
     * the order in which dumps are visited.
     */
    calculateDumpOwnershipCoefficient_: function(dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump))
        return;

      // We only need to consider owned dumps.
      if (dump.ownedBy.length === 0)
        return;

      // Sort the owners in decreasing order of ownership importance and
      // increasing order of not-owning sub-size (in case of equal importance).
      var owners = dump.ownedBy.map(function(ownershipLink) {
        return {
          dump: ownershipLink.source,
          importance: optional(ownershipLink.importance, 0),
          notOwningSubSize: optional(ownershipLink.source.notOwningSubSize_, 0)
        };
      });
      owners.sort(function(a, b) {
        if (a.importance === b.importance)
          return a.notOwningSubSize - b.notOwningSubSize;
        return b.importance - a.importance;
      });

      // Loop over the list of owners and distribute the owned dump's not-owned
      // sub-size among them according to their ownership importance and
      // not-owning sub-size.
      var currentImportanceStartPos = 0;
      var alreadyAttributedSubSize = 0;
      while (currentImportanceStartPos < owners.length) {
        var currentImportance = owners[currentImportanceStartPos].importance;

        // Find the position of the first owner with lower priority.
        var nextImportanceStartPos = currentImportanceStartPos + 1;
        while (nextImportanceStartPos < owners.length &&
               owners[nextImportanceStartPos].importance ===
                  currentImportance) {
          nextImportanceStartPos++;
        }

        // Visit the owners with the same importance in increasing order of
        // not-owned sub-size, split the owned memory among them appropriately,
        // and calculate their owning coefficients.
        var attributedNotOwningSubSize = 0;
        for (var pos = currentImportanceStartPos; pos < nextImportanceStartPos;
             pos++) {
          var owner = owners[pos];
          var notOwningSubSize = owner.notOwningSubSize;
          if (notOwningSubSize > alreadyAttributedSubSize) {
            attributedNotOwningSubSize +=
                (notOwningSubSize - alreadyAttributedSubSize) /
                (nextImportanceStartPos - pos);
            alreadyAttributedSubSize = notOwningSubSize;
          }

          var owningCoefficient = 0;
          if (notOwningSubSize !== 0)
            owningCoefficient = attributedNotOwningSubSize / notOwningSubSize;
          owner.dump.owningCoefficient_ = owningCoefficient;
        }

        currentImportanceStartPos = nextImportanceStartPos;
      }

      // Attribute the remainder of the owned dump's not-owned sub-size to
      // the dump itself and calculate its owned coefficient.
      var notOwnedSubSize = optional(dump.notOwnedSubSize_, 0);
      var remainderSubSize = notOwnedSubSize - alreadyAttributedSubSize;
      var ownedCoefficient = 0;
      if (notOwnedSubSize !== 0)
        ownedCoefficient = remainderSubSize / notOwnedSubSize;
      dump.ownedCoefficient_ = ownedCoefficient;
    },

    /**
     * Calculate cumulative owned and owning coefficients of a memory allocator
     * dump from its (non-cumulative) owned and owning coefficients and the
     * cumulative coefficients of its parent and/or owned dump.
     *
     * The cumulative coefficients represent the total effect of all
     * (non-strict) ancestor ownerships on a memory allocator dump. The
     * cumulative owned coefficient of a MAD can be calculated simply as:
     *
     *   cumulativeOwnedC(M) = ownedC(M) * cumulativeOwnedC(parent(M))
     *
     * This reflects the assumption that if a parent of a child MAD is
     * (partially) owned, then the parent's owner also indirectly owns (a part
     * of) the child MAD.
     *
     * The cumulative owning coefficient of a MAD depends on whether the MAD
     * owns another dump:
     *
     *                           [if M doesn't own another MAD]
     *                         / cumulativeOwningC(parent(M))
     *   cumulativeOwningC(M) =
     *                         \ [if M owns another MAD]
     *                           owningC(M) * cumulativeOwningC(owned(M))
     *
     * The reasoning behind the first case is similar to the one for cumulative
     * owned coefficient above. The only difference is that we don't need to
     * include the dump's (non-cumulative) owning coefficient because it is
     * implicitly 1.
     *
     * The formula for the second case is derived as follows: Since the MAD
     * owns another dump, its memory is not included in its parent's not-owning
     * sub-size and hence shouldn't be affected by the parent's corresponding
     * cumulative coefficient. Instead, the MAD indirectly owns everything
     * owned by its owned dump (and so it should be affected by the
     * corresponding coefficient).
     *
     * Note that undefined coefficients (and coefficients of non-existent
     * dumps) are implicitly assumed to be 1.
     *
     * This method assumes that (1) the size of the dump [see calculateSizes()],
     * (2) the (non-cumulative) owned and owning coefficients of the dump [see
     * the second step of calculateEffectiveSizes()], and (3) the cumulative
     * coefficients of the dump's parent and owned MADs (if present)
     * [depth-first pre-order traversal] have already been calculated.
     */
    calculateDumpCumulativeOwnershipCoefficient_: function(dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump))
        return;

      var cumulativeOwnedCoefficient = optional(dump.ownedCoefficient_, 1);
      var parent = dump.parent;
      if (dump.parent !== undefined)
        cumulativeOwnedCoefficient *= dump.parent.cumulativeOwnedCoefficient_;
      dump.cumulativeOwnedCoefficient_ = cumulativeOwnedCoefficient;

      var cumulativeOwningCoefficient;
      if (dump.owns !== undefined) {
        cumulativeOwningCoefficient = dump.owningCoefficient_ *
            dump.owns.target.cumulativeOwningCoefficient_;
      } else if (dump.parent !== undefined) {
        cumulativeOwningCoefficient = dump.parent.cumulativeOwningCoefficient_;
      } else {
        cumulativeOwningCoefficient = 1;
      }
      dump.cumulativeOwningCoefficient_ = cumulativeOwningCoefficient;
    },

    /**
     * Calculate the effective size of a memory allocator dump.
     *
     * In order to simplify the (already complex) calculation, we use the fact
     * that effective size is cumulative (unlike regular size), i.e. the
     * effective size of a non-leaf node is equal to the sum of effective sizes
     * of its children. The effective size of a leaf MAD is calculated as:
     *
     *   effectiveSize(M) = size(M) * cumulativeOwningC(M) * cumulativeOwnedC(M)
     *
     * This method assumes that (1) the size of the dump and its children [see
     * calculateSizes()] and (2) the cumulative owning and owned coefficients
     * of the dump (if it's a leaf node) [see the third step of
     * calculateEffectiveSizes()] or the effective sizes of its children (if
     * it's a non-leaf node) [depth-first post-order traversal] have already
     * been calculated.
     */
    calculateDumpEffectiveSize_: function(dump) {
      // Completely skip dumps with undefined size. As a result, each dump will
      // have defined effective size if and only if it has defined size.
      if (!hasSize(dump)) {
        // The rest of the pipeline relies on effective size being either a
        // valid ScalarAttribute, or undefined.
        dump.attributes[EFFECTIVE_SIZE_ATTRIBUTE_NAME] = undefined;
        return;
      }

      var effectiveSize;
      if (dump.children === undefined || dump.children.length === 0) {
        // Leaf dump.
        effectiveSize = getSize(dump) * dump.cumulativeOwningCoefficient_ *
            dump.cumulativeOwnedCoefficient_;
      } else {
        // Non-leaf dump.
        effectiveSize = 0;
        dump.children.forEach(function(childDump) {
          if (!hasSize(childDump))
            return;
          effectiveSize +=
              childDump.attributes[EFFECTIVE_SIZE_ATTRIBUTE_NAME].value;
        });
      }
      var attribute = new tr.model.ScalarAttribute('bytes', effectiveSize);
      dump.attributes[EFFECTIVE_SIZE_ATTRIBUTE_NAME] = attribute;

      // Add attribute infos regarding ownership (if applicable).
      // TODO(petrcermak): This belongs to the corresponding analysis UI code.
      if (dump.ownedBy.length > 0) {
        var message = 'shared by:' +
            dump.ownedBy.map(function(ownershipLink) {
              return '\n  - ' + ownershipToUserFriendlyString(
                  ownershipLink.source, ownershipLink.importance);
            }).join();
        attribute.infos.push(new tr.model.AttributeInfo(
            tr.model.AttributeInfoType.MEMORY_OWNED, message));
      }
      if (dump.owns !== undefined) {
        var target = dump.owns.target;
        var message = 'shares ' +
            ownershipToUserFriendlyString(target, dump.owns.importance) +
            ' with';

        var otherOwnershipLinks = target.ownedBy.filter(
            function(ownershipLink) {
          return ownershipLink.source !== dump;
        });
        if (otherOwnershipLinks.length > 0) {
          message += ':';
          message += otherOwnershipLinks.map(function(ownershipLink) {
            return '\n  - ' + ownershipToUserFriendlyString(
                ownershipLink.source, ownershipLink.importance);
          }).join();
        } else {
          message += ' no other dumps';
        }

        attribute.infos.push(new tr.model.AttributeInfo(
            tr.model.AttributeInfoType.MEMORY_OWNER, message));
      }
    },

    aggregateAttributes: function() {
      this.iterateRootAllocatorDumps(function(dump) {
        dump.aggregateAttributes(this.model);
      });
    },

    discountTracingOverhead: function() {
      // TODO(petrcermak): Consider factoring out all the finalization code and
      // constants to a single file.
      tr.b.iterItems(this.processMemoryDumps, function(pid, dump) {
        dump.discountTracingOverhead(this.model);
      }, this);
    },

    iterateContainerDumps: function(fn) {
      fn.call(this, this);
      tr.b.iterItems(this.processMemoryDumps, function(pid, processDump) {
        fn.call(this, processDump);
      }, this);
    },

    iterateRootAllocatorDumps: function(fn) {
      this.iterateContainerDumps(function(containerDump) {
        var memoryAllocatorDumps = containerDump.memoryAllocatorDumps;
        if (memoryAllocatorDumps === undefined)
          return;
        memoryAllocatorDumps.forEach(fn, this);
      });
    },

    /**
     * Traverse the memory dump graph in a depth first post-order, i.e.
     * children and owners of a memory allocator dump are visited before the
     * dump itself. This method will throw an exception if the graph contains
     * a cycle.
     */
    traverseAllocatorDumpsInDepthFirstPostOrder: function(fn) {
      var visitedDumps = new WeakSet();
      var openDumps = new WeakSet();

      function visit(dump) {
        if (visitedDumps.has(dump))
          return;

        if (openDumps.has(dump))
          throw new Error(dump.userFriendlyName + ' contains a cycle');
        openDumps.add(dump);

        // Visit owners before the dumps they own.
        dump.ownedBy.forEach(function(ownershipLink) {
          visit.call(this, ownershipLink.source);
        }, this);

        // Visit children before parents.
        dump.children.forEach(visit, this);

        // Actually visit the current memory allocator dump.
        fn.call(this, dump);
        visitedDumps.add(dump);

        openDumps.delete(dump);
      }

      this.iterateRootAllocatorDumps(visit);
    },

    /**
     * Traverse the memory dump graph in a depth first pre-order, i.e.
     * children and owners of a memory allocator dump are visited after the
     * dump itself. This method will not visit some dumps if the graph contains
     * a cycle.
     */
    traverseAllocatorDumpsInDepthFirstPreOrder: function(fn) {
      var visitedDumps = new WeakSet();

      function visit(dump) {
        if (visitedDumps.has(dump))
          return;

        // If this dumps owns another dump which hasn't been visited yet, then
        // wait for this dump to be visited later.
        if (dump.owns !== undefined && !visitedDumps.has(dump.owns.target))
          return;

        // If this dump's parent hasn't been visited yet, then wait for this
        // dump to be visited later.
        if (dump.parent !== undefined && !visitedDumps.has(dump.parent))
          return;

        // Actually visit the current memory allocator dump.
        fn.call(this, dump);
        visitedDumps.add(dump);

        // Visit owners after the dumps they own.
        dump.ownedBy.forEach(function(ownershipLink) {
          visit.call(this, ownershipLink.source);
        }, this);

        // Visit children after parents.
        dump.children.forEach(visit, this);
      }

      this.iterateRootAllocatorDumps(visit);
    }
  };

  tr.model.EventRegistry.register(
      GlobalMemoryDump,
      {
        name: 'globalMemoryDump',
        pluralName: 'globalMemoryDumps',
        singleViewElementName: 'tr-ui-a-single-global-memory-dump-sub-view',
        multiViewElementName: 'tr-ui-a-multi-global-memory-dump-sub-view'
      });

  return {
    GlobalMemoryDump: GlobalMemoryDump
  };
});


'use strict';

/**
 * @fileoverview Provides the InstantEvent class.
 */
tr.exportTo('tr.model', function() {
  var InstantEventType = {
    GLOBAL: 1,
    PROCESS: 2
  };

  function InstantEvent(category, title, colorId, start, args) {
    tr.model.TimedEvent.call(this);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.start = start;
    this.args = args;

    this.type = undefined;
  };

  InstantEvent.prototype = {
    __proto__: tr.model.TimedEvent.prototype
  };

  function GlobalInstantEvent(category, title, colorId, start, args) {
    InstantEvent.apply(this, arguments);
    this.type = InstantEventType.GLOBAL;
  };

  GlobalInstantEvent.prototype = {
    __proto__: InstantEvent.prototype,
    get userFriendlyName() {
      return 'Global instant event ' + this.title + ' @ ' +
          tr.b.u.TimeStamp.format(start);
    }
  };

  function ProcessInstantEvent(category, title, colorId, start, args) {
    InstantEvent.apply(this, arguments);
    this.type = InstantEventType.PROCESS;
  };

  ProcessInstantEvent.prototype = {
    __proto__: InstantEvent.prototype,

    get userFriendlyName() {
      return 'Process-level instant event ' + this.title + ' @ ' +
          tr.b.u.TimeStamp.format(start);
    }
  };

  tr.model.EventRegistry.register(
      InstantEvent,
      {
        name: 'instantEvent',
        pluralName: 'instantEvents',
        singleViewElementName: 'tr-ui-a-single-instant-event-sub-view',
        multiViewElementName: 'tr-ui-a-multi-instant-event-sub-view'
      });

  return {
    GlobalInstantEvent: GlobalInstantEvent,
    ProcessInstantEvent: ProcessInstantEvent,

    InstantEventType: InstantEventType,
    InstantEvent: InstantEvent
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  /**
   * Indicates how much of a compound-event is selected [if any].
   *
   * The CompoundEventSelectionState enum is used with events that are
   * directly selectable, but also have associated events, too, that can be
   * selected. In this situation, there are a variety of different
   * selected states other than just "yes, no". This enum encodes those
   * various possible states.
   */
  var CompoundEventSelectionState = {
    // Basic bit states.
    NOT_SELECTED: 0,
    EVENT_SELECTED: 0x1,
    SOME_ASSOCIATED_EVENTS_SELECTED: 0x2,
    ALL_ASSOCIATED_EVENTS_SELECTED: 0x4,

    // Common combinations.
    EVENT_AND_SOME_ASSOCIATED_SELECTED: 0x1 | 0x2,
    EVENT_AND_ALL_ASSOCIATED_SELECTED: 0x1 | 0x4
  };

  return {
    CompoundEventSelectionState: CompoundEventSelectionState
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  var CompoundEventSelectionState = tr.model.CompoundEventSelectionState;

  function InteractionRecord(title, colorId, start, duration) {
    tr.model.TimedEvent.call(this, start);
    this.title = title;
    this.colorId = colorId;
    this.duration = duration;
    this.args = {};
    this.associatedEvents = new tr.model.EventSet();

    // sourceEvents are the ones that caused the IR Finder to create this IR.
    this.sourceEvents = new tr.model.EventSet();
  }

  InteractionRecord.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get subSlices() {
      return [];
    },

    get userFriendlyName() {
      return this.title + ' interaction at ' +
          tr.b.u.TimeStamp.format(this.start);
    },

    computeCompoundEvenSelectionState: function(selection) {
      var cess = CompoundEventSelectionState.NOT_SELECTED;
      if (selection.contains(this))
        cess |= CompoundEventSelectionState.EVENT_SELECTED;

      if (this.associatedEvents.intersectionIsEmpty(selection))
        return cess;

      var allContained = this.associatedEvents.every(function(event) {
        return selection.contains(event);
      });

      if (allContained)
        cess |= CompoundEventSelectionState.ALL_ASSOCIATED_EVENTS_SELECTED;
      else
        cess |= CompoundEventSelectionState.SOME_ASSOCIATED_EVENTS_SELECTED;
      return cess;
    }
  };

  tr.model.EventRegistry.register(
      InteractionRecord,
      {
        name: 'interaction',
        pluralName: 'interactions',
        singleViewElementName: 'tr-ui-a-single-interaction-record-sub-view',
        multiViewElementName: 'tr-ui-a-multi-interaction-record-sub-view'
      });

  return {
    InteractionRecord: InteractionRecord
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  /**
   * The value of a given measurement at a given time.
   *
   * As an example, if we're measuring the throughput of data sent over a USB
   * connection, each counter sample might represent the instantaneous
   * throughput of the connection at a given time.
   *
   * @constructor
   * @extends {Event}
   */
  function CounterSample(series, timestamp, value) {
    tr.model.Event.call(this);
    this.series_ = series;
    this.timestamp_ = timestamp;
    this.value_ = value;
  }

  CounterSample.groupByTimestamp = function(samples) {
    var samplesByTimestamp = tr.b.group(samples, function(sample) {
      return sample.timestamp;
    });

    var timestamps = tr.b.dictionaryKeys(samplesByTimestamp);
    timestamps.sort();
    var groups = [];
    for (var i = 0; i < timestamps.length; i++) {
      var ts = timestamps[i];
      var group = samplesByTimestamp[ts];
      group.sort(function(x, y) {
        return x.series.seriesIndex - y.series.seriesIndex;
      });
      groups.push(group);
    }
    return groups;
  }

  CounterSample.prototype = {
    __proto__: tr.model.Event.prototype,

    get series() {
      return this.series_;
    },

    get timestamp() {
      return this.timestamp_;
    },

    get value() {
      return this.value_;
    },

    set timestamp(timestamp) {
      this.timestamp_ = timestamp;
    },

    addBoundsToRange: function(range) {
      range.addValue(this.timestamp);
    },

    getSampleIndex: function() {
      return tr.b.findLowIndexInSortedArray(
          this.series.timestamps,
          function(x) { return x; },
          this.timestamp_);
    },

    get userFriendlyName() {
      return 'Counter sample from ' + this.series_.title + ' at ' +
          tr.b.u.TimeStamp.format(this.timestamp);
    }
  };


  tr.model.EventRegistry.register(
      CounterSample,
      {
        name: 'counterSample',
        pluralName: 'counterSamples',
        singleViewElementName: 'tr-ui-a-counter-sample-sub-view',
        multiViewElementName: 'tr-ui-a-counter-sample-sub-view'
      });

  return {
    CounterSample: CounterSample
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  var CounterSample = tr.model.CounterSample;

  /**
   * A container holding all samples of a given measurement over time.
   *
   * As an example, a counter series might measure the throughput of data sent
   * over a USB connection, with each sample representing the instantaneous
   * throughput of the connection.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function CounterSeries(name, color) {
    tr.model.EventContainer.call(this);

    this.name_ = name;
    this.color_ = color;

    this.timestamps_ = [];
    this.samples_ = [];

    // Set by counter.addSeries
    this.counter = undefined;
    this.seriesIndex = undefined;
  }

  CounterSeries.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get length() {
      return this.timestamps_.length;
    },

    get name() {
      return this.name_;
    },

    get color() {
      return this.color_;
    },

    get samples() {
      return this.samples_;
    },

    get timestamps() {
      return this.timestamps_;
    },

    getSample: function(idx) {
      return this.samples_[idx];
    },

    getTimestamp: function(idx) {
      return this.timestamps_[idx];
    },

    addCounterSample: function(ts, val) {
      var sample = new CounterSample(this, ts, val);
      this.addSample(sample);
      return sample;
    },

    addSample: function(sample) {
      this.timestamps_.push(sample.timestamp);
      this.samples_.push(sample);
    },

    getStatistics: function(sampleIndices) {
      var sum = 0;
      var min = Number.MAX_VALUE;
      var max = -Number.MAX_VALUE;

      for (var i = 0; i < sampleIndices.length; ++i) {
        var sample = this.getSample(sampleIndices[i]).value;

        sum += sample;
        min = Math.min(sample, min);
        max = Math.max(sample, max);
      }

      return {
        min: min,
        max: max,
        avg: (sum / sampleIndices.length),
        start: this.getSample(sampleIndices[0]).value,
        end: this.getSample(sampleIndices.length - 1).value
      };
    },

    shiftTimestampsForward: function(amount) {
      for (var i = 0; i < this.timestamps_.length; ++i) {
        this.timestamps_[i] += amount;
        this.samples_[i].timestamp = this.timestamps_[i];
      }
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      if (eventTypePredicate.call(opt_this, tr.model.CounterSample)) {
        this.samples_.forEach(callback, opt_this);
      }
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
    }
  };

  return {
    CounterSeries: CounterSeries
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  /**
   * A container holding all series of a given type of measurement.
   *
   * As an example, if we're measuring the throughput of data sent over several
   * USB connections, the throughput of each cable might be added as a separate
   * series to a single counter.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function Counter(parent, id, category, name) {
    tr.model.EventContainer.call(this);

    this.parent_ = parent;
    this.id_ = id;
    this.category_ = category || '';
    this.name_ = name;

    this.series_ = [];
    this.totals = [];
  }

  Counter.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parent() {
      return this.parent_;
    },

    get id() {
      return this.id_;
    },

    get category() {
      return this.category_;
    },

    get name() {
      return this.name_;
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
      for (var i = 0; i < this.series_.length; i++)
        callback.call(opt_this, this.series_[i]);
    },

    set timestamps(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set seriesNames(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set seriesColors(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set samples(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    addSeries: function(series) {
      series.counter = this;
      series.seriesIndex = this.series_.length;
      this.series_.push(series);
      return series;
    },

    getSeries: function(idx) {
      return this.series_[idx];
    },

    get series() {
      return this.series_;
    },

    get numSeries() {
      return this.series_.length;
    },

    get numSamples() {
      if (this.series_.length === 0)
        return 0;
      return this.series_[0].length;
    },

    get timestamps() {
      if (this.series_.length === 0)
        return [];
      return this.series_[0].timestamps;
    },

    /**
     * Obtains min, max, avg, values, start, and end for different series for
     * a given counter
     *     getSampleStatistics([0,1])
     * The statistics objects that this returns are an array of objects, one
     * object for each series for the counter in the form:
     * {min: minVal, max: maxVal, avg: avgVal, start: startVal, end: endVal}
     *
     * @param {Array.<Number>} Indices to summarize.
     * @return {Object} An array of statistics. Each element in the array
     * has data for one of the series in the selected counter.
     */
    getSampleStatistics: function(sampleIndices) {
      sampleIndices.sort();

      var ret = [];
      this.series_.forEach(function(series) {
        ret.push(series.getStatistics(sampleIndices));
      });
      return ret;
    },

    /**
     * Shifts all the timestamps inside this counter forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      for (var i = 0; i < this.series_.length; ++i)
        this.series_[i].shiftTimestampsForward(amount);
    },

    /**
     * Updates the bounds for this counter based on the samples it contains.
     */
    updateBounds: function() {
      this.totals = [];
      this.maxTotal = 0;
      this.bounds.reset();

      if (this.series_.length === 0)
        return;

      var firstSeries = this.series_[0];
      var lastSeries = this.series_[this.series_.length - 1];

      this.bounds.addValue(firstSeries.getTimestamp(0));
      this.bounds.addValue(lastSeries.getTimestamp(lastSeries.length - 1));

      var numSeries = this.numSeries;
      this.maxTotal = -Infinity;

      // Sum the samples at each timestamp.
      // Note, this assumes that all series have all timestamps.
      for (var i = 0; i < firstSeries.length; ++i) {
        var total = 0;
        this.series_.forEach(function(series) {
          total += series.getSample(i).value;
          this.totals.push(total);
        }.bind(this));

        this.maxTotal = Math.max(total, this.maxTotal);
      }
    }
  };

  /**
   * Comparison between counters that orders by parent.compareTo, then name.
   */
  Counter.compare = function(x, y) {
    var tmp = x.parent.compareTo(y);
    if (tmp != 0)
      return tmp;
    var tmp = x.name.localeCompare(y.name);
    if (tmp == 0)
      return x.tid - y.tid;
    return tmp;
  };

  return {
    Counter: Counter
  };
});


'use strict';

/**
 * @fileoverview Provides the Slice class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A Slice represents an interval of time plus parameters associated
   * with that interval.
   *
   * @constructor
   */
  function Slice(category, title, colorId, start, args, opt_duration,
                 opt_cpuStart, opt_cpuDuration, opt_argsStripped,
                 opt_bind_id) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.args = args;
    this.startStackFrame = undefined;
    this.endStackFrame = undefined;
    this.didNotFinish = false;
    this.inFlowEvents = [];
    this.outFlowEvents = [];
    this.subSlices = [];
    this.selfTime = undefined;
    this.cpuSelfTime = undefined;
    this.important = false;
    this.parentContainer = undefined;
    this.argsStripped = false;

    this.bind_id_ = opt_bind_id;

    // parentSlice and isTopLevel will be set by SliceGroup.
    this.parentSlice = undefined;
    this.isTopLevel = false;
    // After SliceGroup processes Slices, isTopLevel should be equivalent to
    // !parentSlice.

    if (opt_duration !== undefined)
      this.duration = opt_duration;

    if (opt_cpuStart !== undefined)
      this.cpuStart = opt_cpuStart;

    if (opt_cpuDuration !== undefined)
      this.cpuDuration = opt_cpuDuration;

    if (opt_argsStripped !== undefined)
      this.argsStripped = true;
  }

  Slice.prototype = {
    __proto__: tr.model.TimedEvent.prototype,


    get analysisTypeName() {
      return this.title;
    },

    get userFriendlyName() {
      return 'Slice ' + this.title + ' at ' +
          tr.b.u.TimeStamp.format(this.start);
    },

    findDescendentSlice: function(targetTitle) {
      if (!this.subSlices)
        return undefined;

      for (var i = 0; i < this.subSlices.length; i++) {
        if (this.subSlices[i].title == targetTitle)
          return this.subSlices[i];
        var slice = this.subSlices[i].findDescendentSlice(targetTitle);
        if (slice) return slice;
      }
      return undefined;
    },

    get mostTopLevelSlice() {
      var curSlice = this;
      while (curSlice.parentSlice)
        curSlice = curSlice.parentSlice;

      return curSlice;
    },

    /**
     * Obtains all subsequent slices of this slice.
     *
     * Subsequent slices are slices that get executed after a particular
     * slice, i.e., all the functions that are called after the current one.
     *
     * For instance, E.iterateAllSubsequentSlices() in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will pass F, G, then H to the provided callback.
     *
     * The reason we need subsequent slices of a particular slice is that
     * when there is flow event goes into, e.g., E, we only want to highlight
     * E's subsequent slices to indicate the execution order.
     *
     * The idea to calculate the subsequent slices of slice E is to view
     * the slice group as a tree where the top-level slice A is the root node.
     * The preorder depth-first-search (DFS) order is naturally equivalent
     * to the function call order. We just need to perform a DFS, and start
     * recording the slices after we see the occurance of E.
     */
    iterateAllSubsequentSlices: function(callback, opt_this) {
      var parentStack = [];
      var started = false;

      // get the root node and push it to the DFS stack
      var topmostSlice = this.mostTopLevelSlice;
      parentStack.push(topmostSlice);

      // Using the stack to perform DFS
      while (parentStack.length !== 0) {
        var curSlice = parentStack.pop();

        if (started)
          callback.call(opt_this, curSlice);
        else
          started = (curSlice.guid === this.guid);

        for (var i = curSlice.subSlices.length - 1; i >= 0; i--) {
          parentStack.push(curSlice.subSlices[i]);
        }
      }
    },

    get subsequentSlices() {
      var res = [];

      this.iterateAllSubsequentSlices(function(subseqSlice) {
        res.push(subseqSlice);
      });

      return res;
    },

    /**
     * Obtains the parents of a slice, from the most immediate to the root.
     *
     * For instance, E.iterateAllAncestors() in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will pass D, then A to the provided callback, in the order from the
     * leaves to the root.
     */
    iterateAllAncestors: function(callback, opt_this) {
      var curSlice = this;

      while (curSlice.parentSlice) {
        curSlice = curSlice.parentSlice;
        callback.call(opt_this, curSlice);
      }
    },

    get ancestorSlices() {
      var res = [];

      this.iterateAllAncestors(function(ancestor) {
        res.push(ancestor);
      });

      return res;
    },

    iterateEntireHierarchy: function(callback, opt_this) {
      var mostTopLevelSlice = this.mostTopLevelSlice;
      callback.call(opt_this, mostTopLevelSlice);
      mostTopLevelSlice.iterateAllSubsequentSlices(callback, opt_this);
    },

    get entireHierarchy() {
      var res = [];

      this.iterateEntireHierarchy(function(slice) {
        res.push(slice);
      });

      return res;
    },

    /**
     * Returns this slice, and its ancestor and subsequent slices.
     *
     * For instance, E.ancestorAndSubsequentSlices in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will return E, D, A, F, G, and H, where E is itself, D and A are
     * E's ancestors, and F, G, and H are subsequent slices of E
     */
    get ancestorAndSubsequentSlices() {
      var res = [];

      res.push(this);

      this.iterateAllAncestors(function(aSlice) {
        res.push(aSlice);
      });

      this.iterateAllSubsequentSlices(function(sSlice) {
        res.push(sSlice);
      });

      return res;
    },

    iterateAllDescendents: function(callback, opt_this) {
      this.subSlices.forEach(callback, opt_this);
      this.subSlices.forEach(function(subSlice) {
        subSlice.iterateAllDescendents(callback, opt_this);
      }, opt_this);
    },

    get descendentSlices() {
      var res = [];

      this.iterateAllDescendents(function(des) {
        res.push(des);
      });

      return res;
    }

  };

  return {
    Slice: Slice
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  var Slice = tr.model.Slice;


  var SCHEDULING_STATE = {
    DEBUG: 'Debug',
    EXIT_DEAD: 'Exit Dead',
    RUNNABLE: 'Runnable',
    RUNNING: 'Running',
    SLEEPING: 'Sleeping',
    STOPPED: 'Stopped',
    TASK_DEAD: 'Task Dead',
    UNINTR_SLEEP: 'Uninterruptible Sleep',
    UNINTR_SLEEP_WAKE_KILL: 'Uninterruptible Sleep | WakeKill',
    UNINTR_SLEEP_WAKING: 'Uninterruptible Sleep | Waking',
    UNKNOWN: 'UNKNOWN',
    WAKE_KILL: 'Wakekill',
    WAKING: 'Waking',
    ZOMBIE: 'Zombie'
  };

  /**
   * A ThreadTimeSlice is a slice of time on a specific thread where that thread
   * was running on a specific CPU, or in a specific sleep state.
   *
   * As a thread switches moves through its life, it sometimes goes to sleep and
   * can't run. Other times, its runnable but isn't actually assigned to a CPU.
   * Finally, sometimes it gets put on a CPU to actually execute. Each of these
   * states is represented by a ThreadTimeSlice:
   *
   *   Sleeping or runnable: cpuOnWhichThreadWasRunning is undefined
   *   Running:  cpuOnWhichThreadWasRunning is set.
   *
   * @constructor
   */
  function ThreadTimeSlice(thread, schedulingState, cat,
                           start, args, opt_duration) {
    Slice.call(this, cat, schedulingState,
               this.getColorForState_(schedulingState),
        start, args, opt_duration);
    this.thread = thread;
    this.schedulingState = schedulingState;
    this.cpuOnWhichThreadWasRunning = undefined;
  }

  ThreadTimeSlice.prototype = {
    __proto__: Slice.prototype,

    getColorForState_: function(state) {
      var getColorIdForReservedName = tr.ui.b.getColorIdForReservedName;
      switch (state) {
        case SCHEDULING_STATE.RUNNABLE:
          return getColorIdForReservedName('thread_state_runnable');
        case SCHEDULING_STATE.RUNNING:
          return getColorIdForReservedName('thread_state_running');
        case SCHEDULING_STATE.SLEEPING:
          return getColorIdForReservedName('thread_state_sleeping');
        case SCHEDULING_STATE.DEBUG:
        case SCHEDULING_STATE.EXIT_DEAD:
        case SCHEDULING_STATE.STOPPED:
        case SCHEDULING_STATE.TASK_DEAD:
        case SCHEDULING_STATE.UNINTR_SLEEP:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKING:
        case SCHEDULING_STATE.UNKNOWN:
        case SCHEDULING_STATE.WAKE_KILL:
        case SCHEDULING_STATE.WAKING:
        case SCHEDULING_STATE.ZOMBIE:
          return getColorIdForReservedName('thread_state_iowait');
        default:
          return getColorIdForReservedName('thread_state_unknown');
      }
    },

    get analysisTypeName() {
      return 'tr.ui.analysis.ThreadTimeSlice';
    },

    getAssociatedCpuSlice: function() {
      if (!this.cpuOnWhichThreadWasRunning)
        return undefined;
      var cpuSlices = this.cpuOnWhichThreadWasRunning.slices;
      for (var i = 0; i < cpuSlices.length; i++) {
        var cpuSlice = cpuSlices[i];
        if (cpuSlice.start !== this.start)
          continue;
        if (cpuSlice.duration !== this.duration)
          continue;
        return cpuSlice;
      }
      return undefined;
    },

    getCpuSliceThatTookCpu: function() {
      if (this.cpuOnWhichThreadWasRunning)
        return undefined;
      var curIndex = this.thread.indexOfTimeSlice(this);
      var cpuSliceWhenLastRunning;
      while (curIndex >= 0) {
        var curSlice = this.thread.timeSlices[curIndex];
        if (!curSlice.cpuOnWhichThreadWasRunning) {
          curIndex--;
          continue;
        }
        cpuSliceWhenLastRunning = curSlice.getAssociatedCpuSlice();
        break;
      }
      if (!cpuSliceWhenLastRunning)
        return undefined;

      var cpu = cpuSliceWhenLastRunning.cpu;
      var indexOfSliceOnCpuWhenLastRunning =
          cpu.indexOf(cpuSliceWhenLastRunning);
      var nextRunningSlice = cpu.slices[indexOfSliceOnCpuWhenLastRunning + 1];
      if (!nextRunningSlice)
        return undefined;
      if (Math.abs(nextRunningSlice.start - cpuSliceWhenLastRunning.end) <
          0.00001)
        return nextRunningSlice;
      return undefined;
    }
  };

  tr.model.EventRegistry.register(
      ThreadTimeSlice,
      {
        name: 'threadTimeSlice',
        pluralName: 'threadTimeSlices',
        singleViewElementName: 'tr-ui-a-single-thread-time-slice-sub-view',
        multiViewElementName: 'tr-ui-a-multi-thread-time-slice-sub-view'
      });


  return {
    ThreadTimeSlice: ThreadTimeSlice,
    SCHEDULING_STATE: SCHEDULING_STATE
  };
});


'use strict';

/**
 * @fileoverview Provides the CpuSlice class.
 */
tr.exportTo('tr.model', function() {

  var Slice = tr.model.Slice;

  /**
   * A CpuSlice represents a slice of time on a CPU.
   *
   * @constructor
   */
  function CpuSlice(cat, title, colorId, start, args, opt_duration) {
    Slice.apply(this, arguments);
    this.threadThatWasRunning = undefined;
    this.cpu = undefined;
  }

  CpuSlice.prototype = {
    __proto__: Slice.prototype,

    get analysisTypeName() {
      return 'tr.ui.analysis.CpuSlice';
    },

    getAssociatedTimeslice: function() {
      if (!this.threadThatWasRunning)
        return undefined;
      var timeSlices = this.threadThatWasRunning.timeSlices;
      for (var i = 0; i < timeSlices.length; i++) {
        var timeSlice = timeSlices[i];
        if (timeSlice.start !== this.start)
          continue;
        if (timeSlice.duration !== this.duration)
          continue;
        return timeSlice;
      }
      return undefined;
    }
  };

  tr.model.EventRegistry.register(
      CpuSlice,
      {
        name: 'cpuSlice',
        pluralName: 'cpuSlices',
        singleViewElementName: 'tr-ui-a-single-cpu-slice-sub-view',
        multiViewElementName: 'tr-ui-a-multi-cpu-slice-sub-view'
      });

  return {
    CpuSlice: CpuSlice
  };
});


'use strict';

/**
 * @fileoverview Provides the Cpu class.
 */
tr.exportTo('tr.model', function() {

  var Counter = tr.model.Counter;
  var Slice = tr.model.Slice;
  var CpuSlice = tr.model.CpuSlice;

  /**
   * The Cpu represents a Cpu from the kernel's point of view.
   * @constructor
   */
  function Cpu(kernel, number) {
    if (kernel === undefined || number === undefined)
      throw new Error('Missing arguments');
    this.kernel = kernel;
    this.cpuNumber = number;
    this.slices = [];
    this.counters = {};
    this.bounds = new tr.b.Range();
    this.samples_ = undefined; // Set during createSubSlices

    // Start timestamp of the last active thread.
    this.lastActiveTimestamp_ = undefined;

    // Identifier of the last active thread. On Linux, it's a pid while on
    // Windows it's a thread id.
    this.lastActiveThread_ = undefined;

    // Name and arguments of the last active thread.
    this.lastActiveName_ = undefined;
    this.lastActiveArgs_ = undefined;
  };

  Cpu.prototype = {
    get samples() {
      return this.samples_;
    },

    get userFriendlyName() {
      return 'CPU ' + this.cpuNumber;
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      if (eventTypePredicate.call(opt_this, tr.model.CpuSlice))
        this.slices.forEach(callback, opt_this);

      if (this.samples_) {
        if (eventTypePredicate.call(opt_this, tr.model.Sample))
          this.samples_.forEach(callback, opt_this);
      }
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
      for (var id in this.counters)
        callback.call(opt_this, this.counters[id]);
    },

    /**
     * @return {Counter} The counter on this CPU with the given category/name
     * combination, creating it if it doesn't exist.
     */
    getOrCreateCounter: function(cat, name) {
      var id = cat + '.' + name;
      if (!this.counters[id])
        this.counters[id] = new Counter(this, id, cat, name);
      return this.counters[id];
    },

    /**
     * @return {Counter} the counter on this CPU with the given category/name
     * combination, or undefined if it doesn't exist.
     */
    getCounter: function(cat, name) {
      var id = cat + '.' + name;
      if (!this.counters[id])
        return undefined;
      return this.counters[id];
    },

    /**
     * Shifts all the timestamps inside this CPU forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      for (var sI = 0; sI < this.slices.length; sI++)
        this.slices[sI].start = (this.slices[sI].start + amount);
      for (var id in this.counters)
        this.counters[id].shiftTimestampsForward(amount);
    },

    /**
     * Updates the range based on the current slices attached to the cpu.
     */
    updateBounds: function() {
      this.bounds.reset();
      if (this.slices.length) {
        this.bounds.addValue(this.slices[0].start);
        this.bounds.addValue(this.slices[this.slices.length - 1].end);
      }
      for (var id in this.counters) {
        this.counters[id].updateBounds();
        this.bounds.addRange(this.counters[id].bounds);
      }
      if (this.samples_ && this.samples_.length) {
        this.bounds.addValue(this.samples_[0].start);
        this.bounds.addValue(
            this.samples_[this.samples_.length - 1].end);
      }
    },

    createSubSlices: function() {
      this.samples_ = this.kernel.model.samples.filter(function(sample) {
        return sample.cpu == this;
      }, this);
    },

    addCategoriesToDict: function(categoriesDict) {
      for (var i = 0; i < this.slices.length; i++)
        categoriesDict[this.slices[i].category] = true;
      for (var id in this.counters)
        categoriesDict[this.counters[id].category] = true;
      for (var i = 0; i < this.samples_.length; i++)
        categoriesDict[this.samples_[i].category] = true;
    },



    /*
     * Returns the index of the slice in the CPU's slices, or undefined.
     */
    indexOf: function(cpuSlice) {
      var i = tr.b.findLowIndexInSortedArray(
          this.slices,
          function(slice) { return slice.start; },
          cpuSlice.start);
      if (this.slices[i] !== cpuSlice)
        return undefined;
      return i;
    },

    /**
     * Closes the thread running on the CPU. |end_timestamp| is the timestamp
     * at which the thread was unscheduled. |args| is merged with the arguments
     * specified when the thread was initially scheduled.
     */
    closeActiveThread: function(end_timestamp, args) {
      // Don't generate a slice if the last active thread is the idle task.
      if (this.lastActiveThread_ == undefined || this.lastActiveThread_ == 0)
        return;

      if (end_timestamp < this.lastActiveTimestamp_) {
        throw new Error('The end timestamp of a thread running on CPU ' +
                        this.cpuNumber + ' is before its start timestamp.');
      }

      // Merge |args| with |this.lastActiveArgs_|. If a key is in both
      // dictionaries, the value from |args| is used.
      for (var key in args) {
        this.lastActiveArgs_[key] = args[key];
      }

      var duration = end_timestamp - this.lastActiveTimestamp_;
      var slice = new tr.model.CpuSlice(
          '', this.lastActiveName_,
          tr.ui.b.getColorIdForGeneralPurposeString(this.lastActiveName_),
          this.lastActiveTimestamp_,
          this.lastActiveArgs_,
          duration);
      slice.cpu = this;
      this.slices.push(slice);

      // Clear the last state.
      this.lastActiveTimestamp_ = undefined;
      this.lastActiveThread_ = undefined;
      this.lastActiveName_ = undefined;
      this.lastActiveArgs_ = undefined;
    },

    switchActiveThread: function(timestamp, old_thread_args, new_thread_id,
                                 new_thread_name, new_thread_args) {
      // Close the previous active thread and generate a slice.
      this.closeActiveThread(timestamp, old_thread_args);

      // Keep track of the new thread.
      this.lastActiveTimestamp_ = timestamp;
      this.lastActiveThread_ = new_thread_id;
      this.lastActiveName_ = new_thread_name;
      this.lastActiveArgs_ = new_thread_args;
    },

    /**
     * Returns the frequency statistics for this CPU;
     * the returned object contains the frequencies as keys,
     * and the duration at this frequency in milliseconds as the value,
     * for the range that was specified.
     */
    getFreqStatsForRange: function(range) {
      var stats = {};

      function addStatsForFreq(freqSample, index) {
        // Counters don't have an explicit end or duration;
        // calculate the end by looking at the starting point
        // of the next value in the series, or if that doesn't
        // exist, assume this frequency is held until the end.
        var freqEnd = (index < freqSample.series_.length - 1) ?
            freqSample.series_.samples_[index + 1].timestamp : range.max;

        var freqRange = tr.b.Range.fromExplicitRange(freqSample.timestamp,
            freqEnd);
        var intersection = freqRange.findIntersection(range);
        if (!(freqSample.value in stats))
          stats[freqSample.value] = 0;
        stats[freqSample.value] += intersection.duration;
      }

      var freqCounter = this.getCounter('', 'Clock Frequency');
      if (freqCounter !== undefined) {
        var freqSeries = freqCounter.getSeries(0);
        if (!freqSeries)
          return;

        tr.b.iterateOverIntersectingIntervals(freqSeries.samples_,
            function(x) { return x.timestamp; },
            function(x, index) { return index < freqSeries.length - 1 ?
                                     freqSeries.samples_[index + 1].timestamp :
                                     range.max; },
            range.min,
            range.max,
            addStatsForFreq);
      }

      return stats;
    }
  };

  /**
   * Comparison between processes that orders by cpuNumber.
   */
  Cpu.compare = function(x, y) {
    return x.cpuNumber - y.cpuNumber;
  };


  return {
    Cpu: Cpu
  };
});


'use strict';

/**
 * @fileoverview Provides the TimeToObjectInstanceMap class.
 */
tr.exportTo('tr.model', function() {
  /**
   * Tracks all the instances associated with a given ID over its lifetime.
   *
   * An id can be used multiple times throughout a trace, referring to different
   * objects at different times. This data structure does the bookkeeping to
   * figure out what ObjectInstance is referred to at a given timestamp.
   *
   * @constructor
   */
  function TimeToObjectInstanceMap(createObjectInstanceFunction, parent, id) {
    this.createObjectInstanceFunction_ = createObjectInstanceFunction;
    this.parent = parent;
    this.id = id;
    this.instances = [];
  }

  TimeToObjectInstanceMap.prototype = {
    idWasCreated: function(category, name, ts) {
      if (this.instances.length == 0) {
        this.instances.push(this.createObjectInstanceFunction_(
            this.parent, this.id, category, name, ts));
        this.instances[0].creationTsWasExplicit = true;
        return this.instances[0];
      }

      var lastInstance = this.instances[this.instances.length - 1];
      if (ts < lastInstance.deletionTs) {
        throw new Error('Mutation of the TimeToObjectInstanceMap must be ' +
                        'done in ascending timestamp order.');
      }
      lastInstance = this.createObjectInstanceFunction_(
          this.parent, this.id, category, name, ts);
      lastInstance.creationTsWasExplicit = true;
      this.instances.push(lastInstance);
      return lastInstance;
    },

    addSnapshot: function(category, name, ts, args, opt_baseTypeName) {
      if (this.instances.length == 0) {
        this.instances.push(this.createObjectInstanceFunction_(
            this.parent, this.id, category, name, ts, opt_baseTypeName));
      }

      var i = tr.b.findIndexInSortedIntervals(
          this.instances,
          function(inst) { return inst.creationTs; },
          function(inst) { return inst.deletionTs - inst.creationTs; },
          ts);

      var instance;
      if (i < 0) {
        instance = this.instances[0];
        if (ts > instance.deletionTs ||
            instance.creationTsWasExplicit) {
          throw new Error(
              'At the provided timestamp, no instance was still alive');
        }

        if (instance.snapshots.length != 0) {
          throw new Error(
              'Cannot shift creationTs forward, ' +
              'snapshots have been added. First snap was at ts=' +
              instance.snapshots[0].ts + ' and creationTs was ' +
              instance.creationTs);
        }
        instance.creationTs = ts;
      } else if (i >= this.instances.length) {
        instance = this.instances[this.instances.length - 1];
        if (ts >= instance.deletionTs) {
          // The snap is added after our oldest and deleted instance. This means
          // that this is a new implicit instance.
          instance = this.createObjectInstanceFunction_(
              this.parent, this.id, category, name, ts, opt_baseTypeName);
          this.instances.push(instance);
        } else {
          // If the ts is before the last objects deletion time, then the caller
          // is trying to add a snapshot when there may have been an instance
          // alive. In that case, try to move an instance's creationTs to
          // include this ts, provided that it has an implicit creationTs.

          // Search backward from the right for an instance that was definitely
          // deleted before this ts. Any time an instance is found that has a
          // moveable creationTs
          var lastValidIndex;
          for (var i = this.instances.length - 1; i >= 0; i--) {
            var tmp = this.instances[i];
            if (ts >= tmp.deletionTs)
              break;
            if (tmp.creationTsWasExplicit == false && tmp.snapshots.length == 0)
              lastValidIndex = i;
          }
          if (lastValidIndex === undefined) {
            throw new Error(
                'Cannot add snapshot. No instance was alive that was mutable.');
          }
          instance = this.instances[lastValidIndex];
          instance.creationTs = ts;
        }
      } else {
        instance = this.instances[i];
      }

      return instance.addSnapshot(ts, args, name, opt_baseTypeName);
    },

    get lastInstance() {
      if (this.instances.length == 0)
        return undefined;
      return this.instances[this.instances.length - 1];
    },

    idWasDeleted: function(category, name, ts) {
      if (this.instances.length == 0) {
        this.instances.push(this.createObjectInstanceFunction_(
            this.parent, this.id, category, name, ts));
      }
      var lastInstance = this.instances[this.instances.length - 1];
      if (ts < lastInstance.creationTs)
        throw new Error('Cannot delete a id before it was crated');
      if (lastInstance.deletionTs == Number.MAX_VALUE) {
        lastInstance.wasDeleted(ts);
        return lastInstance;
      }

      if (ts < lastInstance.deletionTs)
        throw new Error('id was already deleted earlier.');

      // A new instance was deleted with no snapshots in-between.
      // Create an instance then kill it.
      lastInstance = this.createObjectInstanceFunction_(
          this.parent, this.id, category, name, ts);
      this.instances.push(lastInstance);
      lastInstance.wasDeleted(ts);
      return lastInstance;
    },

    getInstanceAt: function(ts) {
      var i = tr.b.findIndexInSortedIntervals(
          this.instances,
          function(inst) { return inst.creationTs; },
          function(inst) { return inst.deletionTs - inst.creationTs; },
          ts);
      if (i < 0) {
        if (this.instances[0].creationTsWasExplicit)
          return undefined;
        return this.instances[0];
      } else if (i >= this.instances.length) {
        return undefined;
      }
      return this.instances[i];
    },

    logToConsole: function() {
      for (var i = 0; i < this.instances.length; i++) {
        var instance = this.instances[i];
        var cEF = '';
        var dEF = '';
        if (instance.creationTsWasExplicit)
          cEF = '(explicitC)';
        if (instance.deletionTsWasExplicit)
          dEF = '(explicit)';
        console.log(instance.creationTs, cEF,
                    instance.deletionTs, dEF,
                    instance.category,
                    instance.name,
                    instance.snapshots.length + ' snapshots');
      }
    }
  };

  return {
    TimeToObjectInstanceMap: TimeToObjectInstanceMap
  };
});


'use strict';

/**
 * @fileoverview Provides the ObjectCollection class.
 */
tr.exportTo('tr.model', function() {
  var ObjectInstance = tr.model.ObjectInstance;
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * A collection of object instances and their snapshots, accessible by id and
   * time, or by object name.
   *
   * @constructor
   */
  function ObjectCollection(parent) {
    tr.model.EventContainer.call(this);
    this.parent = parent;
    this.instanceMapsById_ = {}; // id -> TimeToObjectInstanceMap
    this.instancesByTypeName_ = {};
    this.createObjectInstance_ = this.createObjectInstance_.bind(this);
  }

  ObjectCollection.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    iterateAllChildEventContainers: function(callback, opt_this) {
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      var bI = !!eventTypePredicate.call(opt_this, ObjectInstance);
      var bS = !!eventTypePredicate.call(opt_this, ObjectSnapshot);
      if (bI === false && bS === false)
        return;
      this.iterObjectInstances(function(instance) {
        if (bI)
          callback.call(opt_this, instance);
        if (bS)
          instance.snapshots.forEach(callback, opt_this);
      }, opt_this);
    },

    createObjectInstance_: function(
        parent, id, category, name, creationTs, opt_baseTypeName) {
      var constructor = tr.model.ObjectInstance.getConstructor(
          category, name);
      var instance = new constructor(
          parent, id, category, name, creationTs, opt_baseTypeName);
      var typeName = instance.typeName;
      var instancesOfTypeName = this.instancesByTypeName_[typeName];
      if (!instancesOfTypeName) {
        instancesOfTypeName = [];
        this.instancesByTypeName_[typeName] = instancesOfTypeName;
      }
      instancesOfTypeName.push(instance);
      return instance;
    },

    getOrCreateInstanceMap_: function(id) {
      var instanceMap = this.instanceMapsById_[id];
      if (instanceMap)
        return instanceMap;
      instanceMap = new tr.model.TimeToObjectInstanceMap(
          this.createObjectInstance_, this.parent, id);
      this.instanceMapsById_[id] = instanceMap;
      return instanceMap;
    },

    idWasCreated: function(id, category, name, ts) {
      var instanceMap = this.getOrCreateInstanceMap_(id);
      return instanceMap.idWasCreated(category, name, ts);
    },

    addSnapshot: function(id, category, name, ts, args, opt_baseTypeName) {
      var instanceMap = this.getOrCreateInstanceMap_(id);
      var snapshot = instanceMap.addSnapshot(
          category, name, ts, args, opt_baseTypeName);
      if (snapshot.objectInstance.category != category) {
        var msg = 'Added snapshot name=' + name + ' with cat=' + category +
            ' impossible. It instance was created/snapshotted with cat=' +
            snapshot.objectInstance.category + ' name=' +
            snapshot.objectInstance.name;
        throw new Error(msg);
      }
      if (opt_baseTypeName &&
          snapshot.objectInstance.baseTypeName != opt_baseTypeName) {
        throw new Error('Could not add snapshot with baseTypeName=' +
                        opt_baseTypeName + '. It ' +
                        'was previously created with name=' +
                        snapshot.objectInstance.baseTypeName);
      }
      if (snapshot.objectInstance.name != name) {
        throw new Error('Could not add snapshot with name=' + name + '. It ' +
                        'was previously created with name=' +
                        snapshot.objectInstance.name);
      }
      return snapshot;
    },

    idWasDeleted: function(id, category, name, ts) {
      var instanceMap = this.getOrCreateInstanceMap_(id);
      var deletedInstance = instanceMap.idWasDeleted(category, name, ts);
      if (!deletedInstance)
        return;
      if (deletedInstance.category != category) {
        var msg = 'Deleting object ' + deletedInstance.name +
            ' with a different category ' +
            'than when it was created. It previous had cat=' +
            deletedInstance.category + ' but the delete command ' +
            'had cat=' + category;
        throw new Error(msg);
      }
      if (deletedInstance.baseTypeName != name) {
        throw new Error('Deletion requested for name=' +
                        name + ' could not proceed: ' +
                        'An existing object with baseTypeName=' +
                        deletedInstance.baseTypeName + ' existed.');
      }
    },

    autoDeleteObjects: function(maxTimestamp) {
      tr.b.iterItems(this.instanceMapsById_, function(id, i2imap) {
        var lastInstance = i2imap.lastInstance;
        if (lastInstance.deletionTs != Number.MAX_VALUE)
          return;
        i2imap.idWasDeleted(
            lastInstance.category, lastInstance.name, maxTimestamp);
        // idWasDeleted will cause lastInstance.deletionTsWasExplicit to be set
        // to true. Unset it here.
        lastInstance.deletionTsWasExplicit = false;
      });
    },

    getObjectInstanceAt: function(id, ts) {
      var instanceMap = this.instanceMapsById_[id];
      if (!instanceMap)
        return undefined;
      return instanceMap.getInstanceAt(ts);
    },

    getSnapshotAt: function(id, ts) {
      var instance = this.getObjectInstanceAt(id, ts);
      if (!instance)
        return undefined;
      return instance.getSnapshotAt(ts);
    },

    iterObjectInstances: function(iter, opt_this) {
      opt_this = opt_this || this;
      tr.b.iterItems(this.instanceMapsById_, function(id, i2imap) {
        i2imap.instances.forEach(iter, opt_this);
      });
    },

    getAllObjectInstances: function() {
      var instances = [];
      this.iterObjectInstances(function(i) { instances.push(i); });
      return instances;
    },

    getAllInstancesNamed: function(name) {
      return this.instancesByTypeName_[name];
    },

    getAllInstancesByTypeName: function() {
      return this.instancesByTypeName_;
    },

    preInitializeAllObjects: function() {
      this.iterObjectInstances(function(instance) {
        instance.preInitialize();
      });
    },

    initializeAllObjects: function() {
      this.iterObjectInstances(function(instance) {
        instance.initialize();
      });
    },

    initializeInstances: function() {
      this.iterObjectInstances(function(instance) {
        instance.initialize();
      });
    },

    updateBounds: function() {
      this.bounds.reset();
      this.iterObjectInstances(function(instance) {
        instance.updateBounds();
        this.bounds.addRange(instance.bounds);
      }, this);
    },

    shiftTimestampsForward: function(amount) {
      this.iterObjectInstances(function(instance) {
        instance.shiftTimestampsForward(amount);
      });
    },

    addCategoriesToDict: function(categoriesDict) {
      this.iterObjectInstances(function(instance) {
        categoriesDict[instance.category] = true;
      });
    }
  };

  return {
    ObjectCollection: ObjectCollection
  };
});


'use strict';

/**
 * @fileoverview Provides the AsyncSlice class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A AsyncSlice represents an interval of time during which an
   * asynchronous operation is in progress. An AsyncSlice consumes no CPU time
   * itself and so is only associated with Threads at its start and end point.
   *
   * @constructor
   */
  function AsyncSlice(category, title, colorId, start, args, duration,
                      opt_isTopLevel, opt_cpuStart, opt_cpuDuration,
                      opt_argsStripped) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.args = args;
    this.startStackFrame = undefined;
    this.endStackFrame = undefined;
    this.didNotFinish = false;
    this.important = false;
    this.subSlices = [];
    this.parentContainer = undefined;

    this.id = undefined;
    this.startThread = undefined;
    this.endThread = undefined;
    this.cpuStart = undefined;
    this.cpuDuration = undefined;
    this.argsStripped = false;

    this.startStackFrame = undefined;
    this.endStackFrame = undefined;

    this.duration = duration;


    // TODO(nduca): Forgive me for what I must do.
    this.isTopLevel = (opt_isTopLevel === true);

    if (opt_cpuStart !== undefined)
      this.cpuStart = opt_cpuStart;

    if (opt_cpuDuration !== undefined)
      this.cpuDuration = opt_cpuDuration;

    if (opt_argsStripped !== undefined)
      this.argsStripped = opt_argsStripped;
  };

  AsyncSlice.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get analysisTypeName() {
      return this.title;
    },

    get viewSubGroupTitle() {
      return this.title;
    },

    get userFriendlyName() {
      return 'Async slice ' + this.title + ' at ' +
          tr.b.u.TimeStamp.format(this.start);
    },

    findDescendentSlice: function(targetTitle) {
      if (!this.subSlices)
        return undefined;

      for (var i = 0; i < this.subSlices.length; i++) {
        if (this.subSlices[i].title == targetTitle)
          return this.subSlices[i];
        var slice = this.subSlices[i].findDescendentSlice(targetTitle);
        if (slice) return slice;
      }
      return undefined;
    },

    iterateAllDescendents: function(callback, opt_this) {
      this.subSlices.forEach(callback, opt_this);
      this.subSlices.forEach(function(subSlice) {
        subSlice.iterateAllDescendents(callback, opt_this);
      }, opt_this);
    },

    compareTo: function(that) {
      return this.title.localeCompare(that.title);
    }
  };

  tr.model.EventRegistry.register(
      AsyncSlice,
      {
        name: 'asyncSlice',
        pluralName: 'asyncSlices',
        singleViewElementName: 'tr-ui-a-single-async-slice-sub-view',
        multiViewElementName: 'tr-ui-a-multi-async-slice-sub-view'
      });


  var options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  options.mandatoryBaseClass = AsyncSlice;
  options.defaultConstructor = AsyncSlice;
  tr.b.decorateExtensionRegistry(AsyncSlice, options);

  return {
    AsyncSlice: AsyncSlice
  };
});


'use strict';

/**
 * @fileoverview Provides the AsyncSliceGroup class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A group of AsyncSlices associated with a thread.
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function AsyncSliceGroup(parentContainer, opt_name) {
    tr.model.EventContainer.call(this);
    this.parentContainer_ = parentContainer;
    this.slices = [];
    this.name_ = opt_name;
    this.viewSubGroups_ = undefined;
  }

  AsyncSliceGroup.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parentContainer() {
      return this.parentContainer_;
    },

    get model() {
      return this.parentContainer_.parent.model;
    },

    get stableId() {
      return this.parentContainer_.stableId + '.AsyncSliceGroup';
    },

    getSettingsKey: function() {
      if (!this.name_)
        return undefined;
      var parentKey = this.parentContainer_.getSettingsKey();
      if (!parentKey)
        return undefined;
      return parentKey + '.' + this.name_;
    },

    /**
     * Helper function that pushes the provided slice onto the slices array.
     */
    push: function(slice) {
      slice.parentContainer = this.parentContainer;
      this.slices.push(slice);
      return slice;
    },

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    },

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified, including all nested subSlices if there are any.
     */
    shiftTimestampsForward: function(amount) {
      for (var sI = 0; sI < this.slices.length; sI++) {
        var slice = this.slices[sI];
        slice.start = (slice.start + amount);
        // Shift all nested subSlices recursively.
        var shiftSubSlices = function(subSlices) {
          if (subSlices === undefined || subSlices.length === 0)
            return;
          for (var sJ = 0; sJ < subSlices.length; sJ++) {
            subSlices[sJ].start += amount;
            shiftSubSlices(subSlices[sJ].subSlices);
          }
        };
        shiftSubSlices(slice.subSlices);
      }
    },

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds: function() {
      this.bounds.reset();
      for (var i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    },

    /**
     * Gets the sub-groups in this A-S-G defined by the group titles.
     *
     * @return {Array} An array of AsyncSliceGroups where each group has
     * slices that started on the same thread.
     */
    get viewSubGroups() {
      if (this.viewSubGroups_ === undefined) {
        var prefix = '';
        if (this.name !== undefined)
          prefix = this.name + '.';
        else
          prefix = '';

        var subGroupsByTitle = {};
        for (var i = 0; i < this.slices.length; ++i) {
          var slice = this.slices[i];
          var subGroupTitle = slice.viewSubGroupTitle;
          if (!subGroupsByTitle[subGroupTitle]) {
            subGroupsByTitle[subGroupTitle] = new AsyncSliceGroup(
                this.parentContainer_, prefix + subGroupTitle);
          }
          subGroupsByTitle[subGroupTitle].push(slice);
        }
        this.viewSubGroups_ = tr.b.dictionaryValues(subGroupsByTitle);
        this.viewSubGroups_.sort(function(a, b) {
          return a.slices[0].compareTo(b.slices[0]);
        });
      }
      return this.viewSubGroups_;
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      if (eventTypePredicate.call(opt_this, tr.model.AsyncSlice)) {
        for (var i = 0; i < this.slices.length; i++) {
          var slice = this.slices[i];
          callback.call(opt_this, slice);
          if (slice.subSlices)
            slice.subSlices.forEach(callback, opt_this);
        }
      }
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
    }
  };

  return {
    AsyncSliceGroup: AsyncSliceGroup
  };
});


'use strict';

/**
 * @fileoverview Provides the SliceGroup class.
 */
tr.exportTo('tr.model', function() {
  var Slice = tr.model.Slice;

  function getSliceLo(s) {
    return s.start;
  }

  function getSliceHi(s) {
    return s.end;
  }

  /**
   * A group of Slices, plus code to create them from B/E events, as
   * well as arrange them into subRows.
   *
   * Do not mutate the slices array directly. Modify it only by
   * SliceGroup mutation methods.
   *
   * @constructor
   * @param {function(new:Slice, category, title, colorId, start, args)=}
   *     opt_sliceConstructor The constructor to use when creating slices.
   * @extends {tr.model.EventContainer}
   */
  function SliceGroup(parentContainer, opt_sliceConstructor, opt_name) {
    tr.model.EventContainer.call(this);

    this.parentContainer_ = parentContainer;

    var sliceConstructor = opt_sliceConstructor || Slice;
    this.sliceConstructor = sliceConstructor;

    this.openPartialSlices_ = [];

    this.slices = [];
    this.topLevelSlices = [];
    this.haveTopLevelSlicesBeenBuilt = false;
    this.name_ = opt_name;

    if (this.model === undefined)
      throw new Error('SliceGroup must have model defined.');
  }

  SliceGroup.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parentContainer() {
      return this.parentContainer_;
    },

    get model() {
      return this.parentContainer_.model;
    },

    get stableId() {
      return this.parentContainer_.stableId + '.SliceGroup';
    },

    getSettingsKey: function() {
      if (!this.name_)
        return undefined;
      var parentKey = this.parentContainer_.getSettingsKey();
      if (!parentKey)
        return undefined;
      return parentKey + '.' + this.name;
    },

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    },

    /**
     * Helper function that pushes the provided slice onto the slices array.
     * @param {Slice} slice The slice to be added to the slices array.
     */
    pushSlice: function(slice) {
      this.haveTopLevelSlicesBeenBuilt = false;
      slice.parentContainer = this.parentContainer_;
      this.slices.push(slice);
      return slice;
    },

    /**
     * Helper function that pushes the provided slices onto the slices array.
     * @param {Array.<Slice>} slices An array of slices to be added.
     */
    pushSlices: function(slices) {
      this.haveTopLevelSlicesBeenBuilt = false;
      slices.forEach(function(slice) {
        slice.parentContainer = this.parentContainer_;
        this.slices.push(slice);
      }, this);
    },

    /**
     * Opens a new slice in the group's slices.
     *
     * Calls to beginSlice and
     * endSlice must be made with non-monotonically-decreasing timestamps.
     *
     * @param {String} category Category name of the slice to add.
     * @param {String} title Title of the slice to add.
     * @param {Number} ts The timetsamp of the slice, in milliseconds.
     * @param {Object.<string, Object>=} opt_args Arguments associated with
     * the slice.
     * @param {Number=} opt_colorId The color of the slice, defined by
     * its palette id (see ui/base/color_scheme.html).
     */
    beginSlice: function(category, title, ts, opt_args, opt_tts,
                         opt_argsStripped, opt_colorId) {
      if (this.openPartialSlices_.length) {
        var prevSlice = this.openPartialSlices_[
            this.openPartialSlices_.length - 1];
        if (ts < prevSlice.start)
          throw new Error('Slices must be added in increasing timestamp order');
      }

      var colorId = opt_colorId ||
          tr.ui.b.getColorIdForGeneralPurposeString(title);
      var slice = new this.sliceConstructor(category, title, colorId, ts,
                                            opt_args ? opt_args : {}, null,
                                            opt_tts, undefined,
                                            opt_argsStripped);
      this.openPartialSlices_.push(slice);
      slice.didNotFinish = true;
      this.pushSlice(slice);

      return slice;
    },

    isTimestampValidForBeginOrEnd: function(ts) {
      if (!this.openPartialSlices_.length)
        return true;
      var top = this.openPartialSlices_[this.openPartialSlices_.length - 1];
      return ts >= top.start;
    },

    /**
     * @return {Number} The number of beginSlices for which an endSlice has not
     * been issued.
     */
    get openSliceCount() {
      return this.openPartialSlices_.length;
    },

    get mostRecentlyOpenedPartialSlice() {
      if (!this.openPartialSlices_.length)
        return undefined;
      return this.openPartialSlices_[this.openPartialSlices_.length - 1];
    },

    /**
     * Ends the last begun slice in this group and pushes it onto the slice
     * array.
     *
     * @param {Number} ts Timestamp when the slice ended
     * @param {Number=} opt_colorId The color of the slice, defined by
     * its palette id (see ui/base/color_scheme.html).
     * @return {Slice} slice.
     */
    endSlice: function(ts, opt_tts, opt_colorId) {
      if (!this.openSliceCount)
        throw new Error('endSlice called without an open slice');

      var slice = this.openPartialSlices_[this.openSliceCount - 1];
      this.openPartialSlices_.splice(this.openSliceCount - 1, 1);
      if (ts < slice.start)
        throw new Error('Slice ' + slice.title +
                        ' end time is before its start.');

      slice.duration = ts - slice.start;
      slice.didNotFinish = false;
      slice.colorId = opt_colorId || slice.colorId;

      if (opt_tts && slice.cpuStart !== undefined)
        slice.cpuDuration = opt_tts - slice.cpuStart;

      return slice;
    },

    /**
     * Push a complete event as a Slice into the slice list.
     * The timestamp can be in any order.
     *
     * @param {String} category Category name of the slice to add.
     * @param {String} title Title of the slice to add.
     * @param {Number} ts The timetsamp of the slice, in milliseconds.
     * @param {Number} duration The duration of the slice, in milliseconds.
     * @param {Object.<string, Object>=} opt_args Arguments associated with
     * the slice.
     * @param {Number=} opt_colorId The color of the slice, as defined by
     * its palette id (see ui/base/color_scheme.html).
     */
    pushCompleteSlice: function(category, title, ts, duration, tts,
                                cpuDuration, opt_args, opt_argsStripped,
                                opt_colorId, opt_bind_id) {
      var colorId = opt_colorId ||
          tr.ui.b.getColorIdForGeneralPurposeString(title);
      var slice = new this.sliceConstructor(category, title, colorId, ts,
                                            opt_args ? opt_args : {},
                                            duration, tts, cpuDuration,
                                            opt_argsStripped, opt_bind_id);
      if (duration === undefined)
        slice.didNotFinish = true;
      this.pushSlice(slice);
      return slice;
    },

    /**
     * Closes any open slices.
     * @param {Number=} opt_maxTimestamp The end time to use for the closed
     * slices. If not provided,
     * the max timestamp for this slice is provided.
     */
    autoCloseOpenSlices: function(opt_maxTimestamp) {
      if (!opt_maxTimestamp) {
        this.updateBounds();
        opt_maxTimestamp = this.bounds.max;
      }
      for (var sI = 0; sI < this.slices.length; sI++) {
        var slice = this.slices[sI];
        if (slice.didNotFinish)
          slice.duration = opt_maxTimestamp - slice.start;
      }
      this.openPartialSlices_ = [];
    },

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      for (var sI = 0; sI < this.slices.length; sI++) {
        var slice = this.slices[sI];
        slice.start = (slice.start + amount);
      }
    },

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds: function() {
      this.bounds.reset();
      for (var i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    },

    copySlice: function(slice) {
      var newSlice = new this.sliceConstructor(slice.category, slice.title,
          slice.colorId, slice.start,
          slice.args, slice.duration, slice.cpuStart, slice.cpuDuration);
      newSlice.didNotFinish = slice.didNotFinish;
      return newSlice;
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      if (eventTypePredicate.call(opt_this, this.sliceConstructor))
        this.slices.forEach(callback, opt_this);
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
    },

    getSlicesOfName: function(title) {
      var slices = [];
      for (var i = 0; i < this.slices.length; i++) {
        if (this.slices[i].title == title) {
          slices.push(this.slices[i]);
        }
      }
      return slices;
    },

    iterSlicesInTimeRange: function(callback, start, end) {
      var ret = [];
      tr.b.iterateOverIntersectingIntervals(
        this.topLevelSlices,
        function(s) { return s.start; },
        function(s) { return s.duration; },
        start,
        end,
        function(topLevelSlice) {
          callback(topLevelSlice);
          topLevelSlice.iterateAllDescendents(callback);
        });
      return ret;
    },

    findSliceAtTs: function(ts) {
      if (!this.haveTopLevelSlicesBeenBuilt)
        throw new Error('Nope');
      var i = tr.b.findIndexInSortedClosedIntervals(
          this.topLevelSlices,
          getSliceLo, getSliceHi,
          ts);
      if (i == -1 || i == this.topLevelSlices.length)
        return undefined;

      var curSlice = this.topLevelSlices[i];

      // Now recurse on slice looking for subSlice of given ts.
      while (true) {
        var i = tr.b.findIndexInSortedClosedIntervals(
            curSlice.subSlices,
            getSliceLo, getSliceHi,
            ts);
        if (i == -1 || i == curSlice.subSlices.length)
          return curSlice;
        curSlice = curSlice.subSlices[i];
      }
    },

    findNextSliceAfter: function(ts, refGuid) {
      var i = tr.b.findLowIndexInSortedArray(
          this.slices, getSliceLo, ts);
      if (i === this.slices.length)
        return undefined;
      for (; i < this.slices.length; i++) {
        var slice = this.slices[i];
        if (slice.start > ts)
          return slice;
        if (slice.guid <= refGuid)
          continue;
        return slice;
      }
      return undefined;
    },

    /**
     * Construct subSlices for this group.
     * Populate the group topLevelSlices, parent slices get a subSlices[],
     * a selfThreadTime and a selfTime, child slices get a parentSlice
     * reference.
     */
    createSubSlices: function() {
      this.haveTopLevelSlicesBeenBuilt = true;
      this.createSubSlicesImpl_();
      if (this.parentContainer.timeSlices)
        this.addCpuTimeToSubslices_(this.parentContainer.timeSlices);
      this.slices.forEach(function(slice) {
        var selfTime = slice.duration;
        for (var i = 0; i < slice.subSlices.length; i++)
          selfTime -= slice.subSlices[i].duration;
        slice.selfTime = selfTime;

        if (slice.cpuDuration === undefined)
          return;

        var cpuSelfTime = slice.cpuDuration;
        for (var i = 0; i < slice.subSlices.length; i++) {
          if (slice.subSlices[i].cpuDuration !== undefined)
            cpuSelfTime -= slice.subSlices[i].cpuDuration;
        }
        slice.cpuSelfTime = cpuSelfTime;
      });
    },
    createSubSlicesImpl_: function() {
      var precisionUnit = this.model.intrinsicTimeUnit;

      function addSliceIfBounds(root, child) {
        // Because we know that the start time of child is >= the start time
        // of all other slices seen so far, we can just check the last slice
        // of each row for bounding.
        if (root.bounds(child, precisionUnit)) {
          if (root.subSlices && root.subSlices.length > 0) {
            if (addSliceIfBounds(root.subSlices[root.subSlices.length - 1],
                                 child))
              return true;
          }
          child.parentSlice = root;
          if (root.subSlices === undefined)
            root.subSlices = [];
          root.subSlices.push(child);
          return true;
        }
        return false;
      }

      if (!this.slices.length)
        return;

      var ops = [];
      for (var i = 0; i < this.slices.length; i++) {
        if (this.slices[i].subSlices)
          this.slices[i].subSlices.splice(0,
                                          this.slices[i].subSlices.length);
        ops.push(i);
      }

      var originalSlices = this.slices;
      ops.sort(function(ix, iy) {
        var x = originalSlices[ix];
        var y = originalSlices[iy];
        if (x.start != y.start)
          return x.start - y.start;

        // Elements get inserted into the slices array in order of when the
        // slices start. Because slices must be properly nested, we break
        // start-time ties by assuming that the elements appearing earlier
        // in the slices array (and thus ending earlier) start earlier.
        return ix - iy;
      });

      var slices = new Array(this.slices.length);
      for (var i = 0; i < ops.length; i++) {
        slices[i] = originalSlices[ops[i]];
      }

      // Actually build the subrows.
      var rootSlice = slices[0];
      this.topLevelSlices = [];
      this.topLevelSlices.push(rootSlice);
      rootSlice.isTopLevel = true;
      for (var i = 1; i < slices.length; i++) {
        var slice = slices[i];
        if (!addSliceIfBounds(rootSlice, slice)) {
          rootSlice = slice;
          rootSlice.isTopLevel = true;
          this.topLevelSlices.push(rootSlice);
        }
      }

      // Keep the slices in sorted form.
      this.slices = slices;
    },
    addCpuTimeToSubslices_: function(timeSlices) {
      var SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
      var sliceIdx = 0;
      timeSlices.forEach(function(timeSlice) {
        if (timeSlice.schedulingState == SCHEDULING_STATE.RUNNING) {
          while (sliceIdx < this.topLevelSlices.length) {
            if (this.addCpuTimeToSubslice_(this.topLevelSlices[sliceIdx],
                timeSlice)) {
              // The current top-level slice and children are fully
              // accounted for, proceed to next top-level slice.
              sliceIdx++;
            } else {
              // The current top-level runs beyond the time slice, break out
              // so we can potentially add more time slices to it
              break;
            }
          }
        }
      }, this);
    },
    /* Add run-time of this timeSlice to the passed in slice
     * and all of it's children (recursively).
     * Returns whether the slice ends before or at the end of the
     * time slice, signaling we are done with this slice.
     */
    addCpuTimeToSubslice_: function(slice, timeSlice) {
      // Make sure they overlap
      if (slice.start > timeSlice.end || slice.end < timeSlice.start)
        return slice.end <= timeSlice.end;

      // Compute actual overlap
      var duration = timeSlice.duration;
      if (slice.start > timeSlice.start)
        duration -= slice.start - timeSlice.start;
      if (timeSlice.end > slice.end)
        duration -= timeSlice.end - slice.end;

      if (slice.cpuDuration) {
        slice.cpuDuration += duration;
      } else {
        slice.cpuDuration = duration;
      }

      for (var i = 0; i < slice.subSlices.length; i++) {
        this.addCpuTimeToSubslice_(slice.subSlices[i], timeSlice);
      }

      return slice.end <= timeSlice.end;
    }
  };

  /**
   * Merge two slice groups.
   *
   * If the two groups do not nest properly some of the slices of groupB will
   * be split to accomodate the improper nesting.  This is done to accomodate
   * combined kernel and userland call stacks on Android.  Because userland
   * tracing is done by writing to the trace_marker file, the kernel calls
   * that get invoked as part of that write may not be properly nested with
   * the userland call trace.  For example the following sequence may occur:
   *
   *     kernel enter sys_write        (the write to trace_marker)
   *     user   enter some_function
   *     kernel exit  sys_write
   *     ...
   *     kernel enter sys_write        (the write to trace_marker)
   *     user   exit  some_function
   *     kernel exit  sys_write
   *
   * This is handled by splitting the sys_write call into two slices as
   * follows:
   *
   *     | sys_write |            some_function            | sys_write (cont.) |
   *                 | sys_write (cont.) |     | sys_write |
   *
   * The colorId of both parts of the split slices are kept the same, and the
   * " (cont.)" suffix is appended to the later parts of a split slice.
   *
   * The two input SliceGroups are not modified by this, and the merged
   * SliceGroup will contain a copy of each of the input groups' slices (those
   * copies may be split).
   */
  SliceGroup.merge = function(groupA, groupB) {
    // This is implemented by traversing the two slice groups in reverse
    // order.  The slices in each group are sorted by ascending end-time, so
    // we must do the traversal from back to front in order to maintain the
    // sorting.
    //
    // We traverse the two groups simultaneously, merging as we go.  At each
    // iteration we choose the group from which to take the next slice based
    // on which group's next slice has the greater end-time.  During this
    // traversal we maintain a stack of currently "open" slices for each input
    // group.  A slice is considered "open" from the time it gets reached in
    // our input group traversal to the time we reach an slice in this
    // traversal with an end-time before the start time of the "open" slice.
    //
    // Each time a slice from groupA is opened or closed (events corresponding
    // to the end-time and start-time of the input slice, respectively) we
    // split all of the currently open slices from groupB.

    if (groupA.openPartialSlices_.length > 0)
      throw new Error('groupA has open partial slices');

    if (groupB.openPartialSlices_.length > 0)
      throw new Error('groupB has open partial slices');

    if (groupA.parentContainer != groupB.parentContainer)
      throw new Error('Different parent threads. Cannot merge');

    if (groupA.sliceConstructor != groupB.sliceConstructor)
      throw new Error('Different slice constructors. Cannot merge');

    var result = new SliceGroup(groupA.parentContainer,
                                groupA.sliceConstructor,
                                groupA.name_);

    var slicesA = groupA.slices;
    var slicesB = groupB.slices;
    var idxA = 0;
    var idxB = 0;
    var openA = [];
    var openB = [];

    var splitOpenSlices = function(when) {
      for (var i = 0; i < openB.length; i++) {
        var oldSlice = openB[i];
        var oldEnd = oldSlice.end;
        if (when < oldSlice.start || oldEnd < when) {
          throw new Error('slice should not be split');
        }

        var newSlice = result.copySlice(oldSlice);
        newSlice.start = when;
        newSlice.duration = oldEnd - when;
        if (newSlice.title.indexOf(' (cont.)') == -1)
          newSlice.title += ' (cont.)';
        oldSlice.duration = when - oldSlice.start;
        openB[i] = newSlice;
        result.pushSlice(newSlice);
      }
    };

    var closeOpenSlices = function(upTo) {
      while (openA.length > 0 || openB.length > 0) {
        var nextA = openA[openA.length - 1];
        var nextB = openB[openB.length - 1];
        var endA = nextA && nextA.end;
        var endB = nextB && nextB.end;

        if ((endA === undefined || endA > upTo) &&
            (endB === undefined || endB > upTo)) {
          return;
        }

        if (endB === undefined || endA < endB) {
          splitOpenSlices(endA);
          openA.pop();
        } else {
          openB.pop();
        }
      }
    };

    while (idxA < slicesA.length || idxB < slicesB.length) {
      var sA = slicesA[idxA];
      var sB = slicesB[idxB];
      var nextSlice, isFromB;

      if (sA === undefined || (sB !== undefined && sA.start > sB.start)) {
        nextSlice = result.copySlice(sB);
        isFromB = true;
        idxB++;
      } else {
        nextSlice = result.copySlice(sA);
        isFromB = false;
        idxA++;
      }

      closeOpenSlices(nextSlice.start);

      result.pushSlice(nextSlice);

      if (isFromB) {
        openB.push(nextSlice);
      } else {
        splitOpenSlices(nextSlice.start);
        openA.push(nextSlice);
      }
    }

    closeOpenSlices();

    return result;
  };

  return {
    SliceGroup: SliceGroup
  };
});


'use strict';

/**
 * @fileoverview Provides the Thread class.
 */
tr.exportTo('tr.model', function() {
  var Slice = tr.model.Slice;

  /**
   * A ThreadSlice represents an interval of time on a thread resource
   * with associated nesting slice information.
   *
   * ThreadSlices are typically associated with a specific trace event pair on a
   * specific thread.
   * For example,
   *   TRACE_EVENT_BEGIN1("x","myArg", 7) at time=0.1ms
   *   TRACE_EVENT_END0()                 at time=0.3ms
   * This results in a single slice from 0.1 with duration 0.2 on a
   * specific thread.
   *
   * @constructor
   */
  function ThreadSlice(cat, title, colorId, start, args, opt_duration,
                       opt_cpuStart, opt_cpuDuration, opt_argsStripped,
                       opt_bind_id) {
    Slice.call(this, cat, title, colorId, start, args, opt_duration,
               opt_cpuStart, opt_cpuDuration, opt_argsStripped, opt_bind_id);
    // Do not modify this directly.
    // subSlices is configured by SliceGroup.rebuildSubRows_.
    this.subSlices = [];
  }

  ThreadSlice.prototype = {
    __proto__: Slice.prototype,

    getProcess: function() {
      var thread = this.parentContainer;
      if (thread && thread.getProcess)
        return thread.getProcess();
      return undefined;
    }
  };

  tr.model.EventRegistry.register(
      ThreadSlice,
      {
        name: 'slice',
        pluralName: 'slices',
        singleViewElementName: 'tr-ui-a-single-thread-slice-sub-view',
        multiViewElementName: 'tr-ui-a-multi-thread-slice-sub-view'
      });

  return {
    ThreadSlice: ThreadSlice
  };
});


'use strict';

/**
 * @fileoverview Provides the Thread class.
 */
tr.exportTo('tr.model', function() {
  var AsyncSlice = tr.model.AsyncSlice;
  var AsyncSliceGroup = tr.model.AsyncSliceGroup;
  var Slice = tr.model.Slice;
  var SliceGroup = tr.model.SliceGroup;
  var ThreadSlice = tr.model.ThreadSlice;
  var ThreadTimeSlice = tr.model.ThreadTimeSlice;

  /**
   * A Thread stores all the trace events collected for a particular
   * thread. We organize the synchronous slices on a thread by "subrows," where
   * subrow 0 has all the root slices, subrow 1 those nested 1 deep, and so on.
   * The asynchronous slices are stored in an AsyncSliceGroup object.
   *
   * The slices stored on a Thread should be instances of
   * ThreadSlice.
   *
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function Thread(parent, tid) {
    if (!parent)
      throw new Error('Parent must be provided.');

    tr.model.EventContainer.call(this);
    this.parent = parent;
    this.sortIndex = 0;
    this.tid = tid;
    this.name = undefined;
    this.samples_ = undefined; // Set during createSubSlices

    var that = this;

    this.sliceGroup = new SliceGroup(this, ThreadSlice, 'slices');
    this.timeSlices = undefined;
    this.kernelSliceGroup = new SliceGroup(
        this, ThreadSlice, 'kernel-slices');
    this.asyncSliceGroup = new AsyncSliceGroup(this, 'async-slices');
  }

  Thread.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get model() {
      return this.parent.model;
    },

    get stableId() {
      return this.parent.stableId + '.' + this.tid;
    },

    compareTo: function(that) {
      return Thread.compare(this, that);
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
      if (this.sliceGroup.length)
        callback.call(opt_this, this.sliceGroup);
      if (this.kernelSliceGroup.length)
        callback.call(opt_this, this.kernelSliceGroup);
      if (this.asyncSliceGroup.length)
        callback.call(opt_this, this.asyncSliceGroup);
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      if (this.timeSlices && this.timeSlices.length) {
        if (eventTypePredicate.call(opt_this, ThreadTimeSlice))
          this.timeSlices.forEach(callback, opt_this);
      }
    },

    iterateAllPersistableObjects: function(cb) {
      cb(this);
      if (this.sliceGroup.length)
        cb(this.sliceGroup);
      this.asyncSliceGroup.viewSubGroups.forEach(cb);
    },

    /**
     * Shifts all the timestamps inside this thread forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      this.sliceGroup.shiftTimestampsForward(amount);

      if (this.timeSlices) {
        for (var i = 0; i < this.timeSlices.length; i++) {
          var slice = this.timeSlices[i];
          slice.start += amount;
        }
      }

      this.kernelSliceGroup.shiftTimestampsForward(amount);
      this.asyncSliceGroup.shiftTimestampsForward(amount);
    },

    /**
     * Determines whether this thread is empty. If true, it usually implies
     * that it should be pruned from the model.
     */
    get isEmpty() {
      if (this.sliceGroup.length)
        return false;
      if (this.sliceGroup.openSliceCount)
        return false;
      if (this.timeSlices && this.timeSlices.length)
        return false;
      if (this.kernelSliceGroup.length)
        return false;
      if (this.asyncSliceGroup.length)
        return false;
      if (this.samples_.length)
        return false;
      return true;
    },

    /**
     * Updates the bounds based on the
     * current objects associated with the thread.
     */
    updateBounds: function() {
      this.bounds.reset();

      this.sliceGroup.updateBounds();
      this.bounds.addRange(this.sliceGroup.bounds);

      this.kernelSliceGroup.updateBounds();
      this.bounds.addRange(this.kernelSliceGroup.bounds);

      this.asyncSliceGroup.updateBounds();
      this.bounds.addRange(this.asyncSliceGroup.bounds);

      if (this.timeSlices && this.timeSlices.length) {
        this.bounds.addValue(this.timeSlices[0].start);
        this.bounds.addValue(
            this.timeSlices[this.timeSlices.length - 1].end);
      }

      if (this.samples_ && this.samples_.length) {
        this.bounds.addValue(this.samples_[0].start);
        this.bounds.addValue(
            this.samples_[this.samples_.length - 1].end);
      }
    },

    addCategoriesToDict: function(categoriesDict) {
      for (var i = 0; i < this.sliceGroup.length; i++)
        categoriesDict[this.sliceGroup.slices[i].category] = true;
      for (var i = 0; i < this.kernelSliceGroup.length; i++)
        categoriesDict[this.kernelSliceGroup.slices[i].category] = true;
      for (var i = 0; i < this.asyncSliceGroup.length; i++)
        categoriesDict[this.asyncSliceGroup.slices[i].category] = true;
      if (this.samples_) {
        for (var i = 0; i < this.samples_.length; i++)
          categoriesDict[this.samples_[i].category] = true;
      }
    },

    autoCloseOpenSlices: function(opt_maxTimestamp) {
      this.sliceGroup.autoCloseOpenSlices(opt_maxTimestamp);
      this.kernelSliceGroup.autoCloseOpenSlices(opt_maxTimestamp);
    },

    mergeKernelWithUserland: function() {
      if (this.kernelSliceGroup.length > 0) {
        var newSlices = SliceGroup.merge(
            this.sliceGroup, this.kernelSliceGroup);
        this.sliceGroup.slices = newSlices.slices;
        this.kernelSliceGroup = new SliceGroup(this);
        this.updateBounds();
      }
    },

    createSubSlices: function() {
      this.sliceGroup.createSubSlices();
      this.samples_ = this.parent.model.samples.filter(function(sample) {
        return sample.thread == this;
      }, this);
    },

    /**
     * @return {String} A user-friendly name for this thread.
     */
    get userFriendlyName() {
      return this.name || this.tid;
    },

    /**
     * @return {String} User friendly details about this thread.
     */
    get userFriendlyDetails() {
      return 'tid: ' + this.tid +
          (this.name ? ', name: ' + this.name : '');
    },

    getSettingsKey: function() {
      if (!this.name)
        return undefined;
      var parentKey = this.parent.getSettingsKey();
      if (!parentKey)
        return undefined;
      return parentKey + '.' + this.name;
    },

    getProcess: function() {
      return this.parent;
    },

    /*
     * Returns the index of the slice in the timeSlices array, or undefined.
     */
    indexOfTimeSlice: function(timeSlice) {
      var i = tr.b.findLowIndexInSortedArray(
          this.timeSlices,
          function(slice) { return slice.start; },
          timeSlice.start);
      if (this.timeSlices[i] !== timeSlice)
        return undefined;
      return i;
    },

    /*
     * Returns an object with the CPU number used as keys,
     * and the value of each key object is the amount of milliseconds spent
     * running on this CPU.
     * Additionally, stats.total contains the total time
     * spent running on all CPUs.
     */
    getCpuStatsForRange: function(range) {
      var stats = {};
      stats.total = 0;

      if (!this.timeSlices)
        return stats;

      function addStatsForSlice(threadTimeSlice) {
        var freqRange = tr.b.Range.fromExplicitRange(threadTimeSlice.start,
            threadTimeSlice.end);
        var intersection = freqRange.findIntersection(range);

        if (threadTimeSlice.schedulingState ==
            tr.model.SCHEDULING_STATE.RUNNING) {
          var cpu = threadTimeSlice.cpuOnWhichThreadWasRunning;
          if (!(cpu.cpuNumber in stats))
            stats[cpu.cpuNumber] = 0;

          stats[cpu.cpuNumber] += intersection.duration;
          stats.total += intersection.duration;
        }
      }

      tr.b.iterateOverIntersectingIntervals(this.timeSlices,
                                            function(x) { return x.start; },
                                            function(x) { return x.end; },
                                            range.min,
                                            range.max,
                                            addStatsForSlice);
      return stats;
    },

    getSchedulingStatsForRange: function(start, end) {
      var stats = {};

      if (!this.timeSlices) return stats;

      function addStatsForSlice(threadTimeSlice) {
        var overlapStart = Math.max(threadTimeSlice.start, start);
        var overlapEnd = Math.min(threadTimeSlice.end, end);
        var schedulingState = threadTimeSlice.schedulingState;

        if (!(schedulingState in stats))
          stats[schedulingState] = 0;
        stats[schedulingState] += overlapEnd - overlapStart;
      }

      tr.b.iterateOverIntersectingIntervals(this.timeSlices,
                                            function(x) { return x.start; },
                                            function(x) { return x.end; },
                                            start,
                                            end,
                                            addStatsForSlice);
      return stats;
    },

    get samples() {
      return this.samples_;
    }
  };

  /**
   * Comparison between threads that orders first by parent.compareTo,
   * then by names, then by tid.
   */
  Thread.compare = function(x, y) {
    var tmp = x.parent.compareTo(y.parent);
    if (tmp)
      return tmp;

    tmp = x.sortIndex - y.sortIndex;
    if (tmp)
      return tmp;

    tmp = tr.b.comparePossiblyUndefinedValues(
        x.name, y.name,
        function(x, y) { return x.localeCompare(y); });
    if (tmp)
      return tmp;

    return x.tid - y.tid;
  };

  return {
    Thread: Thread
  };
});


'use strict';

/**
 * @fileoverview Provides the ProcessBase class.
 */
tr.exportTo('tr.model', function() {

  var Thread = tr.model.Thread;
  var Counter = tr.model.Counter;

  /**
   * The ProcessBase is a partial base class, upon which Kernel
   * and Process are built.
   *
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function ProcessBase(model) {
    if (!model)
      throw new Error('Must provide a model');
    tr.model.EventContainer.call(this);
    this.model = model;
    this.threads = {};
    this.counters = {};
    this.objects = new tr.model.ObjectCollection(this);
    this.sortIndex = 0;
  };

  ProcessBase.compare = function(x, y) {
    return x.sortIndex - y.sortIndex;
  };

  ProcessBase.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get stableId() {
      throw new Error('Not implemented');
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
      for (var tid in this.threads)
        callback.call(opt_this, this.threads[tid]);
      for (var id in this.counters)
        callback.call(opt_this, this.counters[id]);
      callback.call(opt_this, this.objects);
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
    },

    iterateAllPersistableObjects: function(cb) {
      cb(this);
      for (var tid in this.threads)
        this.threads[tid].iterateAllPersistableObjects(cb);
    },

    /**
     * Gets the number of threads in this process.
     */
    get numThreads() {
      var n = 0;
      for (var p in this.threads) {
        n++;
      }
      return n;
    },

    /**
     * Shifts all the timestamps inside this process forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      this.iterateAllChildEventContainers(function(child) {
        child.shiftTimestampsForward(amount);
      });
    },

    /**
     * Closes any open slices.
     */
    autoCloseOpenSlices: function(opt_maxTimestamp) {
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        thread.autoCloseOpenSlices(opt_maxTimestamp);
      }
    },

    autoDeleteObjects: function(maxTimestamp) {
      this.objects.autoDeleteObjects(maxTimestamp);
    },

    /**
     * Called by the model after finalizing imports,
     * but before joining refs.
     */
    preInitializeObjects: function() {
      this.objects.preInitializeAllObjects();
    },

    /**
     * Called by the model after joining refs.
     */
    initializeObjects: function() {
      this.objects.initializeAllObjects();
    },

    /**
     * Merge slices from the kernel with those from userland for each thread.
     */
    mergeKernelWithUserland: function() {
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        thread.mergeKernelWithUserland();
      }
    },

    updateBounds: function() {
      this.bounds.reset();
      for (var tid in this.threads) {
        this.threads[tid].updateBounds();
        this.bounds.addRange(this.threads[tid].bounds);
      }
      for (var id in this.counters) {
        this.counters[id].updateBounds();
        this.bounds.addRange(this.counters[id].bounds);
      }
      this.objects.updateBounds();
      this.bounds.addRange(this.objects.bounds);
    },

    addCategoriesToDict: function(categoriesDict) {
      for (var tid in this.threads)
        this.threads[tid].addCategoriesToDict(categoriesDict);
      for (var id in this.counters)
        categoriesDict[this.counters[id].category] = true;
      this.objects.addCategoriesToDict(categoriesDict);
    },

    findAllThreadsMatching: function(predicate, opt_this) {
      var threads = [];
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        if (predicate.call(opt_this, thread))
          threads.push(thread);
      }
      return threads;
    },

    /**
     * @param {String} The name of the thread to find.
     * @return {Array} An array of all the matched threads.
     */
    findAllThreadsNamed: function(name) {
      var threads = this.findAllThreadsMatching(function(thread) {
        if (!thread.name)
          return false;
        return thread.name === name;
      });
      return threads;
    },

    findAtMostOneThreadNamed: function(name) {
      var threads = this.findAllThreadsNamed(name);
      if (threads.length === 0)
        return undefined;
      if (threads.length > 1)
        throw new Error('Expected no more than one ' + name);
      return threads[0];
    },

    /**
     * Removes threads from the process that are fully empty.
     */
    pruneEmptyContainers: function() {
      var threadsToKeep = {};
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        if (!thread.isEmpty)
          threadsToKeep[tid] = thread;
      }
      this.threads = threadsToKeep;
    },

    /**
     * @return {TimelineThread} The thread identified by tid on this process,
     * or undefined if it doesn't exist.
     */
    getThread: function(tid) {
      return this.threads[tid];
    },

    /**
     * @return {TimelineThread} The thread identified by tid on this process,
     * creating it if it doesn't exist.
     */
    getOrCreateThread: function(tid) {
      if (!this.threads[tid])
        this.threads[tid] = new Thread(this, tid);
      return this.threads[tid];
    },

    /**
     * @return {Counter} The counter on this process with the given
     * category/name combination, creating it if it doesn't exist.
     */
    getOrCreateCounter: function(cat, name) {
      var id = cat + '.' + name;
      if (!this.counters[id])
        this.counters[id] = new Counter(this, id, cat, name);
      return this.counters[id];
    },

    getSettingsKey: function() {
      throw new Error('Not implemented');
    },

    createSubSlices: function() {
      for (var tid in this.threads)
        this.threads[tid].createSubSlices();
    }
  };

  return {
    ProcessBase: ProcessBase
  };
});


'use strict';

/**
 * @fileoverview Provides the Process class.
 */
tr.exportTo('tr.model', function() {
  var Cpu = tr.model.Cpu;
  var ProcessBase = tr.model.ProcessBase;

  /**
   * The Kernel represents kernel-level objects in the model.
   * @constructor
   */
  function Kernel(model) {
    ProcessBase.call(this, model);

    this.cpus = {};
    this.softwareMeasuredCpuCount_ = undefined;
  };

  /**
   * Comparison between kernels is pretty meaningless.
   */
  Kernel.compare = function(x, y) {
    return 0;
  };

  Kernel.prototype = {
    __proto__: ProcessBase.prototype,

    compareTo: function(that) {
      return Kernel.compare(this, that);
    },

    get userFriendlyName() {
      return 'Kernel';
    },

    get userFriendlyDetails() {
      return 'Kernel';
    },

    get stableId() {
      return 'Kernel';
    },

    /**
     * @return {Cpu} Gets a specific Cpu or creates one if
     * it does not exist.
     */
    getOrCreateCpu: function(cpuNumber) {
      if (!this.cpus[cpuNumber])
        this.cpus[cpuNumber] = new Cpu(this, cpuNumber);
      return this.cpus[cpuNumber];
    },

    get softwareMeasuredCpuCount() {
      return this.softwareMeasuredCpuCount_;
    },

    set softwareMeasuredCpuCount(softwareMeasuredCpuCount) {
      if (this.softwareMeasuredCpuCount_ !== undefined &&
          this.softwareMeasuredCpuCount_ !== softwareMeasuredCpuCount) {
        throw new Error(
            'Cannot change the softwareMeasuredCpuCount once it is set');
      }

      this.softwareMeasuredCpuCount_ = softwareMeasuredCpuCount;
    },

    /**
     * Estimates how many cpus are in the system, for use in system load
     * estimation.
     *
     * If kernel trace was provided, uses that data. Otherwise, uses the
     * software measured cpu count.
     */
    get bestGuessAtCpuCount() {
      var realCpuCount = tr.b.dictionaryLength(this.cpus);
      if (realCpuCount !== 0)
        return realCpuCount;
      return this.softwareMeasuredCpuCount;
    },

    updateBounds: function() {
      ProcessBase.prototype.updateBounds.call(this);
      for (var cpuNumber in this.cpus) {
        var cpu = this.cpus[cpuNumber];
        cpu.updateBounds();
        this.bounds.addRange(cpu.bounds);
      }
    },

    createSubSlices: function() {
      ProcessBase.prototype.createSubSlices.call(this);
      for (var cpuNumber in this.cpus) {
        var cpu = this.cpus[cpuNumber];
        cpu.createSubSlices();
      }
    },

    addCategoriesToDict: function(categoriesDict) {
      ProcessBase.prototype.addCategoriesToDict.call(this, categoriesDict);
      for (var cpuNumber in this.cpus)
        this.cpus[cpuNumber].addCategoriesToDict(categoriesDict);
    },

    getSettingsKey: function() {
      return 'kernel';
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
      ProcessBase.prototype.iterateAllChildEventContainers.call(
          this, callback, opt_this);
      for (var cpuId in this.cpus)
        callback.call(opt_this, this.cpus[cpuId]);
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      ProcessBase.prototype.iterateAllEventsInThisContainer.call(
          this, eventTypePredicate, callback, opt_this);
    }
  };

  return {
    Kernel: Kernel
  };
});


'use strict';

/**
 * @fileoverview Provides the Event Index class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A Event Index maps an id to all the events that have that particular id
   *
   * @constructor
   */
  function ModelIndices(model) {
    // For now the only indices we construct are for flowEvents
    this.flowEventsById_ = {};
    model.flowEvents.forEach(function(fe) {
      if (fe.id !== undefined) {
        if (!this.flowEventsById_.hasOwnProperty(fe.id)) {
          this.flowEventsById_[fe.id] = new Array();
        }
        this.flowEventsById_[fe.id].push(fe);
      }
    }, this);
  }

  ModelIndices.prototype = {
    addEventWithId: function(id, event) {
      if (!this.flowEventsById_.hasOwnProperty(id)) {
        this.flowEventsById_[id] = new Array();
      }
      this.flowEventsById_[id].push(event);
    },

    getFlowEventsWithId: function(id) {
      if (!this.flowEventsById_.hasOwnProperty(id))
        return [];
      return this.flowEventsById_[id];
    }
  };

  return {
    ModelIndices: ModelIndices
  };
});


'use strict';

/**
 * @fileoverview Provides the ProcessMemoryDump class.
 */
tr.exportTo('tr.model', function() {

  // Names of MemoryAllocatorDump(s) from which tracing overhead should be
  // discounted.
  var DISCOUNTED_ALLOCATOR_NAMES = ['winheap', 'malloc'];

  var SIZE_ATTRIBUTE_NAME = tr.model.MemoryAllocatorDump.SIZE_ATTRIBUTE_NAME;
  var EFFECTIVE_SIZE_ATTRIBUTE_NAME =
      tr.model.MemoryAllocatorDump.EFFECTIVE_SIZE_ATTRIBUTE_NAME;

  /**
   * The ProcessMemoryDump represents a memory dump of a single process.
   * @constructor
   */
  function ProcessMemoryDump(globalMemoryDump, process, start) {
    tr.model.ContainerMemoryDump.call(this, start);
    this.process = process;
    this.globalMemoryDump = globalMemoryDump;

    this.totals = undefined;
    this.vmRegions_ = undefined;

    this.tracingMemoryDiscounted_ = false;
  };

  ProcessMemoryDump.prototype = {
    __proto__: tr.model.ContainerMemoryDump.prototype,

    get userFriendlyName() {
      return 'Process memory dump at ' +
          tr.b.u.TimeStamp.format(this.start);
    },

    get containerName() {
      return this.process.userFriendlyName;
    },

    get vmRegions() {
      throw new Error(
          'VM regions must be accessed through the mostRecentVmRegions field');
    },

    set vmRegions(vmRegions) {
      this.vmRegions_ = vmRegions;
    },

    get hasOwnVmRegions() {
      return this.vmRegions_ !== undefined;
    },

    getMostRecentTotalVmRegionStat: function(statName) {
      if (this.mostRecentVmRegions === undefined)
        return undefined;

      var total = 0;
      this.mostRecentVmRegions.forEach(function(vmRegion) {
        var statValue = vmRegion.byteStats[statName];
        if (statValue === undefined)
          return;
        total += statValue;
      });
      return total;
    },

    discountTracingOverhead: function(opt_model) {
      // Make sure that calling this method twice won't lead to
      // 'double-discounting'.
      if (this.tracingMemoryDiscounted_)
        return;
      this.tracingMemoryDiscounted_ = true;

      var tracingDump = this.getMemoryAllocatorDumpByFullName('tracing');
      if (tracingDump === undefined)
        return;

      function getDiscountedSize(sizeAttrName) {
        var sizeAttr = tracingDump.getValidSizeAttributeOrUndefined(
            sizeAttrName, opt_model);
        if (sizeAttr === undefined)
          return 0;
        return sizeAttr.value;
      }

      var discountedSize = getDiscountedSize(SIZE_ATTRIBUTE_NAME);
      var discountedEffectiveSize =
          getDiscountedSize(EFFECTIVE_SIZE_ATTRIBUTE_NAME);
      var discountedResidentSize = getDiscountedSize('resident_size');

      // Subtract 'resident_size' from totals and VM regions stats.
      if (discountedResidentSize > 0) {
        // Subtract the tracing size from the totals.
        if (this.totals !== undefined) {
          if (this.totals.residentBytes !== undefined)
            this.totals.residentBytes -= discountedResidentSize;
          if (this.totals.peakResidentBytes !== undefined)
            this.totals.peakResidentBytes -= discountedResidentSize;
        }

        // Subtract the tracing size from VM regions.
        if (this.vmRegions_ !== undefined) {
          this.vmRegions_.push(VMRegion.fromDict({
            mappedFile: '[discounted tracing overhead]',
            byteStats: {
              privateDirtyResident: -discountedResidentSize,
              proportionalResident: -discountedResidentSize
            }
          }));
        }
      }

      // Subtract 'size' and 'effective_size' from the 'winheap' or 'malloc'
      // MemoryAllocatorDump.
      if (discountedSize > 0 || discountedEffectiveSize > 0) {
        function discountSizeAndEffectiveSize(dump) {
          var dumpSizeAttr = dump.getValidSizeAttributeOrUndefined(
              SIZE_ATTRIBUTE_NAME, opt_model);
          if (dumpSizeAttr !== undefined)
            dumpSizeAttr.value -= discountedSize;

          var dumpEffectiveSizeAttr = dump.getValidSizeAttributeOrUndefined(
              EFFECTIVE_SIZE_ATTRIBUTE_NAME, opt_model);
          if (dumpEffectiveSizeAttr !== undefined)
            dumpEffectiveSizeAttr.value -= discountedEffectiveSize;
        }

        var hasDiscountedFromAllocatorDumps = DISCOUNTED_ALLOCATOR_NAMES.some(
            function(allocatorName) {
          // Discount 'size' and 'effective_size' from the allocator root.
          var allocatorDump = this.getMemoryAllocatorDumpByFullName(
              allocatorName);
          if (allocatorDump === undefined)
            return false;  // Allocator doesn't exist, try another one.
          discountSizeAndEffectiveSize(allocatorDump);

          // Discount 'size' and 'effective_size' from allocated objects of the
          // allocator ('<ALLOCATOR>/allocated_objects').
          var allocatedObjectsDumpName = allocatorName + '/allocated_objects';
          var allocatedObjectsDump = this.getMemoryAllocatorDumpByFullName(
              allocatedObjectsDumpName);
          if (allocatedObjectsDump === undefined)
            return true;  // Allocator has unexpected structure, good enough.
          discountSizeAndEffectiveSize(allocatedObjectsDump);

          // Add a child MAD representing the discounted tracing overhead
          // ('<ALLOCATOR>/allocated_objects/discounted_tracing_overhead').
          var discountDumpName =
              allocatedObjectsDumpName + '/discounted_tracing_overhead';
          var discountDump = new tr.model.MemoryAllocatorDump(
              this, discountDumpName);
          discountDump.parent = allocatedObjectsDump;
          discountDump.addAttribute(SIZE_ATTRIBUTE_NAME,
              new tr.model.ScalarAttribute('bytes', -discountedSize));
          discountDump.addAttribute(EFFECTIVE_SIZE_ATTRIBUTE_NAME,
              new tr.model.ScalarAttribute('bytes', -discountedEffectiveSize));
          allocatedObjectsDump.children.push(discountDump);

          return true;
        }, this);

        // Force rebuilding the memory allocator dump index (if we've just added
        // a new memory allocator dump).
        if (hasDiscountedFromAllocatorDumps)
          this.memoryAllocatorDumps = this.memoryAllocatorDumps;
      }
    }
  };

  ProcessMemoryDump.hookUpMostRecentVmRegionsLinks = function(processDumps) {
    var mostRecentVmRegions = undefined;

    processDumps.forEach(function(processDump) {
      // Update the most recent VM regions from the current dump.
      if (processDump.vmRegions_ !== undefined)
        mostRecentVmRegions = processDump.vmRegions_;

      // Set the most recent VM regions of the current dump.
      processDump.mostRecentVmRegions = mostRecentVmRegions;
    });
  };

  /**
   * @constructor
   */
  function VMRegion(startAddress, sizeInBytes, protectionFlags,
      mappedFile, byteStats) {
    this.startAddress = startAddress;
    this.sizeInBytes = sizeInBytes;
    this.protectionFlags = protectionFlags;
    this.mappedFile = mappedFile;
    this.byteStats = byteStats;
  };

  VMRegion.PROTECTION_FLAG_READ = 4;
  VMRegion.PROTECTION_FLAG_WRITE = 2;
  VMRegion.PROTECTION_FLAG_EXECUTE = 1;

  VMRegion.prototype = {
    get protectionFlagsToString() {
      if (this.protectionFlags === undefined)
        return undefined;
      return (
          (this.protectionFlags & VMRegion.PROTECTION_FLAG_READ ? 'r' : '-') +
          (this.protectionFlags & VMRegion.PROTECTION_FLAG_WRITE ? 'w' : '-') +
          (this.protectionFlags & VMRegion.PROTECTION_FLAG_EXECUTE ? 'x' : '-')
      );
    }
  };

  VMRegion.fromDict = function(dict) {
    return new VMRegion(
        dict.startAddress,
        dict.sizeInBytes,
        dict.protectionFlags,
        dict.mappedFile,
        VMRegionByteStats.fromDict(dict.byteStats));
  };

  /**
   * @constructor
   */
  function VMRegionByteStats(privateCleanResident, privateDirtyResident,
                             sharedCleanResident, sharedDirtyResident,
                             proportionalResident, swapped) {
    this.privateCleanResident = privateCleanResident;
    this.privateDirtyResident = privateDirtyResident;
    this.sharedCleanResident = sharedCleanResident;
    this.sharedDirtyResident = sharedDirtyResident;
    this.proportionalResident = proportionalResident;
    this.swapped = swapped;
  }

  VMRegionByteStats.fromDict = function(dict) {
    return new VMRegionByteStats(
        dict.privateCleanResident,
        dict.privateDirtyResident,
        dict.sharedCleanResident,
        dict.sharedDirtyResident,
        dict.proportionalResident,
        dict.swapped);
  }

  tr.model.EventRegistry.register(
      ProcessMemoryDump,
      {
        name: 'processMemoryDump',
        pluralName: 'processMemoryDumps',
        singleViewElementName: 'tr-ui-a-single-process-memory-dump-sub-view',
        multiViewElementName: 'tr-ui-a-multi-process-memory-dump-sub-view'
      });

  return {
    ProcessMemoryDump: ProcessMemoryDump,
    VMRegion: VMRegion,
    VMRegionByteStats: VMRegionByteStats
  };
});


'use strict';

/**
 * @fileoverview Provides the Process class.
 */
tr.exportTo('tr.model', function() {
  var ProcessBase = tr.model.ProcessBase;
  var ProcessInstantEvent = tr.model.ProcessInstantEvent;
  var Frame = tr.model.Frame;
  var ProcessMemoryDump = tr.model.ProcessMemoryDump;

  /**
   * The Process represents a single userland process in the
   * trace.
   * @constructor
   */
  function Process(model, pid) {
    if (model === undefined)
      throw new Error('model must be provided');
    if (pid === undefined)
      throw new Error('pid must be provided');
    tr.model.ProcessBase.call(this, model);
    this.pid = pid;
    this.name = undefined;
    this.labels = [];
    this.instantEvents = [];
    this.memoryDumps = [];
    this.frames = [];
    this.activities = [];
  };

  /**
   * Comparison between processes that orders by pid.
   */
  Process.compare = function(x, y) {
    var tmp = tr.model.ProcessBase.compare(x, y);
    if (tmp)
      return tmp;

    tmp = tr.b.comparePossiblyUndefinedValues(
        x.name, y.name,
        function(x, y) { return x.localeCompare(y); });
    if (tmp)
      return tmp;

    tmp = tr.b.compareArrays(x.labels, y.labels,
        function(x, y) { return x.localeCompare(y); });
    if (tmp)
      return tmp;

    return x.pid - y.pid;
  };

  Process.prototype = {
    __proto__: tr.model.ProcessBase.prototype,

    get stableId() {
      return this.pid;
    },

    compareTo: function(that) {
      return Process.compare(this, that);
    },

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      ProcessBase.prototype.iterateAllEventsInThisContainer.call(
          this, eventTypePredicate, callback, opt_this);

      if (eventTypePredicate.call(opt_this, ProcessInstantEvent))
        this.instantEvents.forEach(callback, opt_this);

      if (eventTypePredicate.call(opt_this, Frame))
        this.frames.forEach(callback, opt_this);

      if (eventTypePredicate.call(opt_this, ProcessMemoryDump))
        this.memoryDumps.forEach(callback, opt_this);
    },

    pushInstantEvent: function(instantEvent) {
      this.instantEvents.push(instantEvent);
    },

    addLabelIfNeeded: function(labelName) {
      for (var i = 0; i < this.labels.length; i++) {
        if (this.labels[i] === labelName)
          return;
      }
      this.labels.push(labelName);
    },

    get userFriendlyName() {
      var res;
      if (this.name)
        res = this.name + ' (pid ' + this.pid + ')';
      else
        res = 'Process ' + this.pid;
      if (this.labels.length)
        res += ': ' + this.labels.join(', ');
      return res;
    },

    get userFriendlyDetails() {
      if (this.name)
        return this.name + ' (pid ' + this.pid + ')';
      return 'pid: ' + this.pid;
    },

    getSettingsKey: function() {
      if (!this.name)
        return undefined;
      if (!this.labels.length)
        return 'processes.' + this.name;
      return 'processes.' + this.name + '.' + this.labels.join('.');
    },

    shiftTimestampsForward: function(amount) {
      for (var id in this.instantEvents)
        this.instantEvents[id].start += amount;

      for (var i = 0; i < this.frames.length; i++)
        this.frames[i].shiftTimestampsForward(amount);

      for (var i = 0; i < this.memoryDumps.length; i++)
        this.memoryDumps[i].shiftTimestampsForward(amount);

      for (var i = 0; i < this.activities.length; i++)
        this.activities[i].shiftTimestampsForward(amount);

      tr.model.ProcessBase.prototype
          .shiftTimestampsForward.apply(this, arguments);
    },

    updateBounds: function() {
      tr.model.ProcessBase.prototype.updateBounds.apply(this);

      for (var i = 0; i < this.frames.length; i++)
        this.frames[i].addBoundsToRange(this.bounds);

      for (var i = 0; i < this.memoryDumps.length; i++)
        this.memoryDumps[i].addBoundsToRange(this.bounds);

      for (var i = 0; i < this.activities.length; i++)
        this.activities[i].addBoundsToRange(this.bounds);
    },

    sortMemoryDumps: function() {
      this.memoryDumps.sort(function(x, y) {
        return x.start - y.start;
      });
      tr.model.ProcessMemoryDump.hookUpMostRecentVmRegionsLinks(
          this.memoryDumps);
    }
  };

  return {
    Process: Process
  };
});


'use strict';

/**
 * @fileoverview Provides the Sample class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A Sample represents a sample taken at an instant in time, plus its stack
   * frame and parameters associated with that sample.
   *
   * @constructor
   */
  function Sample(cpu, thread, title, start, leafStackFrame,
                  opt_weight, opt_args) {
    tr.model.TimedEvent.call(this, start);

    this.title = title;
    this.cpu = cpu;
    this.thread = thread;
    this.leafStackFrame = leafStackFrame;
    this.weight = opt_weight;
    this.args = opt_args || {};
  }

  Sample.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get colorId() {
      return this.leafStackFrame.colorId;
    },

    get stackTrace() {
      return this.leafStackFrame.stackTrace;
    },

    getUserFriendlyStackTrace: function() {
      return this.leafStackFrame.getUserFriendlyStackTrace();
    },

    get userFriendlyName() {
      return 'Sample at ' + tr.b.u.TimeStamp.format(this.start);
    }
  };

  tr.model.EventRegistry.register(
      Sample,
      {
        name: 'sample',
        pluralName: 'samples',
        singleViewElementName: 'tr-ui-a-single-sample-sub-view',
        multiViewElementName: 'tr-ui-a-multi-sample-sub-view'
      });

  return {
    Sample: Sample
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function StackFrame(parentFrame, id, category, title,
      colorId, opt_sourceInfo) {
    if (id === undefined)
      throw new Error('id must be given');
    this.parentFrame_ = parentFrame;
    this.id = id;
    this.category = category || '';
    this.title_ = title;
    this.colorId = colorId;
    this.children = [];
    this.sourceInfo_ = opt_sourceInfo;

    if (this.parentFrame_)
      this.parentFrame_.addChild(this);
  }

  StackFrame.prototype = {
    get parentFrame() {
      return this.parentFrame_;
    },

    get title() {
      if (this.sourceInfo_) {
        var src = this.sourceInfo_.toString();
        return this.title_ + (src === '' ? '' : ' ' + src);
      }
      return this.title_;
    },

    /**
     * Attempts to find the domain of the origin of the script either from this
     * stack trace or from its ancestors.
     */
    get domain() {
      var result = 'unknown';
      if (this.sourceInfo_ && this.sourceInfo_.domain)
        result = this.sourceInfo_.domain;
      if (result === 'unknown' && this.parentFrame)
        result = this.parentFrame.domain;
      return result;
    },

    set parentFrame(parentFrame) {
      if (this.parentFrame_)
        this.parentFrame_.removeChild(this);
      this.parentFrame_ = parentFrame;
      if (this.parentFrame_)
        this.parentFrame_.addChild(this);
    },

    addChild: function(child) {
      this.children.push(child);
    },

    removeChild: function(child) {
      var i = this.children.indexOf(child.id);
      if (i == -1)
        throw new Error('omg');
      this.children.splice(i, 1);
    },

    removeAllChildren: function() {
      for (var i = 0; i < this.children.length; i++)
        this.children[i].parentFrame_ = undefined;
      this.children.splice(0, this.children.length);
    },

    /**
     * Returns stackFrames where the most specific frame is first.
     */
    get stackTrace() {
      var stack = [];
      var cur = this;
      while (cur) {
        stack.push(cur);
        cur = cur.parentFrame;
      }
      return stack;
    },

    getUserFriendlyStackTrace: function() {
      return this.stackTrace.map(function(x) {
        return x.category + ': ' + x.title;
      });
    }
  };

  return {
    StackFrame: StackFrame
  };
});


'use strict';

/**
 * @fileoverview Implements an element that is hidden by default, but
 * when shown, dims and (attempts to) disable the main document.
 *
 * You can turn any div into an overlay. Note that while an
 * overlay element is shown, its parent is changed. Hiding the overlay
 * restores its original parentage.
 *
 */
tr.exportTo('tr.ui.b', function() {
  if (tr.isHeadless)
    return {};

  var THIS_DOC = document.currentScript.ownerDocument;

  /**
   * Creates a new overlay element. It will not be visible until shown.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var Overlay = tr.ui.b.define('overlay');

  Overlay.prototype = {
    __proto__: HTMLDivElement.prototype,

    /**
     * Initializes the overlay element.
     */
    decorate: function() {
      this.classList.add('overlay');

      this.parentEl_ = this.ownerDocument.body;

      this.visible_ = false;
      this.userCanClose_ = true;

      this.onKeyDown_ = this.onKeyDown_.bind(this);
      this.onClick_ = this.onClick_.bind(this);
      this.onFocusIn_ = this.onFocusIn_.bind(this);
      this.onDocumentClick_ = this.onDocumentClick_.bind(this);
      this.onClose_ = this.onClose_.bind(this);

      this.addEventListener('visible-change',
          tr.ui.b.Overlay.prototype.onVisibleChange_.bind(this), true);

      // Setup the shadow root
      var createShadowRoot = this.createShadowRoot ||
          this.webkitCreateShadowRoot;
      this.shadow_ = createShadowRoot.call(this);
      this.shadow_.appendChild(tr.ui.b.instantiateTemplate('#overlay-template',
                                                        THIS_DOC));

      this.closeBtn_ = this.shadow_.querySelector('close-button');
      this.closeBtn_.addEventListener('click', this.onClose_);

      this.shadow_
          .querySelector('overlay-frame')
          .addEventListener('click', this.onClick_);

      this.observer_ = new WebKitMutationObserver(
          this.didButtonBarMutate_.bind(this));
      this.observer_.observe(this.shadow_.querySelector('button-bar'),
                             { childList: true });

      // title is a variable on regular HTMLElements. However, we want to
      // use it for something more useful.
      Object.defineProperty(
          this, 'title', {
            get: function() {
              return this.shadow_.querySelector('title').textContent;
            },
            set: function(title) {
              this.shadow_.querySelector('title').textContent = title;
            }
          });
    },

    set userCanClose(userCanClose) {
      this.userCanClose_ = userCanClose;
      this.closeBtn_.style.display =
          userCanClose ? 'block' : 'none';
    },

    get buttons() {
      return this.shadow_.querySelector('button-bar');
    },

    get visible() {
      return this.visible_;
    },

    set visible(newValue) {
      if (this.visible_ === newValue)
        return;

      this.visible_ = newValue;
      var e = new tr.b.Event('visible-change');
      this.dispatchEvent(e);
    },

    onVisibleChange_: function() {
      this.visible_ ? this.show_() : this.hide_();
    },

    show_: function() {
      this.parentEl_.appendChild(this);

      if (this.userCanClose_) {
        this.addEventListener('keydown', this.onKeyDown_.bind(this));
        this.addEventListener('click', this.onDocumentClick_.bind(this));
      }

      this.parentEl_.addEventListener('focusin', this.onFocusIn_);
      this.tabIndex = 0;

      // Focus the first thing we find that makes sense. (Skip the close button
      // as it doesn't make sense as the first thing to focus.)
      var focusEl = undefined;
      var elList = this.querySelectorAll('button, input, list, select, a');
      if (elList.length > 0) {
        if (elList[0] === this.closeBtn_) {
          if (elList.length > 1)
            focusEl = elList[1];
        } else {
          focusEl = elList[0];
        }
      }
      if (focusEl === undefined)
        focusEl = this;
      focusEl.focus();
    },

    hide_: function() {
      this.parentEl_.removeChild(this);

      this.parentEl_.removeEventListener('focusin', this.onFocusIn_);

      if (this.closeBtn_)
        this.closeBtn_.removeEventListener(this.onClose_);

      document.removeEventListener('keydown', this.onKeyDown_);
      document.removeEventListener('click', this.onDocumentClick_);
    },

    onClose_: function(e) {
      this.visible = false;
      if ((e.type != 'keydown') ||
          (e.type === 'keydown' && e.keyCode === 27))
        e.stopPropagation();
      e.preventDefault();
      tr.b.dispatchSimpleEvent(this, 'closeclick');
    },

    onFocusIn_: function(e) {
      if (e.target === this)
        return;

      window.setTimeout(function() { this.focus(); }, 0);
      e.preventDefault();
      e.stopPropagation();
    },

    didButtonBarMutate_: function(e) {
      var hasButtons = this.buttons.children.length > 0;
      if (hasButtons)
        this.shadow_.querySelector('button-bar').style.display = undefined;
      else
        this.shadow_.querySelector('button-bar').style.display = 'none';
    },

    onKeyDown_: function(e) {
      // Disallow shift-tab back to another element.
      if (e.keyCode === 9 &&  // tab
          e.shiftKey &&
          e.target === this) {
        e.preventDefault();
        return;
      }

      if (e.keyCode !== 27)  // escape
        return;

      this.onClose_(e);
    },

    onClick_: function(e) {
      e.stopPropagation();
    },

    onDocumentClick_: function(e) {
      if (!this.userCanClose_)
        return;

      this.onClose_(e);
    }
  };

  Overlay.showError = function(msg, opt_err) {
    var o = new Overlay();
    o.title = 'Error';
    o.textContent = msg;
    if (opt_err) {
      var e = tr.b.normalizeException(opt_err);

      var stackDiv = document.createElement('pre');
      stackDiv.textContent = e.stack;
      stackDiv.style.paddingLeft = '8px';
      stackDiv.style.margin = 0;
      o.appendChild(stackDiv);
    }
    var b = document.createElement('button');
    b.textContent = 'OK';
    b.addEventListener('click', function() {
      o.visible = false;
    });
    o.buttons.appendChild(b);
    o.visible = true;
    return o;
  }

  return {
    Overlay: Overlay
  };
});


'use strict';

/**
 * @fileoverview Model is a parsed representation of the
 * TraceEvents obtained from base/trace_event in which the begin-end
 * tokens are converted into a hierarchy of processes, threads,
 * subrows, and slices.
 *
 * The building block of the model is a slice. A slice is roughly
 * equivalent to function call executing on a specific thread. As a
 * result, slices may have one or more subslices.
 *
 * A thread contains one or more subrows of slices. Row 0 corresponds to
 * the "root" slices, e.g. the topmost slices. Row 1 contains slices that
 * are nested 1 deep in the stack, and so on. We use these subrows to draw
 * nesting tasks.
 *
 */
tr.exportTo('tr', function() {
  var Process = tr.model.Process;
  var Device = tr.model.Device;
  var Kernel = tr.model.Kernel;
  var GlobalMemoryDump = tr.model.GlobalMemoryDump;
  var GlobalInstantEvent = tr.model.GlobalInstantEvent;
  var FlowEvent = tr.model.FlowEvent;
  var Alert = tr.model.Alert;
  var InteractionRecord = tr.model.InteractionRecord;
  var Sample = tr.model.Sample;

  function ClockSyncRecord(name, ts, args) {
    this.name = name;
    this.ts = ts;
    this.args = args;
  }

  /**
   * @constructor
   */
  function Model() {
    tr.model.EventContainer.call(this);
    tr.b.EventTarget.decorate(this);

    this.timestampShiftToZeroAmount_ = 0;

    this.faviconHue = 'blue'; // Should be a key from favicons.html

    this.device = new Device(this);
    this.kernel = new Kernel(this);
    this.processes = {};
    this.metadata = [];
    this.categories = [];
    this.instantEvents = [];
    this.flowEvents = [];
    this.clockSyncRecords = [];
    this.intrinsicTimeUnit_ = undefined;

    this.stackFrames = {};
    this.samples = [];

    this.alerts = [];
    this.interactionRecords = [];

    this.flowIntervalTree = new tr.b.IntervalTree(
        function(f) { return f.start; },
        function(f) { return f.end; });

    this.globalMemoryDumps = [];

    this.annotationsByGuid_ = {};
    this.modelIndices = undefined;

    this.importWarnings_ = [];
    this.reportedImportWarnings_ = {};
  }

  Model.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    iterateAllEventsInThisContainer: function(eventTypePredicate,
                                              callback, opt_this) {
      if (eventTypePredicate.call(opt_this, GlobalMemoryDump))
        this.globalMemoryDumps.forEach(callback, opt_this);

      if (eventTypePredicate.call(opt_this, GlobalInstantEvent))
        this.instantEvents.forEach(callback, opt_this);

      if (eventTypePredicate.call(opt_this, FlowEvent))
        this.flowEvents.forEach(callback, opt_this);

      if (eventTypePredicate.call(opt_this, Alert))
        this.alerts.forEach(callback, opt_this);

      if (eventTypePredicate.call(opt_this, InteractionRecord))
        this.interactionRecords.forEach(callback, opt_this);

      if (eventTypePredicate.call(opt_this, Sample))
        this.samples.forEach(callback, opt_this);
    },

    iterateAllChildEventContainers: function(callback, opt_this) {
      callback.call(opt_this, this.device);
      callback.call(opt_this, this.kernel);
      for (var pid in this.processes)
        callback.call(opt_this, this.processes[pid]);
    },

    /**
     * Some objects in the model can persist their state in ModelSettings.
     *
     * This iterates through them.
     */
    iterateAllPersistableObjects: function(callback) {
      this.kernel.iterateAllPersistableObjects(callback);
      for (var pid in this.processes)
        this.processes[pid].iterateAllPersistableObjects(callback);
    },

    updateBounds: function() {
      this.bounds.reset();
      var bounds = this.bounds;

      this.iterateAllChildEventContainers(function(ec) {
        ec.updateBounds();
        bounds.addRange(ec.bounds);
      });
      this.iterateAllEventsInThisContainer(
          function(eventConstructor) { return true; },
          function(event) {
            event.addBoundsToRange(bounds);
          });
    },

    shiftWorldToZero: function() {
      var shiftAmount = -this.bounds.min;
      this.timestampShiftToZeroAmount_ = shiftAmount;
      this.iterateAllChildEventContainers(function(ec) {
        ec.shiftTimestampsForward(shiftAmount);
      });
      this.iterateAllEventsInThisContainer(
        function(eventConstructor) { return true; },
        function(event) {
          event.start += shiftAmount;
        });
      this.updateBounds();
    },

    convertTimestampToModelTime: function(sourceClockDomainName, ts) {
      if (sourceClockDomainName !== 'traceEventClock')
        throw new Error('Only traceEventClock is supported.');
      return tr.b.u.Units.timestampFromUs(ts) +
        this.timestampShiftToZeroAmount_;
    },

    get numProcesses() {
      var n = 0;
      for (var p in this.processes)
        n++;
      return n;
    },

    /**
     * @return {Process} Gets a TimelineProcess for a specified pid. Returns
     * undefined if the process doesn't exist.
     */
    getProcess: function(pid) {
      return this.processes[pid];
    },

    /**
     * @return {Process} Gets a TimelineProcess for a specified pid or
     * creates one if it does not exist.
     */
    getOrCreateProcess: function(pid) {
      if (!this.processes[pid])
        this.processes[pid] = new Process(this, pid);
      return this.processes[pid];
    },

    pushInstantEvent: function(instantEvent) {
      this.instantEvents.push(instantEvent);
    },

    addStackFrame: function(stackFrame) {
      if (this.stackFrames[stackFrame.id])
        throw new Error('Stack frame already exists');
      this.stackFrames[stackFrame.id] = stackFrame;
      return stackFrame;
    },

    addInteractionRecord: function(ir) {
      this.interactionRecords.push(ir);
      return ir;
    },

    getClockSyncRecordsNamed: function(name) {
      return this.clockSyncRecords.filter(function(x) {
        return x.name === name;
      });
    },

    /**
     * Generates the set of categories from the slices and counters.
     */
    updateCategories_: function() {
      var categoriesDict = {};
      this.device.addCategoriesToDict(categoriesDict);
      this.kernel.addCategoriesToDict(categoriesDict);
      for (var pid in this.processes)
        this.processes[pid].addCategoriesToDict(categoriesDict);

      this.categories = [];
      for (var category in categoriesDict)
        if (category != '')
          this.categories.push(category);
    },

    getAllThreads: function() {
      var threads = [];
      for (var tid in this.kernel.threads) {
        threads.push(process.threads[tid]);
      }
      for (var pid in this.processes) {
        var process = this.processes[pid];
        for (var tid in process.threads) {
          threads.push(process.threads[tid]);
        }
      }
      return threads;
    },

    /**
     * @return {Array} An array of all processes in the model.
     */
    getAllProcesses: function() {
      var processes = [];
      for (var pid in this.processes)
        processes.push(this.processes[pid]);
      return processes;
    },

    /**
     * @return {Array} An array of all the counters in the model.
     */
    getAllCounters: function() {
      var counters = [];
      counters.push.apply(
          counters, tr.b.dictionaryValues(this.device.counters));
      counters.push.apply(
          counters, tr.b.dictionaryValues(this.kernel.counters));
      for (var pid in this.processes) {
        var process = this.processes[pid];
        for (var tid in process.counters) {
          counters.push(process.counters[tid]);
        }
      }
      return counters;
    },

    getAnnotationByGUID: function(guid) {
      return this.annotationsByGuid_[guid];
    },

    addAnnotation: function(annotation) {
      if (!annotation.guid)
        throw new Error('Annotation with undefined guid given');

      this.annotationsByGuid_[annotation.guid] = annotation;
      tr.b.dispatchSimpleEvent(this, 'annotationChange');
    },

    removeAnnotation: function(annotation) {
      this.annotationsByGuid_[annotation.guid].onRemove();
      delete this.annotationsByGuid_[annotation.guid];
      tr.b.dispatchSimpleEvent(this, 'annotationChange');
    },

    getAllAnnotations: function() {
      return tr.b.dictionaryValues(this.annotationsByGuid_);
    },

    /**
     * @param {String} The name of the thread to find.
     * @return {Array} An array of all the matched threads.
     */
    findAllThreadsNamed: function(name) {
      var namedThreads = [];
      namedThreads.push.apply(
          namedThreads,
          this.kernel.findAllThreadsNamed(name));
      for (var pid in this.processes) {
        namedThreads.push.apply(
            namedThreads,
            this.processes[pid].findAllThreadsNamed(name));
      }
      return namedThreads;
    },

    set importOptions(options) {
      this.importOptions_ = options;
    },

    /**
     * Returns a time unit that is used to format values and determines the
     * precision of the timestamp values.
     */
    get intrinsicTimeUnit() {
      if (this.intrinsicTimeUnit_ === undefined)
        return tr.b.u.TimeDisplayModes.ms;
      return this.intrinsicTimeUnit_;
    },

    set intrinsicTimeUnit(value) {
      if (this.intrinsicTimeUnit_ === value)
        return;
      if (this.intrinsicTimeUnit_ !== undefined)
        throw new Error('Intrinsic time unit already set');
      this.intrinsicTimeUnit_ = value;
    },

    /**
     * @param {Object} data The import warning data. Data must provide two
     *    accessors: type, message. The types are used to determine if we
     *    should output the message, we'll only output one message of each type.
     *    The message is the actual warning content.
     */
    importWarning: function(data) {
      this.importWarnings_.push(data);

      // Only log each warning type once. We may want to add some kind of
      // flag to allow reporting all importer warnings.
      if (this.reportedImportWarnings_[data.type] === true)
        return;

      if (this.importOptions_.showImportWarnings)
        console.warn(data.message);

      this.reportedImportWarnings_[data.type] = true;
    },

    get hasImportWarnings() {
      return (this.importWarnings_.length > 0);
    },

    get importWarnings() {
      return this.importWarnings_;
    },

    autoCloseOpenSlices: function() {
      // Sort the samples.
      this.samples.sort(function(x, y) {
        return x.start - y.start;
      });

      this.updateBounds();
      this.kernel.autoCloseOpenSlices(this.bounds.max);
      for (var pid in this.processes)
        this.processes[pid].autoCloseOpenSlices(this.bounds.max);
    },

    createSubSlices: function() {
      this.kernel.createSubSlices();
      for (var pid in this.processes)
        this.processes[pid].createSubSlices();
    },

    preInitializeObjects: function() {
      for (var pid in this.processes)
        this.processes[pid].preInitializeObjects();
    },

    initializeObjects: function() {
      for (var pid in this.processes)
        this.processes[pid].initializeObjects();
    },

    pruneEmptyContainers: function() {
      this.kernel.pruneEmptyContainers();
      for (var pid in this.processes)
        this.processes[pid].pruneEmptyContainers();
    },

    mergeKernelWithUserland: function() {
      for (var pid in this.processes)
        this.processes[pid].mergeKernelWithUserland();
    },

    computeWorldBounds: function(shiftWorldToZero) {
      this.updateBounds();
      this.updateCategories_();

      if (shiftWorldToZero)
        this.shiftWorldToZero();
    },

    buildFlowEventIntervalTree: function() {
      for (var i = 0; i < this.flowEvents.length; ++i) {
        var flowEvent = this.flowEvents[i];
        this.flowIntervalTree.insert(flowEvent);
      }
      this.flowIntervalTree.updateHighValues();
    },

    cleanupUndeletedObjects: function() {
      for (var pid in this.processes)
        this.processes[pid].autoDeleteObjects(this.bounds.max);
    },

    sortMemoryDumps: function() {
      this.globalMemoryDumps.sort(function(x, y) {
        return x.start - y.start;
      });

      for (var pid in this.processes)
        this.processes[pid].sortMemoryDumps();
    },

    calculateMemoryGraphAttributes: function() {
      this.globalMemoryDumps.forEach(function(dump) {
        dump.calculateGraphAttributes();
      });
    },

    buildEventIndices: function() {
      this.modelIndices = new tr.model.ModelIndices(this);
    },

    sortInteractionRecords: function() {
      this.interactionRecords.sort(function(x, y) {
        return x.start - y.start;
      });
    },

    sortAlerts: function() {
      this.alerts.sort(function(x, y) {
        return x.start - y.start;
      });
    }
  };

  return {
    ClockSyncRecord: ClockSyncRecord,
    Model: Model
  };
});


  'use strict';

  Polymer('tr-ui-a-single-thread-time-slice-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      if (selection.length !== 1)
        throw new Error('Only supports single slices');
      if (!(selection[0] instanceof tr.model.ThreadTimeSlice))
        throw new Error('Only supports thread time slices');

      this.currentSelection_ = selection;

      var timeSlice = selection[0];
      var thread = timeSlice.thread;

      var shadowRoot = this.shadowRoot;
      shadowRoot.querySelector('#state').textContent = timeSlice.title;
      var stateColor = tr.ui.b.getColorPalette()[timeSlice.colorId];
      shadowRoot.querySelector('#state').style.backgroundColor = stateColor;

      shadowRoot.querySelector('#process-name').textContent =
          thread.parent.userFriendlyName;
      shadowRoot.querySelector('#thread-name').textContent =
          thread.userFriendlyName;

      shadowRoot.querySelector('#start').timestamp = timeSlice.start;
      shadowRoot.querySelector('#duration').duration = timeSlice.duration;
      var onCpuEl = shadowRoot.querySelector('#on-cpu');
      onCpuEl.textContent = '';
      var runningInsteadEl = shadowRoot.querySelector('#running-instead');
      if (timeSlice.cpuOnWhichThreadWasRunning) {
        runningInsteadEl.parentElement.removeChild(runningInsteadEl);

        var cpuLink = document.createElement('tr-ui-a-analysis-link');
        cpuLink.selection = new tr.model.EventSet(
            timeSlice.getAssociatedCpuSlice());
        cpuLink.textContent =
            timeSlice.cpuOnWhichThreadWasRunning.userFriendlyName;
        onCpuEl.appendChild(cpuLink);
      } else {
        onCpuEl.parentElement.removeChild(onCpuEl);

        var cpuSliceThatTookCpu = timeSlice.getCpuSliceThatTookCpu();
        if (cpuSliceThatTookCpu) {
          var cpuLink = document.createElement('tr-ui-a-analysis-link');
          cpuLink.selection = new tr.model.EventSet(cpuSliceThatTookCpu);
          if (cpuSliceThatTookCpu.thread)
            cpuLink.textContent = cpuSliceThatTookCpu.thread.userFriendlyName;
          else
            cpuLink.textContent = cpuSliceThatTookCpu.title;
          runningInsteadEl.appendChild(cpuLink);
        } else {
          runningInsteadEl.parentElement.removeChild(runningInsteadEl);
        }
      }

      var argsEl = shadowRoot.querySelector('#args');
      if (tr.b.dictionaryKeys(timeSlice.args).length > 0) {
        var argsView =
            document.createElement('tr-ui-a-generic-object-view');
        argsView.object = timeSlice.args;

        argsEl.parentElement.style.display = '';
        argsEl.textContent = '';
        argsEl.appendChild(argsView);
      } else {
        argsEl.parentElement.style.display = 'none';
      }
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-thread-time-slice-sub-view', {
    ready: function() {
      this.$.content.eventsHaveSubRows = false;
    },

    get selection() {
      return this.$.content.selection;
    },

    set selection(selection) {
      this.$.content.setSelectionWithoutErrorChecks(selection);
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-instant-event-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    set selection(selection) {
      this.$.content.textContent = '';
      var realView = document.createElement('tr-ui-a-single-event-sub-view');
      realView.setSelectionWithoutErrorChecks(selection);

      this.$.content.appendChild(realView);

      this.currentSelection_ = selection;
    },

    get selection() {
      return this.currentSelection_;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-instant-event-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    set selection(selection) {
      this.$.content.textContent = '';
      var realView = document.createElement('tr-ui-a-multi-event-sub-view');
      realView.eventsHaveDuration = false;
      realView.eventsHaveSubRows = false;

      this.$.content.appendChild(realView);
      realView.setSelectionWithoutErrorChecks(selection);

      this.currentSelection_ = selection;
    },

    get selection() {
      return this.currentSelection_;
    }
  });
  

'use strict';
(function() {
  var COUNTER_SAMPLE_TABLE_COLUMNS = [
    {
      title: 'Counter',
      width: '150px',
      value: function(row) { return row.counter; }
    },
    {
      title: 'Series',
      width: '150px',
      value: function(row) { return row.series; }
    },
    {
      title: 'Time',
      width: '150px',
      value: function(row) { return row.start; }
    },
    {
      title: 'Value',
      width: '100%',
      value: function(row) { return row.value; }
    }
  ];

  Polymer('tr-ui-a-counter-sample-sub-view', {
    ready: function() {
      this.currentSelection_ = undefined;
      this.$.table.tableColumns = COUNTER_SAMPLE_TABLE_COLUMNS;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.currentSelection_ = selection;
      this.updateContents_();
    },

    updateContents_: function() {
      this.$.table.tableRows =
          this.selection ? this.getRows_(this.selection.toArray()) : [];
      this.$.table.rebuild();
    },

    /**
     * Returns the table rows for the specified samples.
     *
     * We print each counter/series combination the first time that it
     * appears. For subsequent samples in each series, we omit the counter
     * and series name. This makes it easy to scan to find the next series.
     *
     * Each series can be collapsed. In the expanded state, all samples
     * are shown. In the collapsed state, only the first sample is displayed.
     */
    getRows_: function(samples) {
      var samplesByCounter = tr.b.group(samples, function(sample) {
        return sample.series.counter.guid;
      });

      var rows = [];
      tr.b.iterItems(samplesByCounter, function(unused, counterSamples) {
        var samplesBySeries = tr.b.group(counterSamples, function(sample) {
          return sample.series.guid;
        });

        tr.b.iterItems(samplesBySeries, function(unused, seriesSamples) {
          var seriesRows = this.getRowsForSamples_(seriesSamples);
          seriesRows[0].counter = seriesSamples[0].series.counter.name;
          seriesRows[0].series = seriesSamples[0].series.name;

          if (seriesRows.length > 1) {
            seriesRows[0].subRows = seriesRows.slice(1);
            seriesRows[0].isExpanded = true;
          }

          rows.push(seriesRows[0]);
        }, this);
      }, this);

      return rows;
    },

    getRowsForSamples_: function(samples) {
      return samples.map(function(sample) {
        return {
          start: sample.timestamp,
          value: sample.value
        };
      });
    }
  });
})();


  'use strict';

  Polymer('tr-ui-a-single-flow-event-sub-view', {
    getEventRows_: function(event) {
            var rows = this.__proto__.__proto__.getEventRows_(event);

            rows.splice(0, 0, {
        name: 'ID',
        value: event.id
      });

      function createLinkTo(slice) {
        var linkEl = document.createElement('tr-ui-a-analysis-link');
        linkEl.setSelectionAndContent(function() {
            return new tr.model.EventSet(slice);
        });
        linkEl.textContent = slice.userFriendlyName;
        return linkEl;
      }

      rows.push({
        name: 'From',
        value: createLinkTo(event.startSlice)
      });
      rows.push({
        name: 'To',
        value: createLinkTo(event.endSlice)
      });
      return rows;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-flow-event-sub-view', {
    ready: function() {
      this.$.content.eventsHaveDuration = false;
      this.$.content.eventsHaveSubRows = false;
    },

    set selection(selection) {
      this.$.content.selection = selection;
    },

    get selection() {
      return this.$.content.selection;
    }
  });
  

'use strict';

tr.exportTo('tr.ui.analysis', function() {
  var ObjectInstanceView = tr.ui.b.define('object-instance-view');

  ObjectInstanceView.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.objectInstance_ = undefined;
    },

    get requiresTallView() {
      return true;
    },

    set modelEvent(obj) {
      this.objectInstance = obj;
    },

    get modelEvent() {
      return this.objectInstance;
    },

    get objectInstance() {
      return this.objectInstance_;
    },

    set objectInstance(i) {
      this.objectInstance_ = i;
      this.updateContents();
    },

    updateContents: function() {
      throw new Error('Not implemented');
    }
  };

  var options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  options.mandatoryBaseClass = ObjectInstanceView;
  options.defaultMetadata = {
    showInTrackView: true
  };
  tr.b.decorateExtensionRegistry(ObjectInstanceView, options);

  return {
    ObjectInstanceView: ObjectInstanceView
  };
});


  'use strict';

  Polymer('tr-ui-a-single-object-instance-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    get requiresTallView() {
      if (this.$.content.children.length === 0)
        return false;
      if (this.$.content.children[0] instanceof
          tr.ui.analysis.ObjectInstanceView)
        return this.$.content.children[0].requiresTallView;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      if (selection.length !== 1)
        throw new Error('Only supports single item selections');
      if (!(selection[0] instanceof tr.model.ObjectInstance))
        throw new Error('Only supports object instances');

      this.$.content.textContent = '';
      this.currentSelection_ = selection;

      var instance = selection[0];
      var typeInfo = tr.ui.analysis.ObjectInstanceView.getTypeInfo(
          instance.category, instance.typeName);
      if (typeInfo) {
        var customView = new typeInfo.constructor();
        this.$.content.appendChild(customView);
        customView.modelEvent = instance;
      } else {
        this.appendGenericAnalysis_(instance);
      }
    },

    appendGenericAnalysis_: function(instance) {
      var html = '';
      html += '<div class="title">' +
          instance.typeName + ' ' +
          instance.id + '</div>\n';
      html += '<table>';
      html += '<tr>';
      html += '<tr><td>creationTs:</td><td>' +
          instance.creationTs + '</td></tr>\n';
      if (instance.deletionTs != Number.MAX_VALUE) {
        html += '<tr><td>deletionTs:</td><td>' +
            instance.deletionTs + '</td></tr>\n';
      } else {
        html += '<tr><td>deletionTs:</td><td>not deleted</td></tr>\n';
      }
      html += '<tr><td>snapshots:</td><td id="snapshots"></td></tr>\n';
      html += '</table>';
      this.$.content.innerHTML = html;
      var snapshotsEl = this.$.content.querySelector('#snapshots');
      instance.snapshots.forEach(function(snapshot) {
        var snapshotLink = document.createElement('tr-ui-a-analysis-link');
        snapshotLink.selection = new tr.model.EventSet(snapshot);
        snapshotsEl.appendChild(snapshotLink);
      });
    }
  });
  

'use strict';

tr.exportTo('tr.ui.analysis', function() {
  var ObjectSnapshotView = tr.ui.b.define('object-snapshot-view');

  ObjectSnapshotView.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.objectSnapshot_ = undefined;
    },

    get requiresTallView() {
      return true;
    },

    set modelEvent(obj) {
      this.objectSnapshot = obj;
    },

    get modelEvent() {
      return this.objectSnapshot;
    },

    get objectSnapshot() {
      return this.objectSnapshot_;
    },

    set objectSnapshot(i) {
      this.objectSnapshot_ = i;
      this.updateContents();
    },

    updateContents: function() {
      throw new Error('Not implemented');
    }
  };

  var options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  options.mandatoryBaseClass = ObjectSnapshotView;
  options.defaultMetadata = {
    showInstances: true,
    showInTrackView: true
  };
  tr.b.decorateExtensionRegistry(ObjectSnapshotView, options);

  return {
    ObjectSnapshotView: ObjectSnapshotView
  };
});


  'use strict';

  Polymer('tr-ui-a-single-object-snapshot-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    get requiresTallView() {
      if (this.children.length === 0)
        return false;
      if (this.children[0] instanceof tr.ui.analysis.ObjectSnapshotView)
        return this.children[0].requiresTallView;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      if (selection.length !== 1)
        throw new Error('Only supports single item selections');
      if (!(selection[0] instanceof tr.model.ObjectSnapshot))
        throw new Error('Only supports object instances');

      this.textContent = '';
      this.currentSelection_ = selection;

      var snapshot = selection[0];

      var typeInfo = tr.ui.analysis.ObjectSnapshotView.getTypeInfo(
          snapshot.objectInstance.category, snapshot.objectInstance.typeName);
      if (typeInfo) {
        var customView = new typeInfo.constructor();
        this.appendChild(customView);
        customView.modelEvent = snapshot;
      } else {
        this.appendGenericAnalysis_(snapshot);
      }
    },

    appendGenericAnalysis_: function(snapshot) {
      var instance = snapshot.objectInstance;

      this.textContent = '';

      var titleEl = document.createElement('div');
      titleEl.classList.add('title');
      titleEl.appendChild(document.createTextNode('Snapshot of '));
      this.appendChild(titleEl);

      var instanceLinkEl = document.createElement('tr-ui-a-analysis-link');
      instanceLinkEl.selection = new tr.model.EventSet(instance);
      titleEl.appendChild(instanceLinkEl);

      titleEl.appendChild(document.createTextNode(' @ '));

      titleEl.appendChild(tr.ui.units.createTimeStampSpan(
          snapshot.ts, {ownerDocument: this.ownerDocument}));

      var tableEl = document.createElement('table');
      this.appendChild(tableEl);

      var rowEl = document.createElement('tr');
      tableEl.appendChild(rowEl);

      var labelEl = document.createElement('td');
      labelEl.textContent = 'args:';
      rowEl.appendChild(labelEl);

      var argsEl = document.createElement('td');
      argsEl.id = 'args';
      rowEl.appendChild(argsEl);

      var objectViewEl = document.createElement('tr-ui-a-generic-object-view');
      objectViewEl.object = snapshot.args;
      argsEl.appendChild(objectViewEl);
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-object-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    ready: function() {
      this.$.content.showHeader = false;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.currentSelection_ = selection;

      var objectEvents = tr.b.asArray(selection).sort(
          tr.b.Range.compareByMinTimes);

      var timeSpanConfig = {ownerDocument: this.ownerDocument};
      var table = this.$.content;
      table.tableColumns = [
        {
          title: 'First',
          value: function(event) {
            if (event instanceof tr.model.ObjectSnapshot)
              return tr.ui.units.createTimeStampSpan(event.ts, timeSpanConfig);

            var spanEl = document.createElement('span');
            spanEl.appendChild(tr.ui.units.createTimeStampSpan(
                event.creationTs, timeSpanConfig));
            spanEl.appendChild(tr.ui.b.createSpan({
                textContent: '-',
                marginLeft: '4px',
                marginRight: '4px'
            }));
            if (event.deletionTs != Number.MAX_VALUE) {
              spanEl.appendChild(tr.ui.units.createTimeStampSpan(
                  event.deletionTs, timeSpanConfig));
            }
            return spanEl;
          },
          width: '200px'
        },
        {
          title: 'Second',
          value: function(event) {
            var linkEl = document.createElement('tr-ui-a-analysis-link');
            linkEl.setSelectionAndContent(function() {
                return new tr.model.EventSet(event);
            }, event.userFriendlyName);
            return linkEl;
          },
          width: '100%'
        }
      ];
      table.tableRows = objectEvents;
      table.rebuild();
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-sample-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    ready: function() {
      this.$.content.tableColumns = [
        {
          title: 'FirstColumn',
          value: function(row) { return row.title; },
          width: '250px'
        },
        {
          title: 'SecondColumn',
          value: function(row) { return row.value; },
          width: '100%'
        }
      ];
      this.$.content.showHeader = false;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.currentSelection_ = selection;

      if (this.currentSelection_ === undefined) {
        this.$.content.tableRows = [];
        return;
      }

      var sample = this.currentSelection_[0];
      var table = this.$.content;

      var rows = [];

      rows.push({
        title: 'Title',
        value: sample.title
      });

      rows.push({
          title: 'Sample time',
          value: tr.ui.units.createTimeStampSpan(
              sample.start, {ownerDocument: this.ownerDocument})
      });

      var sfEl = document.createElement('tr-ui-a-stack-frame');
      sfEl.stackFrame = sample.leafStackFrame;
      rows.push({
        title: 'Stack trace',
        value: sfEl
      });
      table.tableRows = rows;
      table.rebuild();
    }
  });
  

  'use strict';

  (function() {
    var SamplingTreeNode = function(frame) {
      this.parent = undefined;
      this.children = [];
      this.childFrameMap = {};
      this.frame = frame;
      this.accumulatedSamplesCount = 0;
    };

    SamplingTreeNode.prototype = {
      getOrCreateChild: function(frame) {
        if (this.childFrameMap[frame.title] !== undefined)
          return this.childFrameMap[frame.title];

        var node = new SamplingTreeNode(frame);
        node.parent = this;

        this.childFrameMap[frame.title] = node;
        this.children.push(node);

        return node;
      },

      get subRows() {
        return this.children;
      },

      get samplesCount() {
        return this.accumulatedSamplesCount;
      },

      get name() {
        return this.frame.title;
      },

      get category() {
        return this.frame !== undefined ? this.frame.category : 'root';
      }
    };

    Polymer('tr-ui-a-sampling-panel', {
      ready: function() {
        this.selection_ = undefined;
      },

      get selection() {
        return this.selection_;
      },

      set selection(selection) {
        this.selection_ = selection;
        this.samplingData_ = this.createSamplingSummary_(selection);
        this.updateContents_();
      },

      createSamplingSummary_: function(selection) {
        var root = new SamplingTreeNode();
        var samples = selection.getEventsOrganizedByBaseType().sample;

        function addSample(sample) {
          var stack = sample.stackTrace;

                              stack.reverse();

          var currentNode = root;
          for (var i = 0; i < stack.length; i++) {
            var frame = stack[i];
            currentNode.accumulatedSamplesCount++;
            currentNode = currentNode.getOrCreateChild(frame);
          }
          currentNode.accumulatedSamplesCount++;
        }

        for (var i = 0; i < samples.length; i++) {
          addSample(samples[i]);
        }

        return root;
      },

      updateContents_: function() {
        var columns = [
        {
          title: 'Percent',
          value: function(row) {
            var percent = row.samplesCount / this.samplingData_.samplesCount;

            var span = document.createElement('tr-ui-u-scalar-span');
            span.value = (percent * 100).toFixed(2);
            span.percentage = percent;
            span.unit = tr.b.u.Units.unitlessNumber;
            return span;

          }.bind(this),
          width: '60px',
          cmp: function(a, b) {
            return a.samplesCount - b.samplesCount;
          }
        },
        {
          title: 'Samples',
          value: function(row) { return row.samplesCount; },
          width: '60px',
          cmp: function(a, b) {
            return a.samplesCount - b.samplesCount;
          }
        },
        {
          title: 'Symbol',
          value: function(row) { return row.name; },
          width: '250px',
          cmp: function(a, b) {
            return a.name.toString().localeCompare(b.name.toString());
          },
          showExpandButtons: true
        }];

        this.$.table.tableColumns = columns;
        this.$.table.sortColumnIndex = 1;
        this.$.table.sortDescending = true;
        this.$.table.tableRows = this.samplingData_.subRows;
        this.$.table.rebuild();
      }
    });
  })();
  

  'use strict';

  Polymer('tr-ui-a-multi-sample-sub-view', {
    set selection(selection) {
      this.$.panel.selection = selection;
    },

    get selection() {
      return this.$.panel.selection;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-interaction-record-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.textContent = '';
      var realView = document.createElement('tr-ui-a-single-event-sub-view');

      this.appendChild(realView);
      realView.setSelectionWithoutErrorChecks(selection);

      this.currentSelection_ = selection;
    },

    get relatedEventsToHighlight() {
      if (!this.currentSelection_)
        return undefined;
      return this.currentSelection_[0].associatedEvents;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-interaction-record-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    set selection(selection) {
      this.currentSelection_ = selection;
      this.textContent = '';
      var realView = document.createElement('tr-ui-a-multi-event-sub-view');

      this.appendChild(realView);
      realView.setSelectionWithoutErrorChecks(selection);

      this.currentSelection_ = selection;
    },

    get selection() {
      return this.currentSelection_;
    },

    get relatedEventsToHighlight() {
      if (!this.currentSelection_)
        return undefined;
      var selection = new tr.model.EventSet();
      this.currentSelection_.forEach(function(ir) {
        ir.associatedEvents.forEach(function(event) {
          selection.push(event);
        });
      });
      return selection;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-alert-sub-view', {
    ready: function() {
      this.currentSelection_ = undefined;
      this.$.table.tableColumns = [
        {
          title: 'Label',
          value: function(row) { return row.name; },
          width: '150px'
        },
        {
          title: 'Value',
          width: '100%',
          value: function(row) { return row.value; }
        }
      ];
      this.$.table.showHeader = false;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.currentSelection_ = selection;
      this.updateContents_();
    },

    getRowsForSingleAlert_: function(alert) {
      var rows = [];

            for (var argName in alert.args) {
        var argView =
            document.createElement('tr-ui-a-generic-object-view');
        argView.object = alert.args[argName];
        rows.push({ name: argName, value: argView });
      }

            if (alert.associatedEvents.length) {
        alert.associatedEvents.forEach(function(event, i) {
          var linkEl = document.createElement('tr-ui-a-analysis-link');
          linkEl.setSelectionAndContent(function() {
            return event;
          }, event.title);

          var valueString = '';
          if (event instanceof tr.model.TimedEvent)
            valueString = 'took ' + event.duration.toFixed(2) + 'ms';

          rows.push({
            name: linkEl,
            value: valueString
          });
        });
      }

            var descriptionEl = tr.ui.b.createDiv({
          textContent: alert.info.description,
          maxWidth: '300px'
      });
      rows.push({
        name: 'Description',
        value: descriptionEl
      });

            if (alert.info.docLinks) {
        alert.info.docLinks.forEach(function(linkObject) {
          var linkEl = document.createElement('a');
          linkEl.target = '_blank';
          linkEl.href = linkObject.href;
          linkEl.textContent = linkObject.textContent;
          rows.push({
            name: linkObject.label,
            value: linkEl
          });
        });
      }
      return rows;
    },

    getRowsForAlerts_: function(alerts) {
      if (alerts.length == 1) {
        var rows = [{
          name: 'Alert',
          value: alerts[0].title
        }];
        var detailRows = this.getRowsForSingleAlert_(alerts[0]);
        rows.push.apply(rows, detailRows);
        return rows;
      } else {
        return alerts.map(function(alert) {
          return {
            name: 'Alert',
            value: alert.title,
            isExpanded: alerts.size < 10,             subRows: this.getRowsForSingleAlert_(alert)
          };
        }, this);
      }
    },

    updateContents_: function() {
      if (this.currentSelection_ === undefined) {
        this.$.table.rows = [];
        this.$.table.rebuild();
        return;
      }

      var alerts = this.currentSelection_;
      this.$.table.tableRows = this.getRowsForAlerts_(alerts);
      this.$.table.rebuild();
    },

    get relatedEventsToHighlight() {
      if (!this.currentSelection_)
        return undefined;
      return this.currentSelection_[0].associatedEvents;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-frame-sub-view', {
    ready: function() {
      this.currentSelection_ = undefined;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      if (selection.length != 1)
        throw new Error('Only supports single frame!');
      this.currentSelection_ = selection;
      this.$.asv.selection = selection[0].associatedAlerts;
    },

    get relatedEventsToHighlight() {
      if (!this.currentSelection_)
        return undefined;
      return this.currentSelection_[0].associatedEvents;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-frame-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    set selection(selection) {
      this.textContent = '';
      var realView = document.createElement('tr-ui-a-multi-event-sub-view');
      realView.eventsHaveDuration = false;
      realView.eventsHaveSubRows = false;

      this.appendChild(realView);
      realView.setSelectionWithoutErrorChecks(selection);

      this.currentSelection_ = selection;
    },

    get selection() {
      return this.currentSelection_;
    },

    get relatedEventsToHighlight() {
      if (!this.currentSelection_)
        return undefined;
      var selection = new tr.model.EventSet();
      this.currentSelection_.forEach(function(frameEvent) {
        frameEvent.associatedEvents.forEach(function(event) {
          selection.push(event);
        });
      });
      return selection;
    }
  });
  

  'use strict';

  Polymer('tr-ui-b-color-legend', {
    ready: function() {
      var blackSquareCharCode = 9632;
      this.$.square.innerText = String.fromCharCode(blackSquareCharCode);
      this.label_ = undefined;

      this.compoundEventSelectionState_ =
          tr.model.CompoundEventSelectionState.NOT_SELECTED;
    },

    set compoundEventSelectionState(compoundEventSelectionState) {
      this.compoundEventSelectionState_ = compoundEventSelectionState;
          },

    get label() {
      return this.label_;
    },

    set label(label) {
      if (label === undefined) {
        this.setLabelAndColorId(undefined, undefined);
        return;
      }

      var colorId = tr.ui.b.getColorIdForGeneralPurposeString(label);
      this.setLabelAndColorId(label, colorId);
    },

    setLabelAndColorId: function(label, colorId) {
      this.label_ = label;

      this.$.label.textContent = '';
      this.$.label.appendChild(tr.ui.b.asHTMLOrTextNode(label));

      if (colorId === undefined) {
        this.$.square.style.color = 'initial';
      } else {
        var paletteRaw = tr.ui.b.getRawColorPalette();
        var color = tr.ui.b.colorToRGBString(paletteRaw[colorId]);
        this.$.square.style.color = color;
      }
    }
  });
  

'use strict';

/**
 * @fileoverview Helper code for memory dump sub-views.
 */
tr.exportTo('tr.ui.analysis', function() {

  /**
   * A table builder column for displaying memory dump data.
   *
   * @constructor
   */
  function MemoryColumn(name, title, units, cellGetter) {
    this.name = name;
    this.title = title;
    this.units = units;
    this.cell = cellGetter;

    // Color of the values returned by this column. This can be either
    // (1) undefined (no specific color is set), (2) a color string (e.g.
    // 'blue'), or (3) a function mapping defined attributes to color strings
    // (the return value can be undefined again).
    this.color = undefined;
  }

  MemoryColumn.fromRows = function(rows, cellKey, opt_titleBuilder) {
    var columnTraits = {};

    function gatherTraits(row) {
      if (row === undefined)
        return;
      var attrCells = row[cellKey];
      tr.b.iterItems(attrCells, function(attrName, attrCell) {
        if (attrCell === undefined)
          return;
        var attrValue = attrCell.attr;
        if (attrValue === undefined)
          return;
        var existingTraits = columnTraits[attrName];
        if (existingTraits === undefined) {
          columnTraits[attrName] = {
            constructor: attrValue.constructor,
            units: attrValue.units
          };
          return;
        }
        if (existingTraits.constructor !== attrValue.constructor ||
            existingTraits.units !== attrValue.units) {
          existingTraits.constructor = tr.model.UnknownAttribute;
          existingTraits.units = undefined;
        }
      });
      if (row.subRows !== undefined)
        row.subRows.forEach(gatherTraits);
    };
    rows.forEach(gatherTraits);

    var titleBuilder = opt_titleBuilder || tr.b.identity;

    var columns = [];
    tr.b.iterItems(columnTraits, function(columnName, columnTraits) {
      var cellGetter = fieldGetter(cellKey, columnName);
      var title = titleBuilder(columnName);
      columns.push(MemoryColumn.fromAttributeTraits(
          columnName, title, columnTraits, cellGetter));
    });

    return columns;
  };

  MemoryColumn.fromAttributeTraits = function(name, title, traits, cellGetter) {
    var constructor;
    if (traits.constructor === tr.model.ScalarAttribute)
      constructor = ScalarMemoryColumn;
    else
      constructor = MemoryColumn;
    return new constructor(name, title, traits.units, cellGetter);
  };

  MemoryColumn.spaceEqually = function(columns) {
    var columnWidth = (100 / columns.length).toFixed(3) + '%';
    columns.forEach(function(column) {
      column.width = columnWidth;
    });
  };

  /**
   * Sort a list of memory columns according to a list of importance rules.
   * This function modifies the original array and doesn't return anything.
   *
   * The list of importance rules contains objects with mandatory 'importance'
   * numeric fields and optional 'condition' string or regex fields. Example:
   *
   *   var importanceRules = [
   *     {
   *       condition: 'page_size',
   *       importance: 8
   *     },
   *     {
   *       condition: /size/,
   *       importance: 10
   *     },
   *     {
   *       // No condition: matches all columns.
   *       importance: 9
   *     }
   *   ];
   *
   * The importance of a column is determined by the first rule whose condition
   * matches the column's name, so the rules above will sort a generic list of
   * columns into three groups as follows:
   *
   *      [most important, left in the resulting table]
   *   1. columns whose name contains 'size' excluding 'page_size' because it
   *      would have already matched the first rule (Note that string matches
   *      must be exact so a column named 'page_size2' would not match the
   *      first rule and would therefore belong to this group).
   *   2. columns whose name does not contain 'size'.
   *   3. columns whose name is 'page_size'.
   *      [least important, right in the resulting table]
   *
   * where columns are sorted alphabetically within each group.
   */
  MemoryColumn.sortByImportance = function(columns, importanceRules) {
    var positions = columns.map(function(column, srcIndex) {
      return {
        importance: column.getImportance(importanceRules),
        column: column
      };
    });

    positions.sort(function(a, b) {
      // Sort columns with the same importance alphabetically.
      if (a.importance === b.importance)
        return a.column.name.localeCompare(b.column.name);

      // Sort columns in descending order of importance.
      return b.importance - a.importance;
    });

    positions.forEach(function(position, dstIndex) {
      columns[dstIndex] = position.column;
    });
  };

  MemoryColumn.iconFromAttributeInfoType = function(type) {
    switch (type) {
      case tr.model.AttributeInfoType.WARNING:
        return {
          symbol: String.fromCharCode(9888),  // Exclamation mark in a triangle.
          color: 'red'
        };
      case tr.model.AttributeInfoType.LINK:
        return {
          symbol: String.fromCharCode(9903)  // Link symbol.
          /* Don't modify the color. */
        };
      case tr.model.AttributeInfoType.MEMORY_OWNER:
        return {
          symbol: String.fromCharCode(8702),  // Right arrow.
          color: 'green'
        };
      case tr.model.AttributeInfoType.MEMORY_OWNED:
        return {
          symbol: String.fromCharCode(8701),  // Left arrow.
          color: 'green'
        };
      case tr.model.AttributeInfoType.OVERALL_VALUE:
        return {
          symbol: String.fromCharCode(8614)  // Right arrow with a bar.
          /* Don't modify the color. */
        };
      case tr.model.AttributeInfoType.RECENT_VALUE:
        return {
          symbol: String.fromCharCode(8618)  // Right arrow with a hook.
          /* Don't modify the color. */
        };
      default:
        return {
          symbol: String.fromCharCode(9432),  // Circled small letter 'i'.
          color: 'blue'
        };
    }
    throw new Error('Unreachable');
  };

  MemoryColumn.prototype = {
    attr: function(row) {
      var cell = this.cell(row);
      if (cell === undefined)
        return undefined;
      return cell.attr;
    },

    value: function(row) {
      var attr = this.attr(row);
      if (attr === undefined)
        return '';
      return this.formatDefinedAttribute(attr);
    },

    /**
     * Format a defined attribute (both values and infos). This method is not
     * intended to be overriden.
     */
    formatDefinedAttribute: function(attr) {
      var formattedValue = this.formatDefinedAttributeValue(attr);

      // Determine the color of the resulting element.
      var color;
      if (typeof this.color === 'function')
        color = this.color(attr);
      else
        color = this.color;

      // If no color is specified and there are no infos, there is no need
      // to wrap the value in a span element.
      if (color === undefined && attr.infos.length === 0)
        return formattedValue;

      var attrEl = document.createElement('span');
      attrEl.style.display = 'flex';
      attrEl.style.alignItems = 'center';
      attrEl.appendChild(tr.ui.b.asHTMLOrTextNode(formattedValue));

      // Add info icons with tooltips.
      attr.infos.forEach(function(info) {
        var infoEl = document.createElement('span');
        infoEl.style.paddingLeft = '4px';
        infoEl.style.cursor = 'help';
        infoEl.style.fontWeight = 'bold';
        var icon = MemoryColumn.iconFromAttributeInfoType(info.type);
        infoEl.textContent = icon.symbol;
        if (icon.color !== undefined)
          infoEl.style.color = icon.color;
        infoEl.title = info.message;
        attrEl.appendChild(infoEl);
      }, this);

      // Set the color of the element.
      if (color !== undefined)
        attrEl.style.color = color;

      return attrEl;
    },

    /**
     * Format the value of a defined attribute. This method is intended to be
     * overriden by attribute type/unit specific columns (e.g. show '1.0 KiB'
     * instead of '1024' for ScalarAttribute(s) representing bytes).
     */
    formatDefinedAttributeValue: function(attr) {
      return String(attr.value);
    },

    cmp: function(rowA, rowB) {
      var attrA = this.attr(rowA);
      var attrB = this.attr(rowB);
      if (attrA === undefined && attrB === undefined)
        return 0;
      if (attrA === undefined)
        return -1;
      if (attrB === undefined)
        return 1;
      return this.compareDefinedAttributes(attrA, attrB);
    },

    compareDefinedAttributes: function(attrA, attrB) {
      var strA = String(attrA.value);
      var strB = String(attrB.value);
      return strA.localeCompare(strB);
    },

    getImportance: function(importanceRules) {
      if (importanceRules.length === 0)
        return 0;

      // Find the first matching rule.
      for (var i = 0; i < importanceRules.length; i++) {
        var importanceRule = importanceRules[i];
        if (this.matchesNameCondition(importanceRule.condition))
          return importanceRule.importance;
      }

      // No matching rule. Return lower importance than all rules.
      var minImportance = importanceRules[0].importance;
      for (var i = 1; i < importanceRules.length; i++) {
        minImportance = Math.min(minImportance, importanceRules[i].importance);
      }
      return minImportance - 1;
    },

    matchesNameCondition: function(condition) {
      // Rules without conditions match all columns.
      if (condition === undefined)
        return true;

      // String conditions must match the column name exactly.
      if (typeof(condition) === 'string')
        return this.name === condition;

      // If the condition is not a string, assume it is a RegExp.
      return condition.test(this.name);
    }
  };

  /**
   * @constructor
   */
  function ScalarMemoryColumn(name, title, units, cellGetter) {
    MemoryColumn.call(this, name, title, units, cellGetter);
  }

  ScalarMemoryColumn.prototype = {
    __proto__: MemoryColumn.prototype,

    formatDefinedAttributeValue: function(attr) {
      if (this.units === 'bytes') {
        var sizeEl = document.createElement('tr-ui-u-scalar-span');
        sizeEl.setValueAndUnit(attr.value, tr.b.u.Units.sizeInBytes);
        return sizeEl;
      }
      return MemoryColumn.prototype.formatDefinedAttributeValue.call(
          this, attr);
    },

    compareDefinedAttributes: function(attrA, attrB) {
      return attrA.value - attrB.value;
    }
  };

  /**
   * @constructor
   */
  function MemoryCell(attr) {
    this.attr = attr;
  }

  MemoryCell.extractAttribute = function(cell) {
    if (cell === undefined)
      return undefined;
    return cell.attr;
  };

  function fieldGetter(/* fields */) {
    var fields = tr.b.asArray(arguments);
    return function(row) {
      var value = row;
      for (var i = 0; i < fields.length; i++)
        value = value[fields[i]];
      return value;
    };
  }

  /** Limit for the number of sub-rows for recursive table row expansion. */
  var RECURSIVE_EXPANSION_MAX_SUB_ROW_COUNT = 10;

  function expandTableRowsRecursively(table) {
    function expandRowRecursively(row) {
      if (row.subRows === undefined || row.subRows.length === 0)
        return;
      if (row.subRows.length > RECURSIVE_EXPANSION_MAX_SUB_ROW_COUNT)
        return;
      table.setExpandedForTableRow(row, true);
      row.subRows.forEach(expandRowRecursively);
    }
    table.tableRows.forEach(expandRowRecursively);
  }

  // TODO(petrcermak): This code is almost the same as
  // MemoryAllocatorDump.aggregateAttributes. Consider sharing code between
  // the two functions.
  function aggregateTableRowCellsRecursively(row, cellKey) {
    var subRows = row.subRows;
    if (subRows === undefined)
      return;

    subRows.forEach(function(subRow) {
      aggregateTableRowCellsRecursively(subRow, cellKey);
    });

    aggregateTableRowCells(row, subRows, cellKey);
  }

  function aggregateTableRowCells(row, subRows, cellKey) {
    var rowCells = row[cellKey];
    if (rowCells === undefined)
      row[cellKey] = rowCells = {};

    var subRowCellNames = {};
    subRows.forEach(function(subRow) {
      var subRowCells = subRow[cellKey];
      if (subRowCells === undefined)
        return;
      tr.b.iterItems(subRowCells, function(columnName) {
        subRowCellNames[columnName] = true;
      });
    });

    tr.b.iterItems(subRowCellNames, function(cellName) {
      var subRowAttributes = subRows.map(function(subRow) {
        var subRowCells = subRow[cellKey];
        if (subRowCells === undefined)
          return undefined;
        return MemoryCell.extractAttribute(subRowCells[cellName]);
      }, this);
      var existingRowCell = rowCells[cellName];
      var existingRowAttribute = MemoryCell.extractAttribute(existingRowCell);

      var aggregatedAttribute =
          tr.model.Attribute.aggregate(subRowAttributes, existingRowAttribute);

      if (existingRowCell !== undefined) {
        // The cell might contain some extra fields (e.g. custom
        // buildDetailsPane method) which we don't want to throw away.
        existingRowCell.attr = aggregatedAttribute;
      } else {
        rowCells[cellName] = new MemoryCell(aggregatedAttribute);
      }
    });
  }

  return {
    MemoryColumn: MemoryColumn,
    ScalarMemoryColumn: ScalarMemoryColumn,
    MemoryCell: MemoryCell,
    fieldGetter: fieldGetter,
    expandTableRowsRecursively: expandTableRowsRecursively,
    aggregateTableRowCellsRecursively: aggregateTableRowCellsRecursively,
    aggregateTableRowCells: aggregateTableRowCells
  };
});


  'use strict';

  Polymer('tr-ui-a-stacked-pane', {
    rebuild: function() {
      
      if (!this.paneDirty_) {
                        return;
      }

      this.paneDirty_ = false;
      this.rebuildPane_();
    },

    
    scheduleRebuildPane_: function() {
      if (this.paneDirty_)
        return;
      this.paneDirty_ = true;
      setTimeout(this.rebuild.bind(this), 0);
    },

    
    rebuildPane_: function() {
    },

    
    set childPaneBuilder(childPaneBuilder) {
      this.childPaneBuilder_ = childPaneBuilder;
      this.dispatchEvent(new tr.b.Event('request-child-pane-change'));
    },

    get childPaneBuilder() {
      return this.childPaneBuilder_;
    },

    
    appended: function() {
      this.rebuild();
    }
  });
  

  'use strict';

  (function() {
    var IMPORTANCE_RULES = [
      {
        condition: tr.model.MemoryAllocatorDump.SIZE_ATTRIBUTE_NAME,
        importance: 10
      },
      {
        condition: tr.model.MemoryAllocatorDump.EFFECTIVE_SIZE_ATTRIBUTE_NAME,
        importance: 9
      },
      {
        condition: 'page_size',
        importance: 0
      },
      {
        condition: /size/,
        importance: 5
      },
      {
        importance: 0
      }
    ];

    Polymer('tr-ui-a-memory-dump-allocator-details-pane', {
      created: function() {
        this.memoryAllocatorDump_ = undefined;
      },

      set memoryAllocatorDump(memoryAllocatorDump) {
        this.memoryAllocatorDump_ = memoryAllocatorDump;
        this.scheduleRebuildPane_();
      },

      get memoryAllocatorDump() {
        return this.memoryAllocatorDump_;
      },

      rebuildPane_: function() {
        this.$.contents.textContent = '';

        if (this.memoryAllocatorDump_ === undefined) {
          var infoText = this.ownerDocument.createElement('div');
          this.$.contents.appendChild(infoText);
          infoText.classList.add('info-text');
          infoText.innerText = 'No memory allocator dump selected';
          return;
        }

        var rows = this.createRows_();
        var columns = this.createColumns_(rows);

        var table = this.ownerDocument.createElement(
            'tr-ui-b-table');
        this.$.contents.appendChild(table);
        table.supportsSelection = true;
        table.tableRows = rows;
        table.tableColumns = columns;
        table.rebuild();
        tr.ui.analysis.expandTableRowsRecursively(table);
      },

      createRows_: function() {
        var createAllocatorRow = function(allocatorDump) {
          var cells = tr.b.mapItems(allocatorDump.attributes,
              function(attrName, attrValue) {
            return new tr.ui.analysis.MemoryCell(attrValue);
          });

          var title = allocatorDump.name;
          if (title.startsWith('__') && allocatorDump.ownedBy.length === 1) {
            var owner = allocatorDump.ownedBy[0].source;
                                    if (owner.containerMemoryDump ===
                allocatorDump.containerMemoryDump) {
              title = tr.ui.b.createSpan({
                textContent: 'suballocation by ' + owner.fullName,
                tooltip: 'Suballocation name: ' + allocatorDump.fullName,
                italic: true
              });
            }
          }

          var row = {
            title: title,
            cells: cells
          };
          if (allocatorDump.children.length > 0)
            row.subRows = allocatorDump.children.map(createAllocatorRow);
          return row;
        };
        var rows = [createAllocatorRow(this.memoryAllocatorDump_)];
        return rows;
      },

      createColumns_: function(rows) {
        var titleColumn = {
          title: 'Allocator',
          value: function(row) {
            return row.title;
          },
          width: '200px',
          cmp: function(rowA, rowB) {
            return rowA.title.localeCompare(rowB.title);
          }
        };

        var attributeColumns = tr.ui.analysis.MemoryColumn.fromRows(
            rows, 'cells');
        tr.ui.analysis.MemoryColumn.spaceEqually(attributeColumns);
        tr.ui.analysis.MemoryColumn.sortByImportance(
            attributeColumns, IMPORTANCE_RULES);

        var columns = [titleColumn].concat(attributeColumns);
        return columns;
      }
    });
  })();
  

  'use strict';

  (function() {
    
    var CLASSIFICATION_RULES = {
      name: 'Total',
      children: [
        {
          name: 'Android',
          file: /^\/dev\/ashmem(?!\/libc malloc)/,
          children: [
            {
              name: 'Java runtime',
              file: /^\/dev\/ashmem\/dalvik-/,
              children: [
                {
                  name: 'Spaces',
                  file: /\/dalvik-(alloc|main|large object|non moving|zygote) space/,                    children: [
                    {
                      name: 'Normal',
                      file: /\/dalvik-(alloc|main)/
                    },
                    {
                      name: 'Large',
                      file: /\/dalvik-large object/
                    },
                    {
                      name: 'Zygote',
                      file: /\/dalvik-zygote/
                    },
                    {
                      name: 'Non-moving',
                      file: /\/dalvik-non moving/
                    }
                  ]
                },
                {
                  name: 'Linear Alloc',
                  file: /\/dalvik-LinearAlloc/
                },
                {
                  name: 'Indirect Reference Table',
                  file: /\/dalvik-indirect.ref/
                },
                {
                  name: 'Cache',
                  file: /\/dalvik-jit-code-cache/
                },
                {
                  name: 'Accounting'
                }
              ]
            },
            {
              name: 'Cursor',
              file: /\/CursorWindow/
            },
            {
              name: 'Ashmem'
            }
          ]
        },
        {
          name: 'Native heap',
          file: /^((\[heap\])|(\[anon:)|(\/dev\/ashmem\/libc malloc)|(\[discounted tracing overhead\])|$)/          },
        {
          name: 'Stack',
          file: /^\[stack/
        },
        {
          name: 'Files',
          file: /\.((((jar)|(apk)|(ttf)|(odex)|(oat)|(arg))$)|(dex)|(so))/,
          children: [
            {
              name: 'so',
              file: /\.so/
            },
            {
              name: 'jar',
              file: /\.jar$/
            },
            {
              name: 'apk',
              file: /\.apk$/
            },
            {
              name: 'ttf',
              file: /\.ttf$/
            },
            {
              name: 'dex',
              file: /\.((dex)|(odex$))/
            },
            {
              name: 'oat',
              file: /\.oat$/
            },
            {
              name: 'art',
              file: /\.art$/
            }
          ]
        },
        {
          name: 'Devices',
          file: /(^\/dev\/)|(anon_inode:dmabuf)/,
          children: [
            {
              name: 'GPU',
              file: /\/((nv)|(mali)|(kgsl))/
            },
            {
              name: 'DMA',
              file: /anon_inode:dmabuf/
            }
          ]
        }
      ]
    };

    
    function createEmptyRow(rule) {
      var row = {
        title: rule.name,
        rule: rule,
        cells: {},
        subRows: []
      };
      if (rule.children !== undefined)
        row.subRows = rule.children.map(createEmptyRow);
      return row;
    }

    function hexString(address, is64BitAddress) {
      var hexPadding = is64BitAddress ? '0000000000000000' : '00000000';
      if (address === undefined)
        return undefined;
      return (hexPadding + address.toString(16)).substr(-hexPadding.length);
    }

    
    function classifyVMRegion(row, vmRegion, is64BitAddress) {
      var rule = row.rule;
      if (rule === undefined ||
          rule.children === undefined ||
          rule.children.length === 0) {
                var mappedFile = vmRegion.mappedFile || '';

        var cells = {};
        function addCellIfValueDefined(columnName, attrClass, units, value) {
          if (value === undefined)
            return;
          var attr = new attrClass(units, value);
          var cell = new tr.ui.analysis.MemoryCell(attr);
          cells[columnName] = cell;
        }
        function addBytesCellIfValueDefined(columnName, value) {
          addCellIfValueDefined(columnName,
              tr.model.ScalarAttribute, 'bytes', value);
        }
        addCellIfValueDefined('Start address',
            tr.model.StringAttribute, '',
            hexString(vmRegion.startAddress, is64BitAddress));
        addBytesCellIfValueDefined('Virtual size', vmRegion.sizeInBytes);
        addCellIfValueDefined('Protection flags',
            tr.model.StringAttribute, '',
            vmRegion.protectionFlagsToString);
        addBytesCellIfValueDefined('PSS',
            vmRegion.byteStats.proportionalResident);
        addBytesCellIfValueDefined('Private dirty',
            vmRegion.byteStats.privateDirtyResident);
        addBytesCellIfValueDefined('Private clean',
            vmRegion.byteStats.privateCleanResident);
        addBytesCellIfValueDefined('Shared dirty',
            vmRegion.byteStats.sharedDirtyResident);
        addBytesCellIfValueDefined('Shared clean',
            vmRegion.byteStats.sharedCleanResident);
        addBytesCellIfValueDefined('Swapped',
            vmRegion.byteStats.swapped);

        row.subRows.push({title: mappedFile, cells: cells});
        return;
      }

            function vmRegionMatchesChildRule(childRule) {
        var fileRegExp = childRule.file;
        if (fileRegExp === undefined)
          return true;
        return fileRegExp.test(vmRegion.mappedFile);
      }

      var matchedChildRuleIndex = tr.b.findFirstIndexInArray(
          rule.children, vmRegionMatchesChildRule);
      if (matchedChildRuleIndex === -1) {
                matchedChildRuleIndex = rule.children.length;
        if (matchedChildRuleIndex >= row.subRows.length) {
          row.subRows.push({
            title: 'Other',
            cells: {},
            subRows: []
          });
        }
      }

      classifyVMRegion(
          row.subRows[matchedChildRuleIndex], vmRegion, is64BitAddress);
    }

    Polymer('tr-ui-a-memory-dump-vm-regions-details-pane', {
      created: function() {
        this.vmRegions_ = undefined;
      },

      set vmRegions(vmRegions) {
        this.vmRegions_ = vmRegions;
        this.scheduleRebuildPane_();
      },

      get vmRegions() {
        return this.vmRegions_;
      },

      rebuildPane_: function() {
        this.$.contents.textContent = '';

        if (this.vmRegions_ === undefined) {
          var infoText = this.ownerDocument.createElement('div');
          this.$.contents.appendChild(infoText);
          infoText.classList.add('info-text');
          infoText.innerText = 'No memory maps selected';
          return;
        }

        var rows = this.createRows_();
        var columns = this.createColumns_(rows);

        var table = this.ownerDocument.createElement(
            'tr-ui-b-table');
        this.$.contents.appendChild(table);
        table.supportsSelection = true;
        table.tableRows = rows;
        table.tableColumns = columns;

                        table.rebuild();

        tr.ui.analysis.expandTableRowsRecursively(table);
      },

      createRows_: function() {
                var is64BitAddress = this.vmRegions_.some(function(vmRegion) {
          if (vmRegion.startAddress === undefined)
            return;
          return vmRegion.startAddress >= 4294967296 ;
        });

                var rootRow = createEmptyRow(CLASSIFICATION_RULES);

                this.vmRegions_.map(function(vmRegion) {
          classifyVMRegion(rootRow, vmRegion, is64BitAddress);
        });

                tr.ui.analysis.aggregateTableRowCellsRecursively(rootRow, 'cells');

        return [rootRow];
      },

      createColumns_: function(rows) {
        var titleColumn = {
          title: 'Mapped file',
          value: function(row) {
            return row.title;
          },
          width: '200px',
          cmp: function(rowA, rowB) {
            return rowA.title.localeCompare(rowB.title);
          }
        };

        var attributeColumns = tr.ui.analysis.MemoryColumn.fromRows(
            rows, 'cells');
        tr.ui.analysis.MemoryColumn.spaceEqually(attributeColumns);

        var columns = [titleColumn].concat(attributeColumns);
        return columns;
      }
    });
  })();
  

  'use strict';

  Polymer('tr-ui-b-view-specific-brushing-state', {
    
    get viewId() {
      return this.getAttribute('view-id');
    },

    set viewId(viewId) {
      this.setAttribute('view-id', viewId);
    },

    
    get: function() {
      var viewId = this.viewId;
      if (!viewId)
        throw new Error('Element must have a view-id attribute!');

      var brushingStateController =
          tr.c.BrushingStateController.getControllerForElement(this);
      if (!brushingStateController)
        return undefined;

      return brushingStateController.getViewSpecificBrushingState(viewId);
    },

    
    set: function(state) {
      var viewId = this.viewId;
      if (!viewId)
        throw new Error('Element must have a view-id attribute!');

      var brushingStateController =
          tr.c.BrushingStateController.getControllerForElement(this);
      if (!brushingStateController)
        return;

      brushingStateController.changeViewSpecificBrushingState(viewId, state);
    }
  });
  

  'use strict';

  (function() {
    var IMPORTANCE_RULES = [
      {
        condition: 'tracing',
        importance: 0
      },
      {
        importance: 1
      }
    ];

    var DISPLAYED_SIZE_ATTRIBUTE_NAME =
        tr.model.MemoryAllocatorDump.DISPLAYED_SIZE_ATTRIBUTE_NAME;

    var LINK_SYMBOL = String.fromCharCode(9903);
    var GREATER_THAN_OR_EQUAL_TO_SYMBOL = String.fromCharCode(8805);

    Polymer('tr-ui-a-memory-dump-overview-pane', {
      created: function() {
        this.processMemoryDumps_ = undefined;
      },

      ready: function() {
        this.$.table.supportsSelection = true;
        this.$.table.cellSelectionMode = true;
        this.$.table.rowHighlightEnabled = true;
        this.$.table.addEventListener('selection-changed',
            function(tableEvent) {
          tableEvent.stopPropagation();
          this.changeChildPane_();
        }.bind(this));
      },

      set processMemoryDumps(processMemoryDumps) {
        this.processMemoryDumps_ = processMemoryDumps;
        this.scheduleRebuildPane_();
      },

      get processMemoryDumps() {
        return this.processMemoryDumps_;
      },

      get selectedMemoryCell() {
        var selectedTableRow = this.$.table.selectedTableRow;
        if (!selectedTableRow)
          return undefined;

        var selectedColumnIndex = this.$.table.selectedColumnIndex;
        if (selectedColumnIndex === undefined)
          return undefined;

        var selectedColumn = this.$.table.tableColumns[selectedColumnIndex];
        var selectedMemoryCell = selectedColumn.cell(selectedTableRow);
        return selectedMemoryCell;
      },

      changeChildPane_: function() {
        this.storeSelection_();
        var builder = undefined;
        if (this.selectedMemoryCell !== undefined)
          builder = this.selectedMemoryCell.buildDetailsPane;
        this.childPaneBuilder = builder;
      },

      rebuildPane_: function() {
        var processMemoryDumps = this.processMemoryDumps_ || [];

        var rows = processMemoryDumps.map(function(processMemoryDump) {
          function buildVMRegionsPane() {
            var pane = document.createElement(
                    'tr-ui-a-memory-dump-vm-regions-details-pane');
            pane.vmRegions = processMemoryDump.mostRecentVmRegions;
            return pane;
          }

                    var usedMemorySizes = {};
          var totals = processMemoryDump.totals;
          if (totals !== undefined) {
            var totalResident = totals.residentBytes;
            if (totalResident !== undefined) {
              var cell = new tr.ui.analysis.MemoryCell(
                  new tr.model.ScalarAttribute('bytes', totalResident));
              cell.buildDetailsPane = buildVMRegionsPane;
              usedMemorySizes['Total resident'] = cell;
            }

            var peakTotalResident = totals.peakResidentBytes;
            if (peakTotalResident !== undefined) {
              var attr = new tr.model.ScalarAttribute(
                  'bytes', peakTotalResident);
              if (totals.arePeakResidentBytesResettable) {
                attr.infos.push(new tr.model.AttributeInfo(
                    tr.model.AttributeInfoType.RECENT_VALUE,
                    'Peak RSS since previous memory dump.'));
              } else {
                attr.infos.push(new tr.model.AttributeInfo(
                    tr.model.AttributeInfoType.OVERALL_VALUE,
                    'Peak RSS since process startup. Finer grained peaks ' +
                    'require a Linux kernel version ' +
                    GREATER_THAN_OR_EQUAL_TO_SYMBOL + ' 4.0.'));
              }
              var cell = new tr.ui.analysis.MemoryCell(attr);
              cell.buildDetailsPane = buildVMRegionsPane;
              usedMemorySizes['Peak total resident'] = cell;
            }
          }

          function addByteStatCell(byteStatName, columnTitle) {
            var byteStat =
                processMemoryDump.getMostRecentTotalVmRegionStat(byteStatName);
            if (byteStat !== undefined) {
              var attr = new tr.model.ScalarAttribute('bytes', byteStat);
              if (!processMemoryDump.hasOwnVmRegions) {
                attr.infos.push(new tr.model.AttributeInfo(
                    tr.model.AttributeInfoType.LINK,
                     'Older value (process did not dump memory maps).'));
                attr.isOlderValue = true;
              }
              var cell = new tr.ui.analysis.MemoryCell(attr);
              cell.buildDetailsPane = buildVMRegionsPane;
              usedMemorySizes[columnTitle] = cell;
            }
          }
          addByteStatCell('proportionalResident', 'PSS');
          addByteStatCell('privateDirtyResident', 'Private dirty');
          addByteStatCell('swapped', 'Swapped');

                    var allocatorSizes = {};
          if (processMemoryDump.memoryAllocatorDumps !== undefined) {
            processMemoryDump.memoryAllocatorDumps.forEach(function(dump) {
              var attr = dump.attributes[DISPLAYED_SIZE_ATTRIBUTE_NAME];
              var cell = new tr.ui.analysis.MemoryCell(attr);
              cell.buildDetailsPane = function() {
                var pane = document.createElement(
                    'tr-ui-a-memory-dump-allocator-details-pane');
                pane.memoryAllocatorDump = dump;
                return pane;
              };
              allocatorSizes[dump.fullName] = cell;
            }, this);
          }

          return {
            title: processMemoryDump.process.userFriendlyName,
            usedMemorySizes: usedMemorySizes,
            allocatorSizes: allocatorSizes
          };
        }, this);
        this.$.table.tableRows = rows;

                if (rows.length > 1) {
          var totalRow = {
            title: 'Total',
            noLegend: true
          };
          tr.ui.analysis.aggregateTableRowCells(
              totalRow, rows, 'usedMemorySizes');
          tr.ui.analysis.aggregateTableRowCells(
              totalRow, rows, 'allocatorSizes');
          this.$.table.footerRows = [totalRow];
        }

        this.updateColumns_(rows);

        this.$.table.rebuild();

        this.restoreSelection_();
      },

      updateColumns_: function(rows) {
        var titleColumn = {
          title: 'Process',
          value: function(row) {
            if (row.noLegend)
              return row.title;
            var titleEl = document.createElement('tr-ui-b-color-legend');
            titleEl.label = row.title;
            return titleEl;
          },
          width: '200px',
          cmp: function(rowA, rowB) {
            return rowA.title.localeCompare(rowB.title);
          },
          supportsCellSelection: false
        };

        var usedMemorySizeColumns = tr.ui.analysis.MemoryColumn.fromRows(
            rows, 'usedMemorySizes');
        var allocatorSizeColumns = tr.ui.analysis.MemoryColumn.fromRows(
            rows, 'allocatorSizes', function(allocatorName) {
          var titleEl = document.createElement('tr-ui-b-color-legend');
          titleEl.label = allocatorName;
          return titleEl;
        });
        tr.ui.analysis.MemoryColumn.sortByImportance(
            allocatorSizeColumns, IMPORTANCE_RULES);

                        var tracingColumn = tr.b.findFirstInArray(allocatorSizeColumns,
            function(column) {
          return column.name === 'tracing';
        });
        if (tracingColumn !== undefined) {
          var tracingColumnColor = tr.ui.b.getColorPalette()[
              tr.ui.b.getColorIdForReservedName('tracing_memory_column')];
          tracingColumn.title = tr.ui.b.createSpan(
              {textContent: 'tracing', color: tracingColumnColor});
          tracingColumn.color = tracingColumnColor;
        }

                        usedMemorySizeColumns.forEach(function(column) {
          var olderUsedMemoryColumnColor = tr.ui.b.getColorPalette()[
              tr.ui.b.getColorIdForReservedName('older_used_memory_column')];
          var usedMemoryColumnColor = tr.ui.b.getColorPalette()[
              tr.ui.b.getColorIdForReservedName('used_memory_column')];
          column.title = tr.ui.b.createSpan(
              {textContent: column.title, color: usedMemoryColumnColor});
          column.color = function(attr) {
            return attr.isOlderValue ?
                olderUsedMemoryColumnColor : usedMemoryColumnColor;
          }
        });

        var sizeColumns = usedMemorySizeColumns.concat(allocatorSizeColumns);
        tr.ui.analysis.MemoryColumn.spaceEqually(sizeColumns);

        var columns = [titleColumn].concat(sizeColumns);
        this.$.table.tableColumns = columns;
      },

      storeSelection_: function() {
        var selectedRowTitle;
        var selectedRow = this.$.table.selectedTableRow;
        if (selectedRow !== undefined)
          selectedRowTitle = selectedRow.title;

        var selectedColumnName;
        var selectedColumnIndex = this.$.table.selectedColumnIndex;
        if (selectedColumnIndex !== undefined) {
          var selectedColumn = this.$.table.tableColumns[selectedColumnIndex];
          selectedColumnName = selectedColumn.name;
        }

        this.$.state.set(
            {rowTitle: selectedRowTitle, columnName: selectedColumnName});
      },

      restoreSelection_: function() {
        var settings = this.$.state.get();
        if (settings === undefined || settings.rowTitle === undefined ||
            settings.columnName === undefined)
          return;

        var selectedColumnName = settings.columnName;
        var selectedColumnIndex = tr.b.findFirstIndexInArray(
            this.$.table.tableColumns, function(column) {
          return column.name === selectedColumnName;
        });
        if (selectedColumnIndex < 0)
          return;

        var selectedRowTitle = settings.rowTitle;
        var selectedRow = tr.b.findFirstInArray(this.$.table.tableRows,
            function(row) {
          return row.title === selectedRowTitle;
        });
        if (selectedRow === undefined)
          return;

        this.$.table.selectedTableRow = selectedRow;
        this.$.table.selectedColumnIndex = selectedColumnIndex;
      }
    });
  })();
  

  'use strict';

  Polymer('tr-ui-a-stacked-pane-view', {
    
    setPaneBuilder: function(paneBuilder, opt_parentPane) {
      var paneContainer = this.$.pane_container;

                  if (opt_parentPane) {
        if (!(opt_parentPane instanceof HTMLElement))
          throw new Error('Parent pane must be an HTML element');
        if (opt_parentPane.parentElement !== paneContainer)
          throw new Error('Parent pane must be a child of the pane container');
      }

                  while (paneContainer.lastElementChild !== null &&
             paneContainer.lastElementChild !== opt_parentPane) {
        var removedPane = this.$.pane_container.lastElementChild;
        var listener = this.listeners_.get(removedPane);
        if (listener === undefined)
          throw new Error('No listener associated with pane');
        this.listeners_.delete(removedPane);
        removedPane.removeEventListener(
            'request-child-pane-change', listener);
        paneContainer.removeChild(removedPane);
      }

      if (opt_parentPane && opt_parentPane.parentElement !== paneContainer)
        throw new Error('Parent pane was removed from the pane container');

                        if (!paneBuilder)
        return;

      var pane = paneBuilder();
      if (!pane)
        return;

      if (!(pane instanceof HTMLElement))
        throw new Error('Pane must be an HTML element');

            var listener = function(event) {
        this.setPaneBuilder(pane.childPaneBuilder, pane);
      }.bind(this);
      if (!this.listeners_) {
                                        this.listeners_ = new WeakMap();
      }
      this.listeners_.set(pane, listener);
      pane.addEventListener('request-child-pane-change', listener);

      paneContainer.appendChild(pane);
      pane.appended();
    },

    
    rebuild: function() {
      var currentPane = this.$.pane_container.firstElementChild;
      while (currentPane) {
        currentPane.rebuild();
        currentPane = currentPane.nextElementSibling;
      }
    },

        get panesForTesting() {
      var panes = [];
      var currentChild = this.$.pane_container.firstElementChild;
      while (currentChild) {
        panes.push(currentChild);
        currentChild = currentChild.nextElementSibling;
      }
      return panes;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-memory-dump-view', {
    created: function() {
      this.processMemoryDumps_ = undefined;
    },

    set processMemoryDumps(processMemoryDumps) {
      this.processMemoryDumps_ = processMemoryDumps;
      this.setPaneBuilder(function() {
        var overviewPane = document.createElement(
            'tr-ui-a-memory-dump-overview-pane');
        overviewPane.processMemoryDumps = this.processMemoryDumps_;
        return overviewPane;
      }.bind(this));
    },

    get processMemoryDumps() {
      return this.processMemoryDumps_;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-process-memory-dump-sub-view', {
    set selection(selection) {
      if (selection.length !== 1)
        throw new Error('Only supports a single process memory dump');
      if (!(selection[0] instanceof tr.model.ProcessMemoryDump))
        throw new Error('Only supports process memory dumps');
      this.currentSelection_ = selection;
      this.$.memory_dump_view.processMemoryDumps = [selection[0]];
    },

    get selection() {
      return this.currentSelection_;
    },

    get requiresTallView() {
      return true;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-process-memory-dump-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.currentSelection_ = selection;

      selection = tr.b.asArray(selection).sort(
          tr.b.Range.compareByMinTimes);

      var ownerDocument = this.ownerDocument;
      var table = this.$.content;
      table.tableColumns = [
        {
          title: 'Dump',
          value: function(row) {
            var linkEl = document.createElement('tr-ui-a-analysis-link');
            linkEl.setSelectionAndContent(function() {
                return new tr.model.EventSet(row);
            });
            var spanEl = document.createElement('span');
            spanEl.textContent = 'Process memory dump at ';
            linkEl.appendChild(spanEl);
            linkEl.appendChild(tr.ui.units.createTimeStampSpan(
                row.start, {ownerDocument: ownerDocument}));
            return linkEl;
          }
        }
      ];
      table.showHeader = false;
      table.tableRows = selection;
      table.rebuild();
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-single-global-memory-dump-sub-view', {
    set selection(selection) {
      if (selection.length !== 1)
        throw new Error('Only supports a single global memory dump');
      if (!(selection[0] instanceof tr.model.GlobalMemoryDump))
        throw new Error('Only supports global memory dumps');
      this.currentSelection_ = selection;
      this.$.memory_dump_view.processMemoryDumps = tr.b.dictionaryValues(
          selection[0].processMemoryDumps);
    },

    get selection() {
      return this.currentSelection_;
    },

    get requiresTallView() {
      return true;
    }
  });
  

  'use strict';

  Polymer('tr-ui-a-multi-global-memory-dump-sub-view', {
    created: function() {
      this.currentSelection_ = undefined;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.currentSelection_ = selection;

      selection = tr.b.asArray(selection).sort(
          tr.b.Range.compareByMinTimes);

      var ownerDocument = this.ownerDocument;
      var table = this.$.content;
      table.tableColumns = [
        {
          title: 'Dump',
          value: function(row) {
            var linkEl = document.createElement('tr-ui-a-analysis-link');
            linkEl.setSelectionAndContent(function() {
                return new tr.model.EventSet(row);
            });
            var spanEl = document.createElement('span');
            spanEl.textContent = 'Global memory dump at ';
            linkEl.appendChild(spanEl);
            linkEl.appendChild(tr.ui.units.createTimeStampSpan(
                row.start, {ownerDocument: ownerDocument}));
            return linkEl;
          }
        }
      ];
      table.showHeader = false;
      table.tableRows = selection;
      table.rebuild();
    }
  });
  

'use strict';
var EventSet = tr.model.EventSet;

Polymer('tr-ui-a-power-sample-table', {
  ready: function() {
    this.$.table.tableColumns = [
      {
        title: 'Time',
        width: '100px',
        value: function(row) {
          return tr.ui.units.createTimeStampSpan(row.start);
        }
      },
      {
        title: 'Power (mW)',
        width: '100%',
        value: function(row) { return row.power; }
      }
    ];
    this.samples = new EventSet();
  },

  get samples() {
    return this.samples_;
  },

  set samples(samples) {
    this.samples_ = (samples === undefined) ? new EventSet() : samples;
    this.updateContents_();
  },

  updateContents_: function() {
    this.$.table.tableRows = this.samples.toArray();
    this.$.table.rebuild();
  }
});


  'use strict';

  Polymer('tr-ui-a-single-power-sample-sub-view', {
    ready: function() {
      this.currentSelection_ = undefined;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.currentSelection_ = selection;
      this.updateContents_();
    },

    updateContents_: function() {
      this.$.samplesTable.samples = this.selection;
    }
  });
  
!function(){function n(n){return null!=n&&!isNaN(n)}function t(n){return n.length}function e(n){for(var t=1;n*t%1;)t*=10;return t}function r(n,t){try{for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}catch(r){n.prototype=t}}function u(){}function i(n){return aa+n in this}function o(n){return n=aa+n,n in this&&delete this[n]}function a(){var n=[];return this.forEach(function(t){n.push(t)}),n}function c(){var n=0;for(var t in this)t.charCodeAt(0)===ca&&++n;return n}function s(){for(var n in this)if(n.charCodeAt(0)===ca)return!1;return!0}function l(){}function f(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function h(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.substring(1);for(var e=0,r=sa.length;r>e;++e){var u=sa[e]+t;if(u in n)return u}}function g(){}function p(){}function v(n){function t(){for(var t,r=e,u=-1,i=r.length;++u<i;)(t=r[u].on)&&t.apply(this,arguments);return n}var e=[],r=new u;return t.on=function(t,u){var i,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,i=e.indexOf(o)).concat(e.slice(i+1)),r.remove(t)),u&&e.push(r.set(t,{on:u})),n)},t}function d(){Xo.event.preventDefault()}function m(){for(var n,t=Xo.event;n=t.sourceEvent;)t=n;return t}function y(n){for(var t=new p,e=0,r=arguments.length;++e<r;)t[arguments[e]]=v(t);return t.of=function(e,r){return function(u){try{var i=u.sourceEvent=Xo.event;u.target=n,Xo.event=u,t[u.type].apply(e,r)}finally{Xo.event=i}}},t}function x(n){return fa(n,da),n}function M(n){return"function"==typeof n?n:function(){return ha(n,this)}}function _(n){return"function"==typeof n?n:function(){return ga(n,this)}}function b(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function u(){this.setAttribute(n,t)}function i(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=Xo.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?i:u}function w(n){return n.trim().replace(/\s+/g," ")}function S(n){return new RegExp("(?:^|\\s+)"+Xo.requote(n)+"(?:\\s+|$)","g")}function k(n){return n.trim().split(/^|\s+/)}function E(n,t){function e(){for(var e=-1;++e<u;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<u;)n[e](this,r)}n=k(n).map(A);var u=n.length;return"function"==typeof t?r:e}function A(n){var t=S(n);return function(e,r){if(u=e.classList)return r?u.add(n):u.remove(n);var u=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(u)||e.setAttribute("class",w(u+" "+n))):e.setAttribute("class",w(u.replace(t," ")))}}function C(n,t,e){function r(){this.style.removeProperty(n)}function u(){this.style.setProperty(n,t,e)}function i(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?i:u}function N(n,t){function e(){delete this[n]}function r(){this[n]=t}function u(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?u:r}function L(n){return"function"==typeof n?n:(n=Xo.ns.qualify(n)).local?function(){return this.ownerDocument.createElementNS(n.space,n.local)}:function(){return this.ownerDocument.createElementNS(this.namespaceURI,n)}}function T(n){return{__data__:n}}function q(n){return function(){return va(this,n)}}function z(n){return arguments.length||(n=Xo.ascending),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function R(n,t){for(var e=0,r=n.length;r>e;e++)for(var u,i=n[e],o=0,a=i.length;a>o;o++)(u=i[o])&&t(u,o,e);return n}function D(n){return fa(n,ya),n}function P(n){var t,e;return function(r,u,i){var o,a=n[i].update,c=a.length;for(i!=e&&(e=i,t=0),u>=t&&(t=u+1);!(o=a[t])&&++t<c;);return o}}function U(){var n=this.__transition__;n&&++n.active}function j(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function u(){var u=c(t,Bo(arguments));r.call(this),this.addEventListener(n,this[o]=u,u.$=e),u._=t}function i(){var t,e=new RegExp("^__on([^.]+)"+Xo.requote(n)+"$");for(var r in this)if(t=r.match(e)){var u=this[r];this.removeEventListener(t[1],u,u.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),c=H;a>0&&(n=n.substring(0,a));var s=Ma.get(n);return s&&(n=s,c=F),a?t?u:r:t?g:i}function H(n,t){return function(e){var r=Xo.event;Xo.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{Xo.event=r}}}function F(n,t){var e=H(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function O(){var n=".dragsuppress-"+ ++ba,t="click"+n,e=Xo.select(Go).on("touchmove"+n,d).on("dragstart"+n,d).on("selectstart"+n,d);if(_a){var r=Jo.style,u=r[_a];r[_a]="none"}return function(i){function o(){e.on(t,null)}e.on(n,null),_a&&(r[_a]=u),i&&(e.on(t,function(){d(),o()},!0),setTimeout(o,0))}}function Y(n,t){t.changedTouches&&(t=t.changedTouches[0]);var e=n.ownerSVGElement||n;if(e.createSVGPoint){var r=e.createSVGPoint();if(0>wa&&(Go.scrollX||Go.scrollY)){e=Xo.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var u=e[0][0].getScreenCTM();wa=!(u.f||u.e),e.remove()}return wa?(r.x=t.pageX,r.y=t.pageY):(r.x=t.clientX,r.y=t.clientY),r=r.matrixTransform(n.getScreenCTM().inverse()),[r.x,r.y]}var i=n.getBoundingClientRect();return[t.clientX-i.left-n.clientLeft,t.clientY-i.top-n.clientTop]}function I(n){return n>0?1:0>n?-1:0}function Z(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function V(n){return n>1?0:-1>n?Sa:Math.acos(n)}function X(n){return n>1?Ea:-1>n?-Ea:Math.asin(n)}function $(n){return((n=Math.exp(n))-1/n)/2}function B(n){return((n=Math.exp(n))+1/n)/2}function W(n){return((n=Math.exp(2*n))-1)/(n+1)}function J(n){return(n=Math.sin(n/2))*n}function G(){}function K(n,t,e){return new Q(n,t,e)}function Q(n,t,e){this.h=n,this.s=t,this.l=e}function nt(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?i+(o-i)*n/60:180>n?o:240>n?i+(o-i)*(240-n)/60:i}function u(n){return Math.round(255*r(n))}var i,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,i=2*e-o,gt(u(n+120),u(n),u(n-120))}function tt(n,t,e){return new et(n,t,e)}function et(n,t,e){this.h=n,this.c=t,this.l=e}function rt(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),ut(e,Math.cos(n*=Na)*t,Math.sin(n)*t)}function ut(n,t,e){return new it(n,t,e)}function it(n,t,e){this.l=n,this.a=t,this.b=e}function ot(n,t,e){var r=(n+16)/116,u=r+t/500,i=r-e/200;return u=ct(u)*Fa,r=ct(r)*Oa,i=ct(i)*Ya,gt(lt(3.2404542*u-1.5371385*r-.4985314*i),lt(-.969266*u+1.8760108*r+.041556*i),lt(.0556434*u-.2040259*r+1.0572252*i))}function at(n,t,e){return n>0?tt(Math.atan2(e,t)*La,Math.sqrt(t*t+e*e),n):tt(0/0,0/0,n)}function ct(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function st(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function lt(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function ft(n){return gt(n>>16,255&n>>8,255&n)}function ht(n){return ft(n)+""}function gt(n,t,e){return new pt(n,t,e)}function pt(n,t,e){this.r=n,this.g=t,this.b=e}function vt(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function dt(n,t,e){var r,u,i,o,a=0,c=0,s=0;if(u=/([a-z]+)\((.*)\)/i.exec(n))switch(i=u[2].split(","),u[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Mt(i[0]),Mt(i[1]),Mt(i[2]))}return(o=Va.get(n))?t(o.r,o.g,o.b):(null!=n&&"#"===n.charAt(0)&&(r=parseInt(n.substring(1),16),isNaN(r)||(4===n.length?(a=(3840&r)>>4,a=a>>4|a,c=240&r,c=c>>4|c,s=15&r,s=s<<4|s):7===n.length&&(a=(16711680&r)>>16,c=(65280&r)>>8,s=255&r))),t(a,c,s))}function mt(n,t,e){var r,u,i=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-i,c=(o+i)/2;return a?(u=.5>c?a/(o+i):a/(2-o-i),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=0/0,u=c>0&&1>c?0:r),K(r,u,c)}function yt(n,t,e){n=xt(n),t=xt(t),e=xt(e);var r=st((.4124564*n+.3575761*t+.1804375*e)/Fa),u=st((.2126729*n+.7151522*t+.072175*e)/Oa),i=st((.0193339*n+.119192*t+.9503041*e)/Ya);return ut(116*u-16,500*(r-u),200*(u-i))}function xt(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Mt(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function _t(n){return"function"==typeof n?n:function(){return n}}function bt(n){return n}function wt(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),St(t,e,n,r)}}function St(n,t,e,r){function u(){var n,t=c.status;if(!t&&c.responseText||t>=200&&300>t||304===t){try{n=e.call(i,c)}catch(r){return o.error.call(i,r),void 0}o.load.call(i,n)}else o.error.call(i,c)}var i={},o=Xo.dispatch("beforesend","progress","load","error"),a={},c=new XMLHttpRequest,s=null;return!Go.XDomainRequest||"withCredentials"in c||!/^(http(s)?:)?\/\//.test(n)||(c=new XDomainRequest),"onload"in c?c.onload=c.onerror=u:c.onreadystatechange=function(){c.readyState>3&&u()},c.onprogress=function(n){var t=Xo.event;Xo.event=n;try{o.progress.call(i,c)}finally{Xo.event=t}},i.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",i)},i.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",i):t},i.responseType=function(n){return arguments.length?(s=n,i):s},i.response=function(n){return e=n,i},["get","post"].forEach(function(n){i[n]=function(){return i.send.apply(i,[n].concat(Bo(arguments)))}}),i.send=function(e,r,u){if(2===arguments.length&&"function"==typeof r&&(u=r,r=null),c.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),c.setRequestHeader)for(var l in a)c.setRequestHeader(l,a[l]);return null!=t&&c.overrideMimeType&&c.overrideMimeType(t),null!=s&&(c.responseType=s),null!=u&&i.on("error",u).on("load",function(n){u(null,n)}),o.beforesend.call(i,c),c.send(null==r?null:r),i},i.abort=function(){return c.abort(),i},Xo.rebind(i,o,"on"),null==r?i:i.get(kt(r))}function kt(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Et(){var n=At(),t=Ct()-n;t>24?(isFinite(t)&&(clearTimeout(Wa),Wa=setTimeout(Et,t)),Ba=0):(Ba=1,Ga(Et))}function At(){var n=Date.now();for(Ja=Xa;Ja;)n>=Ja.t&&(Ja.f=Ja.c(n-Ja.t)),Ja=Ja.n;return n}function Ct(){for(var n,t=Xa,e=1/0;t;)t.f?t=n?n.n=t.n:Xa=t.n:(t.t<e&&(e=t.t),t=(n=t).n);return $a=n,e}function Nt(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Lt(n,t){var e=Math.pow(10,3*oa(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function Tt(n){var t=n.decimal,e=n.thousands,r=n.grouping,u=n.currency,i=r?function(n){for(var t=n.length,u=[],i=0,o=r[0];t>0&&o>0;)u.push(n.substring(t-=o,t+o)),o=r[i=(i+1)%r.length];return u.reverse().join(e)}:bt;return function(n){var e=Qa.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"",c=e[4]||"",s=e[5],l=+e[6],f=e[7],h=e[8],g=e[9],p=1,v="",d="",m=!1;switch(h&&(h=+h.substring(1)),(s||"0"===r&&"="===o)&&(s=r="0",o="=",f&&(l-=Math.floor((l-1)/4))),g){case"n":f=!0,g="g";break;case"%":p=100,d="%",g="f";break;case"p":p=100,d="%",g="r";break;case"b":case"o":case"x":case"X":"#"===c&&(v="0"+g.toLowerCase());case"c":case"d":m=!0,h=0;break;case"s":p=-1,g="r"}"$"===c&&(v=u[0],d=u[1]),"r"!=g||h||(g="g"),null!=h&&("g"==g?h=Math.max(1,Math.min(21,h)):("e"==g||"f"==g)&&(h=Math.max(0,Math.min(20,h)))),g=nc.get(g)||qt;var y=s&&f;return function(n){var e=d;if(m&&n%1)return"";var u=0>n||0===n&&0>1/n?(n=-n,"-"):a;if(0>p){var c=Xo.formatPrefix(n,h);n=c.scale(n),e=c.symbol+d}else n*=p;n=g(n,h);var x=n.lastIndexOf("."),M=0>x?n:n.substring(0,x),_=0>x?"":t+n.substring(x+1);!s&&f&&(M=i(M));var b=v.length+M.length+_.length+(y?0:u.length),w=l>b?new Array(b=l-b+1).join(r):"";return y&&(M=i(w+M)),u+=v,n=M+_,("<"===o?u+n+w:">"===o?w+u+n:"^"===o?w.substring(0,b>>=1)+u+n+w.substring(b):u+(y?n:w+n))+e}}}function qt(n){return n+""}function zt(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function Rt(n,t,e){function r(t){var e=n(t),r=i(e,1);return r-t>t-e?e:r}function u(e){return t(e=n(new ec(e-1)),1),e}function i(n,e){return t(n=new ec(+n),e),n}function o(n,r,i){var o=u(n),a=[];if(i>1)for(;r>o;)e(o)%i||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{ec=zt;var r=new zt;return r._=n,o(r,t,e)}finally{ec=Date}}n.floor=n,n.round=r,n.ceil=u,n.offset=i,n.range=o;var c=n.utc=Dt(n);return c.floor=c,c.round=Dt(r),c.ceil=Dt(u),c.offset=Dt(i),c.range=a,n}function Dt(n){return function(t,e){try{ec=zt;var r=new zt;return r._=t,n(r,e)._}finally{ec=Date}}}function Pt(n){function t(n){function t(t){for(var e,u,i,o=[],a=-1,c=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.substring(c,a)),null!=(u=uc[e=n.charAt(++a)])&&(e=n.charAt(++a)),(i=C[e])&&(e=i(t,null==u?"e"===e?" ":"0":u)),o.push(e),c=a+1);return o.push(n.substring(c,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},u=e(r,n,t,0);if(u!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var i=null!=r.Z&&ec!==zt,o=new(i?zt:ec);return"j"in r?o.setFullYear(r.y,0,r.j):"w"in r&&("W"in r||"U"in r)?(o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+Math.floor(r.Z/100),r.M+r.Z%100,r.S,r.L),i?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var u,i,o,a=0,c=t.length,s=e.length;c>a;){if(r>=s)return-1;if(u=t.charCodeAt(a++),37===u){if(o=t.charAt(a++),i=N[o in uc?t.charAt(a++):o],!i||(r=i(n,e,r))<0)return-1}else if(u!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){b.lastIndex=0;var r=b.exec(t.substring(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){M.lastIndex=0;var r=M.exec(t.substring(e));return r?(n.w=_.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){E.lastIndex=0;var r=E.exec(t.substring(e));return r?(n.m=A.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.substring(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,C.c.toString(),t,r)}function c(n,t,r){return e(n,C.x.toString(),t,r)}function s(n,t,r){return e(n,C.X.toString(),t,r)}function l(n,t,e){var r=x.get(t.substring(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var f=n.dateTime,h=n.date,g=n.time,p=n.periods,v=n.days,d=n.shortDays,m=n.months,y=n.shortMonths;t.utc=function(n){function e(n){try{ec=zt;var t=new ec;return t._=n,r(t)}finally{ec=Date}}var r=t(n);return e.parse=function(n){try{ec=zt;var t=r.parse(n);return t&&t._}finally{ec=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ee;var x=Xo.map(),M=jt(v),_=Ht(v),b=jt(d),w=Ht(d),S=jt(m),k=Ht(m),E=jt(y),A=Ht(y);p.forEach(function(n,t){x.set(n.toLowerCase(),t)});var C={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return y[n.getMonth()]},B:function(n){return m[n.getMonth()]},c:t(f),d:function(n,t){return Ut(n.getDate(),t,2)},e:function(n,t){return Ut(n.getDate(),t,2)},H:function(n,t){return Ut(n.getHours(),t,2)},I:function(n,t){return Ut(n.getHours()%12||12,t,2)},j:function(n,t){return Ut(1+tc.dayOfYear(n),t,3)},L:function(n,t){return Ut(n.getMilliseconds(),t,3)},m:function(n,t){return Ut(n.getMonth()+1,t,2)},M:function(n,t){return Ut(n.getMinutes(),t,2)},p:function(n){return p[+(n.getHours()>=12)]},S:function(n,t){return Ut(n.getSeconds(),t,2)},U:function(n,t){return Ut(tc.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Ut(tc.mondayOfYear(n),t,2)},x:t(h),X:t(g),y:function(n,t){return Ut(n.getFullYear()%100,t,2)},Y:function(n,t){return Ut(n.getFullYear()%1e4,t,4)},Z:ne,"%":function(){return"%"}},N={a:r,A:u,b:i,B:o,c:a,d:Bt,e:Bt,H:Jt,I:Jt,j:Wt,L:Qt,m:$t,M:Gt,p:l,S:Kt,U:Ot,w:Ft,W:Yt,x:c,X:s,y:Zt,Y:It,Z:Vt,"%":te};return t}function Ut(n,t,e){var r=0>n?"-":"",u=(r?-n:n)+"",i=u.length;return r+(e>i?new Array(e-i+1).join(t)+u:u)}function jt(n){return new RegExp("^(?:"+n.map(Xo.requote).join("|")+")","i")}function Ht(n){for(var t=new u,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function Ft(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Ot(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e));return r?(n.U=+r[0],e+r[0].length):-1}function Yt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e));return r?(n.W=+r[0],e+r[0].length):-1}function It(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Zt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.y=Xt(+r[0]),e+r[0].length):-1}function Vt(n,t,e){return/^[+-]\d{4}$/.test(t=t.substring(e,e+5))?(n.Z=+t,e+5):-1}function Xt(n){return n+(n>68?1900:2e3)}function $t(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function Bt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function Wt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function Jt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function Gt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function Kt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function Qt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function ne(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=~~(oa(t)/60),u=oa(t)%60;return e+Ut(r,"0",2)+Ut(u,"0",2)}function te(n,t,e){oc.lastIndex=0;var r=oc.exec(t.substring(e,e+1));return r?e+r[0].length:-1}function ee(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function re(){}function ue(n,t,e){var r=e.s=n+t,u=r-n,i=r-u;e.t=n-i+(t-u)}function ie(n,t){n&&lc.hasOwnProperty(n.type)&&lc[n.type](n,t)}function oe(n,t,e){var r,u=-1,i=n.length-e;for(t.lineStart();++u<i;)r=n[u],t.point(r[0],r[1],r[2]);t.lineEnd()}function ae(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)oe(n[e],t,1);t.polygonEnd()}function ce(){function n(n,t){n*=Na,t=t*Na/2+Sa/4;var e=n-r,o=e>=0?1:-1,a=o*e,c=Math.cos(t),s=Math.sin(t),l=i*s,f=u*c+l*Math.cos(a),h=l*o*Math.sin(a);hc.add(Math.atan2(h,f)),r=n,u=c,i=s}var t,e,r,u,i;gc.point=function(o,a){gc.point=n,r=(t=o)*Na,u=Math.cos(a=(e=a)*Na/2+Sa/4),i=Math.sin(a)},gc.lineEnd=function(){n(t,e)}}function se(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function le(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function fe(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function he(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function ge(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function pe(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function ve(n){return[Math.atan2(n[1],n[0]),X(n[2])]}function de(n,t){return oa(n[0]-t[0])<Aa&&oa(n[1]-t[1])<Aa}function me(n,t){n*=Na;var e=Math.cos(t*=Na);ye(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function ye(n,t,e){++pc,dc+=(n-dc)/pc,mc+=(t-mc)/pc,yc+=(e-yc)/pc}function xe(){function n(n,u){n*=Na;var i=Math.cos(u*=Na),o=i*Math.cos(n),a=i*Math.sin(n),c=Math.sin(u),s=Math.atan2(Math.sqrt((s=e*c-r*a)*s+(s=r*o-t*c)*s+(s=t*a-e*o)*s),t*o+e*a+r*c);vc+=s,xc+=s*(t+(t=o)),Mc+=s*(e+(e=a)),_c+=s*(r+(r=c)),ye(t,e,r)}var t,e,r;kc.point=function(u,i){u*=Na;var o=Math.cos(i*=Na);t=o*Math.cos(u),e=o*Math.sin(u),r=Math.sin(i),kc.point=n,ye(t,e,r)}}function Me(){kc.point=me}function _e(){function n(n,t){n*=Na;var e=Math.cos(t*=Na),o=e*Math.cos(n),a=e*Math.sin(n),c=Math.sin(t),s=u*c-i*a,l=i*o-r*c,f=r*a-u*o,h=Math.sqrt(s*s+l*l+f*f),g=r*o+u*a+i*c,p=h&&-V(g)/h,v=Math.atan2(h,g);bc+=p*s,wc+=p*l,Sc+=p*f,vc+=v,xc+=v*(r+(r=o)),Mc+=v*(u+(u=a)),_c+=v*(i+(i=c)),ye(r,u,i)}var t,e,r,u,i;kc.point=function(o,a){t=o,e=a,kc.point=n,o*=Na;var c=Math.cos(a*=Na);r=c*Math.cos(o),u=c*Math.sin(o),i=Math.sin(a),ye(r,u,i)},kc.lineEnd=function(){n(t,e),kc.lineEnd=Me,kc.point=me}}function be(){return!0}function we(n,t,e,r,u){var i=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(de(e,r)){u.lineStart();for(var a=0;t>a;++a)u.point((e=n[a])[0],e[1]);return u.lineEnd(),void 0}var c=new ke(e,n,null,!0),s=new ke(e,null,c,!1);c.o=s,i.push(c),o.push(s),c=new ke(r,n,null,!1),s=new ke(r,null,c,!0),c.o=s,i.push(c),o.push(s)}}),o.sort(t),Se(i),Se(o),i.length){for(var a=0,c=e,s=o.length;s>a;++a)o[a].e=c=!c;for(var l,f,h=i[0];;){for(var g=h,p=!0;g.v;)if((g=g.n)===h)return;l=g.z,u.lineStart();do{if(g.v=g.o.v=!0,g.e){if(p)for(var a=0,s=l.length;s>a;++a)u.point((f=l[a])[0],f[1]);else r(g.x,g.n.x,1,u);g=g.n}else{if(p){l=g.p.z;for(var a=l.length-1;a>=0;--a)u.point((f=l[a])[0],f[1])}else r(g.x,g.p.x,-1,u);g=g.p}g=g.o,l=g.z,p=!p}while(!g.v);u.lineEnd()}}}function Se(n){if(t=n.length){for(var t,e,r=0,u=n[0];++r<t;)u.n=e=n[r],e.p=u,u=e;u.n=e=n[0],e.p=u}}function ke(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Ee(n,t,e,r){return function(u,i){function o(t,e){var r=u(t,e);n(t=r[0],e=r[1])&&i.point(t,e)}function a(n,t){var e=u(n,t);d.point(e[0],e[1])}function c(){y.point=a,d.lineStart()}function s(){y.point=o,d.lineEnd()}function l(n,t){v.push([n,t]);var e=u(n,t);M.point(e[0],e[1])}function f(){M.lineStart(),v=[]}function h(){l(v[0][0],v[0][1]),M.lineEnd();var n,t=M.clean(),e=x.buffer(),r=e.length;if(v.pop(),p.push(v),v=null,r){if(1&t){n=e[0];var u,r=n.length-1,o=-1;for(i.lineStart();++o<r;)i.point((u=n[o])[0],u[1]);return i.lineEnd(),void 0}r>1&&2&t&&e.push(e.pop().concat(e.shift())),g.push(e.filter(Ae))}}var g,p,v,d=t(i),m=u.invert(r[0],r[1]),y={point:o,lineStart:c,lineEnd:s,polygonStart:function(){y.point=l,y.lineStart=f,y.lineEnd=h,g=[],p=[],i.polygonStart()},polygonEnd:function(){y.point=o,y.lineStart=c,y.lineEnd=s,g=Xo.merge(g);var n=Le(m,p);g.length?we(g,Ne,n,e,i):n&&(i.lineStart(),e(null,null,1,i),i.lineEnd()),i.polygonEnd(),g=p=null},sphere:function(){i.polygonStart(),i.lineStart(),e(null,null,1,i),i.lineEnd(),i.polygonEnd()}},x=Ce(),M=t(x);return y}}function Ae(n){return n.length>1}function Ce(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:g,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ne(n,t){return((n=n.x)[0]<0?n[1]-Ea-Aa:Ea-n[1])-((t=t.x)[0]<0?t[1]-Ea-Aa:Ea-t[1])}function Le(n,t){var e=n[0],r=n[1],u=[Math.sin(e),-Math.cos(e),0],i=0,o=0;hc.reset();for(var a=0,c=t.length;c>a;++a){var s=t[a],l=s.length;if(l)for(var f=s[0],h=f[0],g=f[1]/2+Sa/4,p=Math.sin(g),v=Math.cos(g),d=1;;){d===l&&(d=0),n=s[d];var m=n[0],y=n[1]/2+Sa/4,x=Math.sin(y),M=Math.cos(y),_=m-h,b=_>=0?1:-1,w=b*_,S=w>Sa,k=p*x;if(hc.add(Math.atan2(k*b*Math.sin(w),v*M+k*Math.cos(w))),i+=S?_+b*ka:_,S^h>=e^m>=e){var E=fe(se(f),se(n));pe(E);var A=fe(u,E);pe(A);var C=(S^_>=0?-1:1)*X(A[2]);(r>C||r===C&&(E[0]||E[1]))&&(o+=S^_>=0?1:-1)}if(!d++)break;h=m,p=x,v=M,f=n}}return(-Aa>i||Aa>i&&0>hc)^1&o}function Te(n){var t,e=0/0,r=0/0,u=0/0;return{lineStart:function(){n.lineStart(),t=1},point:function(i,o){var a=i>0?Sa:-Sa,c=oa(i-e);oa(c-Sa)<Aa?(n.point(e,r=(r+o)/2>0?Ea:-Ea),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(i,r),t=0):u!==a&&c>=Sa&&(oa(e-u)<Aa&&(e-=u*Aa),oa(i-a)<Aa&&(i-=a*Aa),r=qe(e,r,i,o),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=i,r=o),u=a},lineEnd:function(){n.lineEnd(),e=r=0/0},clean:function(){return 2-t}}}function qe(n,t,e,r){var u,i,o=Math.sin(n-e);return oa(o)>Aa?Math.atan((Math.sin(t)*(i=Math.cos(r))*Math.sin(e)-Math.sin(r)*(u=Math.cos(t))*Math.sin(n))/(u*i*o)):(t+r)/2}function ze(n,t,e,r){var u;if(null==n)u=e*Ea,r.point(-Sa,u),r.point(0,u),r.point(Sa,u),r.point(Sa,0),r.point(Sa,-u),r.point(0,-u),r.point(-Sa,-u),r.point(-Sa,0),r.point(-Sa,u);else if(oa(n[0]-t[0])>Aa){var i=n[0]<t[0]?Sa:-Sa;u=e*i/2,r.point(-i,u),r.point(0,u),r.point(i,u)}else r.point(t[0],t[1])}function Re(n){function t(n,t){return Math.cos(n)*Math.cos(t)>i}function e(n){var e,i,c,s,l;return{lineStart:function(){s=c=!1,l=1},point:function(f,h){var g,p=[f,h],v=t(f,h),d=o?v?0:u(f,h):v?u(f+(0>f?Sa:-Sa),h):0;if(!e&&(s=c=v)&&n.lineStart(),v!==c&&(g=r(e,p),(de(e,g)||de(p,g))&&(p[0]+=Aa,p[1]+=Aa,v=t(p[0],p[1]))),v!==c)l=0,v?(n.lineStart(),g=r(p,e),n.point(g[0],g[1])):(g=r(e,p),n.point(g[0],g[1]),n.lineEnd()),e=g;else if(a&&e&&o^v){var m;d&i||!(m=r(p,e,!0))||(l=0,o?(n.lineStart(),n.point(m[0][0],m[0][1]),n.point(m[1][0],m[1][1]),n.lineEnd()):(n.point(m[1][0],m[1][1]),n.lineEnd(),n.lineStart(),n.point(m[0][0],m[0][1])))}!v||e&&de(e,p)||n.point(p[0],p[1]),e=p,c=v,i=d},lineEnd:function(){c&&n.lineEnd(),e=null},clean:function(){return l|(s&&c)<<1}}}function r(n,t,e){var r=se(n),u=se(t),o=[1,0,0],a=fe(r,u),c=le(a,a),s=a[0],l=c-s*s;if(!l)return!e&&n;var f=i*c/l,h=-i*s/l,g=fe(o,a),p=ge(o,f),v=ge(a,h);he(p,v);var d=g,m=le(p,d),y=le(d,d),x=m*m-y*(le(p,p)-1);if(!(0>x)){var M=Math.sqrt(x),_=ge(d,(-m-M)/y);if(he(_,p),_=ve(_),!e)return _;var b,w=n[0],S=t[0],k=n[1],E=t[1];w>S&&(b=w,w=S,S=b);var A=S-w,C=oa(A-Sa)<Aa,N=C||Aa>A;if(!C&&k>E&&(b=k,k=E,E=b),N?C?k+E>0^_[1]<(oa(_[0]-w)<Aa?k:E):k<=_[1]&&_[1]<=E:A>Sa^(w<=_[0]&&_[0]<=S)){var L=ge(d,(-m+M)/y);return he(L,p),[_,ve(L)]}}}function u(t,e){var r=o?n:Sa-n,u=0;return-r>t?u|=1:t>r&&(u|=2),-r>e?u|=4:e>r&&(u|=8),u}var i=Math.cos(n),o=i>0,a=oa(i)>Aa,c=cr(n,6*Na);return Ee(t,e,c,o?[0,-n]:[-Sa,n-Sa])}function De(n,t,e,r){return function(u){var i,o=u.a,a=u.b,c=o.x,s=o.y,l=a.x,f=a.y,h=0,g=1,p=l-c,v=f-s;if(i=n-c,p||!(i>0)){if(i/=p,0>p){if(h>i)return;g>i&&(g=i)}else if(p>0){if(i>g)return;i>h&&(h=i)}if(i=e-c,p||!(0>i)){if(i/=p,0>p){if(i>g)return;i>h&&(h=i)}else if(p>0){if(h>i)return;g>i&&(g=i)}if(i=t-s,v||!(i>0)){if(i/=v,0>v){if(h>i)return;g>i&&(g=i)}else if(v>0){if(i>g)return;i>h&&(h=i)}if(i=r-s,v||!(0>i)){if(i/=v,0>v){if(i>g)return;i>h&&(h=i)}else if(v>0){if(h>i)return;g>i&&(g=i)}return h>0&&(u.a={x:c+h*p,y:s+h*v}),1>g&&(u.b={x:c+g*p,y:s+g*v}),u}}}}}}function Pe(n,t,e,r){function u(r,u){return oa(r[0]-n)<Aa?u>0?0:3:oa(r[0]-e)<Aa?u>0?2:1:oa(r[1]-t)<Aa?u>0?1:0:u>0?3:2}function i(n,t){return o(n.x,t.x)}function o(n,t){var e=u(n,1),r=u(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function c(n){for(var t=0,e=d.length,r=n[1],u=0;e>u;++u)for(var i,o=1,a=d[u],c=a.length,s=a[0];c>o;++o)i=a[o],s[1]<=r?i[1]>r&&Z(s,i,n)>0&&++t:i[1]<=r&&Z(s,i,n)<0&&--t,s=i;return 0!==t}function s(i,a,c,s){var l=0,f=0;if(null==i||(l=u(i,c))!==(f=u(a,c))||o(i,a)<0^c>0){do s.point(0===l||3===l?n:e,l>1?r:t);while((l=(l+c+4)%4)!==f)}else s.point(a[0],a[1])}function l(u,i){return u>=n&&e>=u&&i>=t&&r>=i}function f(n,t){l(n,t)&&a.point(n,t)}function h(){N.point=p,d&&d.push(m=[]),S=!0,w=!1,_=b=0/0}function g(){v&&(p(y,x),M&&w&&A.rejoin(),v.push(A.buffer())),N.point=f,w&&a.lineEnd()}function p(n,t){n=Math.max(-Ac,Math.min(Ac,n)),t=Math.max(-Ac,Math.min(Ac,t));var e=l(n,t);if(d&&m.push([n,t]),S)y=n,x=t,M=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:_,y:b},b:{x:n,y:t}};C(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}_=n,b=t,w=e}var v,d,m,y,x,M,_,b,w,S,k,E=a,A=Ce(),C=De(n,t,e,r),N={point:f,lineStart:h,lineEnd:g,polygonStart:function(){a=A,v=[],d=[],k=!0},polygonEnd:function(){a=E,v=Xo.merge(v);var t=c([n,r]),e=k&&t,u=v.length;(e||u)&&(a.polygonStart(),e&&(a.lineStart(),s(null,null,1,a),a.lineEnd()),u&&we(v,i,t,s,a),a.polygonEnd()),v=d=m=null}};return N}}function Ue(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function je(n){var t=0,e=Sa/3,r=nr(n),u=r(t,e);return u.parallels=function(n){return arguments.length?r(t=n[0]*Sa/180,e=n[1]*Sa/180):[180*(t/Sa),180*(e/Sa)]},u}function He(n,t){function e(n,t){var e=Math.sqrt(i-2*u*Math.sin(t))/u;return[e*Math.sin(n*=u),o-e*Math.cos(n)]}var r=Math.sin(n),u=(r+Math.sin(t))/2,i=1+r*(2*u-r),o=Math.sqrt(i)/u;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/u,X((i-(n*n+e*e)*u*u)/(2*u))]},e}function Fe(){function n(n,t){Nc+=u*n-r*t,r=n,u=t}var t,e,r,u;Rc.point=function(i,o){Rc.point=n,t=r=i,e=u=o},Rc.lineEnd=function(){n(t,e)}}function Oe(n,t){Lc>n&&(Lc=n),n>qc&&(qc=n),Tc>t&&(Tc=t),t>zc&&(zc=t)}function Ye(){function n(n,t){o.push("M",n,",",t,i)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function u(){o.push("Z")}var i=Ie(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return i=Ie(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Ie(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Ze(n,t){dc+=n,mc+=t,++yc}function Ve(){function n(n,r){var u=n-t,i=r-e,o=Math.sqrt(u*u+i*i);xc+=o*(t+n)/2,Mc+=o*(e+r)/2,_c+=o,Ze(t=n,e=r)}var t,e;Pc.point=function(r,u){Pc.point=n,Ze(t=r,e=u)}}function Xe(){Pc.point=Ze}function $e(){function n(n,t){var e=n-r,i=t-u,o=Math.sqrt(e*e+i*i);xc+=o*(r+n)/2,Mc+=o*(u+t)/2,_c+=o,o=u*n-r*t,bc+=o*(r+n),wc+=o*(u+t),Sc+=3*o,Ze(r=n,u=t)}var t,e,r,u;Pc.point=function(i,o){Pc.point=n,Ze(t=r=i,e=u=o)},Pc.lineEnd=function(){n(t,e)}}function Be(n){function t(t,e){n.moveTo(t,e),n.arc(t,e,o,0,ka)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function u(){a.point=t}function i(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:u,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=u,a.point=t},pointRadius:function(n){return o=n,a},result:g};return a}function We(n){function t(n){return(a?r:e)(n)}function e(t){return Ke(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){x=0/0,S.point=i,t.lineStart()}function i(e,r){var i=se([e,r]),o=n(e,r);u(x,M,y,_,b,w,x=o[0],M=o[1],y=e,_=i[0],b=i[1],w=i[2],a,t),t.point(x,M)}function o(){S.point=e,t.lineEnd()}function c(){r(),S.point=s,S.lineEnd=l}function s(n,t){i(f=n,h=t),g=x,p=M,v=_,d=b,m=w,S.point=i}function l(){u(x,M,y,_,b,w,g,p,f,v,d,m,a,t),S.lineEnd=o,o()}var f,h,g,p,v,d,m,y,x,M,_,b,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=c},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function u(t,e,r,a,c,s,l,f,h,g,p,v,d,m){var y=l-t,x=f-e,M=y*y+x*x;if(M>4*i&&d--){var _=a+g,b=c+p,w=s+v,S=Math.sqrt(_*_+b*b+w*w),k=Math.asin(w/=S),E=oa(oa(w)-1)<Aa||oa(r-h)<Aa?(r+h)/2:Math.atan2(b,_),A=n(E,k),C=A[0],N=A[1],L=C-t,T=N-e,q=x*L-y*T;(q*q/M>i||oa((y*L+x*T)/M-.5)>.3||o>a*g+c*p+s*v)&&(u(t,e,r,a,c,s,C,N,E,_/=S,b/=S,w,d,m),m.point(C,N),u(C,N,E,_,b,w,l,f,h,g,p,v,d,m))}}var i=.5,o=Math.cos(30*Na),a=16;return t.precision=function(n){return arguments.length?(a=(i=n*n)>0&&16,t):Math.sqrt(i)},t}function Je(n){var t=We(function(t,e){return n([t*La,e*La])});return function(n){return tr(t(n))}}function Ge(n){this.stream=n}function Ke(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function Qe(n){return nr(function(){return n})()}function nr(n){function t(n){return n=a(n[0]*Na,n[1]*Na),[n[0]*h+c,s-n[1]*h]}function e(n){return n=a.invert((n[0]-c)/h,(s-n[1])/h),n&&[n[0]*La,n[1]*La]}function r(){a=Ue(o=ur(m,y,x),i);var n=i(v,d);return c=g-n[0]*h,s=p+n[1]*h,u()}function u(){return l&&(l.valid=!1,l=null),t}var i,o,a,c,s,l,f=We(function(n,t){return n=i(n,t),[n[0]*h+c,s-n[1]*h]}),h=150,g=480,p=250,v=0,d=0,m=0,y=0,x=0,M=Ec,_=bt,b=null,w=null;return t.stream=function(n){return l&&(l.valid=!1),l=tr(M(o,f(_(n)))),l.valid=!0,l},t.clipAngle=function(n){return arguments.length?(M=null==n?(b=n,Ec):Re((b=+n)*Na),u()):b
},t.clipExtent=function(n){return arguments.length?(w=n,_=n?Pe(n[0][0],n[0][1],n[1][0],n[1][1]):bt,u()):w},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(g=+n[0],p=+n[1],r()):[g,p]},t.center=function(n){return arguments.length?(v=n[0]%360*Na,d=n[1]%360*Na,r()):[v*La,d*La]},t.rotate=function(n){return arguments.length?(m=n[0]%360*Na,y=n[1]%360*Na,x=n.length>2?n[2]%360*Na:0,r()):[m*La,y*La,x*La]},Xo.rebind(t,f,"precision"),function(){return i=n.apply(this,arguments),t.invert=i.invert&&e,r()}}function tr(n){return Ke(n,function(t,e){n.point(t*Na,e*Na)})}function er(n,t){return[n,t]}function rr(n,t){return[n>Sa?n-ka:-Sa>n?n+ka:n,t]}function ur(n,t,e){return n?t||e?Ue(or(n),ar(t,e)):or(n):t||e?ar(t,e):rr}function ir(n){return function(t,e){return t+=n,[t>Sa?t-ka:-Sa>t?t+ka:t,e]}}function or(n){var t=ir(n);return t.invert=ir(-n),t}function ar(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,s=Math.sin(t),l=s*r+a*u;return[Math.atan2(c*i-l*o,a*r-s*u),X(l*i+c*o)]}var r=Math.cos(n),u=Math.sin(n),i=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,s=Math.sin(t),l=s*i-c*o;return[Math.atan2(c*i+s*o,a*r+l*u),X(l*r-a*u)]},e}function cr(n,t){var e=Math.cos(n),r=Math.sin(n);return function(u,i,o,a){var c=o*t;null!=u?(u=sr(e,u),i=sr(e,i),(o>0?i>u:u>i)&&(u+=o*ka)):(u=n+o*ka,i=n-.5*c);for(var s,l=u;o>0?l>i:i>l;l-=c)a.point((s=ve([e,-r*Math.cos(l),-r*Math.sin(l)]))[0],s[1])}}function sr(n,t){var e=se(t);e[0]-=n,pe(e);var r=V(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Aa)%(2*Math.PI)}function lr(n,t,e){var r=Xo.range(n,t-Aa,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function fr(n,t,e){var r=Xo.range(n,t-Aa,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function hr(n){return n.source}function gr(n){return n.target}function pr(n,t,e,r){var u=Math.cos(t),i=Math.sin(t),o=Math.cos(r),a=Math.sin(r),c=u*Math.cos(n),s=u*Math.sin(n),l=o*Math.cos(e),f=o*Math.sin(e),h=2*Math.asin(Math.sqrt(J(r-t)+u*o*J(e-n))),g=1/Math.sin(h),p=h?function(n){var t=Math.sin(n*=h)*g,e=Math.sin(h-n)*g,r=e*c+t*l,u=e*s+t*f,o=e*i+t*a;return[Math.atan2(u,r)*La,Math.atan2(o,Math.sqrt(r*r+u*u))*La]}:function(){return[n*La,t*La]};return p.distance=h,p}function vr(){function n(n,u){var i=Math.sin(u*=Na),o=Math.cos(u),a=oa((n*=Na)-t),c=Math.cos(a);Uc+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*i-e*o*c)*a),e*i+r*o*c),t=n,e=i,r=o}var t,e,r;jc.point=function(u,i){t=u*Na,e=Math.sin(i*=Na),r=Math.cos(i),jc.point=n},jc.lineEnd=function(){jc.point=jc.lineEnd=g}}function dr(n,t){function e(t,e){var r=Math.cos(t),u=Math.cos(e),i=n(r*u);return[i*u*Math.sin(t),i*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),u=t(r),i=Math.sin(u),o=Math.cos(u);return[Math.atan2(n*i,r*o),Math.asin(r&&e*i/r)]},e}function mr(n,t){function e(n,t){var e=oa(oa(t)-Ea)<Aa?0:o/Math.pow(u(t),i);return[e*Math.sin(i*n),o-e*Math.cos(i*n)]}var r=Math.cos(n),u=function(n){return Math.tan(Sa/4+n/2)},i=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(u(t)/u(n)),o=r*Math.pow(u(n),i)/i;return i?(e.invert=function(n,t){var e=o-t,r=I(i)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/i,2*Math.atan(Math.pow(o/r,1/i))-Ea]},e):xr}function yr(n,t){function e(n,t){var e=i-t;return[e*Math.sin(u*n),i-e*Math.cos(u*n)]}var r=Math.cos(n),u=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),i=r/u+n;return oa(u)<Aa?er:(e.invert=function(n,t){var e=i-t;return[Math.atan2(n,e)/u,i-I(u)*Math.sqrt(n*n+e*e)]},e)}function xr(n,t){return[n,Math.log(Math.tan(Sa/4+t/2))]}function Mr(n){var t,e=Qe(n),r=e.scale,u=e.translate,i=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=u.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=i.apply(e,arguments);if(o===e){if(t=null==n){var a=Sa*r(),c=u();i([[c[0]-a,c[1]-a],[c[0]+a,c[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function _r(n,t){return[Math.log(Math.tan(Sa/4+t/2)),-n]}function br(n){return n[0]}function wr(n){return n[1]}function Sr(n){for(var t=n.length,e=[0,1],r=2,u=2;t>u;u++){for(;r>1&&Z(n[e[r-2]],n[e[r-1]],n[u])<=0;)--r;e[r++]=u}return e.slice(0,r)}function kr(n,t){return n[0]-t[0]||n[1]-t[1]}function Er(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Ar(n,t,e,r){var u=n[0],i=e[0],o=t[0]-u,a=r[0]-i,c=n[1],s=e[1],l=t[1]-c,f=r[1]-s,h=(a*(c-s)-f*(u-i))/(f*o-a*l);return[u+h*o,c+h*l]}function Cr(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Nr(){Jr(this),this.edge=this.site=this.circle=null}function Lr(n){var t=Jc.pop()||new Nr;return t.site=n,t}function Tr(n){Or(n),$c.remove(n),Jc.push(n),Jr(n)}function qr(n){var t=n.circle,e=t.x,r=t.cy,u={x:e,y:r},i=n.P,o=n.N,a=[n];Tr(n);for(var c=i;c.circle&&oa(e-c.circle.x)<Aa&&oa(r-c.circle.cy)<Aa;)i=c.P,a.unshift(c),Tr(c),c=i;a.unshift(c),Or(c);for(var s=o;s.circle&&oa(e-s.circle.x)<Aa&&oa(r-s.circle.cy)<Aa;)o=s.N,a.push(s),Tr(s),s=o;a.push(s),Or(s);var l,f=a.length;for(l=1;f>l;++l)s=a[l],c=a[l-1],$r(s.edge,c.site,s.site,u);c=a[0],s=a[f-1],s.edge=Vr(c.site,s.site,null,u),Fr(c),Fr(s)}function zr(n){for(var t,e,r,u,i=n.x,o=n.y,a=$c._;a;)if(r=Rr(a,o)-i,r>Aa)a=a.L;else{if(u=i-Dr(a,o),!(u>Aa)){r>-Aa?(t=a.P,e=a):u>-Aa?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var c=Lr(n);if($c.insert(t,c),t||e){if(t===e)return Or(t),e=Lr(t.site),$c.insert(c,e),c.edge=e.edge=Vr(t.site,c.site),Fr(t),Fr(e),void 0;if(!e)return c.edge=Vr(t.site,c.site),void 0;Or(t),Or(e);var s=t.site,l=s.x,f=s.y,h=n.x-l,g=n.y-f,p=e.site,v=p.x-l,d=p.y-f,m=2*(h*d-g*v),y=h*h+g*g,x=v*v+d*d,M={x:(d*y-g*x)/m+l,y:(h*x-v*y)/m+f};$r(e.edge,s,p,M),c.edge=Vr(s,n,null,M),e.edge=Vr(n,p,null,M),Fr(t),Fr(e)}}function Rr(n,t){var e=n.site,r=e.x,u=e.y,i=u-t;if(!i)return r;var o=n.P;if(!o)return-1/0;e=o.site;var a=e.x,c=e.y,s=c-t;if(!s)return a;var l=a-r,f=1/i-1/s,h=l/s;return f?(-h+Math.sqrt(h*h-2*f*(l*l/(-2*s)-c+s/2+u-i/2)))/f+r:(r+a)/2}function Dr(n,t){var e=n.N;if(e)return Rr(e,t);var r=n.site;return r.y===t?r.x:1/0}function Pr(n){this.site=n,this.edges=[]}function Ur(n){for(var t,e,r,u,i,o,a,c,s,l,f=n[0][0],h=n[1][0],g=n[0][1],p=n[1][1],v=Xc,d=v.length;d--;)if(i=v[d],i&&i.prepare())for(a=i.edges,c=a.length,o=0;c>o;)l=a[o].end(),r=l.x,u=l.y,s=a[++o%c].start(),t=s.x,e=s.y,(oa(r-t)>Aa||oa(u-e)>Aa)&&(a.splice(o,0,new Br(Xr(i.site,l,oa(r-f)<Aa&&p-u>Aa?{x:f,y:oa(t-f)<Aa?e:p}:oa(u-p)<Aa&&h-r>Aa?{x:oa(e-p)<Aa?t:h,y:p}:oa(r-h)<Aa&&u-g>Aa?{x:h,y:oa(t-h)<Aa?e:g}:oa(u-g)<Aa&&r-f>Aa?{x:oa(e-g)<Aa?t:f,y:g}:null),i.site,null)),++c)}function jr(n,t){return t.angle-n.angle}function Hr(){Jr(this),this.x=this.y=this.arc=this.site=this.cy=null}function Fr(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,u=n.site,i=e.site;if(r!==i){var o=u.x,a=u.y,c=r.x-o,s=r.y-a,l=i.x-o,f=i.y-a,h=2*(c*f-s*l);if(!(h>=-Ca)){var g=c*c+s*s,p=l*l+f*f,v=(f*g-s*p)/h,d=(c*p-l*g)/h,f=d+a,m=Gc.pop()||new Hr;m.arc=n,m.site=u,m.x=v+o,m.y=f+Math.sqrt(v*v+d*d),m.cy=f,n.circle=m;for(var y=null,x=Wc._;x;)if(m.y<x.y||m.y===x.y&&m.x<=x.x){if(!x.L){y=x.P;break}x=x.L}else{if(!x.R){y=x;break}x=x.R}Wc.insert(y,m),y||(Bc=m)}}}}function Or(n){var t=n.circle;t&&(t.P||(Bc=t.N),Wc.remove(t),Gc.push(t),Jr(t),n.circle=null)}function Yr(n){for(var t,e=Vc,r=De(n[0][0],n[0][1],n[1][0],n[1][1]),u=e.length;u--;)t=e[u],(!Ir(t,n)||!r(t)||oa(t.a.x-t.b.x)<Aa&&oa(t.a.y-t.b.y)<Aa)&&(t.a=t.b=null,e.splice(u,1))}function Ir(n,t){var e=n.b;if(e)return!0;var r,u,i=n.a,o=t[0][0],a=t[1][0],c=t[0][1],s=t[1][1],l=n.l,f=n.r,h=l.x,g=l.y,p=f.x,v=f.y,d=(h+p)/2,m=(g+v)/2;if(v===g){if(o>d||d>=a)return;if(h>p){if(i){if(i.y>=s)return}else i={x:d,y:c};e={x:d,y:s}}else{if(i){if(i.y<c)return}else i={x:d,y:s};e={x:d,y:c}}}else if(r=(h-p)/(v-g),u=m-r*d,-1>r||r>1)if(h>p){if(i){if(i.y>=s)return}else i={x:(c-u)/r,y:c};e={x:(s-u)/r,y:s}}else{if(i){if(i.y<c)return}else i={x:(s-u)/r,y:s};e={x:(c-u)/r,y:c}}else if(v>g){if(i){if(i.x>=a)return}else i={x:o,y:r*o+u};e={x:a,y:r*a+u}}else{if(i){if(i.x<o)return}else i={x:a,y:r*a+u};e={x:o,y:r*o+u}}return n.a=i,n.b=e,!0}function Zr(n,t){this.l=n,this.r=t,this.a=this.b=null}function Vr(n,t,e,r){var u=new Zr(n,t);return Vc.push(u),e&&$r(u,n,t,e),r&&$r(u,t,n,r),Xc[n.i].edges.push(new Br(u,n,t)),Xc[t.i].edges.push(new Br(u,t,n)),u}function Xr(n,t,e){var r=new Zr(n,null);return r.a=t,r.b=e,Vc.push(r),r}function $r(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function Br(n,t,e){var r=n.a,u=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(u.x-r.x,r.y-u.y):Math.atan2(r.x-u.x,u.y-r.y)}function Wr(){this._=null}function Jr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function Gr(n,t){var e=t,r=t.R,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function Kr(n,t){var e=t,r=t.L,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function Qr(n){for(;n.L;)n=n.L;return n}function nu(n,t){var e,r,u,i=n.sort(tu).pop();for(Vc=[],Xc=new Array(n.length),$c=new Wr,Wc=new Wr;;)if(u=Bc,i&&(!u||i.y<u.y||i.y===u.y&&i.x<u.x))(i.x!==e||i.y!==r)&&(Xc[i.i]=new Pr(i),zr(i),e=i.x,r=i.y),i=n.pop();else{if(!u)break;qr(u.arc)}t&&(Yr(t),Ur(t));var o={cells:Xc,edges:Vc};return $c=Wc=Vc=Xc=null,o}function tu(n,t){return t.y-n.y||t.x-n.x}function eu(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function ru(n){return n.x}function uu(n){return n.y}function iu(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function ou(n,t,e,r,u,i){if(!n(t,e,r,u,i)){var o=.5*(e+u),a=.5*(r+i),c=t.nodes;c[0]&&ou(n,c[0],e,r,o,a),c[1]&&ou(n,c[1],o,r,u,a),c[2]&&ou(n,c[2],e,a,o,i),c[3]&&ou(n,c[3],o,a,u,i)}}function au(n,t){n=Xo.rgb(n),t=Xo.rgb(t);var e=n.r,r=n.g,u=n.b,i=t.r-e,o=t.g-r,a=t.b-u;return function(n){return"#"+vt(Math.round(e+i*n))+vt(Math.round(r+o*n))+vt(Math.round(u+a*n))}}function cu(n,t){var e,r={},u={};for(e in n)e in t?r[e]=fu(n[e],t[e]):u[e]=n[e];for(e in t)e in n||(u[e]=t[e]);return function(n){for(e in r)u[e]=r[e](n);return u}}function su(n,t){return t-=n=+n,function(e){return n+t*e}}function lu(n,t){var e,r,u,i,o,a=0,c=0,s=[],l=[];for(n+="",t+="",Qc.lastIndex=0,r=0;e=Qc.exec(t);++r)e.index&&s.push(t.substring(a,c=e.index)),l.push({i:s.length,x:e[0]}),s.push(null),a=Qc.lastIndex;for(a<t.length&&s.push(t.substring(a)),r=0,i=l.length;(e=Qc.exec(n))&&i>r;++r)if(o=l[r],o.x==e[0]){if(o.i)if(null==s[o.i+1])for(s[o.i-1]+=o.x,s.splice(o.i,1),u=r+1;i>u;++u)l[u].i--;else for(s[o.i-1]+=o.x+s[o.i+1],s.splice(o.i,2),u=r+1;i>u;++u)l[u].i-=2;else if(null==s[o.i+1])s[o.i]=o.x;else for(s[o.i]=o.x+s[o.i+1],s.splice(o.i+1,1),u=r+1;i>u;++u)l[u].i--;l.splice(r,1),i--,r--}else o.x=su(parseFloat(e[0]),parseFloat(o.x));for(;i>r;)o=l.pop(),null==s[o.i+1]?s[o.i]=o.x:(s[o.i]=o.x+s[o.i+1],s.splice(o.i+1,1)),i--;return 1===s.length?null==s[0]?(o=l[0].x,function(n){return o(n)+""}):function(){return t}:function(n){for(r=0;i>r;++r)s[(o=l[r]).i]=o.x(n);return s.join("")}}function fu(n,t){for(var e,r=Xo.interpolators.length;--r>=0&&!(e=Xo.interpolators[r](n,t)););return e}function hu(n,t){var e,r=[],u=[],i=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(fu(n[e],t[e]));for(;i>e;++e)u[e]=n[e];for(;o>e;++e)u[e]=t[e];return function(n){for(e=0;a>e;++e)u[e]=r[e](n);return u}}function gu(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function pu(n){return function(t){return 1-n(1-t)}}function vu(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function du(n){return n*n}function mu(n){return n*n*n}function yu(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function xu(n){return function(t){return Math.pow(t,n)}}function Mu(n){return 1-Math.cos(n*Ea)}function _u(n){return Math.pow(2,10*(n-1))}function bu(n){return 1-Math.sqrt(1-n*n)}function wu(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/ka*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*ka/t)}}function Su(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function ku(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Eu(n,t){n=Xo.hcl(n),t=Xo.hcl(t);var e=n.h,r=n.c,u=n.l,i=t.h-e,o=t.c-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return rt(e+i*n,r+o*n,u+a*n)+""}}function Au(n,t){n=Xo.hsl(n),t=Xo.hsl(t);var e=n.h,r=n.s,u=n.l,i=t.h-e,o=t.s-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return nt(e+i*n,r+o*n,u+a*n)+""}}function Cu(n,t){n=Xo.lab(n),t=Xo.lab(t);var e=n.l,r=n.a,u=n.b,i=t.l-e,o=t.a-r,a=t.b-u;return function(n){return ot(e+i*n,r+o*n,u+a*n)+""}}function Nu(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function Lu(n){var t=[n.a,n.b],e=[n.c,n.d],r=qu(t),u=Tu(t,e),i=qu(zu(e,t,-u))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,u*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*La,this.translate=[n.e,n.f],this.scale=[r,i],this.skew=i?Math.atan2(u,i)*La:0}function Tu(n,t){return n[0]*t[0]+n[1]*t[1]}function qu(n){var t=Math.sqrt(Tu(n,n));return t&&(n[0]/=t,n[1]/=t),t}function zu(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ru(n,t){var e,r=[],u=[],i=Xo.transform(n),o=Xo.transform(t),a=i.translate,c=o.translate,s=i.rotate,l=o.rotate,f=i.skew,h=o.skew,g=i.scale,p=o.scale;return a[0]!=c[0]||a[1]!=c[1]?(r.push("translate(",null,",",null,")"),u.push({i:1,x:su(a[0],c[0])},{i:3,x:su(a[1],c[1])})):c[0]||c[1]?r.push("translate("+c+")"):r.push(""),s!=l?(s-l>180?l+=360:l-s>180&&(s+=360),u.push({i:r.push(r.pop()+"rotate(",null,")")-2,x:su(s,l)})):l&&r.push(r.pop()+"rotate("+l+")"),f!=h?u.push({i:r.push(r.pop()+"skewX(",null,")")-2,x:su(f,h)}):h&&r.push(r.pop()+"skewX("+h+")"),g[0]!=p[0]||g[1]!=p[1]?(e=r.push(r.pop()+"scale(",null,",",null,")"),u.push({i:e-4,x:su(g[0],p[0])},{i:e-2,x:su(g[1],p[1])})):(1!=p[0]||1!=p[1])&&r.push(r.pop()+"scale("+p+")"),e=u.length,function(n){for(var t,i=-1;++i<e;)r[(t=u[i]).i]=t.x(n);return r.join("")}}function Du(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return(e-n)*t}}function Pu(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return Math.max(0,Math.min(1,(e-n)*t))}}function Uu(n){for(var t=n.source,e=n.target,r=Hu(t,e),u=[t];t!==r;)t=t.parent,u.push(t);for(var i=u.length;e!==r;)u.splice(i,0,e),e=e.parent;return u}function ju(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Hu(n,t){if(n===t)return n;for(var e=ju(n),r=ju(t),u=e.pop(),i=r.pop(),o=null;u===i;)o=u,u=e.pop(),i=r.pop();return o}function Fu(n){n.fixed|=2}function Ou(n){n.fixed&=-7}function Yu(n){n.fixed|=4,n.px=n.x,n.py=n.y}function Iu(n){n.fixed&=-5}function Zu(n,t,e){var r=0,u=0;if(n.charge=0,!n.leaf)for(var i,o=n.nodes,a=o.length,c=-1;++c<a;)i=o[c],null!=i&&(Zu(i,t,e),n.charge+=i.charge,r+=i.charge*i.cx,u+=i.charge*i.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var s=t*e[n.point.index];n.charge+=n.pointCharge=s,r+=s*n.point.x,u+=s*n.point.y}n.cx=r/n.charge,n.cy=u/n.charge}function Vu(n,t){return Xo.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=Wu,n}function Xu(n){return n.children}function $u(n){return n.value}function Bu(n,t){return t.value-n.value}function Wu(n){return Xo.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function Ju(n){return n.x}function Gu(n){return n.y}function Ku(n,t,e){n.y0=t,n.y=e}function Qu(n){return Xo.range(n.length)}function ni(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function ti(n){for(var t,e=1,r=0,u=n[0][1],i=n.length;i>e;++e)(t=n[e][1])>u&&(r=e,u=t);return r}function ei(n){return n.reduce(ri,0)}function ri(n,t){return n+t[1]}function ui(n,t){return ii(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function ii(n,t){for(var e=-1,r=+n[0],u=(n[1]-r)/t,i=[];++e<=t;)i[e]=u*e+r;return i}function oi(n){return[Xo.min(n),Xo.max(n)]}function ai(n,t){return n.parent==t.parent?1:2}function ci(n){var t=n.children;return t&&t.length?t[0]:n._tree.thread}function si(n){var t,e=n.children;return e&&(t=e.length)?e[t-1]:n._tree.thread}function li(n,t){var e=n.children;if(e&&(u=e.length))for(var r,u,i=-1;++i<u;)t(r=li(e[i],t),n)>0&&(n=r);return n}function fi(n,t){return n.x-t.x}function hi(n,t){return t.x-n.x}function gi(n,t){return n.depth-t.depth}function pi(n,t){function e(n,r){var u=n.children;if(u&&(o=u.length))for(var i,o,a=null,c=-1;++c<o;)i=u[c],e(i,a),a=i;t(n,r)}e(n,null)}function vi(n){for(var t,e=0,r=0,u=n.children,i=u.length;--i>=0;)t=u[i]._tree,t.prelim+=e,t.mod+=e,e+=t.shift+(r+=t.change)}function di(n,t,e){n=n._tree,t=t._tree;var r=e/(t.number-n.number);n.change+=r,t.change-=r,t.shift+=e,t.prelim+=e,t.mod+=e}function mi(n,t,e){return n._tree.ancestor.parent==t.parent?n._tree.ancestor:e}function yi(n,t){return n.value-t.value}function xi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Mi(n,t){n._pack_next=t,t._pack_prev=n}function _i(n,t){var e=t.x-n.x,r=t.y-n.y,u=n.r+t.r;return.999*u*u>e*e+r*r}function bi(n){function t(n){l=Math.min(n.x-n.r,l),f=Math.max(n.x+n.r,f),h=Math.min(n.y-n.r,h),g=Math.max(n.y+n.r,g)}if((e=n.children)&&(s=e.length)){var e,r,u,i,o,a,c,s,l=1/0,f=-1/0,h=1/0,g=-1/0;if(e.forEach(wi),r=e[0],r.x=-r.r,r.y=0,t(r),s>1&&(u=e[1],u.x=u.r,u.y=0,t(u),s>2))for(i=e[2],Ei(r,u,i),t(i),xi(r,i),r._pack_prev=i,xi(i,u),u=r._pack_next,o=3;s>o;o++){Ei(r,u,i=e[o]);var p=0,v=1,d=1;for(a=u._pack_next;a!==u;a=a._pack_next,v++)if(_i(a,i)){p=1;break}if(1==p)for(c=r._pack_prev;c!==a._pack_prev&&!_i(c,i);c=c._pack_prev,d++);p?(d>v||v==d&&u.r<r.r?Mi(r,u=a):Mi(r=c,u),o--):(xi(r,i),u=i,t(i))}var m=(l+f)/2,y=(h+g)/2,x=0;for(o=0;s>o;o++)i=e[o],i.x-=m,i.y-=y,x=Math.max(x,i.r+Math.sqrt(i.x*i.x+i.y*i.y));n.r=x,e.forEach(Si)}}function wi(n){n._pack_next=n._pack_prev=n}function Si(n){delete n._pack_next,delete n._pack_prev}function ki(n,t,e,r){var u=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,u)for(var i=-1,o=u.length;++i<o;)ki(u[i],t,e,r)}function Ei(n,t,e){var r=n.r+e.r,u=t.x-n.x,i=t.y-n.y;if(r&&(u||i)){var o=t.r+e.r,a=u*u+i*i;o*=o,r*=r;var c=.5+(r-o)/(2*a),s=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+c*u+s*i,e.y=n.y+c*i-s*u}else e.x=n.x+r,e.y=n.y}function Ai(n){return 1+Xo.max(n,function(n){return n.y})}function Ci(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Ni(n){var t=n.children;return t&&t.length?Ni(t[0]):n}function Li(n){var t,e=n.children;return e&&(t=e.length)?Li(e[t-1]):n}function Ti(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function qi(n,t){var e=n.x+t[3],r=n.y+t[0],u=n.dx-t[1]-t[3],i=n.dy-t[0]-t[2];return 0>u&&(e+=u/2,u=0),0>i&&(r+=i/2,i=0),{x:e,y:r,dx:u,dy:i}}function zi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Ri(n){return n.rangeExtent?n.rangeExtent():zi(n.range())}function Di(n,t,e,r){var u=e(n[0],n[1]),i=r(t[0],t[1]);return function(n){return i(u(n))}}function Pi(n,t){var e,r=0,u=n.length-1,i=n[r],o=n[u];return i>o&&(e=r,r=u,u=e,e=i,i=o,o=e),n[r]=t.floor(i),n[u]=t.ceil(o),n}function Ui(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:ls}function ji(n,t,e,r){var u=[],i=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)u.push(e(n[o-1],n[o])),i.push(r(t[o-1],t[o]));return function(t){var e=Xo.bisect(n,t,1,a)-1;return i[e](u[e](t))}}function Hi(n,t,e,r){function u(){var u=Math.min(n.length,t.length)>2?ji:Di,c=r?Pu:Du;return o=u(n,t,c,e),a=u(t,n,c,fu),i}function i(n){return o(n)}var o,a;return i.invert=function(n){return a(n)},i.domain=function(t){return arguments.length?(n=t.map(Number),u()):n},i.range=function(n){return arguments.length?(t=n,u()):t},i.rangeRound=function(n){return i.range(n).interpolate(Nu)},i.clamp=function(n){return arguments.length?(r=n,u()):r},i.interpolate=function(n){return arguments.length?(e=n,u()):e},i.ticks=function(t){return Ii(n,t)},i.tickFormat=function(t,e){return Zi(n,t,e)},i.nice=function(t){return Oi(n,t),u()},i.copy=function(){return Hi(n,t,e,r)},u()}function Fi(n,t){return Xo.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Oi(n,t){return Pi(n,Ui(Yi(n,t)[2]))}function Yi(n,t){null==t&&(t=10);var e=zi(n),r=e[1]-e[0],u=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),i=t/r*u;return.15>=i?u*=10:.35>=i?u*=5:.75>=i&&(u*=2),e[0]=Math.ceil(e[0]/u)*u,e[1]=Math.floor(e[1]/u)*u+.5*u,e[2]=u,e}function Ii(n,t){return Xo.range.apply(Xo,Yi(n,t))}function Zi(n,t,e){var r=Yi(n,t);return Xo.format(e?e.replace(Qa,function(n,t,e,u,i,o,a,c,s,l){return[t,e,u,i,o,a,c,s||"."+Xi(l,r),l].join("")}):",."+Vi(r[2])+"f")}function Vi(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function Xi(n,t){var e=Vi(t[2]);return n in fs?Math.abs(e-Vi(Math.max(Math.abs(t[0]),Math.abs(t[1]))))+ +("e"!==n):e-2*("%"===n)}function $i(n,t,e,r){function u(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function i(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(u(t))}return o.invert=function(t){return i(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(u)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(u)),o):t},o.nice=function(){var t=Pi(r.map(u),e?Math:gs);return n.domain(t),r=t.map(i),o},o.ticks=function(){var n=zi(r),o=[],a=n[0],c=n[1],s=Math.floor(u(a)),l=Math.ceil(u(c)),f=t%1?2:t;if(isFinite(l-s)){if(e){for(;l>s;s++)for(var h=1;f>h;h++)o.push(i(s)*h);o.push(i(s))}else for(o.push(i(s));s++<l;)for(var h=f-1;h>0;h--)o.push(i(s)*h);for(s=0;o[s]<a;s++);for(l=o.length;o[l-1]>c;l--);o=o.slice(s,l)}return o},o.tickFormat=function(n,t){if(!arguments.length)return hs;arguments.length<2?t=hs:"function"!=typeof t&&(t=Xo.format(t));var r,a=Math.max(.1,n/o.ticks().length),c=e?(r=1e-12,Math.ceil):(r=-1e-12,Math.floor);return function(n){return n/i(c(u(n)+r))<=a?t(n):""}},o.copy=function(){return $i(n.copy(),t,e,r)},Fi(o,n)}function Bi(n,t,e){function r(t){return n(u(t))}var u=Wi(t),i=Wi(1/t);return r.invert=function(t){return i(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(u)),r):e},r.ticks=function(n){return Ii(e,n)},r.tickFormat=function(n,t){return Zi(e,n,t)},r.nice=function(n){return r.domain(Oi(e,n))},r.exponent=function(o){return arguments.length?(u=Wi(t=o),i=Wi(1/t),n.domain(e.map(u)),r):t},r.copy=function(){return Bi(n.copy(),t,e)},Fi(r,n)}function Wi(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function Ji(n,t){function e(e){return o[((i.get(e)||"range"===t.t&&i.set(e,n.push(e)))-1)%o.length]}function r(t,e){return Xo.range(n.length).map(function(n){return t+e*n})}var i,o,a;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new u;for(var o,a=-1,c=r.length;++a<c;)i.has(o=r[a])||i.set(o,n.push(o));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(o=n,a=0,t={t:"range",a:arguments},e):o},e.rangePoints=function(u,i){arguments.length<2&&(i=0);var c=u[0],s=u[1],l=(s-c)/(Math.max(1,n.length-1)+i);return o=r(n.length<2?(c+s)/2:c+l*i/2,l),a=0,t={t:"rangePoints",a:arguments},e},e.rangeBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var s=u[1]<u[0],l=u[s-0],f=u[1-s],h=(f-l)/(n.length-i+2*c);return o=r(l+h*c,h),s&&o.reverse(),a=h*(1-i),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var s=u[1]<u[0],l=u[s-0],f=u[1-s],h=Math.floor((f-l)/(n.length-i+2*c)),g=f-l-(n.length-i)*h;return o=r(l+Math.round(g/2),h),s&&o.reverse(),a=Math.round(h*(1-i)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return a},e.rangeExtent=function(){return zi(t.a[0])},e.copy=function(){return Ji(n,t)},e.domain(n)}function Gi(n,t){function e(){var e=0,i=t.length;for(u=[];++e<i;)u[e-1]=Xo.quantile(n,e/i);return r}function r(n){return isNaN(n=+n)?void 0:t[Xo.bisect(u,n)]}var u;return r.domain=function(t){return arguments.length?(n=t.filter(function(n){return!isNaN(n)}).sort(Xo.ascending),e()):n},r.range=function(n){return arguments.length?(t=n,e()):t},r.quantiles=function(){return u},r.invertExtent=function(e){return e=t.indexOf(e),0>e?[0/0,0/0]:[e>0?u[e-1]:n[0],e<u.length?u[e]:n[n.length-1]]},r.copy=function(){return Gi(n,t)},e()}function Ki(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(i*(t-n))))]}function u(){return i=e.length/(t-n),o=e.length-1,r}var i,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],u()):[n,t]},r.range=function(n){return arguments.length?(e=n,u()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?0/0:t/i+n,[t,t+1/i]},r.copy=function(){return Ki(n,t,e)},u()}function Qi(n,t){function e(e){return e>=e?t[Xo.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return Qi(n,t)},e}function no(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Ii(n,t)},t.tickFormat=function(t,e){return Zi(n,t,e)},t.copy=function(){return no(n)},t}function to(n){return n.innerRadius}function eo(n){return n.outerRadius}function ro(n){return n.startAngle}function uo(n){return n.endAngle}function io(n){function t(t){function o(){s.push("M",i(n(l),a))}for(var c,s=[],l=[],f=-1,h=t.length,g=_t(e),p=_t(r);++f<h;)u.call(this,c=t[f],f)?l.push([+g.call(this,c,f),+p.call(this,c,f)]):l.length&&(o(),l=[]);return l.length&&o(),s.length?s.join(""):null}var e=br,r=wr,u=be,i=oo,o=i.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(u=n,t):u},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?i=n:(i=Ms.get(n)||oo).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function oo(n){return n.join("L")}function ao(n){return oo(n)+"Z"}function co(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&u.push("H",r[0]),u.join("")}function so(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("V",(r=n[t])[1],"H",r[0]);return u.join("")}function lo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r=n[t])[0],"V",r[1]);return u.join("")}function fo(n,t){return n.length<4?oo(n):n[1]+po(n.slice(1,n.length-1),vo(n,t))}function ho(n,t){return n.length<3?oo(n):n[0]+po((n.push(n[0]),n),vo([n[n.length-2]].concat(n,[n[1]]),t))}function go(n,t){return n.length<3?oo(n):n[0]+po(n,vo(n,t))}function po(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return oo(n);var e=n.length!=t.length,r="",u=n[0],i=n[1],o=t[0],a=o,c=1;if(e&&(r+="Q"+(i[0]-2*o[0]/3)+","+(i[1]-2*o[1]/3)+","+i[0]+","+i[1],u=n[1],c=2),t.length>1){a=t[1],i=n[c],c++,r+="C"+(u[0]+o[0])+","+(u[1]+o[1])+","+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1];for(var s=2;s<t.length;s++,c++)i=n[c],a=t[s],r+="S"+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1]}if(e){var l=n[c];r+="Q"+(i[0]+2*a[0]/3)+","+(i[1]+2*a[1]/3)+","+l[0]+","+l[1]}return r}function vo(n,t){for(var e,r=[],u=(1-t)/2,i=n[0],o=n[1],a=1,c=n.length;++a<c;)e=i,i=o,o=n[a],r.push([u*(o[0]-e[0]),u*(o[1]-e[1])]);return r}function mo(n){if(n.length<3)return oo(n);var t=1,e=n.length,r=n[0],u=r[0],i=r[1],o=[u,u,u,(r=n[1])[0]],a=[i,i,i,r[1]],c=[u,",",i,"L",_o(ws,o),",",_o(ws,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),bo(c,o,a);return n.pop(),c.push("L",r),c.join("")}function yo(n){if(n.length<4)return oo(n);for(var t,e=[],r=-1,u=n.length,i=[0],o=[0];++r<3;)t=n[r],i.push(t[0]),o.push(t[1]);for(e.push(_o(ws,i)+","+_o(ws,o)),--r;++r<u;)t=n[r],i.shift(),i.push(t[0]),o.shift(),o.push(t[1]),bo(e,i,o);return e.join("")}function xo(n){for(var t,e,r=-1,u=n.length,i=u+4,o=[],a=[];++r<4;)e=n[r%u],o.push(e[0]),a.push(e[1]);for(t=[_o(ws,o),",",_o(ws,a)],--r;++r<i;)e=n[r%u],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),bo(t,o,a);return t.join("")}function Mo(n,t){var e=n.length-1;if(e)for(var r,u,i=n[0][0],o=n[0][1],a=n[e][0]-i,c=n[e][1]-o,s=-1;++s<=e;)r=n[s],u=s/e,r[0]=t*r[0]+(1-t)*(i+u*a),r[1]=t*r[1]+(1-t)*(o+u*c);return mo(n)}function _o(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function bo(n,t,e){n.push("C",_o(_s,t),",",_o(_s,e),",",_o(bs,t),",",_o(bs,e),",",_o(ws,t),",",_o(ws,e))}function wo(n,t){return(t[1]-n[1])/(t[0]-n[0])}function So(n){for(var t=0,e=n.length-1,r=[],u=n[0],i=n[1],o=r[0]=wo(u,i);++t<e;)r[t]=(o+(o=wo(u=i,i=n[t+1])))/2;return r[t]=o,r}function ko(n){for(var t,e,r,u,i=[],o=So(n),a=-1,c=n.length-1;++a<c;)t=wo(n[a],n[a+1]),oa(t)<Aa?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,u=e*e+r*r,u>9&&(u=3*t/Math.sqrt(u),o[a]=u*e,o[a+1]=u*r));for(a=-1;++a<=c;)u=(n[Math.min(c,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),i.push([u||0,o[a]*u||0]);return i}function Eo(n){return n.length<3?oo(n):n[0]+po(n,ko(n))}function Ao(n){for(var t,e,r,u=-1,i=n.length;++u<i;)t=n[u],e=t[0],r=t[1]+ys,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Co(n){function t(t){function c(){v.push("M",a(n(m),f),l,s(n(d.reverse()),f),"Z")}for(var h,g,p,v=[],d=[],m=[],y=-1,x=t.length,M=_t(e),_=_t(u),b=e===r?function(){return g}:_t(r),w=u===i?function(){return p}:_t(i);++y<x;)o.call(this,h=t[y],y)?(d.push([g=+M.call(this,h,y),p=+_.call(this,h,y)]),m.push([+b.call(this,h,y),+w.call(this,h,y)])):d.length&&(c(),d=[],m=[]);return d.length&&c(),v.length?v.join(""):null}var e=br,r=br,u=0,i=wr,o=be,a=oo,c=a.key,s=a,l="L",f=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(u=i=n,t):i},t.y0=function(n){return arguments.length?(u=n,t):u},t.y1=function(n){return arguments.length?(i=n,t):i},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(c="function"==typeof n?a=n:(a=Ms.get(n)||oo).key,s=a.reverse||a,l=a.closed?"M":"L",t):c},t.tension=function(n){return arguments.length?(f=n,t):f},t}function No(n){return n.radius}function Lo(n){return[n.x,n.y]}function To(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]+ys;return[e*Math.cos(r),e*Math.sin(r)]}}function qo(){return 64}function zo(){return"circle"}function Ro(n){var t=Math.sqrt(n/Sa);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Do(n,t){return fa(n,Ns),n.id=t,n}function Po(n,t,e,r){var u=n.id;return R(n,"function"==typeof e?function(n,i,o){n.__transition__[u].tween.set(t,r(e.call(n,n.__data__,i,o)))}:(e=r(e),function(n){n.__transition__[u].tween.set(t,e)}))}function Uo(n){return null==n&&(n=""),function(){this.textContent=n}}function jo(n,t,e,r){var i=n.__transition__||(n.__transition__={active:0,count:0}),o=i[e];if(!o){var a=r.time;o=i[e]={tween:new u,time:a,ease:r.ease,delay:r.delay,duration:r.duration},++i.count,Xo.timer(function(r){function u(r){return i.active>e?s():(i.active=e,o.event&&o.event.start.call(n,l,t),o.tween.forEach(function(e,r){(r=r.call(n,l,t))&&v.push(r)}),Xo.timer(function(){return p.c=c(r||1)?be:c,1},0,a),void 0)}function c(r){if(i.active!==e)return s();for(var u=r/g,a=f(u),c=v.length;c>0;)v[--c].call(n,a);return u>=1?(o.event&&o.event.end.call(n,l,t),s()):void 0}function s(){return--i.count?delete i[e]:delete n.__transition__,1}var l=n.__data__,f=o.ease,h=o.delay,g=o.duration,p=Ja,v=[];return p.t=h+a,r>=h?u(r-h):(p.c=u,void 0)},0,a)}}function Ho(n,t){n.attr("transform",function(n){return"translate("+t(n)+",0)"})}function Fo(n,t){n.attr("transform",function(n){return"translate(0,"+t(n)+")"})}function Oo(n){return n.toISOString()}function Yo(n,t,e){function r(t){return n(t)}function u(n,e){var r=n[1]-n[0],u=r/e,i=Xo.bisect(js,u);return i==js.length?[t.year,Yi(n.map(function(n){return n/31536e6}),e)[2]]:i?t[u/js[i-1]<js[i]/u?i-1:i]:[Os,Yi(n,e)[2]]
}return r.invert=function(t){return Io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(Io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,Io(+e+1),t).length}var i=r.domain(),o=zi(i),a=null==n?u(o,10):"number"==typeof n&&u(o,n);return a&&(n=a[0],t=a[1]),r.domain(Pi(i,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=Io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=Io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=zi(r.domain()),i=null==n?u(e,10):"number"==typeof n?u(e,n):!n.range&&[{range:n},t];return i&&(n=i[0],t=i[1]),n.range(e[0],Io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return Yo(n.copy(),t,e)},Fi(r,n)}function Io(n){return new Date(n)}function Zo(n){return JSON.parse(n.responseText)}function Vo(n){var t=Wo.createRange();return t.selectNode(Wo.body),t.createContextualFragment(n.responseText)}var Xo={version:"3.4.3"};Date.now||(Date.now=function(){return+new Date});var $o=[].slice,Bo=function(n){return $o.call(n)},Wo=document,Jo=Wo.documentElement,Go=window;try{Bo(Jo.childNodes)[0].nodeType}catch(Ko){Bo=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}try{Wo.createElement("div").style.setProperty("opacity",0,"")}catch(Qo){var na=Go.Element.prototype,ta=na.setAttribute,ea=na.setAttributeNS,ra=Go.CSSStyleDeclaration.prototype,ua=ra.setProperty;na.setAttribute=function(n,t){ta.call(this,n,t+"")},na.setAttributeNS=function(n,t,e){ea.call(this,n,t,e+"")},ra.setProperty=function(n,t,e){ua.call(this,n,t+"",e)}}Xo.ascending=function(n,t){return t>n?-1:n>t?1:n>=t?0:0/0},Xo.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:0/0},Xo.min=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i&&!(null!=(e=n[u])&&e>=e);)e=void 0;for(;++u<i;)null!=(r=n[u])&&e>r&&(e=r)}else{for(;++u<i&&!(null!=(e=t.call(n,n[u],u))&&e>=e);)e=void 0;for(;++u<i;)null!=(r=t.call(n,n[u],u))&&e>r&&(e=r)}return e},Xo.max=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i&&!(null!=(e=n[u])&&e>=e);)e=void 0;for(;++u<i;)null!=(r=n[u])&&r>e&&(e=r)}else{for(;++u<i&&!(null!=(e=t.call(n,n[u],u))&&e>=e);)e=void 0;for(;++u<i;)null!=(r=t.call(n,n[u],u))&&r>e&&(e=r)}return e},Xo.extent=function(n,t){var e,r,u,i=-1,o=n.length;if(1===arguments.length){for(;++i<o&&!(null!=(e=u=n[i])&&e>=e);)e=u=void 0;for(;++i<o;)null!=(r=n[i])&&(e>r&&(e=r),r>u&&(u=r))}else{for(;++i<o&&!(null!=(e=u=t.call(n,n[i],i))&&e>=e);)e=void 0;for(;++i<o;)null!=(r=t.call(n,n[i],i))&&(e>r&&(e=r),r>u&&(u=r))}return[e,u]},Xo.sum=function(n,t){var e,r=0,u=n.length,i=-1;if(1===arguments.length)for(;++i<u;)isNaN(e=+n[i])||(r+=e);else for(;++i<u;)isNaN(e=+t.call(n,n[i],i))||(r+=e);return r},Xo.mean=function(t,e){var r,u=t.length,i=0,o=-1,a=0;if(1===arguments.length)for(;++o<u;)n(r=t[o])&&(i+=(r-i)/++a);else for(;++o<u;)n(r=e.call(t,t[o],o))&&(i+=(r-i)/++a);return a?i:void 0},Xo.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),u=+n[r-1],i=e-r;return i?u+i*(n[r]-u):u},Xo.median=function(t,e){return arguments.length>1&&(t=t.map(e)),t=t.filter(n),t.length?Xo.quantile(t.sort(Xo.ascending),.5):void 0},Xo.bisector=function(n){return{left:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n.call(t,t[i],i)<e?r=i+1:u=i}return r},right:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;e<n.call(t,t[i],i)?u=i:r=i+1}return r}}};var ia=Xo.bisector(function(n){return n});Xo.bisectLeft=ia.left,Xo.bisect=Xo.bisectRight=ia.right,Xo.shuffle=function(n){for(var t,e,r=n.length;r;)e=0|Math.random()*r--,t=n[r],n[r]=n[e],n[e]=t;return n},Xo.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},Xo.pairs=function(n){for(var t,e=0,r=n.length-1,u=n[0],i=new Array(0>r?0:r);r>e;)i[e]=[t=u,u=n[++e]];return i},Xo.zip=function(){if(!(u=arguments.length))return[];for(var n=-1,e=Xo.min(arguments,t),r=new Array(e);++n<e;)for(var u,i=-1,o=r[n]=new Array(u);++i<u;)o[i]=arguments[i][n];return r},Xo.transpose=function(n){return Xo.zip.apply(Xo,n)},Xo.keys=function(n){var t=[];for(var e in n)t.push(e);return t},Xo.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},Xo.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},Xo.merge=function(n){for(var t,e,r,u=n.length,i=-1,o=0;++i<u;)o+=n[i].length;for(e=new Array(o);--u>=0;)for(r=n[u],t=r.length;--t>=0;)e[--o]=r[t];return e};var oa=Math.abs;Xo.range=function(n,t,r){if(arguments.length<3&&(r=1,arguments.length<2&&(t=n,n=0)),1/0===(t-n)/r)throw new Error("infinite range");var u,i=[],o=e(oa(r)),a=-1;if(n*=o,t*=o,r*=o,0>r)for(;(u=n+r*++a)>t;)i.push(u/o);else for(;(u=n+r*++a)<t;)i.push(u/o);return i},Xo.map=function(n){var t=new u;if(n instanceof u)n.forEach(function(n,e){t.set(n,e)});else for(var e in n)t.set(e,n[e]);return t},r(u,{has:i,get:function(n){return this[aa+n]},set:function(n,t){return this[aa+n]=t},remove:o,keys:a,values:function(){var n=[];return this.forEach(function(t,e){n.push(e)}),n},entries:function(){var n=[];return this.forEach(function(t,e){n.push({key:t,value:e})}),n},size:c,empty:s,forEach:function(n){for(var t in this)t.charCodeAt(0)===ca&&n.call(this,t.substring(1),this[t])}});var aa="\x00",ca=aa.charCodeAt(0);Xo.nest=function(){function n(t,a,c){if(c>=o.length)return r?r.call(i,a):e?a.sort(e):a;for(var s,l,f,h,g=-1,p=a.length,v=o[c++],d=new u;++g<p;)(h=d.get(s=v(l=a[g])))?h.push(l):d.set(s,[l]);return t?(l=t(),f=function(e,r){l.set(e,n(t,r,c))}):(l={},f=function(e,r){l[e]=n(t,r,c)}),d.forEach(f),l}function t(n,e){if(e>=o.length)return n;var r=[],u=a[e++];return n.forEach(function(n,u){r.push({key:n,values:t(u,e)})}),u?r.sort(function(n,t){return u(n.key,t.key)}):r}var e,r,i={},o=[],a=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(Xo.map,e,0),0)},i.key=function(n){return o.push(n),i},i.sortKeys=function(n){return a[o.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},Xo.set=function(n){var t=new l;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},r(l,{has:i,add:function(n){return this[aa+n]=!0,n},remove:function(n){return n=aa+n,n in this&&delete this[n]},values:a,size:c,empty:s,forEach:function(n){for(var t in this)t.charCodeAt(0)===ca&&n.call(this,t.substring(1))}}),Xo.behavior={},Xo.rebind=function(n,t){for(var e,r=1,u=arguments.length;++r<u;)n[e=arguments[r]]=f(n,t,t[e]);return n};var sa=["webkit","ms","moz","Moz","o","O"];Xo.dispatch=function(){for(var n=new p,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=v(n);return n},p.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.substring(e+1),n=n.substring(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},Xo.event=null,Xo.requote=function(n){return n.replace(la,"\\$&")};var la=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,fa={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},ha=function(n,t){return t.querySelector(n)},ga=function(n,t){return t.querySelectorAll(n)},pa=Jo[h(Jo,"matchesSelector")],va=function(n,t){return pa.call(n,t)};"function"==typeof Sizzle&&(ha=function(n,t){return Sizzle(n,t)[0]||null},ga=Sizzle,va=Sizzle.matchesSelector),Xo.selection=function(){return xa};var da=Xo.selection.prototype=[];da.select=function(n){var t,e,r,u,i=[];n=M(n);for(var o=-1,a=this.length;++o<a;){i.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var c=-1,s=r.length;++c<s;)(u=r[c])?(t.push(e=n.call(u,u.__data__,c,o)),e&&"__data__"in u&&(e.__data__=u.__data__)):t.push(null)}return x(i)},da.selectAll=function(n){var t,e,r=[];n=_(n);for(var u=-1,i=this.length;++u<i;)for(var o=this[u],a=-1,c=o.length;++a<c;)(e=o[a])&&(r.push(t=Bo(n.call(e,e.__data__,a,u))),t.parentNode=e);return x(r)};var ma={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};Xo.ns={prefix:ma,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&(e=n.substring(0,t),n=n.substring(t+1)),ma.hasOwnProperty(e)?{space:ma[e],local:n}:n}},da.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=Xo.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(b(t,n[t]));return this}return this.each(b(n,t))},da.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=k(n)).length,u=-1;if(t=e.classList){for(;++u<r;)if(!t.contains(n[u]))return!1}else for(t=e.getAttribute("class");++u<r;)if(!S(n[u]).test(t))return!1;return!0}for(t in n)this.each(E(t,n[t]));return this}return this.each(E(n,t))},da.style=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t="");for(e in n)this.each(C(e,n[e],t));return this}if(2>r)return Go.getComputedStyle(this.node(),null).getPropertyValue(n);e=""}return this.each(C(n,t,e))},da.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(N(t,n[t]));return this}return this.each(N(n,t))},da.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},da.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},da.append=function(n){return n=L(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},da.insert=function(n,t){return n=L(n),t=M(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},da.remove=function(){return this.each(function(){var n=this.parentNode;n&&n.removeChild(this)})},da.data=function(n,t){function e(n,e){var r,i,o,a=n.length,f=e.length,h=Math.min(a,f),g=new Array(f),p=new Array(f),v=new Array(a);if(t){var d,m=new u,y=new u,x=[];for(r=-1;++r<a;)d=t.call(i=n[r],i.__data__,r),m.has(d)?v[r]=i:m.set(d,i),x.push(d);for(r=-1;++r<f;)d=t.call(e,o=e[r],r),(i=m.get(d))?(g[r]=i,i.__data__=o):y.has(d)||(p[r]=T(o)),y.set(d,o),m.remove(d);for(r=-1;++r<a;)m.has(x[r])&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],o=e[r],i?(i.__data__=o,g[r]=i):p[r]=T(o);for(;f>r;++r)p[r]=T(e[r]);for(;a>r;++r)v[r]=n[r]}p.update=g,p.parentNode=g.parentNode=v.parentNode=n.parentNode,c.push(p),s.push(g),l.push(v)}var r,i,o=-1,a=this.length;if(!arguments.length){for(n=new Array(a=(r=this[0]).length);++o<a;)(i=r[o])&&(n[o]=i.__data__);return n}var c=D([]),s=x([]),l=x([]);if("function"==typeof n)for(;++o<a;)e(r=this[o],n.call(r,r.parentNode.__data__,o));else for(;++o<a;)e(r=this[o],n);return s.enter=function(){return c},s.exit=function(){return l},s},da.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},da.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=q(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]),t.parentNode=(e=this[i]).parentNode;for(var a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return x(u)},da.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],u=r.length-1,i=r[u];--u>=0;)(e=r[u])&&(i&&i!==e.nextSibling&&i.parentNode.insertBefore(e,i),i=e);return this},da.sort=function(n){n=z.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},da.each=function(n){return R(this,function(t,e,r){n.call(t,t.__data__,e,r)})},da.call=function(n){var t=Bo(arguments);return n.apply(t[0]=this,t),this},da.empty=function(){return!this.node()},da.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,u=e.length;u>r;r++){var i=e[r];if(i)return i}return null},da.size=function(){var n=0;return this.each(function(){++n}),n};var ya=[];Xo.selection.enter=D,Xo.selection.enter.prototype=ya,ya.append=da.append,ya.empty=da.empty,ya.node=da.node,ya.call=da.call,ya.size=da.size,ya.select=function(n){for(var t,e,r,u,i,o=[],a=-1,c=this.length;++a<c;){r=(u=this[a]).update,o.push(t=[]),t.parentNode=u.parentNode;for(var s=-1,l=u.length;++s<l;)(i=u[s])?(t.push(r[s]=e=n.call(u.parentNode,i.__data__,s,a)),e.__data__=i.__data__):t.push(null)}return x(o)},ya.insert=function(n,t){return arguments.length<2&&(t=P(this)),da.insert.call(this,n,t)},da.transition=function(){for(var n,t,e=ks||++Ls,r=[],u=Es||{time:Date.now(),ease:yu,delay:0,duration:250},i=-1,o=this.length;++i<o;){r.push(n=[]);for(var a=this[i],c=-1,s=a.length;++c<s;)(t=a[c])&&jo(t,c,e,u),n.push(t)}return Do(r,e)},da.interrupt=function(){return this.each(U)},Xo.select=function(n){var t=["string"==typeof n?ha(n,Wo):n];return t.parentNode=Jo,x([t])},Xo.selectAll=function(n){var t=Bo("string"==typeof n?ga(n,Wo):n);return t.parentNode=Jo,x([t])};var xa=Xo.select(Jo);da.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(j(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(j(n,t,e))};var Ma=Xo.map({mouseenter:"mouseover",mouseleave:"mouseout"});Ma.forEach(function(n){"on"+n in Wo&&Ma.remove(n)});var _a="onselectstart"in Wo?null:h(Jo.style,"userSelect"),ba=0;Xo.mouse=function(n){return Y(n,m())};var wa=/WebKit/.test(Go.navigator.userAgent)?-1:0;Xo.touches=function(n,t){return arguments.length<2&&(t=m().touches),t?Bo(t).map(function(t){var e=Y(n,t);return e.identifier=t.identifier,e}):[]},Xo.behavior.drag=function(){function n(){this.on("mousedown.drag",o).on("touchstart.drag",a)}function t(){return Xo.event.changedTouches[0].identifier}function e(n,t){return Xo.touches(n).filter(function(n){return n.identifier===t})[0]}function r(n,t,e,r){return function(){function o(){var n=t(l,g),e=n[0]-v[0],r=n[1]-v[1];d|=e|r,v=n,f({type:"drag",x:n[0]+c[0],y:n[1]+c[1],dx:e,dy:r})}function a(){m.on(e+"."+p,null).on(r+"."+p,null),y(d&&Xo.event.target===h),f({type:"dragend"})}var c,s=this,l=s.parentNode,f=u.of(s,arguments),h=Xo.event.target,g=n(),p=null==g?"drag":"drag-"+g,v=t(l,g),d=0,m=Xo.select(Go).on(e+"."+p,o).on(r+"."+p,a),y=O();i?(c=i.apply(s,arguments),c=[c.x-v[0],c.y-v[1]]):c=[0,0],f({type:"dragstart"})}}var u=y(n,"drag","dragstart","dragend"),i=null,o=r(g,Xo.mouse,"mousemove","mouseup"),a=r(t,e,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},Xo.rebind(n,u,"on")};var Sa=Math.PI,ka=2*Sa,Ea=Sa/2,Aa=1e-6,Ca=Aa*Aa,Na=Sa/180,La=180/Sa,Ta=Math.SQRT2,qa=2,za=4;Xo.interpolateZoom=function(n,t){function e(n){var t=n*y;if(m){var e=B(v),o=i/(qa*h)*(e*W(Ta*t+v)-$(v));return[r+o*s,u+o*l,i*e/B(Ta*t+v)]}return[r+n*s,u+n*l,i*Math.exp(Ta*t)]}var r=n[0],u=n[1],i=n[2],o=t[0],a=t[1],c=t[2],s=o-r,l=a-u,f=s*s+l*l,h=Math.sqrt(f),g=(c*c-i*i+za*f)/(2*i*qa*h),p=(c*c-i*i-za*f)/(2*c*qa*h),v=Math.log(Math.sqrt(g*g+1)-g),d=Math.log(Math.sqrt(p*p+1)-p),m=d-v,y=(m||Math.log(c/i))/Ta;return e.duration=1e3*y,e},Xo.behavior.zoom=function(){function n(n){n.on(A,s).on(Pa+".zoom",f).on(C,h).on("dblclick.zoom",g).on(L,l)}function t(n){return[(n[0]-S.x)/S.k,(n[1]-S.y)/S.k]}function e(n){return[n[0]*S.k+S.x,n[1]*S.k+S.y]}function r(n){S.k=Math.max(E[0],Math.min(E[1],n))}function u(n,t){t=e(t),S.x+=n[0]-t[0],S.y+=n[1]-t[1]}function i(){_&&_.domain(M.range().map(function(n){return(n-S.x)/S.k}).map(M.invert)),w&&w.domain(b.range().map(function(n){return(n-S.y)/S.k}).map(b.invert))}function o(n){n({type:"zoomstart"})}function a(n){i(),n({type:"zoom",scale:S.k,translate:[S.x,S.y]})}function c(n){n({type:"zoomend"})}function s(){function n(){l=1,u(Xo.mouse(r),g),a(i)}function e(){f.on(C,Go===r?h:null).on(N,null),p(l&&Xo.event.target===s),c(i)}var r=this,i=T.of(r,arguments),s=Xo.event.target,l=0,f=Xo.select(Go).on(C,n).on(N,e),g=t(Xo.mouse(r)),p=O();U.call(r),o(i)}function l(){function n(){var n=Xo.touches(g);return h=S.k,n.forEach(function(n){n.identifier in v&&(v[n.identifier]=t(n))}),n}function e(){for(var t=Xo.event.changedTouches,e=0,i=t.length;i>e;++e)v[t[e].identifier]=null;var o=n(),c=Date.now();if(1===o.length){if(500>c-x){var s=o[0],l=v[s.identifier];r(2*S.k),u(s,l),d(),a(p)}x=c}else if(o.length>1){var s=o[0],f=o[1],h=s[0]-f[0],g=s[1]-f[1];m=h*h+g*g}}function i(){for(var n,t,e,i,o=Xo.touches(g),c=0,s=o.length;s>c;++c,i=null)if(e=o[c],i=v[e.identifier]){if(t)break;n=e,t=i}if(i){var l=(l=e[0]-n[0])*l+(l=e[1]-n[1])*l,f=m&&Math.sqrt(l/m);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+i[0])/2,(t[1]+i[1])/2],r(f*h)}x=null,u(n,t),a(p)}function f(){if(Xo.event.touches.length){for(var t=Xo.event.changedTouches,e=0,r=t.length;r>e;++e)delete v[t[e].identifier];for(var u in v)return void n()}b.on(M,null).on(_,null),w.on(A,s).on(L,l),k(),c(p)}var h,g=this,p=T.of(g,arguments),v={},m=0,y=Xo.event.changedTouches[0].identifier,M="touchmove.zoom-"+y,_="touchend.zoom-"+y,b=Xo.select(Go).on(M,i).on(_,f),w=Xo.select(g).on(A,null).on(L,e),k=O();U.call(g),e(),o(p)}function f(){var n=T.of(this,arguments);m?clearTimeout(m):(U.call(this),o(n)),m=setTimeout(function(){m=null,c(n)},50),d();var e=v||Xo.mouse(this);p||(p=t(e)),r(Math.pow(2,.002*Ra())*S.k),u(e,p),a(n)}function h(){p=null}function g(){var n=T.of(this,arguments),e=Xo.mouse(this),i=t(e),s=Math.log(S.k)/Math.LN2;o(n),r(Math.pow(2,Xo.event.shiftKey?Math.ceil(s)-1:Math.floor(s)+1)),u(e,i),a(n),c(n)}var p,v,m,x,M,_,b,w,S={x:0,y:0,k:1},k=[960,500],E=Da,A="mousedown.zoom",C="mousemove.zoom",N="mouseup.zoom",L="touchstart.zoom",T=y(n,"zoomstart","zoom","zoomend");return n.event=function(n){n.each(function(){var n=T.of(this,arguments),t=S;ks?Xo.select(this).transition().each("start.zoom",function(){S=this.__chart__||{x:0,y:0,k:1},o(n)}).tween("zoom:zoom",function(){var e=k[0],r=k[1],u=e/2,i=r/2,o=Xo.interpolateZoom([(u-S.x)/S.k,(i-S.y)/S.k,e/S.k],[(u-t.x)/t.k,(i-t.y)/t.k,e/t.k]);return function(t){var r=o(t),c=e/r[2];this.__chart__=S={x:u-r[0]*c,y:i-r[1]*c,k:c},a(n)}}).each("end.zoom",function(){c(n)}):(this.__chart__=S,o(n),a(n),c(n))})},n.translate=function(t){return arguments.length?(S={x:+t[0],y:+t[1],k:S.k},i(),n):[S.x,S.y]},n.scale=function(t){return arguments.length?(S={x:S.x,y:S.y,k:+t},i(),n):S.k},n.scaleExtent=function(t){return arguments.length?(E=null==t?Da:[+t[0],+t[1]],n):E},n.center=function(t){return arguments.length?(v=t&&[+t[0],+t[1]],n):v},n.size=function(t){return arguments.length?(k=t&&[+t[0],+t[1]],n):k},n.x=function(t){return arguments.length?(_=t,M=t.copy(),S={x:0,y:0,k:1},n):_},n.y=function(t){return arguments.length?(w=t,b=t.copy(),S={x:0,y:0,k:1},n):w},Xo.rebind(n,T,"on")};var Ra,Da=[0,1/0],Pa="onwheel"in Wo?(Ra=function(){return-Xo.event.deltaY*(Xo.event.deltaMode?120:1)},"wheel"):"onmousewheel"in Wo?(Ra=function(){return Xo.event.wheelDelta},"mousewheel"):(Ra=function(){return-Xo.event.detail},"MozMousePixelScroll");G.prototype.toString=function(){return this.rgb()+""},Xo.hsl=function(n,t,e){return 1===arguments.length?n instanceof Q?K(n.h,n.s,n.l):dt(""+n,mt,K):K(+n,+t,+e)};var Ua=Q.prototype=new G;Ua.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),K(this.h,this.s,this.l/n)},Ua.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),K(this.h,this.s,n*this.l)},Ua.rgb=function(){return nt(this.h,this.s,this.l)},Xo.hcl=function(n,t,e){return 1===arguments.length?n instanceof et?tt(n.h,n.c,n.l):n instanceof it?at(n.l,n.a,n.b):at((n=yt((n=Xo.rgb(n)).r,n.g,n.b)).l,n.a,n.b):tt(+n,+t,+e)};var ja=et.prototype=new G;ja.brighter=function(n){return tt(this.h,this.c,Math.min(100,this.l+Ha*(arguments.length?n:1)))},ja.darker=function(n){return tt(this.h,this.c,Math.max(0,this.l-Ha*(arguments.length?n:1)))},ja.rgb=function(){return rt(this.h,this.c,this.l).rgb()},Xo.lab=function(n,t,e){return 1===arguments.length?n instanceof it?ut(n.l,n.a,n.b):n instanceof et?rt(n.l,n.c,n.h):yt((n=Xo.rgb(n)).r,n.g,n.b):ut(+n,+t,+e)};var Ha=18,Fa=.95047,Oa=1,Ya=1.08883,Ia=it.prototype=new G;Ia.brighter=function(n){return ut(Math.min(100,this.l+Ha*(arguments.length?n:1)),this.a,this.b)},Ia.darker=function(n){return ut(Math.max(0,this.l-Ha*(arguments.length?n:1)),this.a,this.b)},Ia.rgb=function(){return ot(this.l,this.a,this.b)},Xo.rgb=function(n,t,e){return 1===arguments.length?n instanceof pt?gt(n.r,n.g,n.b):dt(""+n,gt,nt):gt(~~n,~~t,~~e)};var Za=pt.prototype=new G;Za.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,u=30;return t||e||r?(t&&u>t&&(t=u),e&&u>e&&(e=u),r&&u>r&&(r=u),gt(Math.min(255,~~(t/n)),Math.min(255,~~(e/n)),Math.min(255,~~(r/n)))):gt(u,u,u)},Za.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),gt(~~(n*this.r),~~(n*this.g),~~(n*this.b))},Za.hsl=function(){return mt(this.r,this.g,this.b)},Za.toString=function(){return"#"+vt(this.r)+vt(this.g)+vt(this.b)};var Va=Xo.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});Va.forEach(function(n,t){Va.set(n,ft(t))}),Xo.functor=_t,Xo.xhr=wt(bt),Xo.dsv=function(n,t){function e(n,e,i){arguments.length<3&&(i=e,e=null);var o=St(n,t,null==e?r:u(e),i);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:u(n)):e},o}function r(n){return e.parse(n.responseText)}function u(n){return function(t){return e.parse(t.responseText,n)}}function i(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),c=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var u=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(u(n),e)}:u})},e.parseRows=function(n,t){function e(){if(l>=s)return o;if(u)return u=!1,i;var t=l;if(34===n.charCodeAt(t)){for(var e=t;e++<s;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}l=e+2;var r=n.charCodeAt(e+1);return 13===r?(u=!0,10===n.charCodeAt(e+2)&&++l):10===r&&(u=!0),n.substring(t+1,e).replace(/""/g,'"')}for(;s>l;){var r=n.charCodeAt(l++),a=1;if(10===r)u=!0;else if(13===r)u=!0,10===n.charCodeAt(l)&&(++l,++a);else if(r!==c)continue;return n.substring(t,l-a)}return n.substring(t)}for(var r,u,i={},o={},a=[],s=n.length,l=0,f=0;(r=e())!==o;){for(var h=[];r!==i&&r!==o;)h.push(r),r=e();(!t||(h=t(h,f++)))&&a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new l,u=[];return t.forEach(function(n){for(var t in n)r.has(t)||u.push(r.add(t))}),[u.map(o).join(n)].concat(t.map(function(t){return u.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(i).join("\n")},e},Xo.csv=Xo.dsv(",","text/csv"),Xo.tsv=Xo.dsv("	","text/tab-separated-values");var Xa,$a,Ba,Wa,Ja,Ga=Go[h(Go,"requestAnimationFrame")]||function(n){setTimeout(n,17)};Xo.timer=function(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var u=e+t,i={c:n,t:u,f:!1,n:null};$a?$a.n=i:Xa=i,$a=i,Ba||(Wa=clearTimeout(Wa),Ba=1,Ga(Et))},Xo.timer.flush=function(){At(),Ct()},Xo.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var Ka=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Lt);Xo.formatPrefix=function(n,t){var e=0;return n&&(0>n&&(n*=-1),t&&(n=Xo.round(n,Nt(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((0>=e?e+1:e-1)/3)))),Ka[8+e/3]};var Qa=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,nc=Xo.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=Xo.round(n,Nt(n,t))).toFixed(Math.max(0,Math.min(20,Nt(n*(1+1e-15),t))))}}),tc=Xo.time={},ec=Date;zt.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){rc.setUTCDate.apply(this._,arguments)},setDay:function(){rc.setUTCDay.apply(this._,arguments)},setFullYear:function(){rc.setUTCFullYear.apply(this._,arguments)},setHours:function(){rc.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){rc.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){rc.setUTCMinutes.apply(this._,arguments)},setMonth:function(){rc.setUTCMonth.apply(this._,arguments)},setSeconds:function(){rc.setUTCSeconds.apply(this._,arguments)},setTime:function(){rc.setTime.apply(this._,arguments)}};var rc=Date.prototype;tc.year=Rt(function(n){return n=tc.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),tc.years=tc.year.range,tc.years.utc=tc.year.utc.range,tc.day=Rt(function(n){var t=new ec(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),tc.days=tc.day.range,tc.days.utc=tc.day.utc.range,tc.dayOfYear=function(n){var t=tc.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=tc[n]=Rt(function(n){return(n=tc.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=tc.year(n).getDay();return Math.floor((tc.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});tc[n+"s"]=e.range,tc[n+"s"].utc=e.utc.range,tc[n+"OfYear"]=function(n){var e=tc.year(n).getDay();return Math.floor((tc.dayOfYear(n)+(e+t)%7)/7)}}),tc.week=tc.sunday,tc.weeks=tc.sunday.range,tc.weeks.utc=tc.sunday.utc.range,tc.weekOfYear=tc.sundayOfYear;var uc={"-":"",_:" ",0:"0"},ic=/^\s*\d+/,oc=/^%/;Xo.locale=function(n){return{numberFormat:Tt(n),timeFormat:Pt(n)}};var ac=Xo.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});Xo.format=ac.numberFormat,Xo.geo={},re.prototype={s:0,t:0,add:function(n){ue(n,this.t,cc),ue(cc.s,this.s,this),this.s?this.t+=cc.t:this.s=cc.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var cc=new re;Xo.geo.stream=function(n,t){n&&sc.hasOwnProperty(n.type)?sc[n.type](n,t):ie(n,t)};var sc={Feature:function(n,t){ie(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,u=e.length;++r<u;)ie(e[r].geometry,t)}},lc={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){oe(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)oe(e[r],t,0)},Polygon:function(n,t){ae(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)ae(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,u=e.length;++r<u;)ie(e[r],t)}};Xo.geo.area=function(n){return fc=0,Xo.geo.stream(n,gc),fc};var fc,hc=new re,gc={sphere:function(){fc+=4*Sa},point:g,lineStart:g,lineEnd:g,polygonStart:function(){hc.reset(),gc.lineStart=ce},polygonEnd:function(){var n=2*hc;fc+=0>n?4*Sa+n:n,gc.lineStart=gc.lineEnd=gc.point=g}};Xo.geo.bounds=function(){function n(n,t){x.push(M=[l=n,h=n]),f>t&&(f=t),t>g&&(g=t)}function t(t,e){var r=se([t*Na,e*Na]);if(m){var u=fe(m,r),i=[u[1],-u[0],0],o=fe(i,u);pe(o),o=ve(o);var c=t-p,s=c>0?1:-1,v=o[0]*La*s,d=oa(c)>180;if(d^(v>s*p&&s*t>v)){var y=o[1]*La;y>g&&(g=y)}else if(v=(v+360)%360-180,d^(v>s*p&&s*t>v)){var y=-o[1]*La;f>y&&(f=y)}else f>e&&(f=e),e>g&&(g=e);d?p>t?a(l,t)>a(l,h)&&(h=t):a(t,h)>a(l,h)&&(l=t):h>=l?(l>t&&(l=t),t>h&&(h=t)):t>p?a(l,t)>a(l,h)&&(h=t):a(t,h)>a(l,h)&&(l=t)}else n(t,e);m=r,p=t}function e(){_.point=t}function r(){M[0]=l,M[1]=h,_.point=n,m=null}function u(n,e){if(m){var r=n-p;y+=oa(r)>180?r+(r>0?360:-360):r}else v=n,d=e;gc.point(n,e),t(n,e)}function i(){gc.lineStart()}function o(){u(v,d),gc.lineEnd(),oa(y)>Aa&&(l=-(h=180)),M[0]=l,M[1]=h,m=null}function a(n,t){return(t-=n)<0?t+360:t}function c(n,t){return n[0]-t[0]}function s(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var l,f,h,g,p,v,d,m,y,x,M,_={point:n,lineStart:e,lineEnd:r,polygonStart:function(){_.point=u,_.lineStart=i,_.lineEnd=o,y=0,gc.polygonStart()},polygonEnd:function(){gc.polygonEnd(),_.point=n,_.lineStart=e,_.lineEnd=r,0>hc?(l=-(h=180),f=-(g=90)):y>Aa?g=90:-Aa>y&&(f=-90),M[0]=l,M[1]=h}};return function(n){g=h=-(l=f=1/0),x=[],Xo.geo.stream(n,_);
var t=x.length;if(t){x.sort(c);for(var e,r=1,u=x[0],i=[u];t>r;++r)e=x[r],s(e[0],u)||s(e[1],u)?(a(u[0],e[1])>a(u[0],u[1])&&(u[1]=e[1]),a(e[0],u[1])>a(u[0],u[1])&&(u[0]=e[0])):i.push(u=e);for(var o,e,p=-1/0,t=i.length-1,r=0,u=i[t];t>=r;u=e,++r)e=i[r],(o=a(u[1],e[0]))>p&&(p=o,l=e[0],h=u[1])}return x=M=null,1/0===l||1/0===f?[[0/0,0/0],[0/0,0/0]]:[[l,f],[h,g]]}}(),Xo.geo.centroid=function(n){pc=vc=dc=mc=yc=xc=Mc=_c=bc=wc=Sc=0,Xo.geo.stream(n,kc);var t=bc,e=wc,r=Sc,u=t*t+e*e+r*r;return Ca>u&&(t=xc,e=Mc,r=_c,Aa>vc&&(t=dc,e=mc,r=yc),u=t*t+e*e+r*r,Ca>u)?[0/0,0/0]:[Math.atan2(e,t)*La,X(r/Math.sqrt(u))*La]};var pc,vc,dc,mc,yc,xc,Mc,_c,bc,wc,Sc,kc={sphere:g,point:me,lineStart:xe,lineEnd:Me,polygonStart:function(){kc.lineStart=_e},polygonEnd:function(){kc.lineStart=xe}},Ec=Ee(be,Te,ze,[-Sa,-Sa/2]),Ac=1e9;Xo.geo.clipExtent=function(){var n,t,e,r,u,i,o={stream:function(n){return u&&(u.valid=!1),u=i(n),u.valid=!0,u},extent:function(a){return arguments.length?(i=Pe(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),u&&(u.valid=!1,u=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(Xo.geo.conicEqualArea=function(){return je(He)}).raw=He,Xo.geo.albers=function(){return Xo.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},Xo.geo.albersUsa=function(){function n(n){var i=n[0],o=n[1];return t=null,e(i,o),t||(r(i,o),t)||u(i,o),t}var t,e,r,u,i=Xo.geo.albers(),o=Xo.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=Xo.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),c={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=i.scale(),e=i.translate(),r=(n[0]-e[0])/t,u=(n[1]-e[1])/t;return(u>=.12&&.234>u&&r>=-.425&&-.214>r?o:u>=.166&&.234>u&&r>=-.214&&-.115>r?a:i).invert(n)},n.stream=function(n){var t=i.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,u){t.point(n,u),e.point(n,u),r.point(n,u)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(i.precision(t),o.precision(t),a.precision(t),n):i.precision()},n.scale=function(t){return arguments.length?(i.scale(t),o.scale(.35*t),a.scale(t),n.translate(i.translate())):i.scale()},n.translate=function(t){if(!arguments.length)return i.translate();var s=i.scale(),l=+t[0],f=+t[1];return e=i.translate(t).clipExtent([[l-.455*s,f-.238*s],[l+.455*s,f+.238*s]]).stream(c).point,r=o.translate([l-.307*s,f+.201*s]).clipExtent([[l-.425*s+Aa,f+.12*s+Aa],[l-.214*s-Aa,f+.234*s-Aa]]).stream(c).point,u=a.translate([l-.205*s,f+.212*s]).clipExtent([[l-.214*s+Aa,f+.166*s+Aa],[l-.115*s-Aa,f+.234*s-Aa]]).stream(c).point,n},n.scale(1070)};var Cc,Nc,Lc,Tc,qc,zc,Rc={point:g,lineStart:g,lineEnd:g,polygonStart:function(){Nc=0,Rc.lineStart=Fe},polygonEnd:function(){Rc.lineStart=Rc.lineEnd=Rc.point=g,Cc+=oa(Nc/2)}},Dc={point:Oe,lineStart:g,lineEnd:g,polygonStart:g,polygonEnd:g},Pc={point:Ze,lineStart:Ve,lineEnd:Xe,polygonStart:function(){Pc.lineStart=$e},polygonEnd:function(){Pc.point=Ze,Pc.lineStart=Ve,Pc.lineEnd=Xe}};Xo.geo.path=function(){function n(n){return n&&("function"==typeof a&&i.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=u(i)),Xo.geo.stream(n,o)),i.result()}function t(){return o=null,n}var e,r,u,i,o,a=4.5;return n.area=function(n){return Cc=0,Xo.geo.stream(n,u(Rc)),Cc},n.centroid=function(n){return dc=mc=yc=xc=Mc=_c=bc=wc=Sc=0,Xo.geo.stream(n,u(Pc)),Sc?[bc/Sc,wc/Sc]:_c?[xc/_c,Mc/_c]:yc?[dc/yc,mc/yc]:[0/0,0/0]},n.bounds=function(n){return qc=zc=-(Lc=Tc=1/0),Xo.geo.stream(n,u(Dc)),[[Lc,Tc],[qc,zc]]},n.projection=function(n){return arguments.length?(u=(e=n)?n.stream||Je(n):bt,t()):e},n.context=function(n){return arguments.length?(i=null==(r=n)?new Ye:new Be(n),"function"!=typeof a&&i.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(i.pointRadius(+t),+t),n):a},n.projection(Xo.geo.albersUsa()).context(null)},Xo.geo.transform=function(n){return{stream:function(t){var e=new Ge(t);for(var r in n)e[r]=n[r];return e}}},Ge.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},Xo.geo.projection=Qe,Xo.geo.projectionMutator=nr,(Xo.geo.equirectangular=function(){return Qe(er)}).raw=er.invert=er,Xo.geo.rotation=function(n){function t(t){return t=n(t[0]*Na,t[1]*Na),t[0]*=La,t[1]*=La,t}return n=ur(n[0]%360*Na,n[1]*Na,n.length>2?n[2]*Na:0),t.invert=function(t){return t=n.invert(t[0]*Na,t[1]*Na),t[0]*=La,t[1]*=La,t},t},rr.invert=er,Xo.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=ur(-n[0]*Na,-n[1]*Na,0).invert,u=[];return e(null,null,1,{point:function(n,e){u.push(n=t(n,e)),n[0]*=La,n[1]*=La}}),{type:"Polygon",coordinates:[u]}}var t,e,r=[0,0],u=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=cr((t=+r)*Na,u*Na),n):t},n.precision=function(r){return arguments.length?(e=cr(t*Na,(u=+r)*Na),n):u},n.angle(90)},Xo.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Na,u=n[1]*Na,i=t[1]*Na,o=Math.sin(r),a=Math.cos(r),c=Math.sin(u),s=Math.cos(u),l=Math.sin(i),f=Math.cos(i);return Math.atan2(Math.sqrt((e=f*o)*e+(e=s*l-c*f*a)*e),c*l+s*f*a)},Xo.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return Xo.range(Math.ceil(i/d)*d,u,d).map(h).concat(Xo.range(Math.ceil(s/m)*m,c,m).map(g)).concat(Xo.range(Math.ceil(r/p)*p,e,p).filter(function(n){return oa(n%d)>Aa}).map(l)).concat(Xo.range(Math.ceil(a/v)*v,o,v).filter(function(n){return oa(n%m)>Aa}).map(f))}var e,r,u,i,o,a,c,s,l,f,h,g,p=10,v=p,d=90,m=360,y=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(i).concat(g(c).slice(1),h(u).reverse().slice(1),g(s).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(i=+t[0][0],u=+t[1][0],s=+t[0][1],c=+t[1][1],i>u&&(t=i,i=u,u=t),s>c&&(t=s,s=c,c=t),n.precision(y)):[[i,s],[u,c]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(y)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],m=+t[1],n):[d,m]},n.minorStep=function(t){return arguments.length?(p=+t[0],v=+t[1],n):[p,v]},n.precision=function(t){return arguments.length?(y=+t,l=lr(a,o,90),f=fr(r,e,y),h=lr(s,c,90),g=fr(i,u,y),n):y},n.majorExtent([[-180,-90+Aa],[180,90-Aa]]).minorExtent([[-180,-80-Aa],[180,80+Aa]])},Xo.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||u.apply(this,arguments)]}}var t,e,r=hr,u=gr;return n.distance=function(){return Xo.geo.distance(t||r.apply(this,arguments),e||u.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(u=t,e="function"==typeof t?null:t,n):u},n.precision=function(){return arguments.length?n:0},n},Xo.geo.interpolate=function(n,t){return pr(n[0]*Na,n[1]*Na,t[0]*Na,t[1]*Na)},Xo.geo.length=function(n){return Uc=0,Xo.geo.stream(n,jc),Uc};var Uc,jc={sphere:g,point:g,lineStart:vr,lineEnd:g,polygonStart:g,polygonEnd:g},Hc=dr(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(Xo.geo.azimuthalEqualArea=function(){return Qe(Hc)}).raw=Hc;var Fc=dr(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},bt);(Xo.geo.azimuthalEquidistant=function(){return Qe(Fc)}).raw=Fc,(Xo.geo.conicConformal=function(){return je(mr)}).raw=mr,(Xo.geo.conicEquidistant=function(){return je(yr)}).raw=yr;var Oc=dr(function(n){return 1/n},Math.atan);(Xo.geo.gnomonic=function(){return Qe(Oc)}).raw=Oc,xr.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Ea]},(Xo.geo.mercator=function(){return Mr(xr)}).raw=xr;var Yc=dr(function(){return 1},Math.asin);(Xo.geo.orthographic=function(){return Qe(Yc)}).raw=Yc;var Ic=dr(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(Xo.geo.stereographic=function(){return Qe(Ic)}).raw=Ic,_r.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Ea]},(Xo.geo.transverseMercator=function(){var n=Mr(_r),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[-n[1],n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},n.rotate([0,0])}).raw=_r,Xo.geom={},Xo.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,u=_t(e),i=_t(r),o=n.length,a=[],c=[];for(t=0;o>t;t++)a.push([+u.call(this,n[t],t),+i.call(this,n[t],t),t]);for(a.sort(kr),t=0;o>t;t++)c.push([a[t][0],-a[t][1]]);var s=Sr(a),l=Sr(c),f=l[0]===s[0],h=l[l.length-1]===s[s.length-1],g=[];for(t=s.length-1;t>=0;--t)g.push(n[a[s[t]][2]]);for(t=+f;t<l.length-h;++t)g.push(n[a[l[t]][2]]);return g}var e=br,r=wr;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},Xo.geom.polygon=function(n){return fa(n,Zc),n};var Zc=Xo.geom.polygon.prototype=[];Zc.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],u=0;++t<e;)n=r,r=this[t],u+=n[1]*r[0]-n[0]*r[1];return.5*u},Zc.centroid=function(n){var t,e,r=-1,u=this.length,i=0,o=0,a=this[u-1];for(arguments.length||(n=-1/(6*this.area()));++r<u;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],i+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[i*n,o*n]},Zc.clip=function(n){for(var t,e,r,u,i,o,a=Cr(n),c=-1,s=this.length-Cr(this),l=this[s-1];++c<s;){for(t=n.slice(),n.length=0,u=this[c],i=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Er(o,l,u)?(Er(i,l,u)||n.push(Ar(i,o,l,u)),n.push(o)):Er(i,l,u)&&n.push(Ar(i,o,l,u)),i=o;a&&n.push(n[0]),l=u}return n};var Vc,Xc,$c,Bc,Wc,Jc=[],Gc=[];Pr.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(jr),t.length},Br.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},Wr.prototype={insert:function(n,t){var e,r,u;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=Qr(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(u=r.R,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.R&&(Gr(this,e),n=e,e=n.U),e.C=!1,r.C=!0,Kr(this,r))):(u=r.L,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.L&&(Kr(this,e),n=e,e=n.U),e.C=!1,r.C=!0,Gr(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,u=n.U,i=n.L,o=n.R;if(e=i?o?Qr(o):i:o,u?u.L===n?u.L=e:u.R=e:this._=e,i&&o?(r=e.C,e.C=n.C,e.L=i,i.U=e,e!==o?(u=e.U,e.U=n.U,n=e.R,u.L=n,e.R=o,o.U=e):(e.U=u,u=e,n=e.R)):(r=n.C,n=e),n&&(n.U=u),!r){if(n&&n.C)return n.C=!1,void 0;do{if(n===this._)break;if(n===u.L){if(t=u.R,t.C&&(t.C=!1,u.C=!0,Gr(this,u),t=u.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,Kr(this,t),t=u.R),t.C=u.C,u.C=t.R.C=!1,Gr(this,u),n=this._;break}}else if(t=u.L,t.C&&(t.C=!1,u.C=!0,Kr(this,u),t=u.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,Gr(this,t),t=u.L),t.C=u.C,u.C=t.L.C=!1,Kr(this,u),n=this._;break}t.C=!0,n=u,u=u.U}while(!n.C);n&&(n.C=!1)}}},Xo.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],u=a[0][1],i=a[1][0],o=a[1][1];return nu(e(n),a).cells.forEach(function(e,a){var c=e.edges,s=e.site,l=t[a]=c.length?c.map(function(n){var t=n.start();return[t.x,t.y]}):s.x>=r&&s.x<=i&&s.y>=u&&s.y<=o?[[r,o],[i,o],[i,u],[r,u]]:[];l.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(i(n,t)/Aa)*Aa,y:Math.round(o(n,t)/Aa)*Aa,i:t}})}var r=br,u=wr,i=r,o=u,a=Kc;return n?t(n):(t.links=function(n){return nu(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return nu(e(n)).cells.forEach(function(e,r){for(var u,i,o=e.site,a=e.edges.sort(jr),c=-1,s=a.length,l=a[s-1].edge,f=l.l===o?l.r:l.l;++c<s;)u=l,i=f,l=a[c].edge,f=l.l===o?l.r:l.l,r<i.i&&r<f.i&&eu(o,i,f)<0&&t.push([n[r],n[i.i],n[f.i]])}),t},t.x=function(n){return arguments.length?(i=_t(r=n),t):r},t.y=function(n){return arguments.length?(o=_t(u=n),t):u},t.clipExtent=function(n){return arguments.length?(a=null==n?Kc:n,t):a===Kc?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===Kc?null:a&&a[1]},t)};var Kc=[[-1e6,-1e6],[1e6,1e6]];Xo.geom.delaunay=function(n){return Xo.geom.voronoi().triangles(n)},Xo.geom.quadtree=function(n,t,e,r,u){function i(n){function i(n,t,e,r,u,i,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var c=n.x,l=n.y;if(null!=c)if(oa(c-e)+oa(l-r)<.01)s(n,t,e,r,u,i,o,a);else{var f=n.point;n.x=n.y=n.point=null,s(n,f,c,l,u,i,o,a),s(n,t,e,r,u,i,o,a)}else n.x=e,n.y=r,n.point=t}else s(n,t,e,r,u,i,o,a)}function s(n,t,e,r,u,o,a,c){var s=.5*(u+a),l=.5*(o+c),f=e>=s,h=r>=l,g=(h<<1)+f;n.leaf=!1,n=n.nodes[g]||(n.nodes[g]=iu()),f?u=s:a=s,h?o=l:c=l,i(n,t,e,r,u,o,a,c)}var l,f,h,g,p,v,d,m,y,x=_t(a),M=_t(c);if(null!=t)v=t,d=e,m=r,y=u;else if(m=y=-(v=d=1/0),f=[],h=[],p=n.length,o)for(g=0;p>g;++g)l=n[g],l.x<v&&(v=l.x),l.y<d&&(d=l.y),l.x>m&&(m=l.x),l.y>y&&(y=l.y),f.push(l.x),h.push(l.y);else for(g=0;p>g;++g){var _=+x(l=n[g],g),b=+M(l,g);v>_&&(v=_),d>b&&(d=b),_>m&&(m=_),b>y&&(y=b),f.push(_),h.push(b)}var w=m-v,S=y-d;w>S?y=d+w:m=v+S;var k=iu();if(k.add=function(n){i(k,n,+x(n,++g),+M(n,g),v,d,m,y)},k.visit=function(n){ou(n,k,v,d,m,y)},g=-1,null==t){for(;++g<p;)i(k,n[g],f[g],h[g],v,d,m,y);--g}else n.forEach(k.add);return f=h=n=l=null,k}var o,a=br,c=wr;return(o=arguments.length)?(a=ru,c=uu,3===o&&(u=e,r=t,e=t=0),i(n)):(i.x=function(n){return arguments.length?(a=n,i):a},i.y=function(n){return arguments.length?(c=n,i):c},i.extent=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],u=+n[1][1]),i):null==t?null:[[t,e],[r,u]]},i.size=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=e=0,r=+n[0],u=+n[1]),i):null==t?null:[r-t,u-e]},i)},Xo.interpolateRgb=au,Xo.interpolateObject=cu,Xo.interpolateNumber=su,Xo.interpolateString=lu;var Qc=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;Xo.interpolate=fu,Xo.interpolators=[function(n,t){var e=typeof t;return("string"===e?Va.has(t)||/^(#|rgb\(|hsl\()/.test(t)?au:lu:t instanceof G?au:"object"===e?Array.isArray(t)?hu:cu:su)(n,t)}],Xo.interpolateArray=hu;var ns=function(){return bt},ts=Xo.map({linear:ns,poly:xu,quad:function(){return du},cubic:function(){return mu},sin:function(){return Mu},exp:function(){return _u},circle:function(){return bu},elastic:wu,back:Su,bounce:function(){return ku}}),es=Xo.map({"in":bt,out:pu,"in-out":vu,"out-in":function(n){return vu(pu(n))}});Xo.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.substring(0,t):n,r=t>=0?n.substring(t+1):"in";return e=ts.get(e)||ns,r=es.get(r)||bt,gu(r(e.apply(null,$o.call(arguments,1))))},Xo.interpolateHcl=Eu,Xo.interpolateHsl=Au,Xo.interpolateLab=Cu,Xo.interpolateRound=Nu,Xo.transform=function(n){var t=Wo.createElementNS(Xo.ns.prefix.svg,"g");return(Xo.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new Lu(e?e.matrix:rs)})(n)},Lu.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var rs={a:1,b:0,c:0,d:1,e:0,f:0};Xo.interpolateTransform=Ru,Xo.layout={},Xo.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Uu(n[e]));return t}},Xo.layout.chord=function(){function n(){var n,s,f,h,g,p={},v=[],d=Xo.range(i),m=[];for(e=[],r=[],n=0,h=-1;++h<i;){for(s=0,g=-1;++g<i;)s+=u[h][g];v.push(s),m.push(Xo.range(i)),n+=s}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&m.forEach(function(n,t){n.sort(function(n,e){return a(u[t][n],u[t][e])})}),n=(ka-l*i)/n,s=0,h=-1;++h<i;){for(f=s,g=-1;++g<i;){var y=d[h],x=m[y][g],M=u[y][x],_=s,b=s+=M*n;p[y+"-"+x]={index:y,subindex:x,startAngle:_,endAngle:b,value:M}}r[y]={index:y,startAngle:f,endAngle:s,value:(s-f)/n},s+=l}for(h=-1;++h<i;)for(g=h-1;++g<i;){var w=p[h+"-"+g],S=p[g+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}c&&t()}function t(){e.sort(function(n,t){return c((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,u,i,o,a,c,s={},l=0;return s.matrix=function(n){return arguments.length?(i=(u=n)&&u.length,e=r=null,s):u},s.padding=function(n){return arguments.length?(l=n,e=r=null,s):l},s.sortGroups=function(n){return arguments.length?(o=n,e=r=null,s):o},s.sortSubgroups=function(n){return arguments.length?(a=n,e=null,s):a},s.sortChords=function(n){return arguments.length?(c=n,e&&t(),s):c},s.chords=function(){return e||n(),e},s.groups=function(){return r||n(),r},s},Xo.layout.force=function(){function n(n){return function(t,e,r,u){if(t.point!==n){var i=t.cx-n.x,o=t.cy-n.y,a=u-e,c=i*i+o*o;if(c>a*a/d){if(p>c){var s=t.charge/c;n.px-=i*s,n.py-=o*s}return!0}if(t.point&&c&&p>c){var s=t.pointCharge/c;n.px-=i*s,n.py-=o*s}}return!t.charge}}function t(n){n.px=Xo.event.x,n.py=Xo.event.y,a.resume()}var e,r,u,i,o,a={},c=Xo.dispatch("start","tick","end"),s=[1,1],l=.9,f=us,h=is,g=-30,p=os,v=.1,d=.64,m=[],y=[];return a.tick=function(){if((r*=.99)<.005)return c.end({type:"end",alpha:r=0}),!0;var t,e,a,f,h,p,d,x,M,_=m.length,b=y.length;for(e=0;b>e;++e)a=y[e],f=a.source,h=a.target,x=h.x-f.x,M=h.y-f.y,(p=x*x+M*M)&&(p=r*i[e]*((p=Math.sqrt(p))-u[e])/p,x*=p,M*=p,h.x-=x*(d=f.weight/(h.weight+f.weight)),h.y-=M*d,f.x+=x*(d=1-d),f.y+=M*d);if((d=r*v)&&(x=s[0]/2,M=s[1]/2,e=-1,d))for(;++e<_;)a=m[e],a.x+=(x-a.x)*d,a.y+=(M-a.y)*d;if(g)for(Zu(t=Xo.geom.quadtree(m),r,o),e=-1;++e<_;)(a=m[e]).fixed||t.visit(n(a));for(e=-1;++e<_;)a=m[e],a.fixed?(a.x=a.px,a.y=a.py):(a.x-=(a.px-(a.px=a.x))*l,a.y-=(a.py-(a.py=a.y))*l);c.tick({type:"tick",alpha:r})},a.nodes=function(n){return arguments.length?(m=n,a):m},a.links=function(n){return arguments.length?(y=n,a):y},a.size=function(n){return arguments.length?(s=n,a):s},a.linkDistance=function(n){return arguments.length?(f="function"==typeof n?n:+n,a):f},a.distance=a.linkDistance,a.linkStrength=function(n){return arguments.length?(h="function"==typeof n?n:+n,a):h},a.friction=function(n){return arguments.length?(l=+n,a):l},a.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,a):g},a.chargeDistance=function(n){return arguments.length?(p=n*n,a):Math.sqrt(p)},a.gravity=function(n){return arguments.length?(v=+n,a):v},a.theta=function(n){return arguments.length?(d=n*n,a):Math.sqrt(d)},a.alpha=function(n){return arguments.length?(n=+n,r?r=n>0?n:0:n>0&&(c.start({type:"start",alpha:r=n}),Xo.timer(a.tick)),a):r},a.start=function(){function n(n,r){if(!e){for(e=new Array(c),a=0;c>a;++a)e[a]=[];for(a=0;s>a;++a){var u=y[a];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var i,o=e[t],a=-1,s=o.length;++a<s;)if(!isNaN(i=o[a][n]))return i;return Math.random()*r}var t,e,r,c=m.length,l=y.length,p=s[0],v=s[1];for(t=0;c>t;++t)(r=m[t]).index=t,r.weight=0;for(t=0;l>t;++t)r=y[t],"number"==typeof r.source&&(r.source=m[r.source]),"number"==typeof r.target&&(r.target=m[r.target]),++r.source.weight,++r.target.weight;for(t=0;c>t;++t)r=m[t],isNaN(r.x)&&(r.x=n("x",p)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof f)for(t=0;l>t;++t)u[t]=+f.call(this,y[t],t);else for(t=0;l>t;++t)u[t]=f;if(i=[],"function"==typeof h)for(t=0;l>t;++t)i[t]=+h.call(this,y[t],t);else for(t=0;l>t;++t)i[t]=h;if(o=[],"function"==typeof g)for(t=0;c>t;++t)o[t]=+g.call(this,m[t],t);else for(t=0;c>t;++t)o[t]=g;return a.resume()},a.resume=function(){return a.alpha(.1)},a.stop=function(){return a.alpha(0)},a.drag=function(){return e||(e=Xo.behavior.drag().origin(bt).on("dragstart.force",Fu).on("drag.force",t).on("dragend.force",Ou)),arguments.length?(this.on("mouseover.force",Yu).on("mouseout.force",Iu).call(e),void 0):e},Xo.rebind(a,c,"on")};var us=20,is=1,os=1/0;Xo.layout.hierarchy=function(){function n(t,o,a){var c=u.call(e,t,o);if(t.depth=o,a.push(t),c&&(s=c.length)){for(var s,l,f=-1,h=t.children=new Array(s),g=0,p=o+1;++f<s;)l=h[f]=n(c[f],p,a),l.parent=t,g+=l.value;r&&h.sort(r),i&&(t.value=g)}else delete t.children,i&&(t.value=+i.call(e,t,o)||0);return t}function t(n,r){var u=n.children,o=0;if(u&&(a=u.length))for(var a,c=-1,s=r+1;++c<a;)o+=t(u[c],s);else i&&(o=+i.call(e,n,r)||0);return i&&(n.value=o),o}function e(t){var e=[];return n(t,0,e),e}var r=Bu,u=Xu,i=$u;return e.sort=function(n){return arguments.length?(r=n,e):r},e.children=function(n){return arguments.length?(u=n,e):u},e.value=function(n){return arguments.length?(i=n,e):i},e.revalue=function(n){return t(n,0),n},e},Xo.layout.partition=function(){function n(t,e,r,u){var i=t.children;if(t.x=e,t.y=t.depth*u,t.dx=r,t.dy=u,i&&(o=i.length)){var o,a,c,s=-1;for(r=t.value?r/t.value:0;++s<o;)n(a=i[s],e,c=a.value*r,u),e+=c}}function t(n){var e=n.children,r=0;if(e&&(u=e.length))for(var u,i=-1;++i<u;)r=Math.max(r,t(e[i]));return 1+r}function e(e,i){var o=r.call(this,e,i);return n(o[0],0,u[0],u[1]/t(o[0])),o}var r=Xo.layout.hierarchy(),u=[1,1];return e.size=function(n){return arguments.length?(u=n,e):u},Vu(e,r)},Xo.layout.pie=function(){function n(i){var o=i.map(function(e,r){return+t.call(n,e,r)}),a=+("function"==typeof r?r.apply(this,arguments):r),c=(("function"==typeof u?u.apply(this,arguments):u)-a)/Xo.sum(o),s=Xo.range(i.length);null!=e&&s.sort(e===as?function(n,t){return o[t]-o[n]}:function(n,t){return e(i[n],i[t])});var l=[];return s.forEach(function(n){var t;l[n]={data:i[n],value:t=o[n],startAngle:a,endAngle:a+=t*c}}),l}var t=Number,e=as,r=0,u=ka;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(u=t,n):u},n};var as={};Xo.layout.stack=function(){function n(a,c){var s=a.map(function(e,r){return t.call(n,e,r)}),l=s.map(function(t){return t.map(function(t,e){return[i.call(n,t,e),o.call(n,t,e)]})}),f=e.call(n,l,c);s=Xo.permute(s,f),l=Xo.permute(l,f);var h,g,p,v=r.call(n,l,c),d=s.length,m=s[0].length;for(g=0;m>g;++g)for(u.call(n,s[0][g],p=v[g],l[0][g][1]),h=1;d>h;++h)u.call(n,s[h][g],p+=l[h-1][g][1],l[h][g][1]);return a}var t=bt,e=Qu,r=ni,u=Ku,i=Ju,o=Gu;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:cs.get(t)||Qu,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:ss.get(t)||ni,n):r},n.x=function(t){return arguments.length?(i=t,n):i},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(u=t,n):u},n};var cs=Xo.map({"inside-out":function(n){var t,e,r=n.length,u=n.map(ti),i=n.map(ei),o=Xo.range(r).sort(function(n,t){return u[n]-u[t]}),a=0,c=0,s=[],l=[];for(t=0;r>t;++t)e=o[t],c>a?(a+=i[e],s.push(e)):(c+=i[e],l.push(e));return l.reverse().concat(s)},reverse:function(n){return Xo.range(n.length).reverse()},"default":Qu}),ss=Xo.map({silhouette:function(n){var t,e,r,u=n.length,i=n[0].length,o=[],a=0,c=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;i>e;++e)c[e]=(a-o[e])/2;return c},wiggle:function(n){var t,e,r,u,i,o,a,c,s,l=n.length,f=n[0],h=f.length,g=[];for(g[0]=c=s=0,e=1;h>e;++e){for(t=0,u=0;l>t;++t)u+=n[t][e][1];for(t=0,i=0,a=f[e][0]-f[e-1][0];l>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;i+=o*n[t][e][1]}g[e]=c-=u?i/u*a:0,s>c&&(s=c)}for(e=0;h>e;++e)g[e]-=s;return g},expand:function(n){var t,e,r,u=n.length,i=n[0].length,o=1/u,a=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];if(r)for(t=0;u>t;t++)n[t][e][1]/=r;else for(t=0;u>t;t++)n[t][e][1]=o}for(e=0;i>e;++e)a[e]=0;return a},zero:ni});Xo.layout.histogram=function(){function n(n,i){for(var o,a,c=[],s=n.map(e,this),l=r.call(this,s,i),f=u.call(this,l,s,i),i=-1,h=s.length,g=f.length-1,p=t?1:1/h;++i<g;)o=c[i]=[],o.dx=f[i+1]-(o.x=f[i]),o.y=0;if(g>0)for(i=-1;++i<h;)a=s[i],a>=l[0]&&a<=l[1]&&(o=c[Xo.bisect(f,a,1,g)-1],o.y+=p,o.push(n[i]));return c}var t=!0,e=Number,r=oi,u=ui;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=_t(t),n):r},n.bins=function(t){return arguments.length?(u="number"==typeof t?function(n){return ii(n,t)}:_t(t),n):u},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},Xo.layout.tree=function(){function n(n,i){function o(n,t){var r=n.children,u=n._tree;if(r&&(i=r.length)){for(var i,a,s,l=r[0],f=l,h=-1;++h<i;)s=r[h],o(s,a),f=c(s,a,f),a=s;vi(n);var g=.5*(l._tree.prelim+s._tree.prelim);t?(u.prelim=t._tree.prelim+e(n,t),u.mod=u.prelim-g):u.prelim=g}else t&&(u.prelim=t._tree.prelim+e(n,t))}function a(n,t){n.x=n._tree.prelim+t;var e=n.children;if(e&&(r=e.length)){var r,u=-1;for(t+=n._tree.mod;++u<r;)a(e[u],t)}}function c(n,t,r){if(t){for(var u,i=n,o=n,a=t,c=n.parent.children[0],s=i._tree.mod,l=o._tree.mod,f=a._tree.mod,h=c._tree.mod;a=si(a),i=ci(i),a&&i;)c=ci(c),o=si(o),o._tree.ancestor=n,u=a._tree.prelim+f-i._tree.prelim-s+e(a,i),u>0&&(di(mi(a,n,r),n,u),s+=u,l+=u),f+=a._tree.mod,s+=i._tree.mod,h+=c._tree.mod,l+=o._tree.mod;a&&!si(o)&&(o._tree.thread=a,o._tree.mod+=f-l),i&&!ci(c)&&(c._tree.thread=i,c._tree.mod+=s-h,r=n)}return r}var s=t.call(this,n,i),l=s[0];pi(l,function(n,t){n._tree={ancestor:n,prelim:0,mod:0,change:0,shift:0,number:t?t._tree.number+1:0}}),o(l),a(l,-l._tree.prelim);var f=li(l,hi),h=li(l,fi),g=li(l,gi),p=f.x-e(f,h)/2,v=h.x+e(h,f)/2,d=g.depth||1;return pi(l,u?function(n){n.x*=r[0],n.y=n.depth*r[1],delete n._tree}:function(n){n.x=(n.x-p)/(v-p)*r[0],n.y=n.depth/d*r[1],delete n._tree}),s}var t=Xo.layout.hierarchy().sort(null).value(null),e=ai,r=[1,1],u=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(u=null==(r=t),n):u?null:r},n.nodeSize=function(t){return arguments.length?(u=null!=(r=t),n):u?r:null},Vu(n,t)},Xo.layout.pack=function(){function n(n,i){var o=e.call(this,n,i),a=o[0],c=u[0],s=u[1],l=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,pi(a,function(n){n.r=+l(n.value)}),pi(a,bi),r){var f=r*(t?1:Math.max(2*a.r/c,2*a.r/s))/2;pi(a,function(n){n.r+=f}),pi(a,bi),pi(a,function(n){n.r-=f})}return ki(a,c/2,s/2,t?1:1/Math.max(2*a.r/c,2*a.r/s)),o}var t,e=Xo.layout.hierarchy().sort(yi),r=0,u=[1,1];return n.size=function(t){return arguments.length?(u=t,n):u},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},Vu(n,e)},Xo.layout.cluster=function(){function n(n,i){var o,a=t.call(this,n,i),c=a[0],s=0;pi(c,function(n){var t=n.children;t&&t.length?(n.x=Ci(t),n.y=Ai(t)):(n.x=o?s+=e(n,o):0,n.y=0,o=n)});var l=Ni(c),f=Li(c),h=l.x-e(l,f)/2,g=f.x+e(f,l)/2;return pi(c,u?function(n){n.x=(n.x-c.x)*r[0],n.y=(c.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(g-h)*r[0],n.y=(1-(c.y?n.y/c.y:1))*r[1]}),a}var t=Xo.layout.hierarchy().sort(null).value(null),e=ai,r=[1,1],u=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(u=null==(r=t),n):u?null:r},n.nodeSize=function(t){return arguments.length?(u=null!=(r=t),n):u?r:null},Vu(n,t)},Xo.layout.treemap=function(){function n(n,t){for(var e,r,u=-1,i=n.length;++u<i;)r=(e=n[u]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var i=e.children;if(i&&i.length){var o,a,c,s=f(e),l=[],h=i.slice(),p=1/0,v="slice"===g?s.dx:"dice"===g?s.dy:"slice-dice"===g?1&e.depth?s.dy:s.dx:Math.min(s.dx,s.dy);for(n(h,s.dx*s.dy/e.value),l.area=0;(c=h.length)>0;)l.push(o=h[c-1]),l.area+=o.area,"squarify"!==g||(a=r(l,v))<=p?(h.pop(),p=a):(l.area-=l.pop().area,u(l,v,s,!1),v=Math.min(s.dx,s.dy),l.length=l.area=0,p=1/0);l.length&&(u(l,v,s,!0),l.length=l.area=0),i.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var i,o=f(t),a=r.slice(),c=[];for(n(a,o.dx*o.dy/t.value),c.area=0;i=a.pop();)c.push(i),c.area+=i.area,null!=i.z&&(u(c,i.z?o.dx:o.dy,o,!a.length),c.length=c.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,u=0,i=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(i>e&&(i=e),e>u&&(u=e));return r*=r,t*=t,r?Math.max(t*u*p/r,r/(t*i*p)):1/0}function u(n,t,e,r){var u,i=-1,o=n.length,a=e.x,s=e.y,l=t?c(n.area/t):0;if(t==e.dx){for((r||l>e.dy)&&(l=e.dy);++i<o;)u=n[i],u.x=a,u.y=s,u.dy=l,a+=u.dx=Math.min(e.x+e.dx-a,l?c(u.area/l):0);u.z=!0,u.dx+=e.x+e.dx-a,e.y+=l,e.dy-=l}else{for((r||l>e.dx)&&(l=e.dx);++i<o;)u=n[i],u.x=a,u.y=s,u.dx=l,s+=u.dy=Math.min(e.y+e.dy-s,l?c(u.area/l):0);u.z=!1,u.dy+=e.y+e.dy-s,e.x+=l,e.dx-=l}}function i(r){var u=o||a(r),i=u[0];return i.x=0,i.y=0,i.dx=s[0],i.dy=s[1],o&&a.revalue(i),n([i],i.dx*i.dy/i.value),(o?e:t)(i),h&&(o=u),u}var o,a=Xo.layout.hierarchy(),c=Math.round,s=[1,1],l=null,f=Ti,h=!1,g="squarify",p=.5*(1+Math.sqrt(5));return i.size=function(n){return arguments.length?(s=n,i):s},i.padding=function(n){function t(t){var e=n.call(i,t,t.depth);return null==e?Ti(t):qi(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return qi(t,n)}if(!arguments.length)return l;var r;return f=null==(l=n)?Ti:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,i},i.round=function(n){return arguments.length?(c=n?Math.round:Number,i):c!=Number},i.sticky=function(n){return arguments.length?(h=n,o=null,i):h},i.ratio=function(n){return arguments.length?(p=n,i):p},i.mode=function(n){return arguments.length?(g=n+"",i):g},Vu(i,a)},Xo.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,u;do e=2*Math.random()-1,r=2*Math.random()-1,u=e*e+r*r;while(!u||u>1);return n+t*e*Math.sqrt(-2*Math.log(u)/u)}},logNormal:function(){var n=Xo.random.normal.apply(Xo,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=Xo.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},Xo.scale={};var ls={floor:bt,ceil:bt};Xo.scale.linear=function(){return Hi([0,1],[0,1],fu,!1)};var fs={s:1,g:1,p:1,r:1,e:1};Xo.scale.log=function(){return $i(Xo.scale.linear().domain([0,1]),10,!0,[1,10])};var hs=Xo.format(".0e"),gs={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};Xo.scale.pow=function(){return Bi(Xo.scale.linear(),1,[0,1])},Xo.scale.sqrt=function(){return Xo.scale.pow().exponent(.5)},Xo.scale.ordinal=function(){return Ji([],{t:"range",a:[[]]})},Xo.scale.category10=function(){return Xo.scale.ordinal().range(ps)},Xo.scale.category20=function(){return Xo.scale.ordinal().range(vs)},Xo.scale.category20b=function(){return Xo.scale.ordinal().range(ds)},Xo.scale.category20c=function(){return Xo.scale.ordinal().range(ms)};var ps=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(ht),vs=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(ht),ds=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(ht),ms=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(ht);Xo.scale.quantile=function(){return Gi([],[])},Xo.scale.quantize=function(){return Ki(0,1,[0,1])},Xo.scale.threshold=function(){return Qi([.5],[0,1])
},Xo.scale.identity=function(){return no([0,1])},Xo.svg={},Xo.svg.arc=function(){function n(){var n=t.apply(this,arguments),i=e.apply(this,arguments),o=r.apply(this,arguments)+ys,a=u.apply(this,arguments)+ys,c=(o>a&&(c=o,o=a,a=c),a-o),s=Sa>c?"0":"1",l=Math.cos(o),f=Math.sin(o),h=Math.cos(a),g=Math.sin(a);return c>=xs?n?"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"M0,"+n+"A"+n+","+n+" 0 1,0 0,"+-n+"A"+n+","+n+" 0 1,0 0,"+n+"Z":"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"Z":n?"M"+i*l+","+i*f+"A"+i+","+i+" 0 "+s+",1 "+i*h+","+i*g+"L"+n*h+","+n*g+"A"+n+","+n+" 0 "+s+",0 "+n*l+","+n*f+"Z":"M"+i*l+","+i*f+"A"+i+","+i+" 0 "+s+",1 "+i*h+","+i*g+"L0,0"+"Z"}var t=to,e=eo,r=ro,u=uo;return n.innerRadius=function(e){return arguments.length?(t=_t(e),n):t},n.outerRadius=function(t){return arguments.length?(e=_t(t),n):e},n.startAngle=function(t){return arguments.length?(r=_t(t),n):r},n.endAngle=function(t){return arguments.length?(u=_t(t),n):u},n.centroid=function(){var n=(t.apply(this,arguments)+e.apply(this,arguments))/2,i=(r.apply(this,arguments)+u.apply(this,arguments))/2+ys;return[Math.cos(i)*n,Math.sin(i)*n]},n};var ys=-Ea,xs=ka-Aa;Xo.svg.line=function(){return io(bt)};var Ms=Xo.map({linear:oo,"linear-closed":ao,step:co,"step-before":so,"step-after":lo,basis:mo,"basis-open":yo,"basis-closed":xo,bundle:Mo,cardinal:go,"cardinal-open":fo,"cardinal-closed":ho,monotone:Eo});Ms.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var _s=[0,2/3,1/3,0],bs=[0,1/3,2/3,0],ws=[0,1/6,2/3,1/6];Xo.svg.line.radial=function(){var n=io(Ao);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},so.reverse=lo,lo.reverse=so,Xo.svg.area=function(){return Co(bt)},Xo.svg.area.radial=function(){var n=Co(Ao);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},Xo.svg.chord=function(){function n(n,a){var c=t(this,i,n,a),s=t(this,o,n,a);return"M"+c.p0+r(c.r,c.p1,c.a1-c.a0)+(e(c,s)?u(c.r,c.p1,c.r,c.p0):u(c.r,c.p1,s.r,s.p0)+r(s.r,s.p1,s.a1-s.a0)+u(s.r,s.p1,c.r,c.p0))+"Z"}function t(n,t,e,r){var u=t.call(n,e,r),i=a.call(n,u,r),o=c.call(n,u,r)+ys,l=s.call(n,u,r)+ys;return{r:i,a0:o,a1:l,p0:[i*Math.cos(o),i*Math.sin(o)],p1:[i*Math.cos(l),i*Math.sin(l)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Sa)+",1 "+t}function u(n,t,e,r){return"Q 0,0 "+r}var i=hr,o=gr,a=No,c=ro,s=uo;return n.radius=function(t){return arguments.length?(a=_t(t),n):a},n.source=function(t){return arguments.length?(i=_t(t),n):i},n.target=function(t){return arguments.length?(o=_t(t),n):o},n.startAngle=function(t){return arguments.length?(c=_t(t),n):c},n.endAngle=function(t){return arguments.length?(s=_t(t),n):s},n},Xo.svg.diagonal=function(){function n(n,u){var i=t.call(this,n,u),o=e.call(this,n,u),a=(i.y+o.y)/2,c=[i,{x:i.x,y:a},{x:o.x,y:a},o];return c=c.map(r),"M"+c[0]+"C"+c[1]+" "+c[2]+" "+c[3]}var t=hr,e=gr,r=Lo;return n.source=function(e){return arguments.length?(t=_t(e),n):t},n.target=function(t){return arguments.length?(e=_t(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},Xo.svg.diagonal.radial=function(){var n=Xo.svg.diagonal(),t=Lo,e=n.projection;return n.projection=function(n){return arguments.length?e(To(t=n)):t},n},Xo.svg.symbol=function(){function n(n,r){return(Ss.get(t.call(this,n,r))||Ro)(e.call(this,n,r))}var t=zo,e=qo;return n.type=function(e){return arguments.length?(t=_t(e),n):t},n.size=function(t){return arguments.length?(e=_t(t),n):e},n};var Ss=Xo.map({circle:Ro,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Cs)),e=t*Cs;return"M0,"+-t+"L"+e+",0"+" 0,"+t+" "+-e+",0"+"Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/As),e=t*As/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/As),e=t*As/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});Xo.svg.symbolTypes=Ss.keys();var ks,Es,As=Math.sqrt(3),Cs=Math.tan(30*Na),Ns=[],Ls=0;Ns.call=da.call,Ns.empty=da.empty,Ns.node=da.node,Ns.size=da.size,Xo.transition=function(n){return arguments.length?ks?n.transition():n:xa.transition()},Xo.transition.prototype=Ns,Ns.select=function(n){var t,e,r,u=this.id,i=[];n=M(n);for(var o=-1,a=this.length;++o<a;){i.push(t=[]);for(var c=this[o],s=-1,l=c.length;++s<l;)(r=c[s])&&(e=n.call(r,r.__data__,s,o))?("__data__"in r&&(e.__data__=r.__data__),jo(e,s,u,r.__transition__[u]),t.push(e)):t.push(null)}return Do(i,u)},Ns.selectAll=function(n){var t,e,r,u,i,o=this.id,a=[];n=_(n);for(var c=-1,s=this.length;++c<s;)for(var l=this[c],f=-1,h=l.length;++f<h;)if(r=l[f]){i=r.__transition__[o],e=n.call(r,r.__data__,f,c),a.push(t=[]);for(var g=-1,p=e.length;++g<p;)(u=e[g])&&jo(u,g,o,i),t.push(u)}return Do(a,o)},Ns.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=q(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]);for(var e=this[i],a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return Do(u,this.id)},Ns.tween=function(n,t){var e=this.id;return arguments.length<2?this.node().__transition__[e].tween.get(n):R(this,null==t?function(t){t.__transition__[e].tween.remove(n)}:function(r){r.__transition__[e].tween.set(n,t)})},Ns.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function u(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function i(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?Ru:fu,a=Xo.ns.qualify(n);return Po(this,"attr."+n,t,a.local?i:u)},Ns.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(u));return r&&function(n){this.setAttribute(u,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(u.space,u.local));return r&&function(n){this.setAttributeNS(u.space,u.local,r(n))}}var u=Xo.ns.qualify(n);return this.tween("attr."+n,u.local?r:e)},Ns.style=function(n,t,e){function r(){this.style.removeProperty(n)}function u(t){return null==t?r:(t+="",function(){var r,u=Go.getComputedStyle(this,null).getPropertyValue(n);return u!==t&&(r=fu(u,t),function(t){this.style.setProperty(n,r(t),e)})})}var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(t="");for(e in n)this.style(e,n[e],t);return this}e=""}return Po(this,"style."+n,t,u)},Ns.styleTween=function(n,t,e){function r(r,u){var i=t.call(this,r,u,Go.getComputedStyle(this,null).getPropertyValue(n));return i&&function(t){this.style.setProperty(n,i(t),e)}}return arguments.length<3&&(e=""),this.tween("style."+n,r)},Ns.text=function(n){return Po(this,"text",n,Uo)},Ns.remove=function(){return this.each("end.transition",function(){var n;this.__transition__.count<2&&(n=this.parentNode)&&n.removeChild(this)})},Ns.ease=function(n){var t=this.id;return arguments.length<1?this.node().__transition__[t].ease:("function"!=typeof n&&(n=Xo.ease.apply(Xo,arguments)),R(this,function(e){e.__transition__[t].ease=n}))},Ns.delay=function(n){var t=this.id;return R(this,"function"==typeof n?function(e,r,u){e.__transition__[t].delay=+n.call(e,e.__data__,r,u)}:(n=+n,function(e){e.__transition__[t].delay=n}))},Ns.duration=function(n){var t=this.id;return R(this,"function"==typeof n?function(e,r,u){e.__transition__[t].duration=Math.max(1,n.call(e,e.__data__,r,u))}:(n=Math.max(1,n),function(e){e.__transition__[t].duration=n}))},Ns.each=function(n,t){var e=this.id;if(arguments.length<2){var r=Es,u=ks;ks=e,R(this,function(t,r,u){Es=t.__transition__[e],n.call(t,t.__data__,r,u)}),Es=r,ks=u}else R(this,function(r){var u=r.__transition__[e];(u.event||(u.event=Xo.dispatch("start","end"))).on(n,t)});return this},Ns.transition=function(){for(var n,t,e,r,u=this.id,i=++Ls,o=[],a=0,c=this.length;c>a;a++){o.push(n=[]);for(var t=this[a],s=0,l=t.length;l>s;s++)(e=t[s])&&(r=Object.create(e.__transition__[u]),r.delay+=r.duration,jo(e,s,i,r)),n.push(e)}return Do(o,i)},Xo.svg.axis=function(){function n(n){n.each(function(){var n,s=Xo.select(this),l=this.__chart__||e,f=this.__chart__=e.copy(),h=null==c?f.ticks?f.ticks.apply(f,a):f.domain():c,g=null==t?f.tickFormat?f.tickFormat.apply(f,a):bt:t,p=s.selectAll(".tick").data(h,f),v=p.enter().insert("g",".domain").attr("class","tick").style("opacity",Aa),d=Xo.transition(p.exit()).style("opacity",Aa).remove(),m=Xo.transition(p).style("opacity",1),y=Ri(f),x=s.selectAll(".domain").data([0]),M=(x.enter().append("path").attr("class","domain"),Xo.transition(x));v.append("line"),v.append("text");var _=v.select("line"),b=m.select("line"),w=p.select("text").text(g),S=v.select("text"),k=m.select("text");switch(r){case"bottom":n=Ho,_.attr("y2",u),S.attr("y",Math.max(u,0)+o),b.attr("x2",0).attr("y2",u),k.attr("x",0).attr("y",Math.max(u,0)+o),w.attr("dy",".71em").style("text-anchor","middle"),M.attr("d","M"+y[0]+","+i+"V0H"+y[1]+"V"+i);break;case"top":n=Ho,_.attr("y2",-u),S.attr("y",-(Math.max(u,0)+o)),b.attr("x2",0).attr("y2",-u),k.attr("x",0).attr("y",-(Math.max(u,0)+o)),w.attr("dy","0em").style("text-anchor","middle"),M.attr("d","M"+y[0]+","+-i+"V0H"+y[1]+"V"+-i);break;case"left":n=Fo,_.attr("x2",-u),S.attr("x",-(Math.max(u,0)+o)),b.attr("x2",-u).attr("y2",0),k.attr("x",-(Math.max(u,0)+o)).attr("y",0),w.attr("dy",".32em").style("text-anchor","end"),M.attr("d","M"+-i+","+y[0]+"H0V"+y[1]+"H"+-i);break;case"right":n=Fo,_.attr("x2",u),S.attr("x",Math.max(u,0)+o),b.attr("x2",u).attr("y2",0),k.attr("x",Math.max(u,0)+o).attr("y",0),w.attr("dy",".32em").style("text-anchor","start"),M.attr("d","M"+i+","+y[0]+"H0V"+y[1]+"H"+i)}if(f.rangeBand){var E=f,A=E.rangeBand()/2;l=f=function(n){return E(n)+A}}else l.rangeBand?l=f:d.call(n,f);v.call(n,l),m.call(n,f)})}var t,e=Xo.scale.linear(),r=Ts,u=6,i=6,o=3,a=[10],c=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in qs?t+"":Ts,n):r},n.ticks=function(){return arguments.length?(a=arguments,n):a},n.tickValues=function(t){return arguments.length?(c=t,n):c},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(u=+t,i=+arguments[e-1],n):u},n.innerTickSize=function(t){return arguments.length?(u=+t,n):u},n.outerTickSize=function(t){return arguments.length?(i=+t,n):i},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Ts="bottom",qs={top:1,right:1,bottom:1,left:1};Xo.svg.brush=function(){function n(i){i.each(function(){var i=Xo.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=i.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),i.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=i.selectAll(".resize").data(p,bt);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return zs[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,f=Xo.transition(i),h=Xo.transition(o);c&&(l=Ri(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),e(f)),s&&(l=Ri(s),h.attr("y",l[0]).attr("height",l[1]-l[0]),r(f)),t(f)})}function t(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+l[+/e$/.test(n)]+","+f[+/^s/.test(n)]+")"})}function e(n){n.select(".extent").attr("x",l[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",l[1]-l[0])}function r(n){n.select(".extent").attr("y",f[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",f[1]-f[0])}function u(){function u(){32==Xo.event.keyCode&&(C||(x=null,L[0]-=l[1],L[1]-=f[1],C=2),d())}function p(){32==Xo.event.keyCode&&2==C&&(L[0]+=l[1],L[1]+=f[1],C=0,d())}function v(){var n=Xo.mouse(_),u=!1;M&&(n[0]+=M[0],n[1]+=M[1]),C||(Xo.event.altKey?(x||(x=[(l[0]+l[1])/2,(f[0]+f[1])/2]),L[0]=l[+(n[0]<x[0])],L[1]=f[+(n[1]<x[1])]):x=null),E&&m(n,c,0)&&(e(S),u=!0),A&&m(n,s,1)&&(r(S),u=!0),u&&(t(S),w({type:"brush",mode:C?"move":"resize"}))}function m(n,t,e){var r,u,a=Ri(t),c=a[0],s=a[1],p=L[e],v=e?f:l,d=v[1]-v[0];return C&&(c-=p,s-=d+p),r=(e?g:h)?Math.max(c,Math.min(s,n[e])):n[e],C?u=(r+=p)+d:(x&&(p=Math.max(c,Math.min(s,2*x[e]-r))),r>p?(u=r,r=p):u=p),v[0]!=r||v[1]!=u?(e?o=null:i=null,v[0]=r,v[1]=u,!0):void 0}function y(){v(),S.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),Xo.select("body").style("cursor",null),T.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),N(),w({type:"brushend"})}var x,M,_=this,b=Xo.select(Xo.event.target),w=a.of(_,arguments),S=Xo.select(_),k=b.datum(),E=!/^(n|s)$/.test(k)&&c,A=!/^(e|w)$/.test(k)&&s,C=b.classed("extent"),N=O(),L=Xo.mouse(_),T=Xo.select(Go).on("keydown.brush",u).on("keyup.brush",p);if(Xo.event.changedTouches?T.on("touchmove.brush",v).on("touchend.brush",y):T.on("mousemove.brush",v).on("mouseup.brush",y),S.interrupt().selectAll("*").interrupt(),C)L[0]=l[0]-L[0],L[1]=f[0]-L[1];else if(k){var q=+/w$/.test(k),z=+/^n/.test(k);M=[l[1-q]-L[0],f[1-z]-L[1]],L[0]=l[q],L[1]=f[z]}else Xo.event.altKey&&(x=L.slice());S.style("pointer-events","none").selectAll(".resize").style("display",null),Xo.select("body").style("cursor",b.style("cursor")),w({type:"brushstart"}),v()}var i,o,a=y(n,"brushstart","brush","brushend"),c=null,s=null,l=[0,0],f=[0,0],h=!0,g=!0,p=Rs[0];return n.event=function(n){n.each(function(){var n=a.of(this,arguments),t={x:l,y:f,i:i,j:o},e=this.__chart__||t;this.__chart__=t,ks?Xo.select(this).transition().each("start.brush",function(){i=e.i,o=e.j,l=e.x,f=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=hu(l,t.x),r=hu(f,t.y);return i=o=null,function(u){l=t.x=e(u),f=t.y=r(u),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){i=t.i,o=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,p=Rs[!c<<1|!s],n):c},n.y=function(t){return arguments.length?(s=t,p=Rs[!c<<1|!s],n):s},n.clamp=function(t){return arguments.length?(c&&s?(h=!!t[0],g=!!t[1]):c?h=!!t:s&&(g=!!t),n):c&&s?[h,g]:c?h:s?g:null},n.extent=function(t){var e,r,u,a,h;return arguments.length?(c&&(e=t[0],r=t[1],s&&(e=e[0],r=r[0]),i=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(h=e,e=r,r=h),(e!=l[0]||r!=l[1])&&(l=[e,r])),s&&(u=t[0],a=t[1],c&&(u=u[1],a=a[1]),o=[u,a],s.invert&&(u=s(u),a=s(a)),u>a&&(h=u,u=a,a=h),(u!=f[0]||a!=f[1])&&(f=[u,a])),n):(c&&(i?(e=i[0],r=i[1]):(e=l[0],r=l[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(h=e,e=r,r=h))),s&&(o?(u=o[0],a=o[1]):(u=f[0],a=f[1],s.invert&&(u=s.invert(u),a=s.invert(a)),u>a&&(h=u,u=a,a=h))),c&&s?[[e,u],[r,a]]:c?[e,r]:s&&[u,a])},n.clear=function(){return n.empty()||(l=[0,0],f=[0,0],i=o=null),n},n.empty=function(){return!!c&&l[0]==l[1]||!!s&&f[0]==f[1]},Xo.rebind(n,a,"on")};var zs={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Rs=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Ds=tc.format=ac.timeFormat,Ps=Ds.utc,Us=Ps("%Y-%m-%dT%H:%M:%S.%LZ");Ds.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?Oo:Us,Oo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},Oo.toString=Us.toString,tc.second=Rt(function(n){return new ec(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),tc.seconds=tc.second.range,tc.seconds.utc=tc.second.utc.range,tc.minute=Rt(function(n){return new ec(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),tc.minutes=tc.minute.range,tc.minutes.utc=tc.minute.utc.range,tc.hour=Rt(function(n){var t=n.getTimezoneOffset()/60;return new ec(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),tc.hours=tc.hour.range,tc.hours.utc=tc.hour.utc.range,tc.month=Rt(function(n){return n=tc.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),tc.months=tc.month.range,tc.months.utc=tc.month.utc.range;var js=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Hs=[[tc.second,1],[tc.second,5],[tc.second,15],[tc.second,30],[tc.minute,1],[tc.minute,5],[tc.minute,15],[tc.minute,30],[tc.hour,1],[tc.hour,3],[tc.hour,6],[tc.hour,12],[tc.day,1],[tc.day,2],[tc.week,1],[tc.month,1],[tc.month,3],[tc.year,1]],Fs=Ds.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",be]]),Os={range:function(n,t,e){return Xo.range(Math.ceil(n/e)*e,+t,e).map(Io)},floor:bt,ceil:bt};Hs.year=tc.year,tc.scale=function(){return Yo(Xo.scale.linear(),Hs,Fs)};var Ys=Hs.map(function(n){return[n[0].utc,n[1]]}),Is=Ps.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",be]]);Ys.year=tc.year.utc,tc.scale.utc=function(){return Yo(Xo.scale.linear(),Ys,Is)},Xo.text=wt(function(n){return n.responseText}),Xo.json=function(n,t){return St(n,"application/json",Zo,t)},Xo.html=function(n,t){return St(n,"text/html",Vo,t)},Xo.xml=wt(function(n){return n.responseXML}),"function"==typeof define&&define.amd?define(Xo):"object"==typeof module&&module.exports?module.exports=Xo:this.d3=Xo}();

'use strict';

tr.exportTo('tr.ui.b', function() {
  var THIS_DOC = document.currentScript.ownerDocument;

  var svgNS = 'http://www.w3.org/2000/svg';
  var highlightIdBoost = tr.ui.b.getColorPaletteHighlightIdBoost();

  function getColorOfKey(key, selected) {
    var id = tr.ui.b.getColorIdForGeneralPurposeString(key);
    if (selected)
      id += highlightIdBoost;
    return tr.ui.b.getColorPalette()[id];
  }

  /**
   * A virtual base class for basic charts that provides X and Y axes, if
   * needed, a title, and legend.
   *
   * @constructor
   */
  var ChartBase = tr.ui.b.define('svg', undefined, svgNS);

  ChartBase.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.classList.add('chart-base');
      this.chartTitle_ = undefined;
      this.seriesKeys_ = undefined;
      this.width_ = 400;
      this.height_ = 300;

      // This should use tr.ui.b.instantiateTemplate. However, creating
      // svg-namespaced elements inside a template isn't possible. Thus, this
      // hack.
      var template = THIS_DOC.querySelector('#chart-base-template');
      var svgEl = template.content.querySelector('svg');
      for (var i = 0; i < svgEl.children.length; i++)
        this.appendChild(svgEl.children[i].cloneNode(true));

      // svg likes to take over width & height properties for some reason. This
      // works around it.
      Object.defineProperty(
          this, 'width', {
            get: function() {
              return this.width_;
            },
            set: function(width) {
              this.width_ = width;
              this.updateContents_();
            }
          });
      Object.defineProperty(
          this, 'height', {
            get: function() {
              return this.height_;
            },
            set: function(height) {
              this.height_ = height;
              this.updateContents_();
            }
          });
    },

    get chartTitle() {
      return this.chartTitle_;
    },

    set chartTitle(chartTitle) {
      this.chartTitle_ = chartTitle;
      this.updateContents_();
    },

    get chartAreaElement() {
      return this.querySelector('#chart-area');
    },

    setSize: function(size) {
      this.width_ = size.width;
      this.height_ = size.height;
      this.updateContents_();
    },

    get margin() {
      var margin = {top: 20, right: 20, bottom: 30, left: 50};
      if (this.chartTitle_)
        margin.top += 20;
      return margin;
    },

    get chartAreaSize() {
      var margin = this.margin;
      return {
        width: this.width_ - margin.left - margin.right,
        height: this.height_ - margin.top - margin.bottom
      };
    },

    getLegendKeys_: function() {
      throw new Error('Not implemented');
    },

    updateScales_: function(width, height) {
      throw new Error('Not implemented');
    },

    updateContents_: function() {
      var margin = this.margin;
      var width = this.chartAreaSize.width;
      var height = this.chartAreaSize.height;

      var thisSel = d3.select(this);
      thisSel.attr('width', this.width_);
      thisSel.attr('height', this.height_);

      var chartAreaSel = d3.select(this.chartAreaElement);
      chartAreaSel.attr(
          'transform',
          'translate(' + margin.left + ',' + margin.top + ')');

      this.updateScales_(width, height);

      // Axes.
      if (this.xScale_ && this.yScale_) {
        var xAxisRenderer = d3.svg.axis()
            .scale(this.xScale_)
            .orient('bottom');

        var yAxisRenderer = d3.svg.axis()
            .scale(this.yScale_)
            .orient('left');

        chartAreaSel.select('.x.axis')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxisRenderer);

        chartAreaSel.select('.y.axis')
            .call(yAxisRenderer);
      }

      // Title.
      var titleSel = chartAreaSel.select('#title');
      if (this.chartTitle_) {
        titleSel.attr('transform', 'translate(' + width * 0.5 + ',-5)')
            .style('display', undefined)
            .style('text-anchor', 'middle')
            .attr('class', 'title')
            .attr('width', width)
            .text(this.chartTitle_);
      } else {
        titleSel.style('display', 'none');
      }

      // Basics
      this.updateLegend_();
    },

    // TODO(charliea): We should change updateLegend_ so that it ellipsizes the
    // series names after a certain point. Otherwise, the series names start
    // dipping below the x-axis and continue on outside of the viewport.
    updateLegend_: function() {
      var keys = this.getLegendKeys_();
      if (keys === undefined)
        return;

      var chartAreaSel = d3.select(this.chartAreaElement);
      var chartAreaSize = this.chartAreaSize;

      var legendEntriesSel = chartAreaSel.selectAll('.legend')
          .data(keys.slice().reverse());

      legendEntriesSel.enter()
          .append('g')
          .attr('class', 'legend')
          .attr('transform', function(d, i) {
            return 'translate(0,' + i * 20 + ')';
          }).append('text').text(function(key) {
            return key;
          });
      legendEntriesSel.exit().remove();

      legendEntriesSel.attr('x', chartAreaSize.width - 18)
          .attr('width', 18)
          .attr('height', 18)
          .style('fill', function(key) {
            var selected = this.currentHighlightedLegendKey === key;
            return getColorOfKey(key, selected);
          }.bind(this));

      legendEntriesSel.selectAll('text')
        .attr('x', chartAreaSize.width - 24)
        .attr('y', 9)
        .attr('dy', '.35em')
        .style('text-anchor', 'end')
        .text(function(d) { return d; });
    },

    get highlightedLegendKey() {
      return this.highlightedLegendKey_;
    },

    set highlightedLegendKey(highlightedLegendKey) {
      this.highlightedLegendKey_ = highlightedLegendKey;
      this.updateHighlight_();
    },

    get currentHighlightedLegendKey() {
      if (this.tempHighlightedLegendKey_)
        return this.tempHighlightedLegendKey_;
      return this.highlightedLegendKey_;
    },

    pushTempHighlightedLegendKey: function(key) {
      if (this.tempHighlightedLegendKey_)
        throw new Error('push cannot nest');
      this.tempHighlightedLegendKey_ = key;
      this.updateHighlight_();
    },

    popTempHighlightedLegendKey: function(key) {
      if (this.tempHighlightedLegendKey_ != key)
        throw new Error('pop cannot happen');
      this.tempHighlightedLegendKey_ = undefined;
      this.updateHighlight_();
    },

    updateHighlight_: function() {
      // Update label colors.
      var chartAreaSel = d3.select(this.chartAreaElement);
      var legendEntriesSel = chartAreaSel.selectAll('.legend');

      var that = this;
      legendEntriesSel.each(function(key) {
        var highlighted = key == that.currentHighlightedLegendKey;
        var color = getColorOfKey(key, highlighted);
        this.style.fill = color;
        if (highlighted)
          this.style.fontWeight = 'bold';
        else
          this.style.fontWeight = '';
      });
    }
  };

  return {
    getColorOfKey: getColorOfKey,
    ChartBase: ChartBase
  };
});


'use strict';

/**
 * @fileoverview A Mouse-event abtraction that waits for
 *   mousedown, then watches for subsequent mousemove events
 *   until the next mouseup event, then waits again.
 *   State changes are signaled with
 *      'mouse-tracker-start' : mousedown and tracking
 *      'mouse-tracker-move' : mouse move
 *      'mouse-tracker-end' : mouseup and not tracking.
 */

tr.exportTo('tr.ui.b', function() {

  /**
   * @constructor
   * @param {HTMLElement} targetElement will recv events 'mouse-tracker-start',
   *     'mouse-tracker-move', 'mouse-tracker-end'.
   */
  function MouseTracker(opt_targetElement) {
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onMouseMove_ = this.onMouseMove_.bind(this);
    this.onMouseUp_ = this.onMouseUp_.bind(this);

    this.targetElement = opt_targetElement;
  }

  MouseTracker.prototype = {

    get targetElement() {
      return this.targetElement_;
    },

    set targetElement(targetElement) {
      if (this.targetElement_)
        this.targetElement_.removeEventListener('mousedown', this.onMouseDown_);
      this.targetElement_ = targetElement;
      if (this.targetElement_)
        this.targetElement_.addEventListener('mousedown', this.onMouseDown_);
    },

    onMouseDown_: function(e) {
      if (e.button !== 0)
        return true;

      e = this.remakeEvent_(e, 'mouse-tracker-start');
      this.targetElement_.dispatchEvent(e);
      document.addEventListener('mousemove', this.onMouseMove_);
      document.addEventListener('mouseup', this.onMouseUp_);
      this.targetElement_.addEventListener('blur', this.onMouseUp_);
      this.savePreviousUserSelect_ = document.body.style['-webkit-user-select'];
      document.body.style['-webkit-user-select'] = 'none';
      e.preventDefault();
      return true;
    },

    onMouseMove_: function(e) {
      e = this.remakeEvent_(e, 'mouse-tracker-move');
      this.targetElement_.dispatchEvent(e);
    },

    onMouseUp_: function(e) {
      document.removeEventListener('mousemove', this.onMouseMove_);
      document.removeEventListener('mouseup', this.onMouseUp_);
      this.targetElement_.removeEventListener('blur', this.onMouseUp_);
      document.body.style['-webkit-user-select'] =
          this.savePreviousUserSelect_;
      e = this.remakeEvent_(e, 'mouse-tracker-end');
      this.targetElement_.dispatchEvent(e);
    },

    remakeEvent_: function(e, newType) {
      var remade = new tr.b.Event(newType, true, true);
      remade.x = e.x;
      remade.y = e.y;
      remade.offsetX = e.offsetX;
      remade.offsetY = e.offsetY;
      remade.clientX = e.clientX;
      remade.clientY = e.clientY;
      return remade;
    }

  };

  function trackMouseMovesUntilMouseUp(mouseMoveHandler,
                                       opt_mouseUpHandler, opt_keyUpHandler) {
    function cleanupAndDispatchToMouseUp(e) {
      document.removeEventListener('mousemove', mouseMoveHandler);
      if (opt_keyUpHandler)
        document.removeEventListener('keyup', opt_keyUpHandler);
      document.removeEventListener('mouseup', cleanupAndDispatchToMouseUp);
      if (opt_mouseUpHandler)
        opt_mouseUpHandler(e);
    }
    document.addEventListener('mousemove', mouseMoveHandler);
    if (opt_keyUpHandler)
      document.addEventListener('keyup', opt_keyUpHandler);
    document.addEventListener('mouseup', cleanupAndDispatchToMouseUp);
  }

  return {
    MouseTracker: MouseTracker,
    trackMouseMovesUntilMouseUp: trackMouseMovesUntilMouseUp
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  var ChartBase = tr.ui.b.ChartBase;
  var getColorOfKey = tr.ui.b.getColorOfKey;

  function getSampleWidth(data, index, leftSide) {
    var leftIndex, rightIndex;
    if (leftSide) {
      leftIndex = Math.max(index - 1, 0);
      rightIndex = index;
    } else {
      leftIndex = index;
      rightIndex = Math.min(index + 1, data.length - 1);
    }
    var leftWidth = data[index].x - data[leftIndex].x;
    var rightWidth = data[rightIndex].x - data[index].x;
    return leftWidth * 0.5 + rightWidth * 0.5;
  }

  /**
   * @constructor
   */
  var LineChart = tr.ui.b.define('line-chart', ChartBase);

  LineChart.prototype = {
    __proto__: ChartBase.prototype,

    decorate: function() {
      ChartBase.prototype.decorate.call(this);
      this.classList.add('line-chart');

      this.brushedRange_ = new tr.b.Range();

      this.xScale_ = d3.scale.linear();
      this.yScale_ = d3.scale.linear();
      d3.select(this.chartAreaElement)
          .append('g')
          .attr('id', 'brushes');
      d3.select(this.chartAreaElement)
          .append('g')
          .attr('id', 'series');

      this.addEventListener('mousedown', this.onMouseDown_.bind(this));
    },

    get data() {
      return this.data_;
    },

    /**
     * Sets the data array for the object
     *
     * @param {Array} data The data. Each element must be an object, with at
     * least an x property. All other properties become series names in the
     * chart. The data can be sparse (i.e. every x value does not have to
     * contain data for every series).
     */
    set data(data) {
      if (data.length == 0)
        throw new Error('Data must be nonzero. Pass undefined.');

      this.data_ = data;
      this.seriesKeys_ = this.getSeriesKeys_();

      this.updateContents_();
    },

    // Note: range can only be set, not retrieved. It needs to be immutable
    // or else odd data binding effects will result.
    set brushedRange(range) {
      this.brushedRange_.reset();
      this.brushedRange_.addRange(range);
      this.updateContents_();
    },

    computeBrushRangeFromIndices: function(indexA, indexB) {
      var r = new tr.b.Range();
      var leftIndex = Math.min(indexA, indexB);
      var rightIndex = Math.max(indexA, indexB);
      leftIndex = Math.max(0, leftIndex);
      rightIndex = Math.min(this.data_.length - 1, rightIndex);
      r.addValue(this.data_[leftIndex].x -
          getSampleWidth(this.data_, leftIndex, true));
      r.addValue(this.data_[rightIndex].x +
          getSampleWidth(this.data_, rightIndex, false));
      return r;
    },

    getLegendKeys_: function() {
      if (this.seriesKeys_ &&
          this.seriesKeys_.length > 1)
        return this.seriesKeys_.slice();
      return [];
    },

    getSeriesKeys_: function() {
      if (this.data_ === undefined)
        return undefined;

      // Accumulate the keys on each data point.
      var keySet = {};
      this.data_.forEach(function(datum) {
        if (datum.x === undefined)
          throw new Error('Elements must have "x" fields.');

        Object.keys(datum).forEach(function(key) {
          // Don't count 'x': it's the domain, not an actual series.
          if (key === 'x')
            return;

          keySet[key] = true;
        });
      });

      return Object.keys(keySet);
    },

    updateScales_: function(width, height) {
      if (this.data_ === undefined)
        return;

      // X.
      this.xScale_.range([0, width]);
      this.xScale_.domain(d3.extent(this.data_, function(d) { return d.x; }));

      // Y.
      var yRange = new tr.b.Range();
      this.data_.forEach(function(datum) {
        this.seriesKeys_.forEach(function(key) {
          // Allow for sparse data
          if (datum[key] !== undefined)
            yRange.addValue(datum[key]);
        });
      }, this);

      this.yScale_.range([height, 0]);
      this.yScale_.domain([yRange.min, yRange.max]);
    },

    updateContents_: function() {
      ChartBase.prototype.updateContents_.call(this);
      if (!this.data_)
        return;

      var chartAreaSel = d3.select(this.chartAreaElement);

      var brushes = this.brushedRange_.isEmpty ? [] : [this.brushedRange_];

      var brushRectsSel = chartAreaSel.select('#brushes')
          .selectAll('rect').data(brushes);
      brushRectsSel.enter()
          .append('rect');
      brushRectsSel.exit().remove();
      brushRectsSel
        .attr('x', function(d) {
            return this.xScale_(d.min);
          }.bind(this))
        .attr('y', 0)
        .attr('width', function(d) {
            return this.xScale_(d.max) - this.xScale_(d.min);
          }.bind(this))
        .attr('height', this.chartAreaSize.height);

      var dataBySeriesKey = this.getDataBySeriesKey_();

      var seriesSel = chartAreaSel.select('#series');
      var pathsSel = seriesSel.selectAll('path').data(this.seriesKeys_);
      pathsSel.enter()
          .append('path')
          .attr('class', 'line')
          .style('stroke', function(key) {
            return getColorOfKey(key);
          })
          .attr('d', function(key) {
            var line = d3.svg.line()
              .x(function(d) { return this.xScale_(d.x); }.bind(this))
              .y(function(d) { return this.yScale_(d[key]); }.bind(this));
            return line(dataBySeriesKey[key]);
          }.bind(this));
      pathsSel.exit().remove();
    },

    /**
     * Returns a map of series key to the data for that series.
     *
     * Example:
     * // returns {y: [{x: 1, y: 1}, {x: 3, y: 3}], z: [{x: 2, z: 2}]}
     * this.data_ = [{x: 1, y: 1}, {x: 2, z: 2}, {x: 3, y: 3}];
     * this.getDataBySeriesKey_();
     * @return {Object} A map of series data by series key.
     */
    getDataBySeriesKey_: function() {
      var dataBySeriesKey = {};
      this.seriesKeys_.forEach(function(seriesKey) {
        dataBySeriesKey[seriesKey] = [];
      });

      this.data_.forEach(function(multiSeriesDatum) {
        var x = multiSeriesDatum.x;

        d3.keys(multiSeriesDatum).forEach(function(seriesKey) {
          // Skip 'x' - it's not a series
          if (seriesKey === 'x')
            return;

          if (multiSeriesDatum[seriesKey] === undefined)
            return;

          var singleSeriesDatum = {x: x};
          singleSeriesDatum[seriesKey] = multiSeriesDatum[seriesKey];
          dataBySeriesKey[seriesKey].push(singleSeriesDatum);
        });
      });

      return dataBySeriesKey;
    },

    getDataIndexAtClientPoint_: function(clientX, clientY, clipToY) {
      var rect = this.getBoundingClientRect();
      var margin = this.margin;
      var chartAreaSize = this.chartAreaSize;

      var x = clientX - rect.left - margin.left;
      var y = clientY - rect.top - margin.top;

      // Don't check width: let people select the left- and right-most data
      // points.
      if (clipToY) {
        if (y < 0 ||
            y >= chartAreaSize.height)
          return undefined;
      }

      var dataX = this.xScale_.invert(x);

      var index;
      if (this.data_) {
        var bisect = d3.bisector(function(d) { return d.x; }).right;
        index = bisect(this.data_, dataX) - 1;
      }

      return index;
    },

    onMouseDown_: function(e) {
      var index = this.getDataIndexAtClientPoint_(e.clientX, e.clientY, true);

      if (index !== undefined) {
        tr.ui.b.trackMouseMovesUntilMouseUp(
            this.onMouseMove_.bind(this, e.button),
            this.onMouseUp_.bind(this, e.button));
      }
      e.preventDefault();
      e.stopPropagation();

      var event = new tr.b.Event('item-mousedown');
      event.data = this.data_[index];
      event.index = index;
      event.buttons = e.buttons;
      this.dispatchEvent(event);
    },

    onMouseMove_: function(button, e) {
      var index = this.getDataIndexAtClientPoint_(e.clientX, e.clientY, false);
      if (e.buttons !== undefined) {
        e.preventDefault();
        e.stopPropagation();
      }

      var event = new tr.b.Event('item-mousemove');
      event.data = this.data_[index];
      event.index = index;
      event.button = button;
      this.dispatchEvent(event);
    },

    onMouseUp_: function(button, e) {
      var index = this.getDataIndexAtClientPoint_(e.clientX, e.clientY, false);
      e.preventDefault();
      e.stopPropagation();

      var event = new tr.b.Event('item-mouseup');
      event.data = this.data_[index];
      event.index = index;
      event.button = button;
      this.dispatchEvent(event);
    }
  };

  return {
    LineChart: LineChart
  };
});


'use strict';

var EventSet = tr.model.EventSet;

var CHART_TITLE = 'Power (in mW) by ms since vertical sync';
// TODO(charliea): Find out how to make this specifiable via CSS.
var CHART_WIDTH_FRACTION_OF_BODY = 0.5;

Polymer('tr-ui-a-frame-power-usage-chart', {
  ready: function() {
    this.chart_ = undefined;
    this.samples_ = new EventSet();
    this.vSyncTimestamps_ = [];
  },

  get chart() {
    return this.chart_;
  },

  get samples() {
    return this.samples_;
  },

  get vSyncTimestamps() {
    return this.vSyncTimestamps_;
  },

  /**
   * Sets the data that powers the chart. Vsync timestamps must be in
   * chronological order.
   */
  setData: function(samples, vSyncTimestamps) {
    this.samples_ = (samples === undefined) ? new EventSet() : samples;
    this.vSyncTimestamps_ =
        (vSyncTimestamps === undefined) ? [] : vSyncTimestamps;
    this.updateContents_();
  },

  updateContents_: function() {
    this.clearChart_();

    var data = this.getDataForLineChart_();

    if (data.length === 0)
      return;

    this.chart_ = this.createChart_(data);
    this.$.content.appendChild(this.chart_);
  },

  createChart_: function(data) {
    var chart = new tr.ui.b.LineChart();
    var width = document.body.clientWidth * CHART_WIDTH_FRACTION_OF_BODY;
    chart.setSize({width: width, height: chart.height});
    chart.chartTitle = CHART_TITLE;
    chart.data = data;

    return chart;
  },

  clearChart_: function() {
    var content = this.$.content;
    while (content.firstChild)
      content.removeChild(content.firstChild);

    this.chart_ = undefined;
  },

  // TODO(charliea): Limit the ms since vsync to the median frame length. The
  // vertical syncs are not 100% regular and highlighting any sample that's
  // in one of these 'vertical sync lulls' makes the x-axis have a much larger
  // scale than it should, effectively squishing the other samples into the
  // left side of the chart.
  /**
   * Returns an array of data points for the chart. Each element in the array
   * is of the form { x: <ms since vsync>, f<frame#>: <power in mW> }.
   */
  getDataForLineChart_: function() {
    var sortedSamples = this.sortSamplesByTimestampAscending_(this.samples);
    var vSyncTimestamps = this.vSyncTimestamps.slice();

    var lastVSyncTimestamp = undefined;
    var points = [];

    // For each power sample, find and record the frame number that it belongs
    // to as well as the amount of time elapsed since that frame began.
    var frameNumber = 0;
    sortedSamples.forEach(function(sample) {
      while (vSyncTimestamps.length > 0 && vSyncTimestamps[0] <= sample.start) {
        lastVSyncTimestamp = vSyncTimestamps.shift();
        frameNumber++;
      }

      // If no vertical sync occurred before the power sample, don't use the
      // power sample.
      if (lastVSyncTimestamp === undefined)
        return;

      var point = { x: sample.start - lastVSyncTimestamp };
      point['f' + frameNumber] = sample.power;
      points.push(point);
    });

    return points;
  },

  sortSamplesByTimestampAscending_: function(samples) {
    return samples.toArray().sort(function(smpl1, smpl2) {
      return smpl1.start - smpl2.start;
    });
  }
});


  'use strict';

  Polymer('tr-ui-a-power-sample-summary-table', {
    ready: function() {
      this.$.table.tableColumns = [
        {
          title: 'Min power',
          width: '100px',
          value: function(row) {
            return tr.b.u.Units.powerInWatts.format(row.min / 1000.0);
          }
        },
        {
          title: 'Max power',
          width: '100px',
          value: function(row) {
            return tr.b.u.Units.powerInWatts.format(row.max / 1000.0);
          }
        },
        {
          title: 'Time-weighted average',
          width: '100px',
          value: function(row) {
            return tr.b.u.Units.powerInWatts.format(
                row.timeWeightedAverage / 1000.0);
          }
        },
        {
          title: 'Energy consumed',
          width: '100px',
          value: function(row) {
            return tr.b.u.Units.energyInJoules.format(row.energyConsumed);
          }
        },
        {
          title: 'Sample count',
          width: '100%',
          value: function(row) { return row.sampleCount; }
        }
      ];
      this.samples = new tr.model.EventSet();
    },

    get samples() {
      return this.samples_;
    },

    set samples(samples) {
      if (samples === this.samples)
        return;

      this.samples_ =
          (samples === undefined) ? new tr.model.EventSet() : samples;
      this.updateContents_();
    },

    updateContents_: function() {
      if (this.samples.length === 0) {
        this.$.table.tableRows = [];
      } else {
        this.$.table.tableRows = [{
          min: this.getMin(),
          max: this.getMax(),
          timeWeightedAverage: this.getTimeWeightedAverage(),
          energyConsumed: this.getEnergyConsumed(),
          sampleCount: this.samples.length
        }];
      }

      this.$.table.rebuild();
    },

    getMin: function() {
      return Math.min.apply(null, this.samples.map(function(sample) {
        return sample.power;
      }));
    },

    getMax: function() {
      return Math.max.apply(null, this.samples.map(function(sample) {
        return sample.power;
      }));
    },

    
    getTimeWeightedAverage: function() {
      var energyConsumed = this.getEnergyConsumed();

      if (energyConsumed === 'N/A')
        return 'N/A';

                  return this.getEnergyConsumed() / this.samples.bounds.duration * 1000;
    },

    getEnergyConsumed: function() {
      if (this.samples.length < 2)
        return 'N/A';

      var bounds = this.samples.bounds;
      return this.samples[0].series.getEnergyConsumed(bounds.min, bounds.max);
    }
  });
  

'use strict';

// TODO(charliea): Add a dropdown that allows the user to select which type of
// power sample analysis view they want (e.g. table of samples, graph).
Polymer('tr-ui-a-multi-power-sample-sub-view', {
  ready: function() {
    this.currentSelection_ = undefined;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    this.currentSelection_ = selection;
    this.updateContents_();
  },

  updateContents_: function() {
    var samples = this.selection;
    var vSyncTimestamps = (this.selection === undefined) ?
        [] : this.selection[0].series.device.vSyncTimestamps;

    this.$.summaryTable.samples = samples;
    this.$.samplesTable.samples = samples;
    this.$.chart.setData(this.selection, vSyncTimestamps);
  }
});


  'use strict';
  (function() {
    var EventRegistry = tr.model.EventRegistry;

    Polymer('tr-ui-a-analysis-view', {
      ready: function() {
        this.tabView_ = document.createElement('tr-ui-a-tab-view');
        this.tabView_.style.flex = '1 1 auto';
        this.appendChild(this.tabView_);
        this.brushingStateController_ = undefined;
        this.onSelectedTabChange_ = this.onSelectedTabChange_.bind(this);
        this.onSelectionChanged_ = this.onSelectionChanged_.bind(this);

        this.lastSeenSelection_ = new tr.model.EventSet();
      },

      set tallMode(value) {
        if (value)
          this.classList.add('tall-mode');
        else
          this.classList.remove('tall-mode');
      },

      get tallMode() {
        return this.classList.contains('tall-mode');
      },

      get tabView() {
        return this.tabView_;
      },

      get brushingStateController() {
        return this.brushingStateController_;
      },

      set brushingStateController(brushingStateController) {
        if (this.brushingStateController) {
          this.brushingStateController_.removeEventListener(
              'change', this.onSelectionChanged_);
        }
        this.brushingStateController_ = brushingStateController;
        if (this.brushingStateController) {
          this.brushingStateController_.addEventListener(
              'change', this.onSelectionChanged_);
        }
        this.onSelectionChanged_();
      },

      get selection() {
        return this.brushingStateController_.selection;
      },

      onSelectionChanged_: function(e) {
        var selection = this.brushingStateController_.selection;

        var selectionHasSameValue = this.lastSeenSelection_.equals(selection);
        this.lastSeenSelection_ = selection;
        if (selectionHasSameValue)
          return;

        var lastSelectedTabTagName;
        var lastSelectedTabTypeName;
        if (this.tabView_.selectedTab) {
          lastSelectedTabTagName = this.tabView_.selectedTab.tagName;
          lastSelectedTabTypeName = this.tabView_.selectedTab._eventTypeName;
        }

        this.tallMode = false;

        var previouslySelectedTab = this.tabView_.selectedTab;
        this.tabView_.removeEventListener(
          'selected-tab-change', this.onSelectedTabChange_);

        var previousSubViews = {};
        for (var i = 0; i < this.tabView_.children.length; i++) {
          var previousSubView = this.tabView_.children[i];
          previousSubViews[previousSubView._eventTypeName] = previousSubView;
        }

        this.tabView_.saveTabStates();
        this.tabView_.textContent = '';
        if (selection.length == 0) {
          this.tabView_.tabStripHeadingText = 'Nothing selected. Tap stuff.';
        } else if (selection.length == 1) {
          this.tabView_.tabStripHeadingText = '1 item selected: ';
        } else {
          this.tabView_.tabStripHeadingText = selection.length +
              ' items selected: ';
        }

        var eventsByBaseTypeName = selection.getEventsOrganizedByBaseType(true);

        var numBaseTypesToAnalyze = tr.b.dictionaryLength(eventsByBaseTypeName);
        for (var eventTypeName in eventsByBaseTypeName) {
          var subSelection = eventsByBaseTypeName[eventTypeName];
          var subView = this.createSubViewForSelection_(
            eventTypeName, subSelection, previousSubViews[eventTypeName]);
                    subView._eventTypeName = eventTypeName;
          this.tabView_.appendChild(subView);

          subView.selection = subSelection;
        }

                        var tab;
        if (lastSelectedTabTagName)
          tab = this.tabView_.querySelector(lastSelectedTabTagName);

                if (!tab && lastSelectedTabTypeName) {
          var tab = tr.b.findFirstInArray(
              this.tabView_.children, function(tab) {
            return tab._eventTypeName === lastSelectedTabTypeName;
          });
        }
                if (!tab)
          tab = this.tabView_.firstChild;

        this.tabView_.selectedTab = tab;
        this.onSelectedTabChange_();

        this.tabView_.addEventListener(
          'selected-tab-change', this.onSelectedTabChange_);
      },

      createSubViewForSelection_: function(eventTypeName, subSelection,
          previousSubView) {
                var eventTypeInfo = EventRegistry.getEventTypeInfoByTypeName(
            eventTypeName);
        var singleMode = subSelection.length == 1;
        var tagName;
        if (subSelection.length === 1)
          tagName = eventTypeInfo.metadata.singleViewElementName;
        else
          tagName = eventTypeInfo.metadata.multiViewElementName;

        if (!tr.ui.b.getPolymerElementNamed(tagName))
          throw new Error('Element not registered: ' + tagName);

                var subView;
        if (previousSubView &&
            previousSubView.tagName === tagName.toUpperCase())
          subView = previousSubView;
        else
          subView = document.createElement(tagName);

                var camelLabel;
        if (subSelection.length === 1)
          camelLabel = EventRegistry.getUserFriendlySingularName(eventTypeName);
        else
          camelLabel = EventRegistry.getUserFriendlyPluralName(eventTypeName);
        subView.tabLabel = camelLabel + ' (' + subSelection.length + ')';

        return subView;
      },

      onSelectedTabChange_: function() {
        var brushingStateController = this.brushingStateController_;
        if (this.tabView_.selectedTab) {
          var selectedTab = this.tabView_.selectedTab;
          this.tallMode = selectedTab.requiresTallView;
          if (brushingStateController) {
            var rlth = selectedTab.relatedEventsToHighlight;
            brushingStateController.changeAnalysisViewRelatedEvents(rlth);
          }
        } else {
          this.tallMode = false;
          if (brushingStateController)
            brushingStateController.changeAnalysisViewRelatedEvents(undefined);
        }
      }
    });
  })();
  

'use strict';

tr.exportTo('tr.ui.b', function() {

  /**
   * Detects when user clicks handle determines new height of container based
   * on user's vertical mouse move and resizes the target.
   * @constructor
   * @extends {HTMLDivElement}
   * You will need to set target to be the draggable element
   */
  var DragHandle = tr.ui.b.define('x-drag-handle');

  DragHandle.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate: function() {
      this.lastMousePos_ = 0;
      this.onMouseMove_ = this.onMouseMove_.bind(this);
      this.onMouseUp_ = this.onMouseUp_.bind(this);
      this.addEventListener('mousedown', this.onMouseDown_);
      this.target_ = undefined;
      this.horizontal = true;
      this.observer_ = new WebKitMutationObserver(
          this.didTargetMutate_.bind(this));
      this.targetSizesByModeKey_ = {};
    },

    get modeKey_() {
      return this.target_.className == '' ? '.' : this.target_.className;
    },

    get target() {
      return this.target_;
    },

    set target(target) {
      this.observer_.disconnect();
      this.target_ = target;
      if (!this.target_)
        return;
      this.observer_.observe(this.target_, {
        attributes: true,
        attributeFilter: ['class']
      });
    },

    get horizontal() {
      return this.horizontal_;
    },

    set horizontal(h) {
      this.horizontal_ = h;
      if (this.horizontal_)
        this.className = 'horizontal-drag-handle';
      else
        this.className = 'vertical-drag-handle';
    },

    get vertical() {
      return !this.horizontal_;
    },

    set vertical(v) {
      this.horizontal = !v;
    },

    forceMutationObserverFlush_: function() {
      var records = this.observer_.takeRecords();
      if (records.length)
        this.didTargetMutate_(records);
    },

    didTargetMutate_: function(e) {
      var modeSize = this.targetSizesByModeKey_[this.modeKey_];
      if (modeSize !== undefined) {
        this.setTargetSize_(modeSize);
        return;
      }

      // If we hadn't previously sized the target, then just remove any manual
      // sizing that we applied.
      this.target_.style[this.targetStyleKey_] = '';
    },

    get targetStyleKey_() {
      return this.horizontal_ ? 'height' : 'width';
    },

    getTargetSize_: function() {
      // If style is not set, start off with computed height.
      var targetStyleKey = this.targetStyleKey_;
      if (!this.target_.style[targetStyleKey]) {
        this.target_.style[targetStyleKey] =
            window.getComputedStyle(this.target_)[targetStyleKey];
      }
      var size = parseInt(this.target_.style[targetStyleKey]);
      this.targetSizesByModeKey_[this.modeKey_] = size;
      return size;
    },

    setTargetSize_: function(s) {
      this.target_.style[this.targetStyleKey_] = s + 'px';
      this.targetSizesByModeKey_[this.modeKey_] = s;
    },

    applyDelta_: function(delta) {
      // Apply new size to the container.
      var curSize = this.getTargetSize_();
      var newSize;
      if (this.target_ === this.nextElementSibling) {
        newSize = curSize + delta;
      } else {
        newSize = curSize - delta;
      }
      this.setTargetSize_(newSize);
    },

    onMouseMove_: function(e) {
      // Compute the difference in height position.
      var curMousePos = this.horizontal_ ? e.clientY : e.clientX;
      var delta = this.lastMousePos_ - curMousePos;

      this.applyDelta_(delta);

      this.lastMousePos_ = curMousePos;
      e.preventDefault();
      return true;
    },

    onMouseDown_: function(e) {
      if (!this.target_)
        return;
      this.forceMutationObserverFlush_();
      this.lastMousePos_ = this.horizontal_ ? e.clientY : e.clientX;
      document.addEventListener('mousemove', this.onMouseMove_);
      document.addEventListener('mouseup', this.onMouseUp_);
      e.preventDefault();
      return true;
    },

    onMouseUp_: function(e) {
      document.removeEventListener('mousemove', this.onMouseMove_);
      document.removeEventListener('mouseup', this.onMouseUp_);
      e.preventDefault();
    }
  };

  return {
    DragHandle: DragHandle
  };
});


  'use strict';

  Polymer('tr-ui-b-dropdown', {
    ready: function() {
      this.$.outer.tabIndex = 0;
    },

    get iconElement() {
      return this.$.icon;
    },

    onOuterKeyDown_: function(e) {
      if (e.keyCode === ' '.charCodeAt(0)) {
        this.toggle_();
        e.preventDefault();
        e.stopPropagation();
      }
    },

    onOuterClick_: function(e) {
      var or = this.$.outer.getBoundingClientRect();
      var inside = true;
      inside &= e.clientX >= or.left;
      inside &= e.clientX < or.right;
      inside &= e.clientY >= or.top;
      inside &= e.clientY < or.bottom;
      if (!inside)
        return;

      e.preventDefault();
      this.toggle_();
    },

    toggle_: function() {
      if (!this.isOpen)
        this.show();
      else
        this.close();
    },

    show: function() {
      if (this.isOpen)
        return;

      this.$.outer.classList.add('open');

      var ddr = this.$.outer.getBoundingClientRect();
      var rW = Math.max(ddr.width, 150);
      this.$.dialog.style.minWidth = rW + 'px';
      this.$.dialog.showModal();

      var ddw = this.$.outer.getBoundingClientRect().width;
      var w = this.$.dialog.getBoundingClientRect().width;
      this.$.dialog.style.top = ddr.bottom - 1 + 'px';
      this.$.dialog.style.left = ddr.left + 'px';
    },

    onDialogClick_: function(e) {
      if (!this.isOpen)
        return;
      if (e.srcElement !== this.$.dialog)
        return;
      e.preventDefault();
      this.close();
    },

    onDialogCancel_: function(e) {
      e.preventDefault();
      this.close();
    },

    close: function() {
      if (!this.isOpen)
        return;
      this.$.dialog.close();
      this.$.outer.classList.remove('open');
      this.$.outer.focus();
    },

    get isOpen() {
      return this.$.dialog.hasAttribute('open');
    }
  });
  

'use strict';
tr.exportTo('tr.ui.b', function() {
  var FaviconsByHue = {
    blue: 'data:image/vndmicrosofticon;base64,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NP+9ZjT/vGY0/7xmNP+8ZjT/vGY0/7xmNP+8ZjT/u2U0/7FiLY0AAAACk5OTFu/v78X5+fn/+fn5//n5+f/5+vr/+fn5//n5+f/5+fn/+fn5//n5+f/5+/3/99iy//KWI//ylSH/8ZUh//GVIf/xlSH/8ZUh//GVIf/xlSH/8ZUh//GVIf/xlSH/8ZUh//GVIf/xlSH/8ZUh//CUIf/vkyD/5Y0fxY1XExbDw8Mz9PT05fn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n7/f/32LL/85cj//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/wlCD/7pIg/+6SIP/pjx/lunIZM9XV1VD39/f0+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fv9//fYsv/zlyP/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/75Mg/+uRH//qkB//6pAf/+iPH/TIfBtQ3d3dYfj4+Pn5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+/3/99iy//OXI//zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh/+6TIP/ojx//548f/+ePH//njx//5o4f+c1/HGHh4eFl+Pj4+vn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n7/f/32LL/85cj//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/tkiD/5Y0f/+SNH//ljR//5Y0f/+WNH//kjB/6zn8cZeDg4Fr4+Pj3+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fv9//fYsv/zlyP/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/65Eg/+KMHv/iix7/4ose/+KLHv/iix7/4ose/+CLHvfLfRta3NzcQvf39+/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+/3/99iy//OXI//zliH/85Yh//OWIf/zliH/85Yh//OWIf/zliH/85Yh/+qR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', // @suppress longLineCheck

    green: 'data:image/vndmicrosofticon;base64,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a/9sjmr/bI1q/2yNav9sjWr/bI1q/2uNav9rjWr/a41q/16GZI0AAAACk5OTFu/v78X5+fn/+fn5//n5+f/5+fr/+fn5//n5+f/5+fn/+fn5//n5+f/8+vv/wOfV/0vCi/9Kwor/SsKK/0rCiv9Kwor/SsKK/0rCiv9Kwor/SsKK/0rCiv9Kwor/SsKK/0rCiv9Kwor/SsKK/0nAif9Jv4j/RreCxStxUBbDw8Mz9PT05fn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//z6+/+/59X/TMSM/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9JwYn/SL6I/0i+iP9GuoXlOJVqM9XV1VD39/f0+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn//Pr7/7/n1f9Mw4z/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/ScCJ/0e8hv9HvIb/R7yG/0a6hfQ9oXJQ3d3dYfj4+Pn5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/8+vv/v+fV/0zDjP9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0i/iP9GuoX/RrqE/0a6hP9GuoT/RrmD+T6ldWHh4eFl+Pj4+vn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//z6+/+/59X/TMOM/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Ivof/RbiD/0W3gv9FuIP/RbiD/0W4g/9Ft4L6PqZ2ZeDg4Fr4+Pj3+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn//Pr7/7/n1f9Mw4z/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SL2H/0W2gv9FtYH/RbWB/0W1gf9FtYH/RbWB/0S0gPc+o3Ra3NzcQvf39+/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/8+vv/v+fV/0zDjP9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0rDi/9Kw4v/SsOL/0e8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', // @suppress longLineCheck

    red: 'data:image/vndmicrosofticon;base64,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xv9HL8b/Ry/G/0cvxv9HL8b/Ry/G/0cvxv9HL8X/Ry7F/z8tuI0AAAACk5OTFu/v78X5+fn/+fn5//n5+f/6+vn/+fr5//n6+f/5+vn/+fr5//n6+f/9/fn/ub73/zhF8v82Q/L/NkPy/zZD8v82Q/L/NkPy/zZD8v82Q/L/NkPy/zZD8v82Q/L/NkPy/zZD8v82Q/L/NkPy/zVC8f81QvD/Mz/mxR8njhbDw8Mz9PT05fn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//z8+f+5vff/OEX0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P81QvH/NEHv/zRB7/8zQOrlKTO6M9XV1VD39/f0+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn//Pz5/7m99/84RfT/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NULw/zRA7P80QOv/NEDr/zNA6fQsN8lQ3d3dYfj4+Pn5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/8/Pn/ub33/zhF9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zVB7/8zQOn/Mz/o/zM/6P8zQOj/Mz/n+S04zmHh4eFl+Pj4+vn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//z8+f+5vff/OEX0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P80Qe7/Mz/m/zM/5f8zP+b/Mz/m/zM/5v8yP+X6LjnPZeDg4Fr4+Pj3+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn//Pz5/7m99/84RfT/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NEHs/zI+4/8yPuP/Mj7j/zI+4/8yPuP/Mj7j/zI+4fctOMxa3NzcQvf39+/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/8/Pn/ub33/zhF9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zZD9P82Q/T/NkP0/zRA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', // @suppress longLineCheck

    yellow: 'data:image/vndmicrosofticon;base64,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//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hv/3/Br36/wa9+v8GuvbsBZnLQNra2mD39/f4+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn//fr5/6Xm+/8Jwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B778/wa79/8Guvf/Brr3/wa59fgFo9hg4uLidPj4+P35+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/9+vn/peb7/wnB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//we++/8GufX/Brj0/wa49P8GuPT/Brfz/QWm3XTk5OR6+Pj4/fn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//36+f+l5vv/CcH//wfB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hvfr/Brfy/wa28f8GtvH/Brbx/wa28f8GtfD9BafdeuXl5W/4+Pj8+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn//fr5/6Xm+/8Jwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B7z5/wa17/8GtO7/BrTu/wa07v8GtO7/BrTu/waz7fwFpdtv4eHhVvj4+Pb5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/9+vn/peb7/wnB//8Hwf//B8H//wfB//8Hwf//B8H//wfB//8Hwf//B8H//we7+P8Gsu3/BrHr/wax6/8Gsev/BrHr/wax6/8Gsev/BrDq9gWh1Vba2toz9vb25vn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//36+f+k5fv/BsH//wPA//8DwP//A8D//wPA//8DwP//A8D//wXA//8Guvb/BrDq/wau6P8Gruj/Bq7o/wau6P8Gruj/Bq7o/wau6P8GreXmBZnLM7+/vxH09PTC+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+/r5/83v+v9x2vz/btn9/2/Z/f9v2f3/b9n9/2/Z/f9v2f3/RdL5/yXG7v8mxOz/JsTs/ybE6/8mxOv/JsTr/yXE6/8lw+v/JcPr/yK95cIQirAR////APDw8IH5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+vn5//r5+f/6+fn/+vn5//r5+f/6+fn/+vn5//r5+f+H8Pz/Oer+/zzq/v886v7/POr+/zzq/v886v7/POr+/zzq/v886v3/OuDzgWz//wD09PQA5+fnNPf39+n5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5/4Xw/f846///O+v//zvr//876///O+v//zvr//876///O+v//zvp/ek32+00Ouf6AMrKygCzs7MF8/Pzmvn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/hfD9/zjr//876///O+v//zvr//876///O+v//zvr//876///OuX5miqptwUwv88AAAAAAPPz8wDp6eku9/f33fn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f+F8P3/OOv//zvr//876///O+v//zvr//876///O+v//zvp/d033O8uOuX5AAAAAAAAAAAAvr6+AP///wDx8fFl+Pj49fn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5/4Xw/f846///O+v//zvr//876///O+v//zvr//876v71OeP2ZY7//wAus8IAAAAAAAAAAAAAAAAA4ODgANPT0wj09PSI+fn5+vn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/hfD9/zjr//876///O+v//zvr//876///O+v/+jrm+Ygyx9gINdPlAAAAAAAAAAAAAAAAAAAAAAAAAAAA6enpAOHh4Q309PSM+fn5+Pn5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5+f/5+fn/+fn5//n5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' // @suppress longLineCheck
  };

  return {
    FaviconsByHue: FaviconsByHue
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  function HotKey(dict) {
    if (dict.eventType === undefined)
      throw new Error('eventType must be given');
    if (dict.keyCode === undefined && dict.keyCodes === undefined)
      throw new Error('keyCode or keyCodes must be given');
    if (dict.keyCode !== undefined && dict.keyCodes !== undefined)
      throw new Error('Only keyCode or keyCodes can be given');
    if (dict.callback === undefined)
      throw new Error('callback must be given');

    this.eventType_ = dict.eventType;
    this.keyCodes_ = [];

    if (dict.keyCode)
      this.pushKeyCode_(dict.keyCode);
    else if (dict.keyCodes) {
      dict.keyCodes.forEach(this.pushKeyCode_, this);
    }

    this.useCapture_ = !!dict.useCapture;
    this.callback_ = dict.callback;
    this.thisArg_ = dict.thisArg !== undefined ? dict.thisArg : undefined;

    this.helpText_ = dict.helpText !== undefined ? dict.helpText : undefined;
  }

  HotKey.prototype = {
    get eventType() {
      return this.eventType_;
    },

    get keyCodes() {
      return this.keyCodes_;
    },

    get helpText() {
      return this.helpText_;
    },

    call: function(e) {
      this.callback_.call(this.thisArg_, e);
    },

    pushKeyCode_: function(keyCode) {
      this.keyCodes_.push(keyCode);
    }
  };

  return {
    HotKey: HotKey
  };
});


  'use strict';
  Polymer('tv-ui-b-hotkey-controller', {
    created: function() {
      this.globalMode_ = false;
      this.slavedToParentController_ = undefined;
      this.curHost_ = undefined;
      this.childControllers_ = [];

      this.bubblingKeyDownHotKeys_ = {};
      this.capturingKeyDownHotKeys_ = {};
      this.bubblingKeyPressHotKeys_ = {};
      this.capturingKeyPressHotKeys_ = {};

      this.onBubblingKeyDown_ = this.onKey_.bind(this, false);
      this.onCapturingKeyDown_ = this.onKey_.bind(this, true);
      this.onBubblingKeyPress_ = this.onKey_.bind(this, false);
      this.onCapturingKeyPress_ = this.onKey_.bind(this, true);
    },

    attached: function() {
      var host = this.findHost_();
      if (host.__hotkeyController)
        throw new Error('Multiple hotkey controllers attached to this host');

      host.__hotkeyController = this;
      this.curHost_ = host;

      var parentElement;
      if (host.parentElement)
        parentElement = host.parentElement;
      else
        parentElement = host.parentNode.host;
      var parentController = tr.b.getHotkeyControllerForElement(
          parentElement);

      if (parentController) {
        this.slavedToParentController_ = parentController;
        parentController.addChildController_(this);
        return;
      }

      host.addEventListener('keydown', this.onBubblingKeyDown_, false);
      host.addEventListener('keydown', this.onCapturingKeyDown_, true);
      host.addEventListener('keypress', this.onBubblingKeyPress_, false);
      host.addEventListener('keypress', this.onCapturingKeyPress_, true);
    },

    detached: function() {
      var host = this.curHost_;
      if (!host)
        return;

      delete host.__hotkeyController;
      this.curHost_ = undefined;

      if (this.slavedToParentController_) {
        this.slavedToParentController_.removeChildController_(this);
        this.slavedToParentController_ = undefined;
        return;
      }

      host.removeEventListener('keydown', this.onBubblingKeyDown_, false);
      host.removeEventListener('keydown', this.onCapturingKeyDown_, true);
      host.removeEventListener('keypress', this.onBubblingKeyPress_, false);
      host.removeEventListener('keypress', this.onCapturingKeyPress_, true);
    },

    addChildController_: function(controller) {
      var i = this.childControllers_.indexOf(controller);
      if (i !== -1)
        throw new Error('Controller already registered');
      this.childControllers_.push(controller);
    },

    removeChildController_: function(controller) {
      var i = this.childControllers_.indexOf(controller);
      if (i === -1)
        throw new Error('Controller not registered');
      this.childControllers_.splice(i, 1);
      return controller;
    },

    getKeyMapForEventType_: function(eventType, useCapture) {
      if (eventType === 'keydown') {
        if (!useCapture)
          return this.bubblingKeyDownHotKeys_;
        else
          return this.capturingKeyDownHotKeys_;
      } else if (eventType === 'keypress') {
        if (!useCapture)
          return this.bubblingKeyPressHotKeys_;
        else
          return this.capturingKeyPressHotKeys_;
      } else {
        throw new Error('Unsupported key event');
      }
    },

    addHotKey: function(hotKey) {
      if (!(hotKey instanceof tr.ui.b.HotKey))
        throw new Error('hotKey must be a tr.ui.b.HotKey');

      var keyMap = this.getKeyMapForEventType_(
          hotKey.eventType, hotKey.useCapture);

      for (var i = 0; i < hotKey.keyCodes.length; i++) {
        var keyCode = hotKey.keyCodes[i];
        if (keyMap[keyCode])
          throw new Error('Key is already bound for keyCode=' + keyCode);
      }

      for (var i = 0; i < hotKey.keyCodes.length; i++) {
        var keyCode = hotKey.keyCodes[i];
        keyMap[keyCode] = hotKey;
      }
      return hotKey;
    },

    removeHotKey: function(hotKey) {
      if (!(hotKey instanceof tr.ui.b.HotKey))
        throw new Error('hotKey must be a tr.ui.b.HotKey');

      var keyMap = this.getKeyMapForEventType_(
          hotKey.eventType, hotKey.useCapture);

      for (var i = 0; i < hotKey.keyCodes.length; i++) {
        var keyCode = hotKey.keyCodes[i];
        if (!keyMap[keyCode])
          throw new Error('Key is not bound for keyCode=' + keyCode);
        keyMap[keyCode] = hotKey;
      }
      for (var i = 0; i < hotKey.keyCodes.length; i++) {
        var keyCode = hotKey.keyCodes[i];
        delete keyMap[keyCode];
      }
      return hotKey;
    },

    get globalMode() {
      return this.globalMode_;
    },

    set globalMode(globalMode) {
      this.detached();
      this.globalMode_ = !!globalMode;
      this.attached();
    },

    get topmostConroller_() {
      if (this.slavedToParentController_)
        return this.slavedToParentController_.topmostConroller_;
      return this;
    },

    childRequestsGeneralFocus: function(child) {
      var topmost = this.topmostConroller_;
      if (topmost.curHost_) {
        if (topmost.curHost_.hasAttribute('tabIndex')) {
          topmost.curHost_.focus();
        } else {
          if (document.activeElement)
            document.activeElement.blur();
        }
      } else {
        if (document.activeElement)
          document.activeElement.blur();
      }
    },

    childRequestsBlur: function(child) {
      child.blur();

      var topmost = this.topmostConroller_;
      if (topmost.curHost_) {
        topmost.curHost_.focus();
      }
    },

    findHost_: function() {
      if (this.globalMode_) {
        return document.body;
      } else {
        if (this.parentElement)
          return this.parentElement;

        var node = this;
        while (node.parentNode) {
          node = node.parentNode;
        }
        return node.host;
      }
    },

    appendMatchingHotKeysTo_: function(matchedHotKeys,
                                        useCapture, e) {
      var localKeyMap = this.getKeyMapForEventType_(e.type, useCapture);
      var localHotKey = localKeyMap[e.keyCode];
      if (localHotKey)
        matchedHotKeys.push(localHotKey);

      for (var i = 0; i < this.childControllers_.length; i++) {
        var controller = this.childControllers_[i];
        controller.appendMatchingHotKeysTo_(matchedHotKeys,
                                             useCapture, e);
      }
    },

    onKey_: function(useCapture, e) {
                  if (useCapture == false && e.path[0].tagName == 'INPUT')
        return;

      var sortedControllers;

      var matchedHotKeys = [];
      this.appendMatchingHotKeysTo_(matchedHotKeys, useCapture, e);

      if (matchedHotKeys.length === 0)
        return false;

      if (matchedHotKeys.length > 1) {
                                throw new Error('More than one hotKey is currently unsupported');
      }


      var hotKey = matchedHotKeys[0];

      var prevented = 0;
      prevented |= hotKey.call(e);

                  return !prevented && e.defaultPrevented;
    }
  });
  

'use strict';

tr.exportTo('tr.b', function() {

  function getHotkeyControllerForElement(refElement) {
    var curElement = refElement;
    while (curElement) {
      if (curElement.tagName === 'tv-ui-b-hotkey-controller')
        return curElement;

      if (curElement.__hotkeyController)
        return curElement.__hotkeyController;

      if (curElement.parentElement) {
        curElement = curElement.parentElement;
        continue;
      }

      // Probably inside a shadow
      curElement = findHost(curElement);
    }
    return undefined;
  }

  function findHost(initialNode) {
    var node = initialNode;
    while (node.parentNode) {
      node = node.parentNode;
    }
    return node.host;
  }

  return {
    getHotkeyControllerForElement: getHotkeyControllerForElement
  };
});


'use strict';

/**
 * @fileoverview FindController.
 */
tr.exportTo('tr.ui', function() {
  var Task = tr.b.Task;

  function FindController(brushingStateController) {
    this.brushingStateController_ = brushingStateController;
    this.filterHits_ = new tr.model.EventSet();
    this.currentHitIndex_ = -1;
    this.activePromise_ = Promise.resolve();
    this.activeTask_ = undefined;
  };

  FindController.prototype = {
    __proto__: Object.prototype,

    get model() {
      return this.brushingStateController_.model;
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    enqueueOperation_: function(operation) {
      var task;
      if (operation instanceof tr.b.Task)
        task = operation;
      else
        task = new tr.b.Task(operation, this);
      if (this.activeTask_) {
        this.activeTask_ = this.activeTask_.enqueue(task);
      } else {
        // We're enqueuing the first task, schedule it.
        this.activeTask_ = task;
        this.activePromise_ = Task.RunWhenIdle(this.activeTask_);
        this.activePromise_.then(function() {
          this.activePromise_ = undefined;
          this.activeTask_ = undefined;
        }.bind(this));
      }
    },

    /**
     * Updates the filter hits based on the provided |filterText|. Returns a
     * promise which resolves when |filterHits| has been refreshed.
     */
    startFiltering: function(filterText) {
      var sc = this.brushingStateController_;
      if (!sc)
        return;

      // TODO(beaudoin): Cancel anything left in the task queue, without
      // invalidating the promise.
      this.enqueueOperation_(function() {
        this.filterHits_ = new tr.model.EventSet();
        this.currentHitIndex_ = -1;
      }.bind(this));

      // Try constructing a UIState from the filterText.
      // UIState.fromUserFriendlyString will throw an error only if the string
      // is syntactically correct to a UI state string but with invalid values.
      // It will return undefined if there is no syntactic match.
      var stateFromString;
      try {
        stateFromString = sc.uiStateFromString(filterText);
      } catch (e) {
        this.enqueueOperation_(function() {
          var overlay = new tr.ui.b.Overlay();
          overlay.textContent = e.message;
          overlay.title = 'UI State Navigation Error';
          overlay.visible = true;
        });
        return this.activePromise_;
      }

      if (stateFromString !== undefined) {
        this.enqueueOperation_(
            sc.navToPosition.bind(this, stateFromString, true));
      } else {
        // filterText is not a navString here -- proceed with find and filter.
        if (filterText.length === 0) {
          this.enqueueOperation_(sc.findTextCleared.bind(sc));
        } else {
          var filter = new tr.c.FullTextFilter(filterText);
          var filterHits = new tr.model.EventSet();
          this.enqueueOperation_(sc.addAllEventsMatchingFilterToSelectionAsTask(
              filter, filterHits));
          this.enqueueOperation_(function() {
            this.filterHits_ = filterHits;
            sc.findTextChangedTo(filterHits);
          }.bind(this));
        }
      }
      return this.activePromise_;
    },

    /**
     * Returns the most recent filter hits as a tr.model.EventSet. Call
     * |startFiltering| to ensure this is up to date after the filter settings
     * have been changed.
     */
    get filterHits() {
      return this.filterHits_;
    },

    get currentHitIndex() {
      return this.currentHitIndex_;
    },

    find_: function(dir) {
      var firstHit = this.currentHitIndex_ === -1;
      if (firstHit && dir < 0)
        this.currentHitIndex_ = 0;

      var N = this.filterHits.length;
      this.currentHitIndex_ = (this.currentHitIndex_ + dir + N) % N;

      if (!this.brushingStateController_)
        return;

      this.brushingStateController_.findFocusChangedTo(
          this.filterHits.subEventSet(this.currentHitIndex_, 1));
    },

    findNext: function() {
      this.find_(1);
    },

    findPrevious: function() {
      this.find_(-1);
    }
  };

  return {
    FindController: FindController
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * Annotation is a base class that represents all annotation objects that
   * can be drawn on the timeline.
   *
   * @constructor
   */
  function Annotation() {
    this.guid_ = tr.b.GUID.allocate();
    this.view_ = undefined;
  };

  Annotation.fromDictIfPossible = function(args) {
    if (args.typeName === undefined)
      throw new Error('Missing typeName argument');

    var typeInfo = Annotation.findTypeInfoMatching(function(typeInfo) {
      return typeInfo.metadata.typeName === args.typeName;
    });

    if (typeInfo === undefined)
      return undefined;

    return typeInfo.constructor.fromDict(args);
  };

  Annotation.fromDict = function() {
    throw new Error('Not implemented');
  }

  Annotation.prototype = {
    get guid() {
      return this.guid_;
    },

    // Invoked by trace model when this annotation is removed.
    onRemove: function() {
    },

    toDict: function() {
      throw new Error('Not implemented');
    },

    getOrCreateView: function(viewport) {
      if (!this.view_)
        this.view_ = this.createView_(viewport);
      return this.view_;
    },

    createView_: function() {
      throw new Error('Not implemented');
    }
  };

  var options = new tr.b.ExtensionRegistryOptions(tr.b. BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(Annotation, options);

  Annotation.addEventListener('will-register', function(e) {
    if (!e.typeInfo.constructor.hasOwnProperty('fromDict'))
      throw new Error('Must have fromDict method');

    if (!e.typeInfo.metadata.typeName)
      throw new Error('Registered Annotations must provide typeName');
  });

  return {
    Annotation: Annotation
  };
});


'use strict';

tr.exportTo('tr.ui.annotations', function() {
  /**
   * A base class for all annotation views.
   * @constructor
   */
  function AnnotationView(viewport, annotation) {
  }

  AnnotationView.prototype = {
    draw: function(ctx) {
      throw new Error('Not implemented');
    }
  };

  return {
    AnnotationView: AnnotationView
  };
});


'use strict';

tr.exportTo('tr.ui.annotations', function() {
  /**
   * A view that draws a vertical line on the timeline at a specific timestamp.
   * @extends {AnnotationView}
   * @constructor
   */
  function XMarkerAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
  }

  XMarkerAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    draw: function(ctx) {
      var dt = this.viewport_.currentDisplayTransform;
      var viewX = dt.xWorldToView(this.annotation_.timestamp);

      ctx.beginPath();
      tr.ui.b.drawLine(ctx, viewX, 0, viewX, ctx.canvas.height);
      ctx.strokeStyle = this.annotation_.strokeStyle;
      ctx.stroke();
    }
  };

  return {
    XMarkerAnnotationView: XMarkerAnnotationView
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  function XMarkerAnnotation(timestamp) {
    tr.model.Annotation.apply(this, arguments);

    this.timestamp = timestamp;
    this.strokeStyle = 'rgba(0, 0, 255, 0.5)';
  }

  XMarkerAnnotation.fromDict = function(dict) {
    return new XMarkerAnnotation(dict.args.timestamp);
  }

  XMarkerAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    toDict: function() {
      return {
        typeName: 'xmarker',
        args: {
          timestamp: this.timestamp
        }
      };
    },

    createView_: function(viewport) {
      return new tr.ui.annotations.XMarkerAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(
      XMarkerAnnotation, {typeName: 'xmarker'});

  return {
    XMarkerAnnotation: XMarkerAnnotation
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  var MOUSE_SELECTOR_MODE = {};
  MOUSE_SELECTOR_MODE.SELECTION = 0x1;
  MOUSE_SELECTOR_MODE.PANSCAN = 0x2;
  MOUSE_SELECTOR_MODE.ZOOM = 0x4;
  MOUSE_SELECTOR_MODE.TIMING = 0x8;
  MOUSE_SELECTOR_MODE.ROTATE = 0x10;
  MOUSE_SELECTOR_MODE.ALL_MODES = 0x1F;

  var MOUSE_SELECTOR_MODE_INFOS = {};
  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.PANSCAN] = {
    mode: MOUSE_SELECTOR_MODE.PANSCAN,
    title: 'pan',
    eventNames: {
      enter: 'enterpan',
      begin: 'beginpan',
      update: 'updatepan',
      end: 'endpan',
      exit: 'exitpan'
    },
    activeBackgroundPosition: '-30px -10px',
    defaultBackgroundPosition: '0 -10px'
  };
  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.SELECTION] = {
    mode: MOUSE_SELECTOR_MODE.SELECTION,
    title: 'selection',
    eventNames: {
      enter: 'enterselection',
      begin: 'beginselection',
      update: 'updateselection',
      end: 'endselection',
      exit: 'exitselection'
    },
    activeBackgroundPosition: '-30px -40px',
    defaultBackgroundPosition: '0 -40px'
  };

  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.ZOOM] = {
    mode: MOUSE_SELECTOR_MODE.ZOOM,
    title: 'zoom',
    eventNames: {
      enter: 'enterzoom',
      begin: 'beginzoom',
      update: 'updatezoom',
      end: 'endzoom',
      exit: 'exitzoom'
    },
    activeBackgroundPosition: '-30px -70px',
    defaultBackgroundPosition: '0 -70px'
  };
  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.TIMING] = {
    mode: MOUSE_SELECTOR_MODE.TIMING,
    title: 'timing',
    eventNames: {
      enter: 'entertiming',
      begin: 'begintiming',
      update: 'updatetiming',
      end: 'endtiming',
      exit: 'exittiming'
    },
    activeBackgroundPosition: '-30px -100px',
    defaultBackgroundPosition: '0 -100px'
  };
  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.ROTATE] = {
    mode: MOUSE_SELECTOR_MODE.ROTATE,
    title: 'rotate',
    eventNames: {
      enter: 'enterrotate',
      begin: 'beginrotate',
      update: 'updaterotate',
      end: 'endrotate',
      exit: 'exitrotate'
    },
    activeBackgroundPosition: '-30px -130px',
    defaultBackgroundPosition: '0 -130px'
  };

  return {
    MOUSE_SELECTOR_MODE_INFOS: MOUSE_SELECTOR_MODE_INFOS,
    MOUSE_SELECTOR_MODE: MOUSE_SELECTOR_MODE
  };
});


  'use strict';

  Polymer('tr-ui-b-mouse-mode-icon', {
    publish: {
      modeName: {
        value: undefined,
        reflect: true
      }
    },

    created: function() {
      this.active_ = false;
      this.acceleratorKey_ = undefined;
    },

    ready: function() {
      this.updateContents_();
    },

    get mode() {
      return tr.ui.b.MOUSE_SELECTOR_MODE[this.modeName];
    },

    set mode(mode) {
      var modeInfo = tr.ui.b.MOUSE_SELECTOR_MODE_INFOS[mode];
      var modeName = tr.b.findFirstKeyInDictMatching(
          tr.ui.b.MOUSE_SELECTOR_MODE,
          function(modeName, candidateMode) {
            return candidateMode === mode;
          });
      if (modeName === undefined)
        throw new Error('Unknown mode');
      this.modeName = modeName;
    },

    modeNameChanged: function() {
      this.updateContents_();
    },

    get active() {
      return this.active_;
    },

    set active(active) {
      this.active_ = !!active;
      if (this.active_)
        this.classList.add('active');
      else
        this.classList.remove('active');
      this.updateContents_();
    },

    get acceleratorKey() {
      return this.acceleratorKey_;
    },

    set acceleratorKey(acceleratorKey) {
      this.acceleratorKey_ = acceleratorKey;
      this.updateContents_();
    },

    updateContents_: function() {
      if (this.modeName === undefined)
        return;

      var mode = this.mode;
      if (mode === undefined)
        throw new Error('Invalid mode');

      var modeInfo = tr.ui.b.MOUSE_SELECTOR_MODE_INFOS[mode];
      if (!modeInfo)
        throw new Error('Invalid mode');

      var title = modeInfo.title;
      if (this.acceleratorKey_)
        title = title + ' (' + this.acceleratorKey_ + ')';
      this.title = title;

      var bp;
      if (this.active_)
        bp = modeInfo.activeBackgroundPosition;
      else
        bp = modeInfo.defaultBackgroundPosition;
      this.style.backgroundPosition = bp;
    }
  });
  

'use strict';

tr.exportTo('tr.ui.b', function() {
  var MOUSE_SELECTOR_MODE = tr.ui.b.MOUSE_SELECTOR_MODE;
  var MOUSE_SELECTOR_MODE_INFOS = tr.ui.b.MOUSE_SELECTOR_MODE_INFOS;


  var MIN_MOUSE_SELECTION_DISTANCE = 4;

  var MODIFIER = {
    SHIFT: 0x1,
    SPACE: 0x2,
    CMD_OR_CTRL: 0x4
  };

  /**
   * Provides a panel for switching the interaction mode of the mouse.
   * It handles the user interaction and dispatches events for the various
   * modes.
   */
  Polymer('tr-ui-b-mouse-mode-selector', {
    __proto__: HTMLDivElement.prototype,

    created: function() {
      this.supportedModeMask_ = MOUSE_SELECTOR_MODE.ALL_MODES;

      this.initialRelativeMouseDownPos_ = {x: 0, y: 0};

      this.defaultMode_ = MOUSE_SELECTOR_MODE.PANSCAN;
      this.settingsKey_ = undefined;
      this.mousePos_ = {x: 0, y: 0};
      this.mouseDownPos_ = {x: 0, y: 0};

      this.onMouseDown_ = this.onMouseDown_.bind(this);
      this.onMouseMove_ = this.onMouseMove_.bind(this);
      this.onMouseUp_ = this.onMouseUp_.bind(this);

      this.onKeyDown_ = this.onKeyDown_.bind(this);
      this.onKeyUp_ = this.onKeyUp_.bind(this);

      this.mode_ = undefined;
      this.modeToKeyCodeMap_ = {};
      this.modifierToModeMap_ = {};

      this.targetElement_ = undefined;
      this.modeBeforeAlternativeModeActivated_ = null;

      this.isInteracting_ = false;
      this.isClick_ = false;
    },

    ready: function() {
      this.buttonsEl_ = this.shadowRoot.querySelector('.buttons');
      this.dragHandleEl_ = this.shadowRoot.querySelector('.drag-handle');
      this.supportedModeMask = MOUSE_SELECTOR_MODE.ALL_MODES;

      this.dragHandleEl_.addEventListener('mousedown',
          this.onDragHandleMouseDown_.bind(this));

      this.buttonsEl_.addEventListener('mouseup', this.onButtonMouseUp_);
      this.buttonsEl_.addEventListener('mousedown', this.onButtonMouseDown_);
      this.buttonsEl_.addEventListener('click', this.onButtonPress_.bind(this));
    },

    attached: function() {
      document.addEventListener('keydown', this.onKeyDown_);
      document.addEventListener('keyup', this.onKeyUp_);
    },

    detached: function() {
      document.removeEventListener('keydown', this.onKeyDown_);
      document.removeEventListener('keyup', this.onKeyUp_);
    },

    get targetElement() {
      return this.targetElement_;
    },

    set targetElement(target) {
      if (this.targetElement_)
        this.targetElement_.removeEventListener('mousedown', this.onMouseDown_);
      this.targetElement_ = target;
      if (this.targetElement_)
        this.targetElement_.addEventListener('mousedown', this.onMouseDown_);
    },

    get defaultMode() {
      return this.defaultMode_;
    },

    set defaultMode(defaultMode) {
      this.defaultMode_ = defaultMode;
    },

    get settingsKey() {
      return this.settingsKey_;
    },

    set settingsKey(settingsKey) {
      this.settingsKey_ = settingsKey;
      if (!this.settingsKey_)
        return;

      var mode = tr.b.Settings.get(this.settingsKey_ + '.mode', undefined);
      // Modes changed from 1,2,3,4 to 0x1, 0x2, 0x4, 0x8. Fix any stray
      // settings to the best of our abilities.
      if (MOUSE_SELECTOR_MODE_INFOS[mode] === undefined)
        mode = undefined;

      // Restoring settings against unsupported modes should just go back to the
      // default mode.
      if ((mode & this.supportedModeMask_) === 0)
        mode = undefined;

      if (!mode)
        mode = this.defaultMode_;
      this.mode = mode;

      var pos = tr.b.Settings.get(this.settingsKey_ + '.pos', undefined);
      if (pos)
        this.pos = pos;
    },

    get supportedModeMask() {
      return this.supportedModeMask_;
    },

    /**
     * Sets the supported modes. Should be an OR-ing of MOUSE_SELECTOR_MODE
     * values.
     */
    set supportedModeMask(supportedModeMask) {
      if (this.mode && (supportedModeMask & this.mode) === 0)
        throw new Error('supportedModeMask must include current mode.');

      function createButtonForMode(mode) {
        return button;
      }

      this.supportedModeMask_ = supportedModeMask;
      this.buttonsEl_.textContent = '';
      for (var modeName in MOUSE_SELECTOR_MODE) {
        if (modeName == 'ALL_MODES')
          continue;
        var mode = MOUSE_SELECTOR_MODE[modeName];
        if ((this.supportedModeMask_ & mode) === 0)
          continue;

        var button = document.createElement('tr-ui-b-mouse-mode-icon');
        button.mode = mode;
        button.classList.add('tool-button');

        this.buttonsEl_.appendChild(button);
      }
    },

    getButtonForMode_: function(mode) {
      for (var i = 0; i < this.buttonsEl_.children.length; i++) {
        var buttonEl = this.buttonsEl_.children[i];
        if (buttonEl.mode === mode)
          return buttonEl;
      }
      return undefined;
    },

    get mode() {
      return this.currentMode_;
    },

    set mode(newMode) {
      if (newMode !== undefined) {
        if (typeof newMode !== 'number')
          throw new Error('Mode must be a number');
        if ((newMode & this.supportedModeMask_) === 0)
          throw new Error('Cannot switch to this mode, it is not supported');
        if (MOUSE_SELECTOR_MODE_INFOS[newMode] === undefined)
          throw new Error('Unrecognized mode');
      }

      var modeInfo;

      if (this.currentMode_ === newMode)
        return;

      if (this.currentMode_) {
        var buttonEl = this.getButtonForMode_(this.currentMode_);
        if (buttonEl)
          buttonEl.active = false;

        // End event.
        if (this.isInteracting_) {

          var mouseEvent = this.createEvent_(
              MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.end);
          this.dispatchEvent(mouseEvent);
        }

        // Exit event.
        modeInfo = MOUSE_SELECTOR_MODE_INFOS[this.currentMode_];
        tr.b.dispatchSimpleEvent(this, modeInfo.eventNames.exit, true);
      }

      this.currentMode_ = newMode;

      if (this.currentMode_) {
        var buttonEl = this.getButtonForMode_(this.currentMode_);
        if (buttonEl)
          buttonEl.active = true;

        // Entering a new mode resets mouse down pos.
        this.mouseDownPos_.x = this.mousePos_.x;
        this.mouseDownPos_.y = this.mousePos_.y;

        // Enter event.
        modeInfo = MOUSE_SELECTOR_MODE_INFOS[this.currentMode_];
        if (!this.isInAlternativeMode_)
          tr.b.dispatchSimpleEvent(this, modeInfo.eventNames.enter, true);

        // Begin event.
        if (this.isInteracting_) {
          var mouseEvent = this.createEvent_(
              MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.begin);
          this.dispatchEvent(mouseEvent);
        }


      }

      if (this.settingsKey_ && !this.isInAlternativeMode_)
        tr.b.Settings.set(this.settingsKey_ + '.mode', this.mode);
    },

    setKeyCodeForMode: function(mode, keyCode) {
      if ((mode & this.supportedModeMask_) === 0)
        throw new Error('Mode not supported');
      this.modeToKeyCodeMap_[mode] = keyCode;

      if (!this.buttonsEl_)
        return;

      var buttonEl = this.getButtonForMode_(mode);
      if (buttonEl)
        buttonEl.acceleratorKey = String.fromCharCode(keyCode);
    },

    setCurrentMousePosFromEvent_: function(e) {
      this.mousePos_.x = e.clientX;
      this.mousePos_.y = e.clientY;
    },

    createEvent_: function(eventName, sourceEvent) {
      var event = new tr.b.Event(eventName, true);
      event.clientX = this.mousePos_.x;
      event.clientY = this.mousePos_.y;
      event.deltaX = this.mousePos_.x - this.mouseDownPos_.x;
      event.deltaY = this.mousePos_.y - this.mouseDownPos_.y;
      event.mouseDownX = this.mouseDownPos_.x;
      event.mouseDownY = this.mouseDownPos_.y;
      event.didPreventDefault = false;
      event.preventDefault = function() {
        event.didPreventDefault = true;
        if (sourceEvent)
          sourceEvent.preventDefault();
      };
      event.stopPropagation = function() {
        sourceEvent.stopPropagation();
      };
      event.stopImmediatePropagation = function() {
        throw new Error('Not implemented');
      };
      return event;
    },

    onMouseDown_: function(e) {
      if (e.button !== 0)
        return;
      this.setCurrentMousePosFromEvent_(e);
      var mouseEvent = this.createEvent_(
          MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.begin, e);
      this.dispatchEvent(mouseEvent);
      this.isInteracting_ = true;
      this.isClick_ = true;
      tr.ui.b.trackMouseMovesUntilMouseUp(this.onMouseMove_, this.onMouseUp_);
    },

    onMouseMove_: function(e) {
      this.setCurrentMousePosFromEvent_(e);

      var mouseEvent = this.createEvent_(
          MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.update, e);
      this.dispatchEvent(mouseEvent);

      if (this.isInteracting_)
        this.checkIsClick_(e);
    },

    onMouseUp_: function(e) {
      if (e.button !== 0)
        return;

      var mouseEvent = this.createEvent_(
          MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.end, e);
      mouseEvent.isClick = this.isClick_;
      this.dispatchEvent(mouseEvent);

      if (this.isClick_ && !mouseEvent.didPreventDefault)
        this.dispatchClickEvents_(e);

      this.isInteracting_ = false;
      this.updateAlternativeModeState_(e);
    },

    onButtonMouseDown_: function(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    },

    onButtonMouseUp_: function(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    },

    onButtonPress_: function(e) {
      this.modeBeforeAlternativeModeActivated_ = undefined;
      this.mode = e.target.mode;
      e.preventDefault();
    },

    onKeyDown_: function(e) {
      // Keys dispatched to INPUT elements still bubble, even when they're
      // handled. So, skip any events that targeted the input element.
      if (e.path[0].tagName == 'INPUT')
        return;

      if (e.keyCode === ' '.charCodeAt(0))
        this.spacePressed_ = true;
      this.updateAlternativeModeState_(e);
    },

    onKeyUp_: function(e) {
      // Keys dispatched to INPUT elements still bubble, even when they're
      // handled. So, skip any events that targeted the input element.
      if (e.path[0].tagName == 'INPUT')
        return;

      if (e.keyCode === ' '.charCodeAt(0))
        this.spacePressed_ = false;

      var didHandleKey = false;
      tr.b.iterItems(this.modeToKeyCodeMap_, function(modeStr, keyCode) {
        if (e.keyCode === keyCode) {
          this.modeBeforeAlternativeModeActivated_ = undefined;
          var mode = parseInt(modeStr);
          this.mode = mode;
          didHandleKey = true;
        }
      }, this);

      if (didHandleKey) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      this.updateAlternativeModeState_(e);
    },

    updateAlternativeModeState_: function(e) {
      var shiftPressed = e.shiftKey;
      var spacePressed = this.spacePressed_;
      var cmdOrCtrlPressed =
          (tr.isMac && e.metaKey) || (!tr.isMac && e.ctrlKey);

      // Figure out the new mode
      var smm = this.supportedModeMask_;
      var newMode;
      var isNewModeAnAlternativeMode = false;
      if (shiftPressed &&
          (this.modifierToModeMap_[MODIFIER.SHIFT] & smm) !== 0) {
        newMode = this.modifierToModeMap_[MODIFIER.SHIFT];
        isNewModeAnAlternativeMode = true;
      } else if (spacePressed &&
                 (this.modifierToModeMap_[MODIFIER.SPACE] & smm) !== 0) {
        newMode = this.modifierToModeMap_[MODIFIER.SPACE];
        isNewModeAnAlternativeMode = true;
      } else if (cmdOrCtrlPressed &&
                 (this.modifierToModeMap_[MODIFIER.CMD_OR_CTRL] & smm) !== 0) {
        newMode = this.modifierToModeMap_[MODIFIER.CMD_OR_CTRL];
        isNewModeAnAlternativeMode = true;
      } else {
        // Go to the old mode, if there is one.
        if (this.isInAlternativeMode_) {
          newMode = this.modeBeforeAlternativeModeActivated_;
          isNewModeAnAlternativeMode = false;
        } else {
          newMode = undefined;
        }
      }

      // Maybe a mode change isn't needed.
      if (this.mode === newMode || newMode === undefined)
        return;

      // Okay, we're changing.
      if (isNewModeAnAlternativeMode)
        this.modeBeforeAlternativeModeActivated_ = this.mode;
      this.mode = newMode;
    },

    get isInAlternativeMode_() {
      return !!this.modeBeforeAlternativeModeActivated_;
    },

    setModifierForAlternateMode: function(mode, modifier) {
      this.modifierToModeMap_[modifier] = mode;
    },

    get pos() {
      return {
        x: parseInt(this.style.left),
        y: parseInt(this.style.top)
      };
    },

    set pos(pos) {
      pos = this.constrainPositionToBounds_(pos);

      this.style.left = pos.x + 'px';
      this.style.top = pos.y + 'px';

      if (this.settingsKey_)
        tr.b.Settings.set(this.settingsKey_ + '.pos', this.pos);
    },

    constrainPositionToBounds_: function(pos) {
      var parent = this.offsetParent || document.body;
      var parentRect = tr.ui.b.windowRectForElement(parent);

      var top = 0;
      var bottom = parentRect.height - this.offsetHeight;
      var left = 0;
      var right = parentRect.width - this.offsetWidth;

      var res = {};
      res.x = Math.max(pos.x, left);
      res.x = Math.min(res.x, right);

      res.y = Math.max(pos.y, top);
      res.y = Math.min(res.y, bottom);
      return res;
    },

    onDragHandleMouseDown_: function(e) {
      e.preventDefault();
      e.stopImmediatePropagation();

      var mouseDownPos = {
        x: e.clientX - this.offsetLeft,
        y: e.clientY - this.offsetTop
      };
      tr.ui.b.trackMouseMovesUntilMouseUp(function(e) {
        var pos = {};
        pos.x = e.clientX - mouseDownPos.x;
        pos.y = e.clientY - mouseDownPos.y;
        this.pos = pos;
      }.bind(this));
    },

    checkIsClick_: function(e) {
      if (!this.isInteracting_ || !this.isClick_)
        return;

      var deltaX = this.mousePos_.x - this.mouseDownPos_.x;
      var deltaY = this.mousePos_.y - this.mouseDownPos_.y;
      var minDist = MIN_MOUSE_SELECTION_DISTANCE;

      if (deltaX * deltaX + deltaY * deltaY > minDist * minDist)
        this.isClick_ = false;
    },

    dispatchClickEvents_: function(e) {
      if (!this.isClick_)
        return;

      var modeInfo = MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.SELECTION];
      var eventNames = modeInfo.eventNames;

      var mouseEvent = this.createEvent_(eventNames.begin);
      this.dispatchEvent(mouseEvent);

      mouseEvent = this.createEvent_(eventNames.end);
      this.dispatchEvent(mouseEvent);
    }
  });

  return {
    MIN_MOUSE_SELECTION_DISTANCE: MIN_MOUSE_SELECTION_DISTANCE,
    MODIFIER: MODIFIER
  };
});


'use strict';

/**
 * @fileoverview Provides the TimingTool class.
 */
tr.exportTo('tr.ui.b', function() {

  /**
   * Tool for taking time measurements in the TimelineTrackView using
   * Viewportmarkers.
   * @constructor
   */
  function TimingTool(viewport, targetElement) {
    this.viewport_ = viewport;

    // Prepare the event handlers to be added and removed repeatedly.
    this.onMouseMove_ = this.onMouseMove_.bind(this);
    this.onDblClick_ = this.onDblClick_.bind(this);
    this.targetElement_ = targetElement;

    // Valid only during mousedown.
    this.isMovingLeftEdge_ = false;
  };

  TimingTool.prototype = {

    onEnterTiming: function(e) {
      this.targetElement_.addEventListener('mousemove', this.onMouseMove_);
      this.targetElement_.addEventListener('dblclick', this.onDblClick_);
    },

    onBeginTiming: function(e) {
      if (!this.isTouchPointInsideTrackBounds_(e.clientX, e.clientY))
        return;

      var pt = this.getSnappedToEventPosition_(e);
      this.mouseDownAt_(pt.x, pt.y);

      this.updateSnapIndicators_(pt);
    },

    updateSnapIndicators_: function(pt) {
      if (!pt.snapped)
        return;
      var ir = this.viewport_.interestRange;
      if (ir.min === pt.x)
        ir.leftSnapIndicator = new tr.ui.SnapIndicator(pt.y, pt.height);
      if (ir.max === pt.x)
        ir.rightSnapIndicator = new tr.ui.SnapIndicator(pt.y, pt.height);
    },

    onUpdateTiming: function(e) {
      var pt = this.getSnappedToEventPosition_(e);
      this.mouseMoveAt_(pt.x, pt.y, true);
      this.updateSnapIndicators_(pt);
    },

    onEndTiming: function(e) {
      this.mouseUp_();
    },

    onExitTiming: function(e) {
      this.targetElement_.removeEventListener('mousemove', this.onMouseMove_);
      this.targetElement_.removeEventListener('dblclick', this.onDblClick_);
    },

    onMouseMove_: function(e) {
      if (e.button)
        return;
      var worldX = this.getWorldXFromEvent_(e);
      this.mouseMoveAt_(worldX, e.clientY, false);
    },

    onDblClick_: function(e) {
      // TODO(nduca): Implement dobuleclicking.
      console.error('not implemented');
    },

    ////////////////////////////////////////////////////////////////////////////

    isTouchPointInsideTrackBounds_: function(clientX, clientY) {
      if (!this.viewport_ ||
          !this.viewport_.modelTrackContainer ||
          !this.viewport_.modelTrackContainer.canvas)
        return false;

      var canvas = this.viewport_.modelTrackContainer.canvas;
      var canvasRect = canvas.getBoundingClientRect();
      if (clientX >= canvasRect.left && clientX <= canvasRect.right &&
          clientY >= canvasRect.top && clientY <= canvasRect.bottom)
        return true;

      return false;
    },

    mouseDownAt_: function(worldX, y) {
      var ir = this.viewport_.interestRange;
      var dt = this.viewport_.currentDisplayTransform;

      var pixelRatio = window.devicePixelRatio || 1;
      var nearnessThresholdWorld = dt.xViewVectorToWorld(6 * pixelRatio);

      if (ir.isEmpty) {
        ir.setMinAndMax(worldX, worldX);
        ir.rightSelected = true;
        this.isMovingLeftEdge_ = false;
        return;
      }


      // Left edge test.
      if (Math.abs(worldX - ir.min) < nearnessThresholdWorld) {
        ir.leftSelected = true;
        ir.min = worldX;
        this.isMovingLeftEdge_ = true;
        return;
      }

      // Right edge test.
      if (Math.abs(worldX - ir.max) < nearnessThresholdWorld) {
        ir.rightSelected = true;
        ir.max = worldX;
        this.isMovingLeftEdge_ = false;
        return;
      }

      ir.setMinAndMax(worldX, worldX);
      ir.rightSelected = true;
      this.isMovingLeftEdge_ = false;
    },

    mouseMoveAt_: function(worldX, y, mouseDown) {
      var ir = this.viewport_.interestRange;

      if (mouseDown) {
        this.updateMovingEdge_(worldX);
        return;
      }

      var ir = this.viewport_.interestRange;
      var dt = this.viewport_.currentDisplayTransform;

      var pixelRatio = window.devicePixelRatio || 1;
      var nearnessThresholdWorld = dt.xViewVectorToWorld(6 * pixelRatio);

      // Left edge test.
      if (Math.abs(worldX - ir.min) < nearnessThresholdWorld) {
        ir.leftSelected = true;
        ir.rightSelected = false;
        return;
      }

      // Right edge test.
      if (Math.abs(worldX - ir.max) < nearnessThresholdWorld) {
        ir.leftSelected = false;
        ir.rightSelected = true;
        return;
      }

      ir.leftSelected = false;
      ir.rightSelected = false;
      return;
    },

    updateMovingEdge_: function(newWorldX) {
      var ir = this.viewport_.interestRange;
      var a = ir.min;
      var b = ir.max;
      if (this.isMovingLeftEdge_)
        a = newWorldX;
      else
        b = newWorldX;

      if (a <= b)
        ir.setMinAndMax(a, b);
      else
        ir.setMinAndMax(b, a);

      if (ir.min == newWorldX) {
        this.isMovingLeftEdge_ = true;
        ir.leftSelected = true;
        ir.rightSelected = false;
      } else {
        this.isMovingLeftEdge_ = false;
        ir.leftSelected = false;
        ir.rightSelected = true;
      }
    },

    mouseUp_: function() {
      var dt = this.viewport_.currentDisplayTransform;
      var ir = this.viewport_.interestRange;

      ir.leftSelected = false;
      ir.rightSelected = false;

      var pixelRatio = window.devicePixelRatio || 1;
      var minWidthValue = dt.xViewVectorToWorld(2 * pixelRatio);
      if (ir.range < minWidthValue)
        ir.reset();
    },

    getWorldXFromEvent_: function(e) {
      var pixelRatio = window.devicePixelRatio || 1;
      var canvas = this.viewport_.modelTrackContainer.canvas;
      var worldOffset = canvas.getBoundingClientRect().left;
      var viewX = (e.clientX - worldOffset) * pixelRatio;
      return this.viewport_.currentDisplayTransform.xViewToWorld(viewX);
    },


    /**
     * Get the closest position of an event within a vertical range of the mouse
     * position if possible, otherwise use the position of the mouse pointer.
     * @param {MouseEvent} e Mouse event with the current mouse coordinates.
     * @return {
     *   {Number} x, The x coordinate in world space.
     *   {Number} y, The y coordinate in world space.
     *   {Number} height, The height of the event.
     *   {boolean} snapped Whether the coordinates are from a snapped event or
     *     the mouse position.
     * }
     */
    getSnappedToEventPosition_: function(e) {
      var pixelRatio = window.devicePixelRatio || 1;
      var EVENT_SNAP_RANGE = 16 * pixelRatio;

      var modelTrackContainer = this.viewport_.modelTrackContainer;
      var modelTrackContainerRect = modelTrackContainer.getBoundingClientRect();

      var viewport = this.viewport_;
      var dt = viewport.currentDisplayTransform;
      var worldMaxDist = dt.xViewVectorToWorld(EVENT_SNAP_RANGE);

      var worldX = this.getWorldXFromEvent_(e);
      var mouseY = e.clientY;

      var selection = new tr.model.EventSet();

      // Look at the track under mouse position first for better performance.
      modelTrackContainer.addClosestEventToSelection(
          worldX, worldMaxDist, mouseY, mouseY, selection);

      // Look at all tracks visible on screen.
      if (!selection.length) {
        modelTrackContainer.addClosestEventToSelection(
            worldX, worldMaxDist,
            modelTrackContainerRect.top, modelTrackContainerRect.bottom,
            selection);
      }

      var minDistX = worldMaxDist;
      var minDistY = Infinity;
      var pixWidth = dt.xViewVectorToWorld(1);

      // Create result object with the mouse coordinates.
      var result = {
        x: worldX,
        y: mouseY - modelTrackContainerRect.top,
        height: 0,
        snapped: false
      };

      var eventBounds = new tr.b.Range();
      for (var i = 0; i < selection.length; i++) {
        var event = selection[i];
        var track = viewport.trackForEvent(event);
        var trackRect = track.getBoundingClientRect();

        eventBounds.reset();
        event.addBoundsToRange(eventBounds);
        var eventX;
        if (Math.abs(eventBounds.min - worldX) <
            Math.abs(eventBounds.max - worldX)) {
          eventX = eventBounds.min;
        } else {
          eventX = eventBounds.max;
        }

        var distX = eventX - worldX;

        var eventY = trackRect.top;
        var eventHeight = trackRect.height;
        var distY = Math.abs(eventY + eventHeight / 2 - mouseY);

        // Prefer events with a closer y position if their x difference is below
        // the width of a pixel.
        if ((distX <= minDistX || Math.abs(distX - minDistX) < pixWidth) &&
            distY < minDistY) {
          minDistX = distX;
          minDistY = distY;

          // Retrieve the event position from the hit.
          result.x = eventX;
          result.y = eventY +
              modelTrackContainer.scrollTop - modelTrackContainerRect.top;
          result.height = eventHeight;
          result.snapped = true;
        }
      }

      return result;
    }
  };

  return {
    TimingTool: TimingTool
  };
});


'use strict';

tr.exportTo('tr.ui', function() {
  var kDefaultPanAnimatoinDurationMs = 100.0;

  /**
   * Pans a TimelineDisplayTransform by a given amount.
   * @constructor
   * @extends {tr.ui.b.Animation}
   * @param {Number} deltaX The total amount of change to the transform's panX.
   * @param {Number} deltaY The total amount of change to the transform's panY.
   * @param {Number=} opt_durationMs How long the pan animation should run.
   * Defaults to kDefaultPanAnimatoinDurationMs.
   */
  function TimelineDisplayTransformPanAnimation(
      deltaX, deltaY, opt_durationMs) {
    this.deltaX = deltaX;
    this.deltaY = deltaY;
    if (opt_durationMs === undefined)
      this.durationMs = kDefaultPanAnimatoinDurationMs;
    else
      this.durationMs = opt_durationMs;

    this.startPanX = undefined;
    this.startPanY = undefined;
    this.startTimeMs = undefined;
  }

  TimelineDisplayTransformPanAnimation.prototype = {
    __proto__: tr.ui.b.Animation.prototype,

    get affectsPanY() {
      return this.deltaY !== 0;
    },

    canTakeOverFor: function(existingAnimation) {
      return existingAnimation instanceof TimelineDisplayTransformPanAnimation;
    },

    takeOverFor: function(existing, timestamp, target) {
      var remainingDeltaXOnExisting = existing.goalPanX - target.panX;
      var remainingDeltaYOnExisting = existing.goalPanY - target.panY;
      var remainingTimeOnExisting = timestamp - (
          existing.startTimeMs + existing.durationMs);
      remainingTimeOnExisting = Math.max(remainingTimeOnExisting, 0);

      this.deltaX += remainingDeltaXOnExisting;
      this.deltaY += remainingDeltaYOnExisting;
      this.durationMs += remainingTimeOnExisting;
    },

    start: function(timestamp, target) {
      this.startTimeMs = timestamp;
      this.startPanX = target.panX;
      this.startPanY = target.panY;
    },

    tick: function(timestamp, target) {
      var percentDone = (timestamp - this.startTimeMs) / this.durationMs;
      percentDone = tr.b.clamp(percentDone, 0, 1);

      target.panX = tr.b.lerp(percentDone, this.startPanX, this.goalPanX);
      if (this.affectsPanY)
        target.panY = tr.b.lerp(percentDone, this.startPanY, this.goalPanY);
      return timestamp >= this.startTimeMs + this.durationMs;
    },

    get goalPanX() {
      return this.startPanX + this.deltaX;
    },

    get goalPanY() {
      return this.startPanY + this.deltaY;
    }
  };

  /**
   * Zooms in/out on a specified location in the world.
   *
   * Zooming in and out is all about keeping the area under the mouse cursor,
   * here called the "focal point" in the same place under the zoom. If one
   * simply changes the scale, the area under the mouse cursor will change. To
   * keep the focal point from moving during the zoom, the pan needs to change
   * in order to compensate. Thus, a ZoomTo animation is given both a focal
   * point in addition to the amount by which to zoom.
   *
   * @constructor
   * @extends {tr.ui.b.Animation}
   * @param {Number} goalFocalPointXWorld The X coordinate in the world which is
   * of interest.
   * @param {Number} goalFocalPointXView Where on the screen the
   * goalFocalPointXWorld should stay centered during the zoom.
   * @param {Number} goalFocalPointY Where the panY should be when the zoom
   * completes.
   * @param {Number} zoomInRatioX The ratio of the current scaleX to the goal
   * scaleX.
   */
  function TimelineDisplayTransformZoomToAnimation(
      goalFocalPointXWorld,
      goalFocalPointXView,
      goalFocalPointY,
      zoomInRatioX,
      opt_durationMs) {
    this.goalFocalPointXWorld = goalFocalPointXWorld;
    this.goalFocalPointXView = goalFocalPointXView;
    this.goalFocalPointY = goalFocalPointY;
    this.zoomInRatioX = zoomInRatioX;
    if (opt_durationMs === undefined)
      this.durationMs = kDefaultPanAnimatoinDurationMs;
    else
      this.durationMs = opt_durationMs;

    this.startTimeMs = undefined;
    this.startScaleX = undefined;
    this.goalScaleX = undefined;
    this.startPanY = undefined;
  }

  TimelineDisplayTransformZoomToAnimation.prototype = {
    __proto__: tr.ui.b.Animation.prototype,

    get affectsPanY() {
      return this.startPanY != this.goalFocalPointY;
    },

    canTakeOverFor: function(existingAnimation) {
      return false;
    },

    takeOverFor: function(existingAnimation, timestamp, target) {
      this.goalScaleX = target.scaleX * this.zoomInRatioX;
    },

    start: function(timestamp, target) {
      this.startTimeMs = timestamp;
      this.startScaleX = target.scaleX;
      this.goalScaleX = this.zoomInRatioX * target.scaleX;
      this.startPanY = target.panY;
    },

    tick: function(timestamp, target) {
      var percentDone = (timestamp - this.startTimeMs) / this.durationMs;
      percentDone = tr.b.clamp(percentDone, 0, 1);

      target.scaleX = tr.b.lerp(percentDone, this.startScaleX, this.goalScaleX);
      if (this.affectsPanY) {
        target.panY = tr.b.lerp(
            percentDone, this.startPanY, this.goalFocalPointY);
      }

      target.xPanWorldPosToViewPos(
          this.goalFocalPointXWorld, this.goalFocalPointXView);
      return timestamp >= this.startTimeMs + this.durationMs;
    }
  };

  return {
    TimelineDisplayTransformPanAnimation:
        TimelineDisplayTransformPanAnimation,
    TimelineDisplayTransformZoomToAnimation:
        TimelineDisplayTransformZoomToAnimation
  };
});


'use strict';

/**
 * @fileoverview Container that decorates its children.
 */
tr.exportTo('tr.ui.b', function() {
  /**
   * @constructor
   */
  var ContainerThatDecoratesItsChildren = tr.ui.b.define('div');

  ContainerThatDecoratesItsChildren.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.observer_ = new WebKitMutationObserver(this.didMutate_.bind(this));
      this.observer_.observe(this, { childList: true });

      // textContent is a variable on regular HTMLElements. However, we want to
      // hook and prevent writes to it.
      Object.defineProperty(
          this, 'textContent',
          { get: undefined, set: this.onSetTextContent_});
    },

    appendChild: function(x) {
      HTMLUnknownElement.prototype.appendChild.call(this, x);
      this.didMutate_(this.observer_.takeRecords());
    },

    insertBefore: function(x, y) {
      HTMLUnknownElement.prototype.insertBefore.call(this, x, y);
      this.didMutate_(this.observer_.takeRecords());
    },

    removeChild: function(x) {
      HTMLUnknownElement.prototype.removeChild.call(this, x);
      this.didMutate_(this.observer_.takeRecords());
    },

    replaceChild: function(x, y) {
      HTMLUnknownElement.prototype.replaceChild.call(this, x, y);
      this.didMutate_(this.observer_.takeRecords());
    },

    onSetTextContent_: function(textContent) {
      if (textContent != '')
        throw new Error('textContent can only be set to \'\'.');
      this.clear();
    },

    clear: function() {
      while (this.lastChild)
        HTMLUnknownElement.prototype.removeChild.call(this, this.lastChild);
      this.didMutate_(this.observer_.takeRecords());
    },

    didMutate_: function(records) {
      this.beginDecorating_();
      for (var i = 0; i < records.length; i++) {
        var addedNodes = records[i].addedNodes;
        if (addedNodes) {
          for (var j = 0; j < addedNodes.length; j++)
            this.decorateChild_(addedNodes[j]);
        }
        var removedNodes = records[i].removedNodes;
        if (removedNodes) {
          for (var j = 0; j < removedNodes.length; j++) {
            this.undecorateChild_(removedNodes[j]);
          }
        }
      }
      this.doneDecoratingForNow_();
    },

    decorateChild_: function(child) {
      throw new Error('Not implemented');
    },

    undecorateChild_: function(child) {
      throw new Error('Not implemented');
    },

    beginDecorating_: function() {
    },

    doneDecoratingForNow_: function() {
    }
  };

  return {
    ContainerThatDecoratesItsChildren: ContainerThatDecoratesItsChildren
  };

});


'use strict';

/**
 * @fileoverview Renders an array of slices into the provided div,
 * using a child canvas element. Uses a FastRectRenderer to draw only
 * the visible slices.
 */
tr.exportTo('tr.ui.tracks', function() {
  /**
   * The base class for all tracks.
   * @constructor
   */
  var Track = tr.ui.b.define('track',
                             tr.ui.b.ContainerThatDecoratesItsChildren);
  Track.prototype = {
    __proto__: tr.ui.b.ContainerThatDecoratesItsChildren.prototype,

    decorate: function(viewport) {
      tr.ui.b.ContainerThatDecoratesItsChildren.prototype.decorate.call(this);
      if (viewport === undefined)
        throw new Error('viewport is required when creating a Track.');

      this.viewport_ = viewport;
      this.classList.add('track');
    },

    get viewport() {
      return this.viewport_;
    },

    get drawingContainer() {
      var cur = this;
      while (cur) {
        if (cur instanceof tr.ui.tracks.DrawingContainer)
          return cur;
        cur = cur.parentElement;
      }
      return undefined;
    },

    get eventContainer() {
    },

    invalidateDrawingContainer: function() {
      var dc = this.drawingContainer;
      if (dc)
        dc.invalidate();
    },

    context: function() {
      // This is a little weird here, but we have to be able to walk up the
      // parent tree to get the context.
      if (!this.parentNode)
        return undefined;
      if (!this.parentNode.context)
        throw new Error('Parent container does not support context() method.');
      return this.parentNode.context();
    },

    decorateChild_: function(childTrack) {
    },

    undecorateChild_: function(childTrack) {
      if (childTrack.detach)
        childTrack.detach();
    },

    updateContents_: function() {
    },

    drawTrack: function(type) {
      var ctx = this.context();

      var pixelRatio = window.devicePixelRatio || 1;
      var bounds = this.getBoundingClientRect();
      var canvasBounds = ctx.canvas.getBoundingClientRect();

      ctx.save();
      ctx.translate(0, pixelRatio * (bounds.top - canvasBounds.top));

      var dt = this.viewport.currentDisplayTransform;
      var viewLWorld = dt.xViewToWorld(0);
      var viewRWorld = dt.xViewToWorld(bounds.width * pixelRatio);

      this.draw(type, viewLWorld, viewRWorld);
      ctx.restore();
    },

    draw: function(type, viewLWorld, viewRWorld) {
    },

    addEventsToTrackMap: function(eventToTrackMap) {
    },

    addContainersToTrackMap: function(containerToTrackMap) {
    },

    addIntersectingEventsInRangeToSelection: function(
        loVX, hiVX, loVY, hiVY, selection) {

      var pixelRatio = window.devicePixelRatio || 1;
      var dt = this.viewport.currentDisplayTransform;
      var viewPixWidthWorld = dt.xViewVectorToWorld(1);
      var loWX = dt.xViewToWorld(loVX * pixelRatio);
      var hiWX = dt.xViewToWorld(hiVX * pixelRatio);

      var clientRect = this.getBoundingClientRect();
      var a = Math.max(loVY, clientRect.top);
      var b = Math.min(hiVY, clientRect.bottom);
      if (a > b)
        return;

      this.addIntersectingEventsInRangeToSelectionInWorldSpace(
          loWX, hiWX, viewPixWidthWorld, selection);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
    },

    /**
     * Gets implemented by supporting track types. The method adds the event
     * closest to worldX to the selection.
     *
     * @param {number} worldX The position that is looked for.
     * @param {number} worldMaxDist The maximum distance allowed from worldX to
     *     the event.
     * @param {number} loY Lower Y bound of the search interval in view space.
     * @param {number} hiY Upper Y bound of the search interval in view space.
     * @param {Selection} selection Selection to which to add hits.
     */
    addClosestEventToSelection: function(
        worldX, worldMaxDist, loY, hiY, selection) {
    },

    addClosestInstantEventToSelection: function(instantEvents, worldX,
                                                worldMaxDist, selection) {
      var instantEvent = tr.b.findClosestElementInSortedArray(
          instantEvents,
          function(x) { return x.start; },
          worldX,
          worldMaxDist);

      if (!instantEvent)
        return;

      selection.push(instantEvent);
    }
  };

  return {
    Track: Track
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  var constants = {
    HEADING_WIDTH: 250
  };

  return {
    constants: constants
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  var DrawType = {
    GENERAL_EVENT: 1,
    INSTANT_EVENT: 2,
    BACKGROUND: 3,
    GRID: 4,
    FLOW_ARROWS: 5,
    MARKERS: 6,
    HIGHLIGHTS: 7,
    ANNOTATIONS: 8
  };

  var DrawingContainer = tr.ui.b.define('drawing-container',
                                        tr.ui.tracks.Track);

  DrawingContainer.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      this.classList.add('drawing-container');

      this.canvas_ = document.createElement('canvas');
      this.canvas_.className = 'drawing-container-canvas';
      this.canvas_.style.left = tr.ui.b.constants.HEADING_WIDTH + 'px';
      this.appendChild(this.canvas_);

      this.ctx_ = this.canvas_.getContext('2d');

      this.viewportChange_ = this.viewportChange_.bind(this);
      this.viewport.addEventListener('change', this.viewportChange_);
    },

    // Needed to support the calls in TimelineTrackView.
    get canvas() {
      return this.canvas_;
    },

    context: function() {
      return this.ctx_;
    },

    viewportChange_: function() {
      this.invalidate();
    },

    invalidate: function() {
      if (this.rafPending_)
        return;
      this.rafPending_ = true;

      tr.b.requestPreAnimationFrame(this.preDraw_, this);
    },

    preDraw_: function() {
      this.rafPending_ = false;
      this.updateCanvasSizeIfNeeded_();

      tr.b.requestAnimationFrameInThisFrameIfPossible(this.draw_, this);
    },

    draw_: function() {
      this.ctx_.clearRect(0, 0, this.canvas_.width, this.canvas_.height);

      var typesToDraw = [
        DrawType.BACKGROUND,
        DrawType.HIGHLIGHTS,
        DrawType.GRID,
        DrawType.INSTANT_EVENT,
        DrawType.GENERAL_EVENT,
        DrawType.MARKERS,
        DrawType.ANNOTATIONS,
        DrawType.FLOW_ARROWS
      ];

      for (var idx in typesToDraw) {
        for (var i = 0; i < this.children.length; ++i) {
          if (!(this.children[i] instanceof tr.ui.tracks.Track))
            continue;
          this.children[i].drawTrack(typesToDraw[idx]);
        }
      }

      var pixelRatio = window.devicePixelRatio || 1;
      var bounds = this.canvas_.getBoundingClientRect();
      var dt = this.viewport.currentDisplayTransform;
      var viewLWorld = dt.xViewToWorld(0);
      var viewRWorld = dt.xViewToWorld(
          bounds.width * pixelRatio);

      this.viewport.drawGridLines(this.ctx_, viewLWorld, viewRWorld);
    },

    updateCanvasSizeIfNeeded_: function() {
      var visibleChildTracks =
          tr.b.asArray(this.children).filter(this.visibleFilter_);

      var thisBounds = this.getBoundingClientRect();

      var firstChildTrackBounds = visibleChildTracks[0].getBoundingClientRect();
      var lastChildTrackBounds =
          visibleChildTracks[visibleChildTracks.length - 1].
              getBoundingClientRect();

      var innerWidth = firstChildTrackBounds.width -
          tr.ui.b.constants.HEADING_WIDTH;
      var innerHeight = lastChildTrackBounds.bottom - firstChildTrackBounds.top;

      var pixelRatio = window.devicePixelRatio || 1;
      if (this.canvas_.width != innerWidth * pixelRatio) {
        this.canvas_.width = innerWidth * pixelRatio;
        this.canvas_.style.width = innerWidth + 'px';
      }

      if (this.canvas_.height != innerHeight * pixelRatio) {
        this.canvas_.height = innerHeight * pixelRatio;
        this.canvas_.style.height = innerHeight + 'px';
      }
    },

    visibleFilter_: function(element) {
      if (!(element instanceof tr.ui.tracks.Track))
        return false;
      return window.getComputedStyle(element).display !== 'none';
    },

    addClosestEventToSelection: function(
        worldX, worldMaxDist, loY, hiY, selection) {
      for (var i = 0; i < this.children.length; ++i) {
        if (!(this.children[i] instanceof tr.ui.tracks.Track))
          continue;
        var trackClientRect = this.children[i].getBoundingClientRect();
        var a = Math.max(loY, trackClientRect.top);
        var b = Math.min(hiY, trackClientRect.bottom);
        if (a <= b) {
          this.children[i].addClosestEventToSelection(
              worldX, worldMaxDist, loY, hiY, selection);
        }
      }

      tr.ui.tracks.Track.prototype.addClosestEventToSelection.
          apply(this, arguments);
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      for (var i = 0; i < this.children.length; ++i) {
        if (!(this.children[i] instanceof tr.ui.tracks.Track))
          continue;
        this.children[i].addEventsToTrackMap(eventToTrackMap);
      }
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      for (var i = 0; i < this.children.length; ++i) {
        if (!(this.children[i] instanceof tr.ui.tracks.Track))
          continue;
        this.children[i].addContainersToTrackMap(containerToTrackMap);
      }
    }
  };

  return {
    DrawingContainer: DrawingContainer,
    DrawType: DrawType
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  var SelectableItem = tr.model.SelectableItem;
  var SelectionState = tr.model.SelectionState;

  /**
   * A ProxySelectableItem is a selectable item which is not a model item itself
   * but instead acts as a proxy for a model item.
   *
   * @constructor
   * @extends {SelectableItem}
   */
  function ProxySelectableItem(modelItem) {
    SelectableItem.call(this, modelItem);
  };

  ProxySelectableItem.prototype = {
    __proto__: SelectableItem.prototype,

    get selectionState() {
      var modelItem = this.modelItem_;
      if (modelItem === undefined)
        return SelectionState.NONE;
      return modelItem.selectionState;
    }
  };

  return {
    ProxySelectableItem: ProxySelectableItem
  };
});


  'use strict';
  Polymer('tr-ui-heading', {
    DOWN_ARROW: String.fromCharCode(0x25BE),
    RIGHT_ARROW: String.fromCharCode(0x25B8),

    ready: function(viewport) {
            this.style.width = (tr.ui.b.constants.HEADING_WIDTH - 6) + 'px';

      this.heading_ = '';
      this.expanded_ = true;
      this.arrowVisible_ = false;
      this.selectionGenerator_ = undefined;

      this.updateContents_();
    },

    get heading() {
      return this.heading_;
    },

    set heading(text) {
      if (this.heading_ === text)
        return;

      this.heading_ = text;
      this.updateContents_();
    },

    set arrowVisible(val) {
      if (this.arrowVisible_ === val)
        return;

      this.arrowVisible_ = !!val;
      this.updateContents_();
    },

    set tooltip(text) {
      this.$.heading.title = text;
    },

    set selectionGenerator(generator) {
      if (this.selectionGenerator_ === generator)
        return;

      this.selectionGenerator_ = generator;
      this.updateContents_();
    },

    get expanded() {
      return this.expanded_;
    },

    set expanded(expanded) {
      if (this.expanded_ === expanded)
        return;

      this.expanded_ = !!expanded;
      this.updateContents_();
    },

    onHeadingDivClicked_: function() {
      this.dispatchEvent(new tr.b.Event('heading-clicked', {'bubbles': true}));
    },

    updateContents_: function() {
      if (this.arrowVisible_) {
        this.$.arrow.style.display = '';
      } else {
        this.$.arrow.style.display = 'none';
        this.$.heading.style.display = this.expanded_ ? '' : 'none';
      }

      if (this.arrowVisible_) {
        this.$.arrow.textContent =
            this.expanded_ ? this.DOWN_ARROW : this.RIGHT_ARROW;
      }

      this.$.link.style.display = 'none';
      this.$.heading_content.style.display = 'none';

      if (this.selectionGenerator_) {
        this.$.link.style.display = 'inline-block';
        this.$.link.selection = this.selectionGenerator_;
        this.$.link.textContent = this.heading_;
      } else {
        this.$.heading_content.style.display = 'inline-block';
        this.$.heading_content.textContent = this.heading_;
      }
    }
  });
  

'use strict';

tr.exportTo('tr.ui.tracks', function() {
  var EventPresenter = tr.ui.b.EventPresenter;
  var SelectionState = tr.model.SelectionState;

  /**
   * A track that displays an array of dots with filled letters inside them.
   * @constructor
   * @extends {Track}
   */
  var LetterDotTrack = tr.ui.b.define(
      'letter-dot-track', tr.ui.tracks.Track);

  LetterDotTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      this.classList.add('letter-dot-track');
      this.items_ = undefined;

      this.heading_ = document.createElement('tr-ui-heading');
      this.appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    get items() {
      return this.items_;
    },

    set items(items) {
      this.items_ = items;
      this.invalidateDrawingContainer();
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
    },

    get dumpRadiusView() {
      return 7 * (window.devicePixelRatio || 1);
    },

    draw: function(type, viewLWorld, viewRWorld) {
      if (this.items_ === undefined)
        return;
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawLetterDots_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawLetterDots_: function(viewLWorld, viewRWorld) {
      var ctx = this.context();
      var pixelRatio = window.devicePixelRatio || 1;

      var bounds = this.getBoundingClientRect();
      var height = bounds.height * pixelRatio;
      var halfHeight = height * 0.5;
      var twoPi = Math.PI * 2;
      var palette = tr.ui.b.getColorPalette();
      var highlightIdBoost = tr.ui.b.paletteProperties.highlightIdBoost;

      // Culling parameters.
      var dt = this.viewport.currentDisplayTransform;
      var dumpRadiusView = this.dumpRadiusView;
      var itemRadiusWorld = dt.xViewVectorToWorld(height);

      // Draw the memory dumps.
      var items = this.items_;
      var loI = tr.b.findLowIndexInSortedArray(
          items,
          function(item) { return item.start; },
          viewLWorld);

      var oldFont = ctx.font;
      ctx.font = '400 ' + Math.floor(9 * pixelRatio) + 'px Arial';
      ctx.strokeStyle = 'rgb(0,0,0)';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';

      var drawItems = function(selected) {
        for (var i = loI; i < items.length; ++i) {
          var item = items[i];
          var x = item.start;
          if (x - itemRadiusWorld > viewRWorld)
            break;
          if (item.selected !== selected)
            continue;
          var xView = dt.xWorldToView(x);

          ctx.fillStyle = EventPresenter.getSelectableItemColor(item);
          ctx.beginPath();
          ctx.arc(xView, halfHeight, dumpRadiusView + 0.5, 0, twoPi);
          ctx.fill();
          if (item.selected) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'rgb(100,100,0)';
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(xView, halfHeight, dumpRadiusView, 0, twoPi);
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = 'rgb(255,255,0)';
            ctx.stroke();
          } else {
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgb(0,0,0)';
            ctx.stroke();
          }

          ctx.fillStyle = 'rgb(255, 255, 255)';
          ctx.fillText(item.dotLetter, xView, halfHeight);
        }
      };

      // Draw unselected items first to make sure they don't occlude selected
      // items.
      drawItems(false);
      drawItems(true);

      ctx.lineWidth = 1;
      ctx.font = oldFont;
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      if (this.items_ === undefined)
        return;

      this.items_.forEach(function(item) {
        item.addToTrackMap(eventToTrackMap, this);
      }, this);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
      if (this.items_ === undefined)
        return;

      var itemRadiusWorld = viewPixWidthWorld * this.dumpRadiusView;
      tr.b.iterateOverIntersectingIntervals(
          this.items_,
          function(x) { return x.start - itemRadiusWorld; },
          function(x) { return 2 * itemRadiusWorld; },
          loWX, hiWX,
          function(item) {
            item.addToSelection(selection);
          }.bind(this));
    },

    /**
     * Add the item to the left or right of the provided event, if any, to the
     * selection.
     * @param {event} The current event item.
     * @param {Number} offset Number of slices away from the event to look.
     * @param {Selection} selection The selection to add an event to,
     * if found.
     * @return {boolean} Whether an event was found.
     * @private
     */
    addEventNearToProvidedEventToSelection: function(event, offset, selection) {
      if (this.items_ === undefined)
        return;

      var items = this.items_;
      var index = tr.b.findFirstIndexInArray(items, function(item) {
        return item.modelItem === event;
      });
      if (index === -1)
        return false;

      var newIndex = index + offset;
      if (newIndex >= 0 && newIndex < items.length) {
        items[newIndex].addToSelection(selection);
        return true;
      }
      return false;
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
    },

    addClosestEventToSelection: function(worldX, worldMaxDist, loY, hiY,
                                         selection) {
      if (this.items_ === undefined)
        return;

      var item = tr.b.findClosestElementInSortedArray(
          this.items_,
          function(x) { return x.start; },
          worldX,
          worldMaxDist);

      if (!item)
        return;

      item.addToSelection(selection);
    }
  };

  /**
   * A filled dot with a letter inside it.
   *
   * @constructor
   * @extends {ProxySelectableItem}
   */
  function LetterDot(modelItem, dotLetter, colorId, start) {
    tr.model.ProxySelectableItem.call(this, modelItem);
    this.dotLetter = dotLetter;
    this.colorId = colorId;
    this.start = start;
  };

  LetterDot.prototype = {
    __proto__: tr.model.ProxySelectableItem.prototype
  };

  return {
    LetterDotTrack: LetterDotTrack,
    LetterDot: LetterDot
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of alert objects.
   * @constructor
   * @extends {LetterDotTrack}
   */
  var AlertTrack = tr.ui.b.define(
      'alert-track', tr.ui.tracks.LetterDotTrack);

  AlertTrack.prototype = {
    __proto__: tr.ui.tracks.LetterDotTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.LetterDotTrack.prototype.decorate.call(this, viewport);
      this.heading = 'Alerts';
      this.alerts_ = undefined;
    },

    get alerts() {
      return this.alerts_;
    },

    set alerts(alerts) {
      this.alerts_ = alerts;
      if (alerts === undefined) {
        this.items = undefined;
        return;
      }
      this.items = this.alerts_.map(function(alert) {
        return new tr.ui.tracks.LetterDot(
            alert, String.fromCharCode(9888), alert.colorId, alert.start);
      });
    }
  };

  return {
    AlertTrack: AlertTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  var Task = tr.b.Task;

  /**
   * A generic track that contains other tracks as its children.
   * @constructor
   */
  var ContainerTrack = tr.ui.b.define('container-track', tr.ui.tracks.Track);
  ContainerTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
    },

    detach: function() {
      this.textContent = '';
    },

    get tracks_() {
      var tracks = [];
      for (var i = 0; i < this.children.length; i++) {
        if (this.children[i] instanceof tr.ui.tracks.Track)
          tracks.push(this.children[i]);
      }
      return tracks;
    },

    drawTrack: function(type) {
      this.tracks_.forEach(function(track) {
        track.drawTrack(type);
      });
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loY Lower Y bound of the interval to search, in
     *     viewspace space.
     * @param {number} hiY Upper Y bound of the interval to search, in
     *     viewspace space.
     * @param {Selection} selection Selection to which to add results.
     */
    addIntersectingEventsInRangeToSelection: function(
        loVX, hiVX, loY, hiY, selection) {
      for (var i = 0; i < this.tracks_.length; i++) {
        var trackClientRect = this.tracks_[i].getBoundingClientRect();
        var a = Math.max(loY, trackClientRect.top);
        var b = Math.min(hiY, trackClientRect.bottom);
        if (a <= b)
          this.tracks_[i].addIntersectingEventsInRangeToSelection(
              loVX, hiVX, loY, hiY, selection);
      }

      tr.ui.tracks.Track.prototype.addIntersectingEventsInRangeToSelection.
          apply(this, arguments);
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      for (var i = 0; i < this.children.length; ++i)
        this.children[i].addEventsToTrackMap(eventToTrackMap);
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
      for (var i = 0; i < this.tracks_.length; i++)
        this.tracks_[i].addAllEventsMatchingFilterToSelection(
            filter, selection);
    },

    addAllEventsMatchingFilterToSelectionAsTask: function(filter, selection) {
      var task = new Task();
      for (var i = 0; i < this.tracks_.length; i++) {
        task.subTask(function(i) { return function() {
          this.tracks_[i].addAllEventsMatchingFilterToSelection(
              filter, selection);
        } }(i), this);
      }
      return task;
    },

    addClosestEventToSelection: function(
        worldX, worldMaxDist, loY, hiY, selection) {
      for (var i = 0; i < this.tracks_.length; i++) {
        var trackClientRect = this.tracks_[i].getBoundingClientRect();
        var a = Math.max(loY, trackClientRect.top);
        var b = Math.min(hiY, trackClientRect.bottom);
        if (a <= b) {
          this.tracks_[i].addClosestEventToSelection(
              worldX, worldMaxDist, loY, hiY, selection);
        }
      }

      tr.ui.tracks.Track.prototype.addClosestEventToSelection.
          apply(this, arguments);
    },

    clearTracks_: function() {
      this.tracks_.forEach(function(track) {
        this.removeChild(track);
      }, this);
    }
  };

  return {
    ContainerTrack: ContainerTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * A vertical axis for a (set of) chart series which maps an arbitrary range
   * of values [min, max] to the unit range [0, 1].
   *
   * @constructor
   */
  function ChartAxis(opt_min, opt_max) {
    this.guid_ = tr.b.GUID.allocate();
    this.bounds = new tr.b.Range();
    if (opt_min !== undefined)
      this.bounds.addValue(opt_min);
    if (opt_max !== undefined)
      this.bounds.addValue(opt_max);
  };

  ChartAxis.prototype = {
    get guid() {
      return this.guid_;
    },

    valueToUnitRange: function(value) {
      if (this.bounds.isEmpty)
        throw new Error('Chart axis bounds are empty');
      var bounds = this.bounds;
      if (bounds.range === 0)
        return 0;
      return (value - bounds.min) / bounds.range;
    },

    /**
     * Automatically set the axis bounds from the range of values of all series
     * in a list.
     *
     * See the description of autoSetFromRange for the optional configuration
     * argument flags.
     */
    autoSetFromSeries: function(series, opt_config) {
      var range = new tr.b.Range();
      series.forEach(function(s) {
        range.addRange(s.range);
      }, this);
      this.autoSetFromRange(range, opt_config);
    },

    /**
     * Automatically set the axis bound from a range of values.
     *
     * The following four flags, which affect the behavior of this method with
     * respect to already defined bounds, can be present in the optional
     * configuration (a flag is assumed to be false if it is not provided or if
     * the configuration is not provided):
     *
     *   - expandMin: allow decreasing the min bound (if range.min < this.min)
     *   - shrinkMin: allow increasing the min bound (if range.min > this.min)
     *   - expandMax: allow increasing the max bound (if range.max > this.max)
     *   - shrinkMax: allow decreasing the max bound (if range.max < this.max)
     *
     * This method will ensure that the resulting bounds are defined and valid
     * (i.e. min <= max) provided that they were valid or empty before and the
     * value range is non-empty and valid.
     *
     * Note that unless expanding/shrinking a bound is explicitly enabled in
     * the configuration, non-empty bounds will not be changed under any
     * circumstances.
     *
     * Observe that if no configuration is provided (or all flags are set to
     * false), this method will only modify the axis bounds if they are empty.
     */
    autoSetFromRange: function(range, opt_config) {
      if (range.isEmpty)
        return;

      var bounds = this.bounds;
      if (bounds.isEmpty) {
        bounds.addRange(range);
        return;
      }

      if (!opt_config)
        return;

      var useRangeMin = (opt_config.expandMin && range.min < bounds.min ||
                         opt_config.shrinkMin && range.min > bounds.min);
      var useRangeMax = (opt_config.expandMax && range.max > bounds.max ||
                         opt_config.shrinkMax && range.max < bounds.max);

      // Neither bound is modified.
      if (!useRangeMin && !useRangeMax)
        return;

      // Both bounds are modified. Assuming the range argument is a valid
      // range, no extra checks are necessary.
      if (useRangeMin && useRangeMax) {
        bounds.min = range.min;
        bounds.max = range.max;
        return;
      }

      // Only one bound is modified. We must ensure that it doesn't go
      // over/under the other (unmodified) bound.
      if (useRangeMin) {
        bounds.min = Math.min(range.min, bounds.max);
      } else {
        bounds.max = Math.max(range.max, bounds.min);
      }
    }
  };

  return {
    ChartAxis: ChartAxis
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * A point in a chart series with x (timestamp) and y (value) coordinates
   * and an associated model item. The point can optionally also have a base
   * y coordinate (which for example corresponds to the bottom edge of the
   * associated bar in a bar chart).
   *
   * @constructor
   * @extends {ProxySelectableItem}
   */
  function ChartPoint(modelItem, x, y, opt_yBase) {
    tr.model.ProxySelectableItem.call(this, modelItem);
    this.x = x;
    this.y = y;

    // If the base y-coordinate is undefined, the bottom edge of the associated
    // bar in a bar chart will start at the outer bottom edge (which is most
    // likely slightly below zero).
    this.yBase = opt_yBase;
  };

  ChartPoint.prototype = {
    __proto__: tr.model.ProxySelectableItem.prototype
  };

  return {
    ChartPoint: ChartPoint
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  var EventPresenter = tr.ui.b.EventPresenter;
  var SelectionState = tr.model.SelectionState;

  /**
   * The type of a chart series.
   * @enum
   */
  var ChartSeriesType = {
    LINE: 0,
    AREA: 1
  };

  // The default rendering configuration for ChartSeries.
  var DEFAULT_RENDERING_CONFIG = {
    // The type of the chart series.
    chartType: ChartSeriesType.LINE,

    // The size of a selected point dot in device-independent pixels (circle
    // diameter).
    selectedPointSize: 4,

    // The size of an unselected point dot in device-independent pixels (square
    // width/height).
    unselectedPointSize: 3,

    // The color of the chart.
    colorId: 0,

    // The width of the top line in device-independent pixels.
    lineWidth: 1,

    // Minimum distance between points in physical pixels. Points which are
    // closer than this distance will be skipped.
    skipDistance: 1,

    // Density in points per physical pixel at which unselected point dots
    // become transparent.
    unselectedPointDensityTransparent: 0.10,

    // Density in points per physical pixel at which unselected point dots
    // become fully opaque.
    unselectedPointDensityOpaque: 0.05,

    // Opacity of area chart background.
    backgroundOpacity: 0.5
  };

  // The virtual width of the last point in a series (whose rectangle has zero
  // width) in world timestamps difference for the purposes of selection.
  var LAST_POINT_WIDTH = 16;

  /**
   * Visual components of a ChartSeries.
   * @enum
   */
  var ChartSeriesComponent = {
    BACKGROUND: 0,
    LINE: 1,
    DOTS: 2
  };

  /**
   * A series of points corresponding to a single chart on a chart track.
   * This class is responsible for drawing the actual chart onto canvas.
   *
   * @constructor
   */
  function ChartSeries(points, axis, opt_renderingConfig) {
    this.points = points;
    this.axis = axis;

    this.useRenderingConfig_(opt_renderingConfig);
  }

  ChartSeries.prototype = {
    useRenderingConfig_: function(opt_renderingConfig) {
      var config = opt_renderingConfig || {};

      // Store all configuration flags as private properties.
      tr.b.iterItems(DEFAULT_RENDERING_CONFIG, function(key, defaultValue) {
        var value = config[key];
        if (value === undefined)
          value = defaultValue;
        this[key + '_'] = value;
      }, this);

      // Avoid unnecessary recomputation in getters.
      this.topPadding = this.bottomPadding = Math.max(
          this.selectedPointSize_, this.unselectedPointSize_) / 2;
    },

    get range() {
      var range = new tr.b.Range();
      this.points.forEach(function(point) {
        range.addValue(point.y);
      }, this);
      return range;
    },

    draw: function(ctx, transform, highDetails) {
      if (this.points === undefined || this.points.length === 0)
        return;

      // Draw the background.
      if (this.chartType_ === ChartSeriesType.AREA) {
        this.drawComponent_(ctx, transform, ChartSeriesComponent.BACKGROUND,
            highDetails);
      }

      // Draw the line at the top.
      if (this.chartType_ === ChartSeriesType.LINE || highDetails) {
        this.drawComponent_(ctx, transform, ChartSeriesComponent.LINE,
            highDetails);
      }

      // Draw the points.
      this.drawComponent_(ctx, transform, ChartSeriesComponent.DOTS,
          highDetails);
    },

    drawComponent_: function(ctx, transform, component, highDetails) {
      // We need to consider extra pixels outside the visible area to avoid
      // visual glitches due to non-zero width of dots.
      var extraPixels = 0;
      if (component === ChartSeriesComponent.DOTS) {
        extraPixels = Math.max(
            this.selectedPointSize_, this.unselectedPointSize_);
      }
      var leftViewX = transform.leftViewX - extraPixels * transform.pixelRatio;
      var rightViewX = transform.rightViewX +
          extraPixels * transform.pixelRatio;
      var leftTimestamp = transform.leftTimestamp - extraPixels;
      var rightTimestamp = transform.rightTimestamp + extraPixels;

      // Find the index of the first and last (partially) visible points.
      var firstVisibleIndex = tr.b.findLowIndexInSortedArray(
          this.points,
          function(point) { return point.x; },
          leftTimestamp);
      var lastVisibleIndex = tr.b.findLowIndexInSortedArray(
          this.points,
          function(point) { return point.x; },
          rightTimestamp);
      if (lastVisibleIndex >= this.points.length ||
          this.points[lastVisibleIndex].x > rightTimestamp) {
        lastVisibleIndex--;
      }

      // Pre-calculate component style which does not depend on individual
      // points:
      //   * Skip distance between points,
      //   * Selected (circle) and unselected (square) dot size,
      //   * Unselected dot opacity,
      //   * Selected dot edge color and width, and
      //   * Line component color and width.
      var viewSkipDistance = this.skipDistance_ * transform.pixelRatio;
      var circleRadius;
      var squareSize;
      var squareHalfSize;
      var squareOpacity;

      switch (component) {
        case ChartSeriesComponent.DOTS:
          // Selected dot edge color and width.
          ctx.strokeStyle = EventPresenter.getCounterSeriesColor(
              this.colorId_, SelectionState.NONE);
          ctx.lineWidth = transform.pixelRatio;

          // Selected (circle) and unselected (square) dot size.
          circleRadius = (this.selectedPointSize_ / 2) * transform.pixelRatio;
          squareSize = this.unselectedPointSize_ * transform.pixelRatio;
          squareHalfSize = squareSize / 2;

          // Unselected dot opacity.
          if (!highDetails) {
            // Unselected dots are not displayed in 'low details' mode.
            squareOpacity = 0;
            break;
          }
          var visibleIndexRange = lastVisibleIndex - firstVisibleIndex;
          if (visibleIndexRange <= 0) {
            // There is at most one visible point.
            squareOpacity = 1;
            break;
          }
          var visibleViewXRange =
              transform.worldXToViewX(this.points[lastVisibleIndex].x) -
              transform.worldXToViewX(this.points[firstVisibleIndex].x);
          if (visibleViewXRange === 0) {
            // Multiple visible points which all have the same timestamp.
            squareOpacity = 1;
            break;
          }
          var density = visibleIndexRange / visibleViewXRange;
          var clampedDensity = tr.b.clamp(density,
              this.unselectedPointDensityOpaque_,
              this.unselectedPointDensityTransparent_);
          var densityRange = this.unselectedPointDensityTransparent_ -
              this.unselectedPointDensityOpaque_;
          squareOpacity =
              (this.unselectedPointDensityTransparent_ - clampedDensity) /
              densityRange;
          break;

        case ChartSeriesComponent.LINE:
          // Line component color and width.
          ctx.strokeStyle = EventPresenter.getCounterSeriesColor(
              this.colorId_, SelectionState.NONE);
          ctx.lineWidth = this.lineWidth_ * transform.pixelRatio;
          break;

        case ChartSeriesComponent.BACKGROUND:
          // Style depends on the selection state of individual points.
          break;

        default:
          throw new Error('Invalid component: ' + component);
      }

      // The main loop which draws the given component of visible points from
      // left to right. Given the potentially large number of points to draw,
      // it should be considered performance-critical and function calls should
      // be avoided when possible.
      //
      // Note that the background and line components are drawn in a delayed
      // fashion: the rectangle/line that we draw in an iteration corresponds
      // to the *previous* point. This does not apply to the dots, whose
      // position is independent of the surrounding dots.
      var previousViewX = undefined;
      var previousViewY = undefined;
      var previousViewYBase = undefined;
      var lastSelectionState = undefined;
      var baseSteps = undefined;
      var startIndex = Math.max(firstVisibleIndex - 1, 0);

      for (var i = startIndex; i < this.points.length; i++) {
        var currentPoint = this.points[i];
        var currentViewX = transform.worldXToViewX(currentPoint.x);

        // Stop drawing the points once we are to the right of the visible area.
        if (currentViewX > rightViewX) {
          if (previousViewX !== undefined) {
            previousViewX = currentViewX = rightViewX;
            if (component === ChartSeriesComponent.BACKGROUND ||
                component === ChartSeriesComponent.LINE) {
              ctx.lineTo(currentViewX, previousViewY);
            }
          }
          break;
        }

        if (i + 1 < this.points.length) {
          var nextPoint = this.points[i + 1];
          var nextViewX = transform.worldXToViewX(nextPoint.x);

          // Skip points that are too close to each other.
          if (previousViewX !== undefined &&
              nextViewX - previousViewX <= viewSkipDistance &&
              nextViewX < rightViewX) {
            continue;
          }

          // Start drawing right at the left side of the visible are (instead
          // of potentially very far to the left).
          if (currentViewX < leftViewX) {
            currentViewX = leftViewX;
          }
        }

        if (previousViewX !== undefined &&
            currentViewX - previousViewX < viewSkipDistance) {
          // We know that nextViewX > previousViewX + viewSkipDistance, so we
          // can safely move this points's x over that much without passing
          // nextViewX. This ensures that the previous point is visible when
          // zoomed out very far.
          currentViewX = previousViewX + viewSkipDistance;
        }

        var currentViewY = Math.round(transform.worldYToViewY(currentPoint.y));
        var currentViewYBase;
        if (currentPoint.yBase === undefined) {
          currentViewYBase = transform.outerBottomViewY;
        } else {
          currentViewYBase = Math.round(
              transform.worldYToViewY(currentPoint.yBase));
        }
        var currentSelectionState = currentPoint.selectionState;

        // Actually draw the given component of the point.
        switch (component) {
          case ChartSeriesComponent.DOTS:
            // Change dot style when the selection state changes (and at the
            // beginning).
            if (currentSelectionState !== lastSelectionState) {
              if (currentSelectionState === SelectionState.SELECTED) {
                ctx.fillStyle = EventPresenter.getCounterSeriesColor(
                    this.colorId_, currentSelectionState);
              } else if (squareOpacity > 0) {
                ctx.fillStyle = EventPresenter.getCounterSeriesColor(
                    this.colorId_, currentSelectionState, squareOpacity);
              }
            }

            // Draw the dot for the current point.
            if (currentSelectionState === SelectionState.SELECTED) {
              ctx.beginPath();
              ctx.arc(currentViewX, currentViewY, circleRadius, 0, 2 * Math.PI);
              ctx.fill();
              ctx.stroke();
            } else if (squareOpacity > 0) {
              ctx.fillRect(currentViewX - squareHalfSize,
                  currentViewY - squareHalfSize, squareSize, squareSize);
            }
            break;

          case ChartSeriesComponent.LINE:
            // Draw the top line for the previous point (if applicable), or
            // prepare for drawing the top line of the current point in the next
            // iteration.
            if (previousViewX === undefined) {
              ctx.beginPath();
              ctx.moveTo(currentViewX, currentViewY);
            } else {
              ctx.lineTo(currentViewX, previousViewY);
            }

            // Move to the current point coordinate.
            ctx.lineTo(currentViewX, currentViewY);
            break;

          case ChartSeriesComponent.BACKGROUND:
            // Draw the background for the previous point (if applicable).
            if (previousViewX !== undefined)
              ctx.lineTo(currentViewX, previousViewY);

            // Finish the bottom part of the backgound polygon, change
            // background color and start a new polygon when the selection state
            // changes (and at the beginning).
            if (currentSelectionState !== lastSelectionState) {
              if (previousViewX !== undefined) {
                var previousBaseStepViewX = currentViewX;
                for (var j = baseSteps.length - 1; j >= 0; j--) {
                  var baseStep = baseSteps[j];
                  var baseStepViewX = baseStep.viewX;
                  var baseStepViewY = baseStep.viewY;
                  ctx.lineTo(previousBaseStepViewX, baseStepViewY);
                  ctx.lineTo(baseStepViewX, baseStepViewY);
                  previousBaseStepViewX = baseStepViewX;
                }
                ctx.closePath();
                ctx.fill();
              }
              ctx.beginPath();
              ctx.fillStyle = EventPresenter.getCounterSeriesColor(
                  this.colorId_, currentSelectionState,
                  this.backgroundOpacity_);
              ctx.moveTo(currentViewX, currentViewYBase);
              baseSteps = [];
            }

            if (currentViewYBase !== previousViewYBase ||
                currentSelectionState !== lastSelectionState) {
              baseSteps.push({viewX: currentViewX, viewY: currentViewYBase});
            }

            // Move to the current point coordinate.
            ctx.lineTo(currentViewX, currentViewY);
            break;

          default:
            throw new Error('Not reachable');
        }

        previousViewX = currentViewX;
        previousViewY = currentViewY;
        previousViewYBase = currentViewYBase;
        lastSelectionState = currentSelectionState;
      }

      // If we still have an open background or top line polygon (which is
      // always the case once we have started drawing due to the delayed fashion
      // of drawing), we must close it.
      if (previousViewX !== undefined) {
        switch (component) {
          case ChartSeriesComponent.DOTS:
            // All dots were drawn in the main loop.
            break;

          case ChartSeriesComponent.LINE:
            ctx.stroke();
            break;

          case ChartSeriesComponent.BACKGROUND:
            var previousBaseStepViewX = currentViewX;
            for (var j = baseSteps.length - 1; j >= 0; j--) {
              var baseStep = baseSteps[j];
              var baseStepViewX = baseStep.viewX;
              var baseStepViewY = baseStep.viewY;
              ctx.lineTo(previousBaseStepViewX, baseStepViewY);
              ctx.lineTo(baseStepViewX, baseStepViewY);
              previousBaseStepViewX = baseStepViewX;
            }
            ctx.closePath();
            ctx.fill();
            break;

          default:
            throw new Error('Not reachable');
        }
      }
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
      var points = this.points;

      function getPointWidth(point, i) {
        if (i === points.length - 1)
          return LAST_POINT_WIDTH * viewPixWidthWorld;
        var nextPoint = points[i + 1];
        return nextPoint.x - point.x;
      }

      function selectPoint(point) {
        point.addToSelection(selection);
      }

      tr.b.iterateOverIntersectingIntervals(
          this.points,
          function(point) { return point.x },
          getPointWidth,
          loWX,
          hiWX,
          selectPoint);
    },

    addEventNearToProvidedEventToSelection: function(event, offset, selection) {
      if (this.points === undefined)
        return false;

      var index = tr.b.findFirstIndexInArray(this.points, function(point) {
        return point.modelItem === event;
      }, this);
      if (index === -1)
        return false;

      var newIndex = index + offset;
      if (newIndex < 0 || newIndex >= this.points.length)
        return false;

      this.points[newIndex].addToSelection(selection);
      return true;
    },

    addClosestEventToSelection: function(worldX, worldMaxDist, loY, hiY,
                                         selection) {
      if (this.points === undefined)
        return;

      var item = tr.b.findClosestElementInSortedArray(
          this.points,
          function(point) { return point.x },
          worldX,
          worldMaxDist);

      if (!item)
        return;

      item.addToSelection(selection);
    }
  };

  return {
    ChartSeries: ChartSeries,
    ChartSeriesType: ChartSeriesType
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * A helper object encapsulating all parameters necessary to draw a chart
   * series and provides conversion between world coordinates and physical
   * pixels.
   *
   * All parameters (except for pixelRatio) are assumed to be in physical pixels
   * (i.e. already pre-multiplied with pixelRatio).
   *
   * The diagram below explains the meaning of the resulting fields with
   * respect to a chart track:
   *
   *      outerTopViewY -> +--------------------/-\-------+ <- Top padding
   *      innerTopViewY -> + - - - - - - - - - -| |- - - -+ <- Axis max
   *                       | ..               ==\-/==     |
   *                       |   ==       Series       ==   |
   *                       |     ==/-\==               .. |
   *   innerBottomViewY -> + - - -Point- - - - - - - - - -+ <- Axis min
   *   outerBottomViewY -> +-------\-/--------------------+ <- Bottom padding
   *                       ^                              ^
   *                   leftViewX                      rightViewX
   *                 leftTimeStamp                  rightTimestamp
   *
   * Labels starting with a lower case letter are the resulting fields of the
   * transform object. Labels starting with an upper case letter correspond
   * to the relevant chart track concepts.
   *
   * @constructor
   */
  function ChartTransform(displayTransform, axis, trackWidth,
      trackHeight, topPadding, bottomPadding, pixelRatio) {
    this.pixelRatio = pixelRatio;

    // X axis.
    this.leftViewX = 0;
    this.rightViewX = trackWidth;
    this.leftTimestamp = displayTransform.xViewToWorld(this.leftViewX);
    this.rightTimestamp = displayTransform.xViewToWorld(this.rightViewX);

    this.displayTransform_ = displayTransform;

    // Y axis.
    this.outerTopViewY = 0;
    this.innerTopViewY = topPadding;
    this.innerBottomViewY = trackHeight - bottomPadding;
    this.outerBottomViewY = trackHeight;

    this.axis_ = axis;
    this.innerHeight_ = this.innerBottomViewY - this.innerTopViewY;
  };

  ChartTransform.prototype = {
    worldXToViewX: function(worldX) {
      return this.displayTransform_.xWorldToView(worldX);
    },

    viewXToWorldX: function(viewX) {
      return this.displayTransform_.xViewToWorld(viewX);
    },

    worldYToViewY: function(worldY) {
      var innerHeightCoefficient = 1 - this.axis_.valueToUnitRange(worldY);
      return innerHeightCoefficient * this.innerHeight_ + this.innerTopViewY;
    }
  };

  return {
    ChartTransform: ChartTransform
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * A track that displays a chart.
   *
   * @constructor
   * @extends {Track}
   */
  var ChartTrack =
      tr.ui.b.define('chart-track', tr.ui.tracks.Track);

  ChartTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      this.classList.add('chart-track');
      this.series_ = undefined;

      // GUID -> {axis: ChartAxis, series: [ChartSeries]}.
      this.axisGuidToAxisData_ = undefined;

      // The maximum top and bottom padding of all series.
      this.topPadding_ = undefined;
      this.bottomPadding_ = undefined;

      this.heading_ = document.createElement('tr-ui-heading');
      this.appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    get series() {
      return this.series_;
    },

    /**
     * Set the list of chart series to be displayed on this track. The list
     * is assumed to be sorted in increasing z-order (i.e. the last series in
     * the list will be drawn at the top).
     */
    set series(series) {
      this.series_ = series;
      this.calculateAxisDataAndPadding_();
      this.invalidateDrawingContainer();
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
      this.invalidateDrawingContainer();
    },

    get hasVisibleContent() {
      return !!this.series && this.series.length > 0;
    },

    calculateAxisDataAndPadding_: function() {
      if (!this.series_) {
        this.axisGuidToAxisData_ = undefined;
        this.topPadding_ = undefined;
        this.bottomPadding_ = undefined;
        return;
      }

      var axisGuidToAxisData = {};
      var topPadding = 0;
      var bottomPadding = 0;

      this.series_.forEach(function(series) {
        var axis = series.axis;
        var axisGuid = axis.guid;
        if (!(axisGuid in axisGuidToAxisData)) {
          axisGuidToAxisData[axisGuid] = {
            axis: axis,
            series: []
          };
        }
        axisGuidToAxisData[axisGuid].series.push(series);
        topPadding = Math.max(topPadding, series.topPadding);
        bottomPadding = Math.max(bottomPadding, series.bottomPadding);
      }, this);

      this.axisGuidToAxisData_ = axisGuidToAxisData;
      this.topPadding_ = topPadding;
      this.bottomPadding_ = bottomPadding;
    },

    draw: function(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawChart_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawChart_: function(viewLWorld, viewRWorld) {
      if (!this.series_)
        return;

      var ctx = this.context();

      // Get track drawing parameters.
      var displayTransform = this.viewport.currentDisplayTransform;
      var pixelRatio = window.devicePixelRatio || 1;
      var bounds = this.getBoundingClientRect();
      var highDetails = this.viewport.highDetails;

      // Pre-multiply all device-independent pixel parameters with the pixel
      // ratio to avoid unnecessary recomputation in the performance-critical
      // drawing code.
      var width = bounds.width * pixelRatio;
      var height = bounds.height * pixelRatio;
      var topPadding = this.topPadding_ * pixelRatio;
      var bottomPadding = this.bottomPadding_ * pixelRatio;

      // Set up clipping.
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, width, height);
      ctx.clip();

      // Draw all series in the increasing z-order.
      this.series_.forEach(function(series) {
        var chartTransform = new tr.ui.tracks.ChartTransform(
            displayTransform, series.axis, width, height, topPadding,
            bottomPadding, pixelRatio);
        series.draw(ctx, chartTransform, highDetails);
      }, this);

      // Stop clipping.
      ctx.restore();
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      // TODO(petrcermak): Consider adding the series to the track map instead
      // of the track (a potential performance optimization).
      this.series_.forEach(function(series) {
        series.points.forEach(function(point) {
          point.addToTrackMap(eventToTrackMap, this);
        }, this);
      }, this);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
      this.series_.forEach(function(series) {
        series.addIntersectingEventsInRangeToSelectionInWorldSpace(
            loWX, hiWX, viewPixWidthWorld, selection);
      }, this);
    },

    addEventNearToProvidedEventToSelection: function(event, offset, selection) {
      var foundItem = false;
      this.series_.forEach(function(series) {
        foundItem = foundItem || series.addEventNearToProvidedEventToSelection(
            event, offset, selection);
      }, this);
      return foundItem;
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
      // Do nothing.
    },

    addClosestEventToSelection: function(worldX, worldMaxDist, loY, hiY,
                                         selection) {
      this.series_.forEach(function(series) {
        series.addClosestEventToSelection(
            worldX, worldMaxDist, loY, hiY, selection);
      }, this);
    },

    /**
     * Automatically set the bounds of all axes on this track from the range of
     * values of all series (in this track) associated with each of them.
     *
     * See the description of ChartAxis.autoSetFromRange for the optional
     * configuration argument flags.
     */
    autoSetAllAxes: function(opt_config) {
      tr.b.iterItems(this.axisGuidToAxisData_, function(axisGuid, axisData) {
        var axis = axisData.axis;
        var series = axisData.series;
        axis.autoSetFromSeries(series, opt_config);
      }, this);
    },

    /**
     * Automatically set the bounds of the provided axis from the range of
     * values of all series (in this track) associated with it.
     *
     * See the description of ChartAxis.autoSetFromRange for the optional
     * configuration argument flags.
     */
    autoSetAxis: function(axis, opt_config) {
      var series = this.axisGuidToAxisData_[axis.guid].series;
      axis.autoSetFromSeries(series, opt_config);
    }
  };

  return {
    ChartTrack: ChartTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  var ChartTrack = tr.ui.tracks.ChartTrack;

  /**
   * A track that displays a PowerSeries.
   *
   * @constructor
   * @extends {ChartTrack}
   */
  var PowerSeriesTrack = tr.ui.b.define('power-series-track', ChartTrack);

  PowerSeriesTrack.prototype = {
    __proto__: ChartTrack.prototype,

    decorate: function(viewport) {
      ChartTrack.prototype.decorate.call(this, viewport);
      this.classList.add('power-series-track');
      this.heading = 'Power';
      this.powerSeries_ = undefined;
    },

    set powerSeries(powerSeries) {
      this.powerSeries_ = powerSeries;

      this.series = this.buildChartSeries_();
      this.autoSetAllAxes({expandMax: true});
    },

    get hasVisibleContent() {
      return (this.powerSeries_ && this.powerSeries_.samples.length > 0);
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      containerToTrackMap.addContainer(this.powerSeries_, this);
    },

    buildChartSeries_: function() {
      if (!this.hasVisibleContent)
        return [];

      var axis = new tr.ui.tracks.ChartAxis(0, undefined);
      var pts = this.powerSeries_.samples.map(function(smpl) {
        return new tr.ui.tracks.ChartPoint(smpl, smpl.start, smpl.power);
      });
      var renderingConfig = {
        chartType: tr.ui.tracks.ChartSeriesType.AREA,
        colorId: tr.ui.b.getColorIdForGeneralPurposeString(this.heading)
      };

      return [new tr.ui.tracks.ChartSeries(pts, axis, renderingConfig)];
    }
  };

  return {
    PowerSeriesTrack: PowerSeriesTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * @constructor
   */
  var SpacingTrack = tr.ui.b.define('spacing-track', tr.ui.tracks.Track);

  SpacingTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      this.classList.add('spacing-track');

      this.heading_ = document.createElement('tr-ui-heading');
      this.appendChild(this.heading_);
    },

    draw: function(type, viewLWorld, viewRWorld) {
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
    }
  };

  return {
    SpacingTrack: SpacingTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  var ContainerTrack = tr.ui.tracks.ContainerTrack;

  // TODO(charliea): Make this track collapsible.
  /**
   * Track to visualize the device model.
   *
   * @constructor
   * @extends {ContainerTrack}
   */
  var DeviceTrack = tr.ui.b.define('device-track', ContainerTrack);

  DeviceTrack.prototype = {

    __proto__: ContainerTrack.prototype,

    decorate: function(viewport) {
      ContainerTrack.prototype.decorate.call(this, viewport);

      this.classList.add('device-track');
      this.device_ = undefined;
      this.powerSeriesTrack_ = undefined;
    },

    get device() {
      return this.device_;
    },

    set device(device) {
      this.device_ = device;
      this.updateContents_();
    },

    get powerSeriesTrack() {
      return this.powerSeriesTrack_;
    },

    get hasVisibleContent() {
      return (this.powerSeriesTrack_ &&
          this.powerSeriesTrack_.hasVisibleContent);
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      containerToTrackMap.addContainer(this.device, this);
      this.tracks_.forEach(function(track) {
        track.addContainersToTrackMap(containerToTrackMap);
      });
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      this.tracks_.forEach(function(track) {
        track.addEventsToTrackMap(eventToTrackMap);
      });
    },

    appendPowerSeriesTrack_: function() {
      this.powerSeriesTrack_ = new tr.ui.tracks.PowerSeriesTrack(this.viewport);
      this.powerSeriesTrack_.powerSeries = this.device.powerSeries;

      if (this.powerSeriesTrack_.hasVisibleContent) {
        this.appendChild(this.powerSeriesTrack_);
        this.appendChild(new tr.ui.tracks.SpacingTrack(this.viewport));
      }
    },

    updateContents_: function() {
      this.clearTracks_();
      this.appendPowerSeriesTrack_();
    }
  };

  return {
    DeviceTrack: DeviceTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  var DISPLAYED_SIZE_ATTRIBUTE_NAME =
      tr.model.MemoryAllocatorDump.DISPLAYED_SIZE_ATTRIBUTE_NAME;

  /**
   * Add numeric values from a source dictionary to the numeric values in
   * a destination dictionary. Undefined values are treated as zeros. Note that
   * this method modifies the destination dictionary in place.
   *
   * Example: addDictionary({a: 1, b: 2}, {b: 3, c: 4}) will update the
   * destination dictionary (first argument) to {a: 1, b: 5, c: 4}.
   */
  function addDictionary(dstDict, srcDict) {
    tr.b.iterItems(srcDict, function(key, value) {
      var existingValue = dstDict[key];
      if (existingValue === undefined)
        existingValue = 0;
      dstDict[key] = existingValue + value;
    });
  }

  /**
   * Get a dictionary mapping root allocator names (e.g. 'v8') to the
   * corresponding sizes (e.g. 1024) in a process memory dump.
   */
  function getProcessMemoryDumpAllocatorSizes(processMemoryDump) {
    var allocatorDumps = processMemoryDump.memoryAllocatorDumps;
    if (allocatorDumps === undefined)
      return {};
    var allocatorSizes = {};
    allocatorDumps.forEach(function(allocatorDump) {
      // Don't show tracing overhead in the charts.
      // TODO(petrcermak): Find a less hacky way to do this.
      if (allocatorDump.fullName === 'tracing')
        return;
      var allocatorSize = allocatorDump.attributes[
          DISPLAYED_SIZE_ATTRIBUTE_NAME];
      if (allocatorSize === undefined)
        return;
      var allocatorSizeValue = allocatorSize.value;
      if (allocatorSizeValue === undefined)
        return;
      allocatorSizes[allocatorDump.fullName] = allocatorSizeValue;
    });
    return allocatorSizes;
  };

  /**
   * Get a dictionary mapping root allocator names (e.g. 'v8') to the
   * corresponding sizes (e.g. 1024) in a global memory dump (i.e. summed over
   * all simultaneous process memory dumps).
   */
  function getGlobalMemoryDumpAllocatorSizes(globalMemoryDump) {
    var globalAllocatorSizes = {};
    tr.b.iterItems(globalMemoryDump.processMemoryDumps,
        function(pid, processMemoryDump) {
      addDictionary(globalAllocatorSizes,
          getProcessMemoryDumpAllocatorSizes(processMemoryDump));
    });
    return globalAllocatorSizes;
  }

  /**
   * A generic function which converts a list of memory dumps to a list of chart
   * series (one per root allocator). Each series represents the evolution of
   * the size of a the corresponding root allocator (e.g. 'v8') over time.
   */
  function buildAllocatedMemoryChartSeries(memoryDumps,
      memoryDumpToAllocatorSizesFn) {
    var allocatorNameToPoints = {};
    var dumpsData = memoryDumps.map(function(memoryDump) {
      var allocatorSizes = memoryDumpToAllocatorSizesFn(memoryDump);
      tr.b.iterItems(allocatorSizes, function(allocatorName) {
        allocatorNameToPoints[allocatorName] = [];
      });
      return {dump: memoryDump, sizes: allocatorSizes};
    });

    // Do not generate any chart series if no process memory dump contains any
    // allocator dumps.
    if (Object.keys(allocatorNameToPoints).length === 0)
      return undefined;

    dumpsData.forEach(function(dumpData) {
      var memoryDump = dumpData.dump;
      var allocatorSizes = dumpData.sizes;
      tr.b.iterItems(allocatorNameToPoints, function(allocatorName, points) {
        var allocatorSize = allocatorSizes[allocatorName] || 0;
        points.push(new tr.ui.tracks.ChartPoint(
            memoryDump, memoryDump.start, allocatorSize));
      });
    });

    // Create one common axis for all allocated memory chart series.
    var axis = new tr.ui.tracks.ChartAxis(0);

    // Build a chart series for each allocator.
    var series = [];
    tr.b.iterItems(allocatorNameToPoints, function(allocatorName, points) {
      var colorId = tr.ui.b.getColorIdForGeneralPurposeString(allocatorName);
      var renderingConfig = {
        chartType: tr.ui.tracks.ChartSeriesType.LINE,
        colorId: colorId
      };
      series.push(new tr.ui.tracks.ChartSeries(points, axis, renderingConfig));
    });

    return series;
  }

  /**
   * Transform a list of memory dumps to a list of letter dots (with letter 'M'
   * inside).
   */
  function buildMemoryLetterDots(memoryDumps) {
    var lightMemoryColorId =
        tr.ui.b.getColorIdForReservedName('light_memory_dump');
    var detailedMemoryColorId =
        tr.ui.b.getColorIdForReservedName('detailed_memory_dump');
    return memoryDumps.map(function(memoryDump) {
      var memoryColorId;
      switch (memoryDump.levelOfDetail) {
        case 'detailed':
          memoryColorId = detailedMemoryColorId;
          break;
        case 'light':
        default:
          memoryColorId = lightMemoryColorId;
      }
      return new tr.ui.tracks.LetterDot(
          memoryDump, 'M', memoryColorId, memoryDump.start);
    });
  }

  /**
   * Convert a list of global memory dumps to a list of chart series (one per
   * process). Each series represents the evolution of the memory used by the
   * process over time.
   */
  function buildGlobalUsedMemoryChartSeries(globalMemoryDumps) {
    // Do not generate the chart if no process memory dump contains VM regions.
    var containsVmRegions = globalMemoryDumps.some(function(globalDump) {
      for (var pid in globalDump.processMemoryDumps)
        if (globalDump.processMemoryDumps[pid].mostRecentVmRegions)
          return true;
      return false;
    });
    if (!containsVmRegions)
      return undefined;

    // Find all processes that dump memory at least once.
    var pidToProcess = {};
    globalMemoryDumps.forEach(function(globalDump) {
      tr.b.iterItems(globalDump.processMemoryDumps, function(pid, processDump) {
        pidToProcess[pid] = processDump.process;
      });
    });

    // Build one list of points for each instrumented process.
    var pidToPoints = {};
    tr.b.iterItems(pidToProcess, function(pid, process) {
      pidToPoints[pid] = [];
    });

    // For every timestamp, calculate the total PSS (proportional set size) of
    // each process and append it to the corresponding list of points.
    globalMemoryDumps.forEach(function(globalDump) {
      var pssBase = 0;
      tr.b.iterItems(pidToPoints, function(pid, points) {
        var processMemoryDump = globalDump.processMemoryDumps[pid];
        var pss;
        if (processMemoryDump === undefined) {
          // If no dump was found, assume that the process is dead.
          pss = 0;
        } else {
          pss = processMemoryDump.getMostRecentTotalVmRegionStat(
              'proportionalResident');
          if (pss === undefined) {
            // If the dump does not provide the necessary information (namely
            // most recent VM regions), assume zero.
            pss = 0;
          }
        }
        var cumulativePss = pssBase + pss;
        points.push(new tr.ui.tracks.ChartPoint(
            globalDump, globalDump.start, cumulativePss, pssBase));
        pssBase = cumulativePss;
      });
    });

    // Create one common axis for all used memory chart series.
    var axis = new tr.ui.tracks.ChartAxis(0);

    // Build a chart series for each instrumented process.
    var series = [];
    tr.b.iterItems(pidToPoints, function(pid, points) {
      var process = pidToProcess[pid];
      var colorId = tr.ui.b.getColorIdForGeneralPurposeString(
          process.userFriendlyName);
      var renderingConfig = {
        chartType: tr.ui.tracks.ChartSeriesType.AREA,
        colorId: colorId,
        backgroundOpacity: 0.8
      };
      series.push(new tr.ui.tracks.ChartSeries(points, axis, renderingConfig));
    });

    // Show the first series (with the smallest cumulative value) at the top.
    series.reverse();

    return series;
  }

  /**
   * Convert a list of process memory dumps to a list of chart series (one per
   * root allocator). Each series represents the evolution of the size of a the
   * corresponding root allocator (e.g. 'v8') over time.
   */
  function buildProcessAllocatedMemoryChartSeries(processMemoryDumps) {
    return buildAllocatedMemoryChartSeries(processMemoryDumps,
        getProcessMemoryDumpAllocatorSizes);
  }

  /**
   * Convert a list of global memory dumps to a list of chart series (one per
   * root allocator). Each series represents the evolution of the size of a the
   * corresponding root allocator (e.g. 'v8') over time.
   */
  function buildGlobalAllocatedMemoryChartSeries(globalMemoryDumps) {
    return buildAllocatedMemoryChartSeries(globalMemoryDumps,
        getGlobalMemoryDumpAllocatorSizes);
  }

  return {
    buildMemoryLetterDots:
        buildMemoryLetterDots,
    buildGlobalUsedMemoryChartSeries:
        buildGlobalUsedMemoryChartSeries,
    buildProcessAllocatedMemoryChartSeries:
        buildProcessAllocatedMemoryChartSeries,
    buildGlobalAllocatedMemoryChartSeries:
        buildGlobalAllocatedMemoryChartSeries
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  var USED_MEMORY_TRACK_HEIGHT = 50;
  var ALLOCATED_MEMORY_TRACK_HEIGHT = 50;

  /**
   * A track that displays an array of GlobalMemoryDump objects.
   * @constructor
   * @extends {ContainerTrack}
   */
  var GlobalMemoryDumpTrack = tr.ui.b.define(
      'global-memory-dump-track', tr.ui.tracks.ContainerTrack);

  GlobalMemoryDumpTrack.prototype = {
    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.memoryDumps_ = undefined;
    },

    get memoryDumps() {
      return this.memoryDumps_;
    },

    set memoryDumps(memoryDumps) {
      this.memoryDumps_ = memoryDumps;
      this.updateContents_();
    },

    updateContents_: function() {
      this.clearTracks_();

      // Show no tracks if there are no dumps.
      if (!this.memoryDumps_ || !this.memoryDumps_.length)
        return;

      this.appendDumpDotsTrack_();
      this.appendUsedMemoryTrack_();
      this.appendAllocatedMemoryTrack_();
    },

    appendDumpDotsTrack_: function() {
      var items = tr.ui.tracks.buildMemoryLetterDots(this.memoryDumps_);
      if (!items)
        return;

      var track = new tr.ui.tracks.LetterDotTrack(this.viewport);
      track.heading = 'Memory Dumps';
      track.items = items;
      this.appendChild(track);
    },

    appendUsedMemoryTrack_: function() {
      var series = tr.ui.tracks.buildGlobalUsedMemoryChartSeries(
          this.memoryDumps_);
      if (!series)
        return;

      var track = new tr.ui.tracks.ChartTrack(this.viewport);
      track.heading = 'Used memory (per process)';
      track.height = USED_MEMORY_TRACK_HEIGHT + 'px';
      track.series = series;
      track.autoSetAllAxes({expandMax: true});
      this.appendChild(track);
    },

    appendAllocatedMemoryTrack_: function() {
      var series = tr.ui.tracks.buildGlobalAllocatedMemoryChartSeries(
          this.memoryDumps_);
      if (!series)
        return;

      var track = new tr.ui.tracks.ChartTrack(this.viewport);
      track.heading = 'Allocated memory (per allocator)';
      track.height = ALLOCATED_MEMORY_TRACK_HEIGHT + 'px';
      track.series = series;
      track.autoSetAllAxes({expandMax: true});
      this.appendChild(track);
    }
  };

  return {
    GlobalMemoryDumpTrack: GlobalMemoryDumpTrack
  };
});


'use strict';

/**
 * @fileoverview Allows custom highlighting to be added to the full model track.
 */
tr.exportTo('tr.ui.tracks', function() {

  /**
   * Highlights cetrain features of the model.
   * @constructor
   */
  function Highlighter(viewport) {
    if (viewport === undefined) {
      throw new Error('viewport must be provided');
    }
    this.viewport_ = viewport;
  };

  Highlighter.prototype = {
    __proto__: Object.prototype,

    processModel: function(model) {
      throw new Error('processModel implementation missing');
    },

    drawHighlight: function(ctx, dt, viewLWorld, viewRWorld, viewHeight) {
      throw new Error('drawHighlight implementation missing');
    }
  };


  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Highlighter;
  tr.b.decorateExtensionRegistry(Highlighter, options);

  return {
    Highlighter: Highlighter
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * A track that displays a Counter object.
   * @constructor
   * @extends {ChartTrack}
   */
  var CounterTrack = tr.ui.b.define('counter-track', tr.ui.tracks.ChartTrack);

  CounterTrack.prototype = {
    __proto__: tr.ui.tracks.ChartTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ChartTrack.prototype.decorate.call(this, viewport);
      this.classList.add('counter-track');
    },

    get counter() {
      return this.chart;
    },

    set counter(counter) {
      this.heading = counter.name + ': ';
      this.series = CounterTrack.buildChartSeriesFromCounter(counter);
      this.autoSetAllAxes({expandMax: true});
    },

    getModelEventFromItem: function(chartValue) {
      return chartValue;
    }
  };

  CounterTrack.buildChartSeriesFromCounter = function(counter) {
    var numSeries = counter.series.length;
    var totals = counter.totals;

    // Create one common axis for all series.
    var chartAxis = new tr.ui.tracks.ChartAxis(0, undefined);

    // Build one chart series for each counter series.
    var chartSeries = counter.series.map(function(series, seriesIndex) {
      var chartPoints = series.samples.map(function(sample, sampleIndex) {
        var total = totals[sampleIndex * numSeries + seriesIndex];
        return new tr.ui.tracks.ChartPoint(sample, sample.timestamp, total);
      });
      var renderingConfig = {
        chartType: tr.ui.tracks.ChartSeriesType.AREA,
        colorId: series.color
      };
      return new tr.ui.tracks.ChartSeries(
          chartPoints, chartAxis, renderingConfig);
    });

    // Show the first series (with the smallest cumulative value) at the top.
    chartSeries.reverse();

    return chartSeries;
  };

  return {
    CounterTrack: CounterTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  var palette = tr.ui.b.getColorPalette();

  var startCompare = function(x, y) { return x.start - y.start; }

  /**
   * Track enabling quick selection of frame slices/events.
   * @constructor
   */
  var FrameTrack = tr.ui.b.define(
      'frame-track', tr.ui.tracks.LetterDotTrack);

  FrameTrack.prototype = {
    __proto__: tr.ui.tracks.LetterDotTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.LetterDotTrack.prototype.decorate.call(this, viewport);
      this.heading = 'Frames';

      this.frames_ = undefined;
      this.items = undefined;
    },

    get frames() {
      return this.frames_;
    },

    set frames(frames) {
      this.frames_ = frames;
      if (frames === undefined)
        return;

      this.frames_ = this.frames_.slice();
      this.frames_.sort(startCompare);

      // letter dots
      this.items = this.frames_.map(function(frame) {
        return new FrameDot(frame);
      });
    }
  };

  /**
   * @constructor
   * @extends {LetterDot}
   */
  function FrameDot(frame) {
    tr.ui.tracks.LetterDot.call(this, frame, 'F', frame.colorId, frame.start);
  }

  FrameDot.prototype = {
    __proto__: tr.ui.tracks.LetterDot.prototype
  };

  return {
    FrameTrack: FrameTrack
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  var Settings = tr.b.Settings;

  /**
   * A way to persist settings specific to parts of a trace model.
   *
   * This object should not be persisted because it builds up internal data
   * structures that map model objects to settings keys. It should thus be
   * created for the duration of whatever interaction(s) you're going to do with
   * model settings, and then discarded.
   *
   * This system works on a notion of an object key: for an object's key, it
   * considers all the other keys in the model. If it is unique, then the key is
   * persisted to tr.b.Settings. However, if it is not unique, then the
   * setting is stored on the object itself. Thus, objects with unique keys will
   * be persisted across page reloads, whereas objects with nonunique keys will
   * not.
   */
  function ModelSettings(model) {
    this.model = model;
    this.objectsByKey_ = [];
    this.nonuniqueKeys_ = [];
    this.buildObjectsByKeyMap_();
    this.removeNonuniqueKeysFromSettings_();
    this.ephemeralSettingsByGUID_ = {};
  }

  ModelSettings.prototype = {
    buildObjectsByKeyMap_: function() {
      var objects = [];
      this.model.iterateAllPersistableObjects(function(o) {
        objects.push(o);
      });

      var objectsByKey = {};
      var NONUNIQUE_KEY = 'nonuniqueKey';
      for (var i = 0; i < objects.length; i++) {
        var object = objects[i];
        var objectKey = object.getSettingsKey();
        if (!objectKey)
          continue;
        if (objectsByKey[objectKey] === undefined) {
          objectsByKey[objectKey] = object;
          continue;
        }
        objectsByKey[objectKey] = NONUNIQUE_KEY;
      }

      var nonuniqueKeys = {};
      tr.b.dictionaryKeys(objectsByKey).forEach(function(objectKey) {
        if (objectsByKey[objectKey] !== NONUNIQUE_KEY)
          return;
        delete objectsByKey[objectKey];
        nonuniqueKeys[objectKey] = true;
      });

      this.nonuniqueKeys = nonuniqueKeys;
      this.objectsByKey_ = objectsByKey;
    },

    removeNonuniqueKeysFromSettings_: function() {
      var settings = Settings.get('trace_model_settings', {});
      var settingsChanged = false;
      tr.b.dictionaryKeys(settings).forEach(function(objectKey) {
        if (!this.nonuniqueKeys[objectKey])
          return;
        settingsChanged = true;
        delete settings[objectKey];
      }, this);
      if (settingsChanged)
        Settings.set('trace_model_settings', settings);
    },

    hasUniqueSettingKey: function(object) {
      var objectKey = object.getSettingsKey();
      if (!objectKey)
        return false;
      return this.objectsByKey_[objectKey] !== undefined;
    },

    getSettingFor: function(object, objectLevelKey, defaultValue) {
      var objectKey = object.getSettingsKey();
      if (!objectKey || !this.objectsByKey_[objectKey]) {
        var settings = this.getEphemeralSettingsFor_(object);
        var ephemeralValue = settings[objectLevelKey];
        if (ephemeralValue !== undefined)
          return ephemeralValue;
        return defaultValue;
      }

      var settings = Settings.get('trace_model_settings', {});
      if (!settings[objectKey])
        settings[objectKey] = {};
      var value = settings[objectKey][objectLevelKey];
      if (value !== undefined)
        return value;
      return defaultValue;
    },

    setSettingFor: function(object, objectLevelKey, value) {
      var objectKey = object.getSettingsKey();
      if (!objectKey || !this.objectsByKey_[objectKey]) {
        this.getEphemeralSettingsFor_(object)[objectLevelKey] = value;
        return;
      }

      var settings = Settings.get('trace_model_settings', {});
      if (!settings[objectKey])
        settings[objectKey] = {};
      if (settings[objectKey][objectLevelKey] === value)
        return;
      settings[objectKey][objectLevelKey] = value;
      Settings.set('trace_model_settings', settings);
    },

    getEphemeralSettingsFor_: function(object) {
      if (object.guid === undefined)
        throw new Error('Only objects with GUIDs can be persisted');
      if (this.ephemeralSettingsByGUID_[object.guid] === undefined)
        this.ephemeralSettingsByGUID_[object.guid] = {};
      return this.ephemeralSettingsByGUID_[object.guid];
    }
  };

  return {
    ModelSettings: ModelSettings
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a group of objects in multiple rows.
   * @constructor
   * @extends {ContainerTrack}
   */
  var MultiRowTrack = tr.ui.b.define(
      'multi-row-track', tr.ui.tracks.ContainerTrack);

  MultiRowTrack.prototype = {

    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.tooltip_ = '';
      this.heading_ = '';

      this.groupingSource_ = undefined;
      this.itemsToGroup_ = undefined;

      this.defaultToCollapsedWhenSubRowCountMoreThan = 1;

      this.itemsGroupedOnLastUpdateContents_ = undefined;

      this.currentSubRows_ = [];
      this.expanded_ = true;
    },

    get itemsToGroup() {
      return this.itemsToGroup_;
    },

    setItemsToGroup: function(itemsToGroup, opt_groupingSource) {
      this.itemsToGroup_ = itemsToGroup;
      this.groupingSource_ = opt_groupingSource;
      this.updateContents_();
      this.updateExpandedStateFromGroupingSource_();
    },

    get heading() {
      return this.heading_;
    },

    set heading(h) {
      this.heading_ = h;
      this.updateContents_();
    },

    get tooltip() {
      return this.tooltip_;
    },

    set tooltip(t) {
      this.tooltip_ = t;
      this.updateContents_();
    },

    get subRows() {
      return this.currentSubRows_;
    },

    get hasVisibleContent() {
      return this.children.length > 0;
    },

    get expanded() {
      return this.expanded_;
    },

    set expanded(expanded) {
      if (this.expanded_ == expanded)
        return;
      this.expanded_ = expanded;
      this.expandedStateChanged_();
    },

    onHeadingClicked_: function(e) {
      if (this.subRows.length <= 1)
        return;
      this.expanded = !this.expanded;

      if (this.groupingSource_) {
        var modelSettings = new tr.model.ModelSettings(
            this.groupingSource_.model);
        modelSettings.setSettingFor(this.groupingSource_, 'expanded',
                                    this.expanded);
      }

      e.stopPropagation();
    },

    updateExpandedStateFromGroupingSource_: function() {
      if (this.groupingSource_) {
        var numSubRows = this.subRows.length;
        var modelSettings = new tr.model.ModelSettings(
            this.groupingSource_.model);
        if (numSubRows > 1) {
          var defaultExpanded;
          if (numSubRows > this.defaultToCollapsedWhenSubRowCountMoreThan) {
            defaultExpanded = false;
          } else {
            defaultExpanded = true;
          }
          this.expanded = modelSettings.getSettingFor(
              this.groupingSource_, 'expanded', defaultExpanded);
        } else {
          this.expanded = undefined;
        }
      }
    },

    expandedStateChanged_: function() {
      var minH = Math.max(2, Math.ceil(18 / this.children.length));
      var h = (this.expanded_ ? 18 : minH) + 'px';

      for (var i = 0; i < this.children.length; i++) {
        this.children[i].height = h;
        if (i === 0)
          this.children[i].arrowVisible = true;
        this.children[i].expanded = this.expanded;
      }

      if (this.children.length === 1) {
        this.children[0].expanded = true;
        this.children[0].arrowVisible = false;
      }
    },

    updateContents_: function() {
      tr.ui.tracks.ContainerTrack.prototype.updateContents_.call(this);
      if (!this.itemsToGroup_) {
        this.updateHeadingAndTooltip_();
        this.currentSubRows_ = [];
        return;
      }

      if (this.areArrayContentsSame_(this.itemsGroupedOnLastUpdateContents_,
                                     this.itemsToGroup_)) {
        this.updateHeadingAndTooltip_();
        return;
      }

      this.itemsGroupedOnLastUpdateContents_ = this.itemsToGroup_;

      this.detach();
      if (!this.itemsToGroup_.length) {
        this.currentSubRows_ = [];
        return;
      }
      var subRows = this.buildSubRows_(this.itemsToGroup_);
      this.currentSubRows_ = subRows;
      for (var srI = 0; srI < subRows.length; srI++) {
        var subRow = subRows[srI];
        if (!subRow.length)
          continue;
        var track = this.addSubTrack_(subRow);
        track.addEventListener(
          'heading-clicked', this.onHeadingClicked_.bind(this));
      }
      this.updateHeadingAndTooltip_();
      this.expandedStateChanged_();
    },

    updateHeadingAndTooltip_: function() {
      if (!this.firstChild)
        return;
      this.firstChild.heading = this.heading_;
      this.firstChild.tooltip = this.tooltip_;
    },

    /**
     * Breaks up the list of slices into N rows, each of which is a list of
     * slices that are non overlapping.
     */
    buildSubRows_: function(itemsToGroup) {
      throw new Error('Not implemented');
    },

    addSubTrack_: function(subRowItems) {
      throw new Error('Not implemented');
    },

    areArrayContentsSame_: function(a, b) {
      if (!a || !b)
        return false;
      if (!a.length || !b.length)
        return false;
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] != b[i])
          return false;
      }
      return true;
    }
  };

  return {
    MultiRowTrack: MultiRowTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  var SelectionState = tr.model.SelectionState;
  var EventPresenter = tr.ui.b.EventPresenter;

  /**
   * A track that displays an array of Slice objects.
   * @constructor
   * @extends {Track}
   */
  var ObjectInstanceTrack = tr.ui.b.define(
      'object-instance-track', tr.ui.tracks.Track);

  ObjectInstanceTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      this.classList.add('object-instance-track');
      this.objectInstances_ = [];
      this.objectSnapshots_ = [];

      this.heading_ = document.createElement('tr-ui-heading');
      this.appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    get objectInstances() {
      return this.objectInstances_;
    },

    set objectInstances(objectInstances) {
      if (!objectInstances || objectInstances.length == 0) {
        this.heading = '';
        this.objectInstances_ = [];
        this.objectSnapshots_ = [];
        return;
      }
      this.heading = objectInstances[0].typeName;
      this.objectInstances_ = objectInstances;
      this.objectSnapshots_ = [];
      this.objectInstances_.forEach(function(instance) {
        this.objectSnapshots_.push.apply(
            this.objectSnapshots_, instance.snapshots);
      }, this);
      this.objectSnapshots_.sort(function(a, b) {
        return a.ts - b.ts;
      });
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
    },

    get snapshotRadiusView() {
      return 7 * (window.devicePixelRatio || 1);
    },

    draw: function(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawLetterDots_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawLetterDots_: function(viewLWorld, viewRWorld) {
      var ctx = this.context();
      var pixelRatio = window.devicePixelRatio || 1;

      var bounds = this.getBoundingClientRect();
      var height = bounds.height * pixelRatio;
      var halfHeight = height * 0.5;
      var twoPi = Math.PI * 2;

      // Culling parameters.
      var dt = this.viewport.currentDisplayTransform;
      var snapshotRadiusView = this.snapshotRadiusView;
      var snapshotRadiusWorld = dt.xViewVectorToWorld(height);
      var loI;

      // Begin rendering in world space.
      ctx.save();
      dt.applyTransformToCanvas(ctx);

      // Instances
      var objectInstances = this.objectInstances_;
      var loI = tr.b.findLowIndexInSortedArray(
          objectInstances,
          function(instance) {
            return instance.deletionTs;
          },
          viewLWorld);
      ctx.strokeStyle = 'rgb(0,0,0)';
      for (var i = loI; i < objectInstances.length; ++i) {
        var instance = objectInstances[i];
        var x = instance.creationTs;
        if (x > viewRWorld)
          break;

        var right = instance.deletionTs == Number.MAX_VALUE ?
            viewRWorld : instance.deletionTs;
        ctx.fillStyle = EventPresenter.getObjectInstanceColor(instance);
        ctx.fillRect(x, pixelRatio, right - x, height - 2 * pixelRatio);
      }
      ctx.restore();

      // Snapshots. Has to run in worldspace because ctx.arc gets transformed.
      var objectSnapshots = this.objectSnapshots_;
      loI = tr.b.findLowIndexInSortedArray(
          objectSnapshots,
          function(snapshot) {
            return snapshot.ts + snapshotRadiusWorld;
          },
          viewLWorld);
      for (var i = loI; i < objectSnapshots.length; ++i) {
        var snapshot = objectSnapshots[i];
        var x = snapshot.ts;
        if (x - snapshotRadiusWorld > viewRWorld)
          break;
        var xView = dt.xWorldToView(x);

        ctx.fillStyle = EventPresenter.getObjectSnapshotColor(snapshot);
        ctx.beginPath();
        ctx.arc(xView, halfHeight, snapshotRadiusView, 0, twoPi);
        ctx.fill();
        if (snapshot.selected) {
          ctx.lineWidth = 5;
          ctx.strokeStyle = 'rgb(100,100,0)';
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(xView, halfHeight, snapshotRadiusView - 1, 0, twoPi);
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgb(255,255,0)';
          ctx.stroke();
        } else {
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgb(0,0,0)';
          ctx.stroke();
        }
      }
      ctx.lineWidth = 1;

      // For performance reasons we only check the SelectionState of the first
      // instance. If it's DIMMED we assume that all are DIMMED.
      // TODO(egraether): Allow partial highlight.
      var selectionState = SelectionState.NONE;
      if (objectInstances.length &&
          objectInstances[0].selectionState === SelectionState.DIMMED) {
        selectionState = SelectionState.DIMMED;
      }

      // Dim the track when there is an active highlight.
      if (selectionState === SelectionState.DIMMED) {
        var width = bounds.width * pixelRatio;
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      if (this.objectInstance_ !== undefined) {
        this.objectInstance_.forEach(function(obj) {
          eventToTrackMap.addEvent(obj, this);
        }, this);
      }

      if (this.objectSnapshots_ !== undefined) {
        this.objectSnapshots_.forEach(function(obj) {
          eventToTrackMap.addEvent(obj, this);
        }, this);
      }
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
      // Pick snapshots first.
      var foundSnapshot = false;
      function onSnapshot(snapshot) {
        selection.push(snapshot);
        foundSnapshot = true;
      }
      var snapshotRadiusView = this.snapshotRadiusView;
      var snapshotRadiusWorld = viewPixWidthWorld * snapshotRadiusView;
      tr.b.iterateOverIntersectingIntervals(
          this.objectSnapshots_,
          function(x) { return x.ts - snapshotRadiusWorld; },
          function(x) { return 2 * snapshotRadiusWorld; },
          loWX, hiWX,
          onSnapshot);
      if (foundSnapshot)
        return;

      // Try picking instances.
      tr.b.iterateOverIntersectingIntervals(
          this.objectInstances_,
          function(x) { return x.creationTs; },
          function(x) { return x.deletionTs - x.creationTs; },
          loWX, hiWX,
          selection.push.bind(selection));
    },

    /**
     * Add the item to the left or right of the provided event, if any, to the
     * selection.
     * @param {event} The current event item.
     * @param {Number} offset Number of slices away from the event to look.
     * @param {Selection} selection The selection to add an event to,
     * if found.
     * @return {boolean} Whether an event was found.
     * @private
     */
    addEventNearToProvidedEventToSelection: function(event, offset, selection) {
      var events;
      if (event instanceof tr.model.ObjectSnapshot)
        events = this.objectSnapshots_;
      else if (event instanceof tr.model.ObjectInstance)
        events = this.objectInstances_;
      else
        throw new Error('Unrecognized event');

      var index = events.indexOf(event);
      var newIndex = index + offset;
      if (newIndex >= 0 && newIndex < events.length) {
        selection.push(events[newIndex]);
        return true;
      }
      return false;
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
    },

    addClosestEventToSelection: function(worldX, worldMaxDist, loY, hiY,
                                         selection) {
      var snapshot = tr.b.findClosestElementInSortedArray(
          this.objectSnapshots_,
          function(x) { return x.ts; },
          worldX,
          worldMaxDist);

      if (!snapshot)
        return;

      selection.push(snapshot);

      // TODO(egraether): Search for object instances as well, which was not
      // implemented because it makes little sense with the current visual and
      // needs to take care of overlapping intervals.
    }
  };


  var options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(ObjectInstanceTrack, options);

  return {
    ObjectInstanceTrack: ObjectInstanceTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a ObjectInstanceGroup.
   * @constructor
   * @extends {ContainerTrack}
   */
  var ObjectInstanceGroupTrack = tr.ui.b.define(
      'object-instance-group-track', tr.ui.tracks.MultiRowTrack);

  ObjectInstanceGroupTrack.prototype = {

    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      this.classList.add('object-instance-group-track');
      this.objectInstances_ = undefined;
    },

    get objectInstances() {
      return this.itemsToGroup;
    },

    set objectInstances(objectInstances) {
      this.setItemsToGroup(objectInstances);
    },

    addSubTrack_: function(objectInstances) {
      var hasMultipleRows = this.subRows.length > 1;
      var track = new tr.ui.tracks.ObjectInstanceTrack(this.viewport);
      track.objectInstances = objectInstances;
      this.appendChild(track);
      return track;
    },

    buildSubRows_: function(objectInstances) {
      objectInstances.sort(function(x, y) {
        return x.creationTs - y.creationTs;
      });

      var subRows = [];
      for (var i = 0; i < objectInstances.length; i++) {
        var objectInstance = objectInstances[i];

        var found = false;
        for (var j = 0; j < subRows.length; j++) {
          var subRow = subRows[j];
          var lastItemInSubRow = subRow[subRow.length - 1];
          if (objectInstance.creationTs >= lastItemInSubRow.deletionTs) {
            found = true;
            subRow.push(objectInstance);
            break;
          }
        }
        if (!found) {
          var subRow = [objectInstance];
          subRows.push(subRow);
        }
      }
      return subRows;
    },
    updateHeadingAndTooltip_: function() {
    }
  };

  return {
    ObjectInstanceGroupTrack: ObjectInstanceGroupTrack
  };
});


'use strict';

/**
 * @fileoverview Provides a mechanism for drawing massive numbers of
 * colored rectangles into a canvas in an efficient manner, provided
 * they are drawn left to right with fixed y and height throughout.
 *
 * The basic idea used here is to fuse subpixel rectangles together so that
 * we never issue a canvas fillRect for them. It turns out Javascript can
 * do this quite efficiently, compared to asking Canvas2D to do the same.
 *
 * A few extra things are done by this class in the name of speed:
 * - Viewport culling: off-viewport rectangles are discarded.
 *
 * - The actual discarding operation is done in world space,
 *   e.g. pre-transform.
 *
 * - Rather than expending compute cycles trying to figure out an average
 *   color for fused rectangles from css strings, you instead draw using
 *   palletized colors. The fused rect color is choosen from the rectangle with
 *   the higher alpha value, if equal the max pallete index encountered.
 *
 * Make sure to flush the trackRenderer before finishing drawing in order
 * to commit any queued drawing operations.
 */
tr.exportTo('tr.ui.b', function() {

  /**
   * Creates a fast rect renderer with a specific set of culling rules
   * and color pallette.
   * @param {GraphicsContext2D} ctx Canvas2D drawing context.
   * @param {number} minRectSize Only rectangles with width < minRectSize are
   *    considered for merging.
   * @param {number} maxMergeDist Controls how many successive small rectangles
   *    can be merged together before issuing a rectangle.
   * @param {Array} pallette The color pallete for drawing. Pallette slots
   *    should map to valid Canvas fillStyle strings.
   *
   * @constructor
   */
  function FastRectRenderer(ctx, minRectSize, maxMergeDist, pallette) {
    this.ctx_ = ctx;
    this.minRectSize_ = minRectSize;
    this.maxMergeDist_ = maxMergeDist;
    this.pallette_ = pallette;
  }

  FastRectRenderer.prototype = {
    y_: 0,
    h_: 0,
    merging_: false,
    mergeStartX_: 0,
    mergeCurRight_: 0,
    mergedColorId_: 0,
    mergedAlpha_: 0,

    /**
     * Changes the y position and height for subsequent fillRect
     * calls. x and width are specifieid on the fillRect calls.
     */
    setYandH: function(y, h) {
      if (this.y_ === y &&
          this.h_ === h)
        return;
      this.flush();
      this.y_ = y;
      this.h_ = h;
    },

    /**
     * Fills rectangle at the specified location, if visible. If the
     * rectangle is subpixel, it will be merged with adjacent rectangles.
     * The drawing operation may not take effect until flush is called.
     * @param {number} colorId The color of this rectangle, as an index
     *     in the renderer's color pallete.
     * @param {number} alpha The opacity of the rectangle as 0.0-1.0 number.
     */
    fillRect: function(x, w, colorId, alpha) {
      var r = x + w;
      if (w < this.minRectSize_) {
        if (r - this.mergeStartX_ > this.maxMergeDist_)
          this.flush();
        if (!this.merging_) {
          this.merging_ = true;
          this.mergeStartX_ = x;
          this.mergeCurRight_ = r;
          this.mergedColorId_ = colorId;
          this.mergedAlpha_ = alpha;
        } else {
          this.mergeCurRight_ = r;

          if (this.mergedAlpha_ < alpha ||
              (this.mergedAlpha_ === alpha && this.mergedColorId_ < colorId)) {
            this.mergedAlpha_ = alpha;
            this.mergedColorId_ = colorId;
          }
        }
      } else {
        if (this.merging_)
          this.flush();
        this.ctx_.fillStyle = this.pallette_[colorId];
        this.ctx_.globalAlpha = alpha;
        this.ctx_.fillRect(x, this.y_, w, this.h_);
      }
    },

    /**
     * Commits any pending fillRect operations to the underlying graphics
     * context.
     */
    flush: function() {
      if (this.merging_) {
        this.ctx_.fillStyle = this.pallette_[this.mergedColorId_];
        this.ctx_.globalAlpha = this.mergedAlpha_;
        this.ctx_.fillRect(this.mergeStartX_, this.y_,
                           this.mergeCurRight_ - this.mergeStartX_, this.h_);
        this.merging_ = false;
      }
    }
  };

  return {
    FastRectRenderer: FastRectRenderer
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * A track that displays an array of Rect objects.
   * @constructor
   * @extends {Track}
   */
  var RectTrack = tr.ui.b.define(
      'rect-track', tr.ui.tracks.Track);

  RectTrack.prototype = {

    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      this.classList.add('rect-track');
      this.asyncStyle_ = false;
      this.rects_ = null;

      this.heading_ = document.createElement('tr-ui-heading');
      this.appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    set selectionGenerator(generator) {
      this.heading_.selectionGenerator = generator;
    },

    set expanded(expanded) {
      this.heading_.expanded = !!expanded;
    },

    set arrowVisible(arrowVisible) {
      this.heading_.arrowVisible = !!arrowVisible;
    },

    get expanded() {
      return this.heading_.expanded;
    },

    get asyncStyle() {
      return this.asyncStyle_;
    },

    set asyncStyle(v) {
      this.asyncStyle_ = !!v;
    },

    get rects() {
      return this.rects_;
    },

    set rects(rects) {
      this.rects_ = rects || [];
      this.invalidateDrawingContainer();
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
      this.invalidateDrawingContainer();
    },

    get hasVisibleContent() {
      return this.rects_.length > 0;
    },

    draw: function(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawRects_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawRects_: function(viewLWorld, viewRWorld) {
      var ctx = this.context();

      ctx.save();
      var bounds = this.getBoundingClientRect();
      tr.ui.b.drawSlices(
          ctx,
          this.viewport.currentDisplayTransform,
          viewLWorld,
          viewRWorld,
          bounds.height,
          this.rects_,
          this.asyncStyle_);
      ctx.restore();

      if (bounds.height <= 6)
        return;

      var fontSize, yOffset;
      if (bounds.height < 15) {
        fontSize = 6;
        yOffset = 1.0;
      } else {
        fontSize = 10;
        yOffset = 2.5;
      }
      tr.ui.b.drawLabels(
          ctx,
          this.viewport.currentDisplayTransform,
          viewLWorld,
          viewRWorld,
          this.rects_,
          this.asyncStyle_,
          fontSize,
          yOffset);
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      if (this.rects_ === undefined || this.rects_ === null)
        return;

      this.rects_.forEach(function(rect) {
        rect.addToTrackMap(eventToTrackMap, this);
      }, this);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
      function onRect(rect) {
        rect.addToSelection(selection);
      }
      onRect = onRect.bind(this);
      var instantEventWidth = 2 * viewPixWidthWorld;
      tr.b.iterateOverIntersectingIntervals(this.rects_,
          function(x) { return x.start; },
          function(x) { return x.duration == 0 ?
                               x.duration + instantEventWidth :
                               x.duration; },
          loWX, hiWX,
          onRect);
    },

    /**
     * Add the item to the left or right of the provided event, if any, to the
     * selection.
     * @param {rect} The current rect.
     * @param {Number} offset Number of rects away from the event to look.
     * @param {Selection} selection The selection to add an event to,
     * if found.
     * @return {boolean} Whether an event was found.
     * @private
     */
    addEventNearToProvidedEventToSelection: function(event, offset, selection) {
      var index = tr.b.findFirstIndexInArray(this.rects_, function(rect) {
        return rect.modelItem === event;
      });
      if (index === -1)
        return false;

      var newIndex = index + offset;
      if (newIndex < 0 || newIndex >= this.rects_.length)
        return false;

      this.rects_[newIndex].addToSelection(selection);
      return true;
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
      for (var i = 0; i < this.rects_.length; ++i) {
        // TODO(petrcermak): Rather than unpacking the proxy item here,
        // we should probably add an addToSelectionIfMatching(selection, filter)
        // method to SelectableItem (#900).
        var modelItem = this.rects_[i].modelItem;
        if (!modelItem)
          continue;
        if (filter.matchSlice(modelItem))
          selection.push(modelItem);
      }
    },

    addClosestEventToSelection: function(worldX, worldMaxDist, loY, hiY,
                                         selection) {
      var rect = tr.b.findClosestIntervalInSortedIntervals(
          this.rects_,
          function(x) { return x.start; },
          function(x) { return x.end; },
          worldX,
          worldMaxDist);

      if (!rect)
        return;

      rect.addToSelection(selection);
    }
  };

  /**
   * A filled rectangle with a title.
   *
   * @constructor
   * @extends {ProxySelectableItem}
   */
  function Rect(modelItem, title, colorId, start, duration) {
    tr.model.ProxySelectableItem.call(this, modelItem);
    this.title = title;
    this.colorId = colorId;
    this.start = start;
    this.duration = duration;
    this.end = start + duration;
  };

  Rect.prototype = {
    __proto__: tr.model.ProxySelectableItem.prototype
  };

  return {
    RectTrack: RectTrack,
    Rect: Rect
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * Visualizes a Process's state using a series of rects to represent activity.
   * @constructor
   */
  var ProcessSummaryTrack = tr.ui.b.define('process-summary-track',
                                           tr.ui.tracks.RectTrack);

  ProcessSummaryTrack.buildRectsFromProcess = function(process) {
    if (!process)
      return [];

    var ops = [];
    // build list of start/end ops for each top level or important slice
    var pushOp = function(isStart, time, slice) {
      ops.push({
        isStart: isStart,
        time: time,
        slice: slice
      });
    };
    for (var tid in process.threads) {
      var sliceGroup = process.threads[tid].sliceGroup;

      sliceGroup.topLevelSlices.forEach(function(slice) {
        pushOp(true, slice.start, undefined);
        pushOp(false, slice.end, undefined);
      });
      sliceGroup.slices.forEach(function(slice) {
        if (slice.important) {
          pushOp(true, slice.start, slice);
          pushOp(false, slice.end, slice);
        }
      });
    }
    ops.sort(function(a, b) { return a.time - b.time; });

    var rects = [];
    /**
     * Build a row of rects which display one way for unimportant activity,
     * and during important slices, show up as those important slices.
     *
     * If an important slice starts in the middle of another,
     * just drop it on the floor.
     */
    var genericColorId = tr.ui.b.getColorIdForReservedName('generic_work');
    var pushRect = function(start, end, slice) {
      rects.push(new tr.ui.tracks.Rect(
          slice, /* modelItem: show selection state of slice if present */
          slice ? slice.title : '', /* title */
          slice ? slice.colorId : genericColorId, /* colorId */
          start, /* start */
          end - start /* duration */));
    }
    var depth = 0;
    var currentSlice = undefined;
    var lastStart = undefined;
    ops.forEach(function(op) {
      depth += op.isStart ? 1 : -1;

      if (currentSlice) {
        // simply find end of current important slice
        if (!op.isStart && op.slice == currentSlice) {
          // important slice has ended
          pushRect(lastStart, op.time, currentSlice);
          lastStart = depth >= 1 ? op.time : undefined;
          currentSlice = undefined;
        }
      } else {
        if (op.isStart) {
          if (depth == 1) {
            lastStart = op.time;
            currentSlice = op.slice;
          } else if (op.slice) {
            // switch to slice
            if (op.time != lastStart) {
              pushRect(lastStart, op.time, undefined);
              lastStart = op.time;
            }
            currentSlice = op.slice;
          }
        } else {
          if (depth == 0) {
            pushRect(lastStart, op.time, undefined);
            lastStart = undefined;
          }
        }
      }
    });
    return rects;
  };

  ProcessSummaryTrack.prototype = {
    __proto__: tr.ui.tracks.RectTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.RectTrack.prototype.decorate.call(this, viewport);
    },

    get process() {
      return this.process_;
    },

    set process(process) {
      this.process_ = process;
      this.rects = ProcessSummaryTrack.buildRectsFromProcess(process);
    }
  };

  return {
    ProcessSummaryTrack: ProcessSummaryTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of Slice objects.
   * @constructor
   * @extends {RectTrack}
   */
  var SliceTrack = tr.ui.b.define(
      'slice-track', tr.ui.tracks.RectTrack);

  SliceTrack.prototype = {

    __proto__: tr.ui.tracks.RectTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.RectTrack.prototype.decorate.call(this, viewport);
    },

    get slices() {
      return this.rects;
    },

    set slices(slices) {
      this.rects = slices;
    }
  };

  return {
    SliceTrack: SliceTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a AsyncSliceGroup.
   * @constructor
   * @extends {MultiRowTrack}
   */
  var AsyncSliceGroupTrack = tr.ui.b.define(
      'async-slice-group-track',
      tr.ui.tracks.MultiRowTrack);

  AsyncSliceGroupTrack.prototype = {

    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      this.classList.add('async-slice-group-track');
      this.group_ = undefined;
    },

    addSubTrack_: function(slices) {
      var track = new tr.ui.tracks.SliceTrack(this.viewport);
      track.slices = slices;
      this.appendChild(track);
      track.asyncStyle = true;
      return track;
    },

    get group() {
      return this.group_;
    },

    set group(group) {
      this.group_ = group;
      this.setItemsToGroup(this.group_.slices, this.group_);
    },

    get eventContainer() {
      return this.group;
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      containerToTrackMap.addContainer(this.group, this);
    },

    /**
     * Breaks up the list of slices into N rows, each of which is a list of
     * slices that are non overlapping.
     *
     * It uses a very simple approach: walk through the slices in sorted order
     * by start time. For each slice, try to fit it in an existing subRow. If
     * it doesn't fit in any subrow, make another subRow. It then fits nested
     * subSlices recursively into rows below parent slice according to which
     * nested level the child is in.
     */
    buildSubRows_: function(slices, opt_skipSort) {
      if (!opt_skipSort) {
        slices.sort(function(x, y) {
          return x.start - y.start;
        });
      }

      // Helper function that returns true if it can put the slice on row n.
      var findLevel = function(sliceToPut, rows, n) {
        if (n >= rows.length)
          return true; // We always can make empty rows to put the slice.
        var subRow = rows[n];
        var lastSliceInSubRow = subRow[subRow.length - 1];
        if (sliceToPut.start >= lastSliceInSubRow.end) {
          if (sliceToPut.subSlices === undefined ||
              sliceToPut.subSlices.length === 0) {
            return true;
          }
          // Make sure nested sub slices can be fitted in as well.
          for (var i = 0; i < sliceToPut.subSlices.length; i++) {
            if (!findLevel(sliceToPut.subSlices[i], rows, n + 1))
              return false;
          }
          return true;
        }
        return false;
      }

      var subRows = [];
      for (var i = 0; i < slices.length; i++) {
        var slice = slices[i];

        var found = false;
        var index = subRows.length;
        for (var j = 0; j < subRows.length; j++) {
          if (findLevel(slice, subRows, j)) {
            found = true;
            index = j;
            break;
          }
        }
        if (!found)
          subRows.push([]);
        subRows[index].push(slice);

        // Fit subSlices recursively into rows below parent.
        var fitSubSlicesRecursively = function(subSlices, level, rows) {
          if (subSlices === undefined || subSlices.length === 0)
            return;
          if (level === rows.length)
            rows.push([]);
          for (var h = 0; h < subSlices.length; h++) {
             rows[level].push(subSlices[h]);
             fitSubSlicesRecursively(subSlices[h].subSlices, level + 1, rows);
          }
        }
        fitSubSlicesRecursively(slice.subSlices, index + 1, subRows);
      }
      return subRows;
    }
  };

  return {
    AsyncSliceGroupTrack: AsyncSliceGroupTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of Sample objects.
   * @constructor
   * @extends {RectTrack}
   */
  var SampleTrack = tr.ui.b.define(
      'sample-track', tr.ui.tracks.RectTrack);

  SampleTrack.prototype = {

    __proto__: tr.ui.tracks.RectTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.RectTrack.prototype.decorate.call(this, viewport);
    },

    get samples() {
      return this.rects;
    },

    set samples(samples) {
      this.rects = samples;
    }
  };

  return {
    SampleTrack: SampleTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a SliceGroup.
   * @constructor
   * @extends {MultiRowTrack}
   */
  var SliceGroupTrack = tr.ui.b.define(
      'slice-group-track', tr.ui.tracks.MultiRowTrack);

  SliceGroupTrack.prototype = {

    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      this.classList.add('slice-group-track');
      this.group_ = undefined;
      // Set the collapse threshold so we don't collapse by default, but the
      // user can explicitly collapse if they want it.
      this.defaultToCollapsedWhenSubRowCountMoreThan = 100;
    },

    addSubTrack_: function(slices) {
      var track = new tr.ui.tracks.SliceTrack(this.viewport);
      track.slices = slices;
      this.appendChild(track);
      return track;
    },

    get group() {
      return this.group_;
    },

    set group(group) {
      this.group_ = group;
      this.setItemsToGroup(this.group_.slices, this.group_);
    },

    get eventContainer() {
      return this.group;
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      containerToTrackMap.addContainer(this.group, this);
    },

    /**
     * Breaks up the list of slices into N rows, each of which is a list of
     * slices that are non overlapping.
     */
    buildSubRows_: function(slices) {
      var precisionUnit = this.group.model.intrinsicTimeUnit;

      // This function works by walking through slices by start time.
      //
      // The basic idea here is to insert each slice as deep into the subrow
      // list as it can go such that every subSlice is fully contained by its
      // parent slice.
      //
      // Visually, if we start with this:
      //  0:  [    a       ]
      //  1:    [  b  ]
      //  2:    [c][d]
      //
      // To place this slice:
      //               [e]
      // We first check row 2's last item, [d]. [e] wont fit into [d] (they dont
      // even intersect). So we go to row 1. That gives us [b], and [d] wont fit
      // into that either. So, we go to row 0 and its last slice, [a]. That can
      // completely contain [e], so that means we should add [e] as a subchild
      // of [a]. That puts it on row 1, yielding:
      //  0:  [    a       ]
      //  1:    [  b  ][e]
      //  2:    [c][d]
      //
      // If we then get this slice:
      //                      [f]
      // We do the same deepest-to-shallowest walk of the subrows trying to fit
      // it. This time, it doesn't fit in any open slice. So, we simply append
      // it to row 0:
      //  0:  [    a       ]  [f]
      //  1:    [  b  ][e]
      //  2:    [c][d]
      if (!slices.length)
        return [];

      var ops = [];
      for (var i = 0; i < slices.length; i++) {
        if (slices[i].subSlices)
          slices[i].subSlices.splice(0,
                                     slices[i].subSlices.length);
        ops.push(i);
      }

      ops.sort(function(ix, iy) {
        var x = slices[ix];
        var y = slices[iy];
        if (x.start != y.start)
          return x.start - y.start;

        // Elements get inserted into the slices array in order of when the
        // slices start. Because slices must be properly nested, we break
        // start-time ties by assuming that the elements appearing earlier in
        // the slices array (and thus ending earlier) start earlier.
        return ix - iy;
      });

      var subRows = [[]];
      this.badSlices_ = [];  // TODO(simonjam): Connect this again.

      for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        var slice = slices[op];

        // Try to fit the slice into the existing subrows.
        var inserted = false;
        for (var j = subRows.length - 1; j >= 0; j--) {
          if (subRows[j].length == 0)
            continue;

          var insertedSlice = subRows[j][subRows[j].length - 1];
          if (slice.start < insertedSlice.start) {
            this.badSlices_.push(slice);
            inserted = true;
          }
          if (insertedSlice.bounds(slice, precisionUnit)) {
            // Insert it into subRow j + 1.
            while (subRows.length <= j + 1)
              subRows.push([]);
            subRows[j + 1].push(slice);
            if (insertedSlice.subSlices)
              insertedSlice.subSlices.push(slice);
            inserted = true;
            break;
          }
        }
        if (inserted)
          continue;

        // Append it to subRow[0] as a root.
        subRows[0].push(slice);
      }

      return subRows;
    }
  };

  return {
    SliceGroupTrack: SliceGroupTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * Visualizes a Thread using a series of SliceTracks.
   * @constructor
   */
  var ThreadTrack = tr.ui.b.define('thread-track',
                                   tr.ui.tracks.ContainerTrack);
  ThreadTrack.prototype = {
    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.classList.add('thread-track');
    },

    get thread() {
      return this.thread_;
    },

    set thread(thread) {
      this.thread_ = thread;
      this.updateContents_();
    },

    get hasVisibleContent() {
      return this.tracks_.length > 0;
    },

    get eventContainer() {
      return this.thread;
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      containerToTrackMap.addContainer(this.thread, this);
      for (var i = 0; i < this.childNodes.length; ++i)
        this.childNodes[i].addContainersToTrackMap(containerToTrackMap);
    },

    updateContents_: function() {
      this.detach();

      if (!this.thread_)
        return;

      this.heading = this.thread_.userFriendlyName + ': ';
      this.tooltip = this.thread_.userFriendlyDetails;

      if (this.thread_.asyncSliceGroup.length)
        this.appendAsyncSliceTracks_();

      this.appendThreadSamplesTracks_();

      if (this.thread_.timeSlices) {
        var timeSlicesTrack = new tr.ui.tracks.SliceTrack(this.viewport);
        timeSlicesTrack.heading = '';
        timeSlicesTrack.height = tr.ui.b.THIN_SLICE_HEIGHT + 'px';
        timeSlicesTrack.slices = this.thread_.timeSlices;
        if (timeSlicesTrack.hasVisibleContent)
          this.appendChild(timeSlicesTrack);
      }

      if (this.thread_.sliceGroup.length) {
        var track = new tr.ui.tracks.SliceGroupTrack(this.viewport);
        track.heading = this.thread_.userFriendlyName;
        track.tooltip = this.thread_.userFriendlyDetails;
        track.group = this.thread_.sliceGroup;
        if (track.hasVisibleContent)
          this.appendChild(track);
      }
    },

    appendAsyncSliceTracks_: function() {
      var subGroups = this.thread_.asyncSliceGroup.viewSubGroups;
      subGroups.forEach(function(subGroup) {
        var asyncTrack = new tr.ui.tracks.AsyncSliceGroupTrack(this.viewport);
        var title = subGroup.slices[0].viewSubGroupTitle;
        asyncTrack.group = subGroup;
        asyncTrack.heading = title;
        if (asyncTrack.hasVisibleContent)
          this.appendChild(asyncTrack);
      }, this);
    },

    appendThreadSamplesTracks_: function() {
      var threadSamples = this.thread_.samples;
      if (threadSamples === undefined || threadSamples.length === 0)
        return;
      var samplesByTitle = {};
      threadSamples.forEach(function(sample) {
        if (samplesByTitle[sample.title] === undefined)
          samplesByTitle[sample.title] = [];
        samplesByTitle[sample.title].push(sample);
      });

      var sampleTitles = tr.b.dictionaryKeys(samplesByTitle);
      sampleTitles.sort();

      sampleTitles.forEach(function(sampleTitle) {
        var samples = samplesByTitle[sampleTitle];
        var samplesTrack = new tr.ui.tracks.SampleTrack(this.viewport);
        samplesTrack.group = this.thread_;
        samplesTrack.samples = samples;
        samplesTrack.heading = this.thread_.userFriendlyName + ': ' +
            sampleTitle;
        samplesTrack.tooltip = this.thread_.userFriendlyDetails;
        samplesTrack.selectionGenerator = function() {
          var selection = new tr.model.EventSet();
          for (var i = 0; i < samplesTrack.samples.length; i++) {
            selection.push(samplesTrack.samples[i]);
          }
          return selection;
        };
        this.appendChild(samplesTrack);
      }, this);
    },

    collapsedDidChange: function(collapsed) {
      if (collapsed) {
        var h = parseInt(this.tracks[0].height);
        for (var i = 0; i < this.tracks.length; ++i) {
          if (h > 2) {
            this.tracks[i].height = Math.floor(h) + 'px';
          } else {
            this.tracks[i].style.display = 'none';
          }
          h = h * 0.5;
        }
      } else {
        for (var i = 0; i < this.tracks.length; ++i) {
          this.tracks[i].height = this.tracks[0].height;
          this.tracks[i].style.display = '';
        }
      }
    }
  };

  return {
    ThreadTrack: ThreadTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  var ObjectSnapshotView = tr.ui.analysis.ObjectSnapshotView;
  var ObjectInstanceView = tr.ui.analysis.ObjectInstanceView;
  var SpacingTrack = tr.ui.tracks.SpacingTrack;

  /**
   * Visualizes a Process by building ThreadTracks and CounterTracks.
   * @constructor
   */
  var ProcessTrackBase =
      tr.ui.b.define('process-track-base', tr.ui.tracks.ContainerTrack);

  ProcessTrackBase.prototype = {

    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);

      this.processBase_ = undefined;

      this.classList.add('process-track-base');
      this.classList.add('expanded');

      this.processNameEl_ = tr.ui.b.createSpan();
      this.processNameEl_.classList.add('process-track-name');

      this.headerEl_ = tr.ui.b.createDiv({className: 'process-track-header'});
      this.headerEl_.appendChild(this.processNameEl_);
      this.headerEl_.addEventListener('click', this.onHeaderClick_.bind(this));

      this.appendChild(this.headerEl_);
    },

    get processBase() {
      return this.processBase_;
    },

    set processBase(processBase) {
      this.processBase_ = processBase;

      if (this.processBase_) {
        var modelSettings = new tr.model.ModelSettings(this.processBase_.model);
        var defaultValue = this.processBase_.important;
        this.expanded = modelSettings.getSettingFor(
            this.processBase_, 'expanded', defaultValue);
      }

      this.updateContents_();
    },

    get expanded() {
      return this.classList.contains('expanded');
    },

    set expanded(expanded) {
      expanded = !!expanded;

      if (this.expanded === expanded)
        return;

      this.classList.toggle('expanded');

      // Expanding and collapsing tracks is, essentially, growing and shrinking
      // the viewport. We dispatch a change event to trigger any processing
      // to happen.
      this.viewport_.dispatchChangeEvent();

      if (!this.processBase_)
        return;

      var modelSettings = new tr.model.ModelSettings(this.processBase_.model);
      modelSettings.setSettingFor(this.processBase_, 'expanded', expanded);
      this.updateContents_();
      this.viewport.rebuildEventToTrackMap();
      this.viewport.rebuildContainerToTrackMap();
    },

    get hasVisibleContent() {
      if (this.expanded)
        return this.children.length > 1;
      return true;
    },

    onHeaderClick_: function(e) {
      e.stopPropagation();
      e.preventDefault();
      this.expanded = !this.expanded;
    },

    updateContents_: function() {
      this.clearTracks_();

      if (!this.processBase_)
        return;

      this.processNameEl_.textContent = this.processBase_.userFriendlyName;
      this.headerEl_.title = this.processBase_.userFriendlyDetails;

      // Create the object instance tracks for this process.
      this.willAppendTracks_();
      if (this.expanded) {
        this.appendMemoryDumpTrack_();
        this.appendObjectInstanceTracks_();
        this.appendCounterTracks_();
        this.appendFrameTrack_();
        this.appendThreadTracks_();
      } else {
        this.appendSummaryTrack_();
      }
      this.didAppendTracks_();
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      this.tracks_.forEach(function(track) {
        track.addEventsToTrackMap(eventToTrackMap);
      });
    },

    willAppendTracks_: function() {
    },

    didAppendTracks_: function() {
    },

    appendMemoryDumpTrack_: function() {
    },

    appendSummaryTrack_: function() {
      var track = new tr.ui.tracks.ProcessSummaryTrack(this.viewport);
      track.process = this.process;
      if (!track.hasVisibleContent)
        return;
      this.appendChild(track);
      // no spacing track, since this track only shown in collapsed state
    },

    appendFrameTrack_: function() {
      var frames = this.process ? this.process.frames : undefined;
      if (!frames || !frames.length)
        return;

      var track = new tr.ui.tracks.FrameTrack(this.viewport);
      track.frames = frames;
      this.appendChild(track);
      this.backgroundProvider = track;
    },

    appendObjectInstanceTracks_: function() {
      var instancesByTypeName =
          this.processBase_.objects.getAllInstancesByTypeName();
      var instanceTypeNames = tr.b.dictionaryKeys(instancesByTypeName);
      instanceTypeNames.sort();

      var didAppendAtLeastOneTrack = false;
      instanceTypeNames.forEach(function(typeName) {
        var allInstances = instancesByTypeName[typeName];

        // If a object snapshot has a view it will be shown,
        // unless the view asked for it to not be shown.
        var instanceViewInfo = ObjectInstanceView.getTypeInfo(
            undefined, typeName);
        var snapshotViewInfo = ObjectSnapshotView.getTypeInfo(
            undefined, typeName);
        if (instanceViewInfo && !instanceViewInfo.metadata.showInTrackView)
          instanceViewInfo = undefined;
        if (snapshotViewInfo && !snapshotViewInfo.metadata.showInTrackView)
          snapshotViewInfo = undefined;
        var hasViewInfo = instanceViewInfo || snapshotViewInfo;

        // There are some instances that don't merit their own track in
        // the UI. Filter them out.
        var visibleInstances = [];
        for (var i = 0; i < allInstances.length; i++) {
          var instance = allInstances[i];

          // Do not create tracks for instances that have no snapshots.
          if (instance.snapshots.length === 0)
            continue;

          // Do not create tracks for instances that have implicit snapshots
          // and don't have a view.
          if (instance.hasImplicitSnapshots && !hasViewInfo)
            continue;

          visibleInstances.push(instance);
        }
        if (visibleInstances.length === 0)
          return;

        // Look up the constructor for this track, or use the default
        // constructor if none exists.
        var trackConstructor =
            tr.ui.tracks.ObjectInstanceTrack.getConstructor(
                undefined, typeName);
        if (!trackConstructor) {
          var snapshotViewInfo = ObjectSnapshotView.getTypeInfo(
              undefined, typeName);
          if (snapshotViewInfo && snapshotViewInfo.metadata.showInstances) {
            trackConstructor = tr.ui.tracks.ObjectInstanceGroupTrack;
          } else {
            trackConstructor = tr.ui.tracks.ObjectInstanceTrack;
          }
        }
        var track = new trackConstructor(this.viewport);
        track.objectInstances = visibleInstances;
        this.appendChild(track);
        didAppendAtLeastOneTrack = true;
      }, this);
      if (didAppendAtLeastOneTrack)
        this.appendChild(new SpacingTrack(this.viewport));
    },

    appendCounterTracks_: function() {
      // Add counter tracks for this process.
      var counters = tr.b.dictionaryValues(this.processBase.counters);
      counters.sort(tr.model.Counter.compare);

      // Create the counters for this process.
      counters.forEach(function(counter) {
        var track = new tr.ui.tracks.CounterTrack(this.viewport);
        track.counter = counter;
        this.appendChild(track);
        this.appendChild(new SpacingTrack(this.viewport));
      }.bind(this));
    },

    appendThreadTracks_: function() {
      // Get a sorted list of threads.
      var threads = tr.b.dictionaryValues(this.processBase.threads);
      threads.sort(tr.model.Thread.compare);

      // Create the threads.
      threads.forEach(function(thread) {
        var track = new tr.ui.tracks.ThreadTrack(this.viewport);
        track.thread = thread;
        if (!track.hasVisibleContent)
          return;
        this.appendChild(track);
        this.appendChild(new SpacingTrack(this.viewport));
      }.bind(this));
    }
  };

  return {
    ProcessTrackBase: ProcessTrackBase
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  /**
   * Visualizes a Cpu using a series of of SliceTracks.
   * @constructor
   */
  var CpuTrack =
      tr.ui.b.define('cpu-track', tr.ui.tracks.ContainerTrack);
  CpuTrack.prototype = {
    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.classList.add('cpu-track');
      this.detailedMode_ = true;
    },

    get cpu() {
      return this.cpu_;
    },

    set cpu(cpu) {
      this.cpu_ = cpu;
      this.updateContents_();
    },

    get detailedMode() {
      return this.detailedMode_;
    },

    set detailedMode(detailedMode) {
      this.detailedMode_ = detailedMode;
      this.updateContents_();
    },

    get tooltip() {
      return this.tooltip_;
    },

    set tooltip(value) {
      this.tooltip_ = value;
      this.updateContents_();
    },

    get hasVisibleContent() {
      if (this.cpu_ === undefined)
        return false;
      var cpu = this.cpu_;
      if (cpu.slices.length)
        return true;
      if (cpu.samples && cpu.samples.length)
        return true;
      if (tr.b.dictionaryLength(cpu.counters) > 0)
        return true;
      return false;
    },

    updateContents_: function() {
      this.detach();
      if (!this.cpu_)
        return;
      var slices = this.cpu_.slices;
      if (slices.length) {
        var track = new tr.ui.tracks.SliceTrack(this.viewport);
        track.slices = slices;
        track.heading = this.cpu_.userFriendlyName + ':';
        this.appendChild(track);
      }

      if (this.detailedMode_) {
        this.appendSamplesTracks_();

        for (var counterName in this.cpu_.counters) {
          var counter = this.cpu_.counters[counterName];
          track = new tr.ui.tracks.CounterTrack(this.viewport);
          track.heading = this.cpu_.userFriendlyName + ' ' +
              counter.name + ':';
          track.counter = counter;
          this.appendChild(track);
        }
      }
    },

    appendSamplesTracks_: function() {
      var samples = this.cpu_.samples;
      if (samples === undefined || samples.length === 0)
        return;
      var samplesByTitle = {};
      samples.forEach(function(sample) {
        if (samplesByTitle[sample.title] === undefined)
          samplesByTitle[sample.title] = [];
        samplesByTitle[sample.title].push(sample);
      });

      var sampleTitles = tr.b.dictionaryKeys(samplesByTitle);
      sampleTitles.sort();

      sampleTitles.forEach(function(sampleTitle) {
        var samples = samplesByTitle[sampleTitle];
        var samplesTrack = new tr.ui.tracks.SliceTrack(this.viewport);
        samplesTrack.group = this.cpu_;
        samplesTrack.slices = samples;
        samplesTrack.heading = this.cpu_.userFriendlyName + ': ' +
            sampleTitle;
        samplesTrack.tooltip = this.cpu_.userFriendlyDetails;
        samplesTrack.selectionGenerator = function() {
          var selection = new tr.model.EventSet();
          for (var i = 0; i < samplesTrack.slices.length; i++) {
            selection.push(samplesTrack.slices[i]);
          }
          return selection;
        };
        this.appendChild(samplesTrack);
      }, this);
    }
  };

  return {
    CpuTrack: CpuTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  var Cpu = tr.model.Cpu;
  var CpuTrack = tr.ui.tracks.cpu_track;
  var ProcessTrackBase = tr.ui.tracks.ProcessTrackBase;
  var SpacingTrack = tr.ui.tracks.SpacingTrack;

  /**
   * @constructor
   */
  var KernelTrack = tr.ui.b.define('kernel-track', ProcessTrackBase);

  KernelTrack.prototype = {
    __proto__: ProcessTrackBase.prototype,

    decorate: function(viewport) {
      ProcessTrackBase.prototype.decorate.call(this, viewport);
    },


    // Kernel maps to processBase because we derive from ProcessTrackBase.
    set kernel(kernel) {
      this.processBase = kernel;
    },

    get kernel() {
      return this.processBase;
    },

    get eventContainer() {
      return this.kernel;
    },

    get hasVisibleContent() {
      return this.children.length > 1;
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      containerToTrackMap.addContainer(this.kernel, this);
    },

    willAppendTracks_: function() {
      var cpus = tr.b.dictionaryValues(this.kernel.cpus);
      cpus.sort(tr.model.Cpu.compare);

      var didAppendAtLeastOneTrack = false;
      for (var i = 0; i < cpus.length; ++i) {
        var cpu = cpus[i];
        var track = new tr.ui.tracks.CpuTrack(this.viewport);
        track.detailedMode = this.expanded;
        track.cpu = cpu;
        if (!track.hasVisibleContent)
          continue;
        this.appendChild(track);
        didAppendAtLeastOneTrack = true;
      }
      if (didAppendAtLeastOneTrack)
        this.appendChild(new SpacingTrack(this.viewport));
    }
  };


  return {
    KernelTrack: KernelTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of interaction records.
   * @constructor
   * @extends {MultiRowTrack}
   */
  var InteractionTrack = tr.ui.b.define(
      'interaction-track', tr.ui.tracks.MultiRowTrack);

  InteractionTrack.prototype = {
    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      this.heading = 'Interactions';
      this.subRows_ = [];
    },

    set model(model) {
      this.setItemsToGroup(model.interactionRecords, {
        guid: tr.b.GUID.allocate(),
        model: model,
        getSettingsKey: function() {
          return undefined;
        }
      });
    },

    buildSubRows_: function(slices) {
      if (this.subRows_.length)
        return this.subRows_;
      this.subRows_.push.apply(this.subRows_,
          tr.ui.tracks.AsyncSliceGroupTrack.prototype.buildSubRows_.call(
          {}, slices, true));
      return this.subRows_;
    },

    addSubTrack_: function(slices) {
      var track = new tr.ui.tracks.SliceTrack(this.viewport);
      track.slices = slices;
      this.appendChild(track);
      return track;
    }
  };

  return {
    InteractionTrack: InteractionTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {

  var ALLOCATED_MEMORY_TRACK_HEIGHT = 50;

  /**
   * A track that displays an array of ProcessMemoryDump objects.
   * @constructor
   * @extends {ContainerTrack}
   */
  var ProcessMemoryDumpTrack = tr.ui.b.define(
      'process-memory-dump-track', tr.ui.tracks.ContainerTrack);

  ProcessMemoryDumpTrack.prototype = {
    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.memoryDumps_ = undefined;
    },

    get memoryDumps() {
      return this.memoryDumps_;
    },

    set memoryDumps(memoryDumps) {
      this.memoryDumps_ = memoryDumps;
      this.updateContents_();
    },

    updateContents_: function() {
      this.clearTracks_();

      // Show no tracks if there are no dumps.
      if (!this.memoryDumps_ || !this.memoryDumps_.length)
        return;

      this.appendAllocatedMemoryTrack_();
    },

    appendAllocatedMemoryTrack_: function() {
      var series = tr.ui.tracks.buildProcessAllocatedMemoryChartSeries(
          this.memoryDumps_);
      if (!series)
        return;

      var track = new tr.ui.tracks.ChartTrack(this.viewport);
      track.heading = 'Allocated memory (per allocator)';
      track.height = ALLOCATED_MEMORY_TRACK_HEIGHT + 'px';
      track.series = series;
      track.autoSetAllAxes({expandMax: true});
      this.appendChild(track);
    }
  };

  return {
    ProcessMemoryDumpTrack: ProcessMemoryDumpTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  var ProcessTrackBase = tr.ui.tracks.ProcessTrackBase;

  /**
   * @constructor
   */
  var ProcessTrack = tr.ui.b.define('process-track', ProcessTrackBase);

  ProcessTrack.prototype = {
    __proto__: ProcessTrackBase.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ProcessTrackBase.prototype.decorate.call(this, viewport);
    },

    drawTrack: function(type) {
      switch (type) {
        case tr.ui.tracks.DrawType.INSTANT_EVENT:
          if (!this.processBase.instantEvents ||
              this.processBase.instantEvents.length === 0)
            break;

          var ctx = this.context();

          var pixelRatio = window.devicePixelRatio || 1;
          var bounds = this.getBoundingClientRect();
          var canvasBounds = ctx.canvas.getBoundingClientRect();

          ctx.save();
          ctx.translate(0, pixelRatio * (bounds.top - canvasBounds.top));

          var dt = this.viewport.currentDisplayTransform;
          var viewLWorld = dt.xViewToWorld(0);
          var viewRWorld = dt.xViewToWorld(
              bounds.width * pixelRatio);

          tr.ui.b.drawInstantSlicesAsLines(
              ctx,
              this.viewport.currentDisplayTransform,
              viewLWorld,
              viewRWorld,
              bounds.height,
              this.processBase.instantEvents,
              2);

          ctx.restore();

          break;

        case tr.ui.tracks.DrawType.BACKGROUND:
          this.drawBackground_();
          // Don't bother recursing further, Process is the only level that
          // draws backgrounds.
          return;
      }

      tr.ui.tracks.ContainerTrack.prototype.drawTrack.call(this, type);
    },

    drawBackground_: function() {
      var ctx = this.context();
      var canvasBounds = ctx.canvas.getBoundingClientRect();
      var pixelRatio = window.devicePixelRatio || 1;

      var draw = false;
      ctx.fillStyle = '#eee';
      for (var i = 0; i < this.children.length; ++i) {
        if (!(this.children[i] instanceof tr.ui.tracks.Track) ||
            (this.children[i] instanceof tr.ui.tracks.SpacingTrack))
          continue;

        draw = !draw;
        if (!draw)
          continue;

        var bounds = this.children[i].getBoundingClientRect();
        ctx.fillRect(0, pixelRatio * (bounds.top - canvasBounds.top),
            ctx.canvas.width, pixelRatio * bounds.height);
      }
    },

    // Process maps to processBase because we derive from ProcessTrackBase.
    set process(process) {
      this.processBase = process;
    },

    get process() {
      return this.processBase;
    },

    get eventContainer() {
      return this.process;
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      containerToTrackMap.addContainer(this.process, this);
      this.tracks_.forEach(function(track) {
        track.addContainersToTrackMap(containerToTrackMap);
      });
    },

    appendMemoryDumpTrack_: function() {
      var processMemoryDumps = this.process.memoryDumps;
      if (processMemoryDumps.length) {
        var pmdt = new tr.ui.tracks.ProcessMemoryDumpTrack(this.viewport_);
        pmdt.memoryDumps = processMemoryDumps;
        this.appendChild(pmdt);
      }
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
      function onPickHit(instantEvent) {
        selection.push(instantEvent);
      }
      var instantEventWidth = 2 * viewPixWidthWorld;
      tr.b.iterateOverIntersectingIntervals(this.processBase.instantEvents,
          function(x) { return x.start; },
          function(x) { return x.duration + instantEventWidth; },
          loWX, hiWX,
          onPickHit.bind(this));

      tr.ui.tracks.ContainerTrack.prototype.
          addIntersectingEventsInRangeToSelectionInWorldSpace.
          apply(this, arguments);
    },

    addClosestEventToSelection: function(worldX, worldMaxDist, loY, hiY,
                                         selection) {
      this.addClosestInstantEventToSelection(this.processBase.instantEvents,
                                             worldX, worldMaxDist, selection);
      tr.ui.tracks.ContainerTrack.prototype.addClosestEventToSelection.
          apply(this, arguments);
    }
  };

  return {
    ProcessTrack: ProcessTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  var SelectionState = tr.model.SelectionState;
  var EventPresenter = tr.ui.b.EventPresenter;

  /**
   * Visualizes a Model by building ProcessTracks and CpuTracks.
   * @constructor
   */
  var ModelTrack = tr.ui.b.define('model-track', tr.ui.tracks.ContainerTrack);


  ModelTrack.prototype = {

    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.classList.add('model-track');

      var typeInfos = tr.ui.tracks.Highlighter.getAllRegisteredTypeInfos();
      this.highlighters_ = typeInfos.map(
        function(typeInfo) {
          return new typeInfo.constructor(viewport);
        });

      this.upperMode_ = false;
      this.annotationViews_ = [];
    },

    // upperMode is true if the track is being used on the ruler.
    get upperMode() {
      return this.upperMode_;
    },

    set upperMode(upperMode) {
      this.upperMode_ = upperMode;
      this.updateContents_();
    },

    detach: function() {
      tr.ui.tracks.ContainerTrack.prototype.detach.call(this);
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      this.updateContents_();

      this.model_.addEventListener('annotationChange',
          this.updateAnnotations_.bind(this));
    },

    get hasVisibleContent() {
      return this.children.length > 0;
    },

    updateContents_: function() {
      this.textContent = '';
      if (!this.model_)
        return;

      if (this.upperMode_)
        this.updateContentsForUpperMode_();
      else
        this.updateContentsForLowerMode_();
    },

    updateContentsForUpperMode_: function() {
    },

    updateContentsForLowerMode_: function() {
      if (this.model_.interactionRecords.length) {
        var mrt = new tr.ui.tracks.InteractionTrack(this.viewport_);
        mrt.model = this.model_;
        this.appendChild(mrt);
      }

      if (this.model_.alerts.length) {
        var at = new tr.ui.tracks.AlertTrack(this.viewport_);
        at.alerts = this.model_.alerts;
        this.appendChild(at);
      }

      if (this.model_.globalMemoryDumps.length) {
        var gmdt = new tr.ui.tracks.GlobalMemoryDumpTrack(this.viewport_);
        gmdt.memoryDumps = this.model_.globalMemoryDumps;
        this.appendChild(gmdt);
      }

      this.appendDeviceTrack_();
      this.appendKernelTrack_();

      // Get a sorted list of processes.
      var processes = this.model_.getAllProcesses();
      processes.sort(tr.model.Process.compare);

      for (var i = 0; i < processes.length; ++i) {
        var process = processes[i];

        var track = new tr.ui.tracks.ProcessTrack(this.viewport);
        track.process = process;
        if (!track.hasVisibleContent)
          continue;

        this.appendChild(track);
      }
      this.viewport_.rebuildEventToTrackMap();
      this.viewport_.rebuildContainerToTrackMap();

      for (var i = 0; i < this.highlighters_.length; i++) {
        this.highlighters_[i].processModel(this.model_);
      }

      this.updateAnnotations_();
    },

    updateAnnotations_: function() {
      this.annotationViews_ = [];
      var annotations = this.model_.getAllAnnotations();
      for (var i = 0; i < annotations.length; i++) {
        this.annotationViews_.push(
            annotations[i].getOrCreateView(this.viewport_));
      }
      this.invalidateDrawingContainer();
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      if (!this.model_)
        return;

      var tracks = this.children;
      for (var i = 0; i < tracks.length; ++i)
        tracks[i].addEventsToTrackMap(eventToTrackMap);

      if (this.instantEvents === undefined)
        return;

      var vp = this.viewport_;
      this.instantEvents.forEach(function(ev) {
        eventToTrackMap.addEvent(ev, this);
      }.bind(this));
    },

    addContainersToTrackMap: function(containerToTrackMap) {
      var tracks = this.children;
      for (var i = 0; i < tracks.length; ++i)
        tracks[i].addContainersToTrackMap(containerToTrackMap);
    },

    appendDeviceTrack_: function() {
      var device = this.model.device;
      var track = new tr.ui.tracks.DeviceTrack(this.viewport);
      track.device = this.model.device;
      if (!track.hasVisibleContent)
        return;
      this.appendChild(track);
    },

    appendKernelTrack_: function() {
      var kernel = this.model.kernel;
      var track = new tr.ui.tracks.KernelTrack(this.viewport);
      track.kernel = this.model.kernel;
      if (!track.hasVisibleContent)
        return;
      this.appendChild(track);
    },

    drawTrack: function(type) {
      var ctx = this.context();
      if (!this.model_)
        return;

      var pixelRatio = window.devicePixelRatio || 1;
      var bounds = this.getBoundingClientRect();
      var canvasBounds = ctx.canvas.getBoundingClientRect();

      ctx.save();
      ctx.translate(0, pixelRatio * (bounds.top - canvasBounds.top));

      var dt = this.viewport.currentDisplayTransform;
      var viewLWorld = dt.xViewToWorld(0);
      var viewRWorld = dt.xViewToWorld(bounds.width * pixelRatio);

      switch (type) {
        case tr.ui.tracks.DrawType.GRID:
          this.viewport.drawMajorMarkLines(ctx);
          // The model is the only thing that draws grid lines.
          ctx.restore();
          return;

        case tr.ui.tracks.DrawType.FLOW_ARROWS:
          if (this.model_.flowIntervalTree.size === 0) {
            ctx.restore();
            return;
          }

          this.drawFlowArrows_(viewLWorld, viewRWorld);
          ctx.restore();
          return;

        case tr.ui.tracks.DrawType.INSTANT_EVENT:
          if (!this.model_.instantEvents ||
              this.model_.instantEvents.length === 0)
            break;

          tr.ui.b.drawInstantSlicesAsLines(
              ctx,
              this.viewport.currentDisplayTransform,
              viewLWorld,
              viewRWorld,
              bounds.height,
              this.model_.instantEvents,
              4);

          break;

        case tr.ui.tracks.DrawType.MARKERS:
          if (!this.viewport.interestRange.isEmpty) {
            this.viewport.interestRange.draw(ctx, viewLWorld, viewRWorld);
            this.viewport.interestRange.drawIndicators(
                ctx, viewLWorld, viewRWorld);
          }
          ctx.restore();
          return;

        case tr.ui.tracks.DrawType.HIGHLIGHTS:
          for (var i = 0; i < this.highlighters_.length; i++) {
            this.highlighters_[i].drawHighlight(ctx, dt, viewLWorld, viewRWorld,
                bounds.height);
          }
          ctx.restore();
          return;

        case tr.ui.tracks.DrawType.ANNOTATIONS:
          for (var i = 0; i < this.annotationViews_.length; i++) {
            this.annotationViews_[i].draw(ctx);
          }
          ctx.restore();
          return;
      }
      ctx.restore();

      tr.ui.tracks.ContainerTrack.prototype.drawTrack.call(this, type);
    },

    drawFlowArrows_: function(viewLWorld, viewRWorld) {
      var ctx = this.context();
      var dt = this.viewport.currentDisplayTransform;
      dt.applyTransformToCanvas(ctx);

      var pixWidth = dt.xViewVectorToWorld(1);

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.lineWidth = pixWidth > 1.0 ? 1 : pixWidth;

      var events =
          this.model_.flowIntervalTree.findIntersection(viewLWorld, viewRWorld);

      // When not showing flow events, show only highlighted/selected ones.
      var onlyHighlighted = !this.viewport.showFlowEvents;
      var canvasBounds = ctx.canvas.getBoundingClientRect();
      for (var i = 0; i < events.length; ++i) {
        if (onlyHighlighted &&
            events[i].selectionState !== SelectionState.SELECTED &&
            events[i].selectionState !== SelectionState.HIGHLIGHTED)
          continue;
        this.drawFlowArrow_(ctx, events[i], canvasBounds, pixWidth);
      }
    },

    drawFlowArrow_: function(ctx, flowEvent,
                             canvasBounds, pixWidth) {
      var pixelRatio = window.devicePixelRatio || 1;

      var startTrack = this.viewport.trackForEvent(flowEvent.startSlice);
      var endTrack = this.viewport.trackForEvent(flowEvent.endSlice);

      // TODO(nduca): Figure out how to draw flow arrows even when
      // processes are collapsed, bug #931.
      if (startTrack === undefined || endTrack === undefined)
        return;

      var startBounds = startTrack.getBoundingClientRect();
      var endBounds = endTrack.getBoundingClientRect();

      if (flowEvent.selectionState == SelectionState.SELECTED) {
        ctx.shadowBlur = 1;
        ctx.shadowColor = 'red';
        ctx.shadowOffsety = 2;
        ctx.strokeStyle = 'red';
      } else if (flowEvent.selectionState == SelectionState.HIGHLIGHTED) {
        ctx.shadowBlur = 1;
        ctx.shadowColor = 'red';
        ctx.shadowOffsety = 2;
        ctx.strokeStyle = 'red';
      } else if (flowEvent.selectionState == SelectionState.DIMMED) {
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
      } else {
        var hasBoost = false;
        var startSlice = flowEvent.startSlice;
        hasBoost |= startSlice.selectionState === SelectionState.SELECTED;
        hasBoost |= startSlice.selectionState === SelectionState.HIGHLIGHTED;
        var endSlice = flowEvent.endSlice;
        hasBoost |= endSlice.selectionState === SelectionState.SELECTED;
        hasBoost |= endSlice.selectionState === SelectionState.HIGHLIGHTED;
        if (hasBoost) {
          ctx.shadowBlur = 1;
          ctx.shadowColor = 'rgba(255, 0, 0, 0.4)';
          ctx.shadowOffsety = 2;
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
        } else {
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
        }
      }

      var startSize = startBounds.left + startBounds.top +
          startBounds.bottom + startBounds.right;
      var endSize = endBounds.left + endBounds.top +
          endBounds.bottom + endBounds.right;
      // Nothing to do if both ends of the track are collapsed.
      if (startSize === 0 && endSize === 0)
        return;

      var startY = this.calculateTrackY_(startTrack, canvasBounds);
      var endY = this.calculateTrackY_(endTrack, canvasBounds);

      var pixelStartY = pixelRatio * startY;
      var pixelEndY = pixelRatio * endY;
      var half = (flowEvent.end - flowEvent.start) / 2;

      ctx.beginPath();
      ctx.moveTo(flowEvent.start, pixelStartY);
      ctx.bezierCurveTo(
          flowEvent.start + half, pixelStartY,
          flowEvent.start + half, pixelEndY,
          flowEvent.end, pixelEndY);
      ctx.stroke();

      var arrowWidth = 5 * pixWidth * pixelRatio;
      var distance = flowEvent.end - flowEvent.start;
      if (distance <= (2 * arrowWidth))
        return;

      var tipX = flowEvent.end;
      var tipY = pixelEndY;
      var arrowHeight = (endBounds.height / 4) * pixelRatio;
      tr.ui.b.drawTriangle(ctx,
          tipX, tipY,
          tipX - arrowWidth, tipY - arrowHeight,
          tipX - arrowWidth, tipY + arrowHeight);
      ctx.fill();
    },

    calculateTrackY_: function(track, canvasBounds) {
      var bounds = track.getBoundingClientRect();
      var size = bounds.left + bounds.top + bounds.bottom + bounds.right;
      if (size === 0)
        return this.calculateTrackY_(track.parentNode, canvasBounds);

      return bounds.top - canvasBounds.top + (bounds.height / 2);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
      function onPickHit(instantEvent) {
        selection.push(instantEvent);
      }
      var instantEventWidth = 3 * viewPixWidthWorld;
      tr.b.iterateOverIntersectingIntervals(this.model_.instantEvents,
          function(x) { return x.start; },
          function(x) { return x.duration + instantEventWidth; },
          loWX, hiWX,
          onPickHit.bind(this));

      tr.ui.tracks.ContainerTrack.prototype.
          addIntersectingEventsInRangeToSelectionInWorldSpace.
          apply(this, arguments);
    },

    addClosestEventToSelection: function(worldX, worldMaxDist, loY, hiY,
                                         selection) {
      this.addClosestInstantEventToSelection(this.model_.instantEvents,
                                             worldX, worldMaxDist, selection);
      tr.ui.tracks.ContainerTrack.prototype.addClosestEventToSelection.
          apply(this, arguments);
    }
  };

  return {
    ModelTrack: ModelTrack
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays the ruler.
   * @constructor
   * @extends {Track}
   */
  var RulerTrack = tr.ui.b.define('ruler-track', tr.ui.tracks.Track);

  var logOf10 = Math.log(10);
  function log10(x) {
    return Math.log(x) / logOf10;
  }

  RulerTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      this.classList.add('ruler-track');
      this.strings_secs_ = [];
      this.strings_msecs_ = [];
      this.strings_usecs_ = [];
      this.strings_nsecs_ = [];

      this.viewportChange_ = this.viewportChange_.bind(this);
      viewport.addEventListener('change', this.viewportChange_);

      var heading = document.createElement('tr-ui-heading');
      heading.arrowVisible = false;
      this.appendChild(heading);
    },

    detach: function() {
      tr.ui.tracks.Track.prototype.detach.call(this);
      this.viewport.removeEventListener('change',
                                        this.viewportChange_);
    },

    viewportChange_: function() {
      if (this.viewport.interestRange.isEmpty)
        this.classList.remove('tall-mode');
      else
        this.classList.add('tall-mode');
    },

    draw: function(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GRID:
          this.drawGrid_(viewLWorld, viewRWorld);
          break;
        case tr.ui.tracks.DrawType.MARKERS:
          if (!this.viewport.interestRange.isEmpty)
            this.viewport.interestRange.draw(this.context(),
                                             viewLWorld, viewRWorld);
          break;
      }
    },

    drawGrid_: function(viewLWorld, viewRWorld) {
      var ctx = this.context();
      var pixelRatio = window.devicePixelRatio || 1;

      var canvasBounds = ctx.canvas.getBoundingClientRect();
      var trackBounds = this.getBoundingClientRect();
      var width = canvasBounds.width * pixelRatio;
      var height = trackBounds.height * pixelRatio;

      var hasInterestRange = !this.viewport.interestRange.isEmpty;

      var rulerHeight = hasInterestRange ? (height * 2) / 5 : height;

      var vp = this.viewport;
      var dt = vp.currentDisplayTransform;

      var idealMajorMarkDistancePix = 150 * pixelRatio;
      var idealMajorMarkDistanceWorld =
          dt.xViewVectorToWorld(idealMajorMarkDistancePix);

      var majorMarkDistanceWorld;

      // The conservative guess is the nearest enclosing 0.1, 1, 10, 100, etc.
      var conservativeGuess =
          Math.pow(10, Math.ceil(log10(idealMajorMarkDistanceWorld)));

      // Once we have a conservative guess, consider things that evenly add up
      // to the conservative guess, e.g. 0.5, 0.2, 0.1 Pick the one that still
      // exceeds the ideal mark distance.
      var divisors = [10, 5, 2, 1];
      for (var i = 0; i < divisors.length; ++i) {
        var tightenedGuess = conservativeGuess / divisors[i];
        if (dt.xWorldVectorToView(tightenedGuess) < idealMajorMarkDistancePix)
          continue;
        majorMarkDistanceWorld = conservativeGuess / divisors[i - 1];
        break;
      }

      var unit;
      var unitDivisor;
      var tickLabels = undefined;
      if (majorMarkDistanceWorld < 0.0001) {
        unit = 'ns';
        unitDivisor = 0.000001;
        tickLabels = this.strings_nsecs_;
      } else if (majorMarkDistanceWorld < 0.1) {
        unit = 'us';
        unitDivisor = 0.001;
        tickLabels = this.strings_usecs_;
      } else if (majorMarkDistanceWorld < 100) {
        unit = 'ms';
        unitDivisor = 1;
        tickLabels = this.strings_msecs_;
      } else {
        unit = 's';
        unitDivisor = 1000;
        tickLabels = this.strings_secs_;
      }

      var numTicksPerMajor = 5;
      var minorMarkDistanceWorld = majorMarkDistanceWorld / numTicksPerMajor;
      var minorMarkDistancePx = dt.xWorldVectorToView(minorMarkDistanceWorld);

      var firstMajorMark =
          Math.floor(viewLWorld / majorMarkDistanceWorld) *
              majorMarkDistanceWorld;

      var minorTickH = Math.floor(rulerHeight * 0.25);

      ctx.save();

      var pixelRatio = window.devicePixelRatio || 1;
      ctx.lineWidth = Math.round(pixelRatio);

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      var crispLineCorrection = (ctx.lineWidth % 2) / 2;
      ctx.translate(crispLineCorrection, -crispLineCorrection);

      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      ctx.font = (9 * pixelRatio) + 'px sans-serif';

      vp.majorMarkPositions = [];

      // Each iteration of this loop draws one major mark
      // and numTicksPerMajor minor ticks.
      //
      // Rendering can't be done in world space because canvas transforms
      // affect line width. So, do the conversions manually.
      ctx.beginPath();
      for (var curX = firstMajorMark;
           curX < viewRWorld;
           curX += majorMarkDistanceWorld) {

        var curXView = Math.floor(dt.xWorldToView(curX));

        var unitValue = curX / unitDivisor;
        var roundedUnitValue = Math.round(unitValue * 100000) / 100000;

        if (!tickLabels[roundedUnitValue])
          tickLabels[roundedUnitValue] = roundedUnitValue + ' ' + unit;
        ctx.fillText(tickLabels[roundedUnitValue],
                     curXView + (2 * pixelRatio), 0);

        vp.majorMarkPositions.push(curXView);

        // Major mark
        tr.ui.b.drawLine(ctx, curXView, 0, curXView, rulerHeight);

        // Minor marks
        for (var i = 1; i < numTicksPerMajor; ++i) {
          var xView = Math.floor(curXView + minorMarkDistancePx * i);
          tr.ui.b.drawLine(ctx,
              xView, rulerHeight - minorTickH,
              xView, rulerHeight);
        }
      }

      // Draw bottom bar.
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      tr.ui.b.drawLine(ctx, 0, height, width, height);
      ctx.stroke();

      // Give distance between directly adjacent markers.
      if (!hasInterestRange)
        return;

      // Draw middle bar.
      tr.ui.b.drawLine(ctx, 0, rulerHeight, width, rulerHeight);
      ctx.stroke();

      // Distance Variables.
      var displayDistance;
      var displayTextColor = 'rgb(0,0,0)';

      // Arrow Variables.
      var arrowSpacing = 10 * pixelRatio;
      var arrowColor = 'rgb(128,121,121)';
      var arrowPosY = rulerHeight * 1.75;
      var arrowWidthView = 3 * pixelRatio;
      var arrowLengthView = 10 * pixelRatio;
      var spaceForArrowsView = 2 * (arrowWidthView + arrowSpacing);

      ctx.textBaseline = 'middle';
      ctx.font = (14 * pixelRatio) + 'px sans-serif';
      var textPosY = arrowPosY;

      var interestRange = vp.interestRange;

      // If the range is zero, draw it's min timestamp next to the line.
      if (interestRange.range === 0) {
        var markerWorld = interestRange.min;
        var markerView = dt.xWorldToView(markerWorld);
        var displayValue = markerWorld / unitDivisor;
        displayValue = Math.abs((Math.round(displayValue * 1000) / 1000));

        var textToDraw = displayValue + ' ' + unit;
        var textLeftView = markerView + 4 * pixelRatio;
        var textWidthView = ctx.measureText(textToDraw).width;

        // Put text to the left in case it gets cut off.
        if (textLeftView + textWidthView > width)
          textLeftView = markerView - 4 * pixelRatio - textWidthView;

        ctx.fillStyle = displayTextColor;
        ctx.fillText(textToDraw, textLeftView, textPosY);
        return;
      }

      var leftMarker = interestRange.min;
      var rightMarker = interestRange.max;

      var leftMarkerView = dt.xWorldToView(leftMarker);
      var rightMarkerView = dt.xWorldToView(rightMarker);

      var distanceBetweenMarkers = interestRange.range;
      var distanceBetweenMarkersView =
          dt.xWorldVectorToView(distanceBetweenMarkers);
      var positionInMiddleOfMarkersView =
          leftMarkerView + (distanceBetweenMarkersView / 2);

      // Determine units.
      if (distanceBetweenMarkers < 0.0001) {
        unit = 'ns';
        unitDivisor = 0.000001;
      } else if (distanceBetweenMarkers < 0.1) {
        unit = 'us';
        unitDivisor = 0.001;
      } else if (distanceBetweenMarkers < 100) {
        unit = 'ms';
        unitDivisor = 1;
      } else {
        unit = 's';
        unitDivisor = 1000;
      }

      // Calculate display value to print.
      displayDistance = distanceBetweenMarkers / unitDivisor;
      var roundedDisplayDistance =
          Math.abs((Math.round(displayDistance * 1000) / 1000));
      var textToDraw = roundedDisplayDistance + ' ' + unit;
      var textWidthView = ctx.measureText(textToDraw).width;
      var spaceForArrowsAndTextView =
          textWidthView + spaceForArrowsView + arrowSpacing;

      // Set text positions.
      var textLeftView = positionInMiddleOfMarkersView - textWidthView / 2;
      var textRightView = textLeftView + textWidthView;

      if (spaceForArrowsAndTextView > distanceBetweenMarkersView) {
        // Print the display distance text right of the 2 markers.
        textLeftView = rightMarkerView + 2 * arrowSpacing;

        // Put text to the left in case it gets cut off.
        if (textLeftView + textWidthView > width)
          textLeftView = leftMarkerView - 2 * arrowSpacing - textWidthView;

        ctx.fillStyle = displayTextColor;
        ctx.fillText(textToDraw, textLeftView, textPosY);

        // Draw the arrows pointing from outside in and a line in between.
        ctx.strokeStyle = arrowColor;
        ctx.beginPath();
        tr.ui.b.drawLine(ctx, leftMarkerView, arrowPosY, rightMarkerView,
            arrowPosY);
        ctx.stroke();

        ctx.fillStyle = arrowColor;
        tr.ui.b.drawArrow(ctx,
            leftMarkerView - 1.5 * arrowSpacing, arrowPosY,
            leftMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
        tr.ui.b.drawArrow(ctx,
            rightMarkerView + 1.5 * arrowSpacing, arrowPosY,
            rightMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);

      } else if (spaceForArrowsView <= distanceBetweenMarkersView) {
        var leftArrowStart;
        var rightArrowStart;
        if (spaceForArrowsAndTextView <= distanceBetweenMarkersView) {
          // Print the display distance text.
          ctx.fillStyle = displayTextColor;
          ctx.fillText(textToDraw, textLeftView, textPosY);

          leftArrowStart = textLeftView - arrowSpacing;
          rightArrowStart = textRightView + arrowSpacing;
        } else {
          leftArrowStart = positionInMiddleOfMarkersView;
          rightArrowStart = positionInMiddleOfMarkersView;
        }

        // Draw the arrows pointing inside out.
        ctx.strokeStyle = arrowColor;
        ctx.fillStyle = arrowColor;
        tr.ui.b.drawArrow(ctx,
            leftArrowStart, arrowPosY,
            leftMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
        tr.ui.b.drawArrow(ctx,
            rightArrowStart, arrowPosY,
            rightMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
      }

      ctx.restore();
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loVY Lower Y bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVY Upper Y bound of the interval to search, in
     *     viewspace.
     * @param {Selection} selection Selection to which to add results.
     */
    addIntersectingEventsInRangeToSelection: function(
        loVX, hiVX, loY, hiY, selection) {
      // Does nothing. There's nothing interesting to pick on the ruler
      // track.
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
    }
  };

  return {
    RulerTrack: RulerTrack
  };
});


  'use strict';

  Polymer('tr-ui-timeline-track-view', {
    ready: function() {
      this.displayTransform_ = new tr.ui.TimelineDisplayTransform();
      this.model_ = undefined;

      this.timelineView_ = undefined;

      this.viewport_ = new tr.ui.TimelineViewport(this);
      this.viewportDisplayTransformAtMouseDown_ = undefined;
      this.brushingStateController_ = undefined;

      this.rulerTrackContainer_ =
          new tr.ui.tracks.DrawingContainer(this.viewport_);
      this.appendChild(this.rulerTrackContainer_);
      this.rulerTrackContainer_.invalidate();

      this.rulerTrack_ = new tr.ui.tracks.RulerTrack(this.viewport_);
      this.rulerTrackContainer_.appendChild(this.rulerTrack_);

      this.upperModelTrack_ = new tr.ui.tracks.ModelTrack(this.viewport_);
      this.upperModelTrack_.upperMode = true;
      this.rulerTrackContainer_.appendChild(this.upperModelTrack_);

      this.modelTrackContainer_ =
          new tr.ui.tracks.DrawingContainer(this.viewport_);
      this.appendChild(this.modelTrackContainer_);
      this.modelTrackContainer_.style.display = 'block';
      this.modelTrackContainer_.invalidate();

      this.viewport_.modelTrackContainer = this.modelTrackContainer_;

      this.modelTrack_ = new tr.ui.tracks.ModelTrack(this.viewport_);
      this.modelTrackContainer_.appendChild(this.modelTrack_);

      this.timingTool_ = new tr.ui.b.TimingTool(this.viewport_, this);

      this.initMouseModeSelector();

      this.hideDragBox_();

      this.initHintText_();

      this.onSelectionChanged_ = this.onSelectionChanged_.bind(this);

      this.onDblClick_ = this.onDblClick_.bind(this);
      this.addEventListener('dblclick', this.onDblClick_);

      this.onMouseWheel_ = this.onMouseWheel_.bind(this);
      this.addEventListener('mousewheel', this.onMouseWheel_);

      this.onMouseDown_ = this.onMouseDown_.bind(this);
      this.addEventListener('mousedown', this.onMouseDown_);

      this.onMouseMove_ = this.onMouseMove_.bind(this);
      this.addEventListener('mousemove', this.onMouseMove_);

      this.onTouchStart_ = this.onTouchStart_.bind(this);
      this.addEventListener('touchstart', this.onTouchStart_);

      this.onTouchMove_ = this.onTouchMove_.bind(this);
      this.addEventListener('touchmove', this.onTouchMove_);

      this.onTouchEnd_ = this.onTouchEnd_.bind(this);
      this.addEventListener('touchend', this.onTouchEnd_);


      this.addHotKeys_();

      this.mouseViewPosAtMouseDown_ = {x: 0, y: 0};
      this.lastMouseViewPos_ = {x: 0, y: 0};

      this.lastTouchViewPositions_ = [];

      this.alert_ = undefined;

      this.isPanningAndScanning_ = false;
      this.isZooming_ = false;
    },

    initMouseModeSelector: function() {
      this.mouseModeSelector_ = document.createElement(
          'tr-ui-b-mouse-mode-selector');
      this.mouseModeSelector_.targetElement = this;
      this.appendChild(this.mouseModeSelector_);

      this.mouseModeSelector_.addEventListener('beginpan',
          this.onBeginPanScan_.bind(this));
      this.mouseModeSelector_.addEventListener('updatepan',
          this.onUpdatePanScan_.bind(this));
      this.mouseModeSelector_.addEventListener('endpan',
          this.onEndPanScan_.bind(this));

      this.mouseModeSelector_.addEventListener('beginselection',
          this.onBeginSelection_.bind(this));
      this.mouseModeSelector_.addEventListener('updateselection',
          this.onUpdateSelection_.bind(this));
      this.mouseModeSelector_.addEventListener('endselection',
          this.onEndSelection_.bind(this));

      this.mouseModeSelector_.addEventListener('beginzoom',
          this.onBeginZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('updatezoom',
          this.onUpdateZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('endzoom',
          this.onEndZoom_.bind(this));

      this.mouseModeSelector_.addEventListener('entertiming',
          this.timingTool_.onEnterTiming.bind(this.timingTool_));
      this.mouseModeSelector_.addEventListener('begintiming',
          this.timingTool_.onBeginTiming.bind(this.timingTool_));
      this.mouseModeSelector_.addEventListener('updatetiming',
          this.timingTool_.onUpdateTiming.bind(this.timingTool_));
      this.mouseModeSelector_.addEventListener('endtiming',
          this.timingTool_.onEndTiming.bind(this.timingTool_));
      this.mouseModeSelector_.addEventListener('exittiming',
          this.timingTool_.onExitTiming.bind(this.timingTool_));

      var m = tr.ui.b.MOUSE_SELECTOR_MODE;
      this.mouseModeSelector_.supportedModeMask =
          m.SELECTION | m.PANSCAN | m.ZOOM | m.TIMING;
      this.mouseModeSelector_.settingsKey =
          'timelineTrackView.mouseModeSelector';
      this.mouseModeSelector_.setKeyCodeForMode(m.PANSCAN, '2'.charCodeAt(0));
      this.mouseModeSelector_.setKeyCodeForMode(m.SELECTION, '1'.charCodeAt(0));
      this.mouseModeSelector_.setKeyCodeForMode(m.ZOOM, '3'.charCodeAt(0));
      this.mouseModeSelector_.setKeyCodeForMode(m.TIMING, '4'.charCodeAt(0));

      this.mouseModeSelector_.setModifierForAlternateMode(
          m.SELECTION, tr.ui.b.MODIFIER.SHIFT);
      this.mouseModeSelector_.setModifierForAlternateMode(
          m.PANSCAN, tr.ui.b.MODIFIER.SPACE);
      this.mouseModeSelector_.setModifierForAlternateMode(
          m.ZOOM, tr.ui.b.MODIFIER.CMD_OR_CTRL);
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    set brushingStateController(brushingStateController) {
      if (this.brushingStateController_) {
        this.brushingStateController_.removeEventListener('change',
                                                      this.onSelectionChanged_);
      }
      this.brushingStateController_ = brushingStateController;
      if (this.brushingStateController_) {
        this.brushingStateController_.addEventListener('change',
                                                   this.onSelectionChanged_);
      }
    },

    set timelineView(view) {
      this.timelineView_ = view;
    },

    onSelectionChanged_: function() {
      this.showHintText_('Press \'m\' to mark current selection');
      this.viewport_.dispatchChangeEvent();
    },

    set selection(selection) {
      throw new Error('DO NOT CALL THIS');
    },

    set highlight(highlight) {
      throw new Error('DO NOT CALL THIS');
    },

    detach: function() {
      this.modelTrack_.detach();
      this.upperModelTrack_.detach();

      this.viewport_.detach();
    },

    get viewport() {
      return this.viewport_;
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      if (!model)
        throw new Error('Model cannot be undefined');

      var modelInstanceChanged = this.model_ !== model;
      this.model_ = model;
      this.modelTrack_.model = model;
      this.upperModelTrack_.model = model;

            if (modelInstanceChanged)
        this.viewport_.setWhenPossible(this.setInitialViewport_.bind(this));
    },

    get hasVisibleContent() {
      return this.modelTrack_.hasVisibleContent ||
          this.upperModelTrack_.hasVisibleContent;
    },

    setInitialViewport_: function() {
                        this.modelTrackContainer_.updateCanvasSizeIfNeeded_();
      var w = this.modelTrackContainer_.canvas.width;

      var min;
      var range;

      if (this.model_.bounds.isEmpty) {
        min = 0;
        range = 1000;
      } else if (this.model_.bounds.range === 0) {
        min = this.model_.bounds.min;
        range = 1000;
      } else {
        min = this.model_.bounds.min;
        range = this.model_.bounds.range;
      }

      var boost = range * 0.15;
      this.displayTransform_.set(this.viewport_.currentDisplayTransform);
      this.displayTransform_.xSetWorldBounds(
          min - boost, min + range + boost, w);
      this.viewport_.setDisplayTransformImmediately(this.displayTransform_);
    },

    
    addAllEventsMatchingFilterToSelectionAsTask: function(filter, selection) {
      var modelTrack = this.modelTrack_;
      var firstT = modelTrack.addAllEventsMatchingFilterToSelectionAsTask(
          filter, selection);
      var lastT = firstT.after(function() {
        this.upperModelTrack_.addAllEventsMatchingFilterToSelection(
          filter, selection);

      }, this);
      return firstT;
    },

    onMouseMove_: function(e) {
                  if (this.isZooming_)
        return;

      this.storeLastMousePos_(e);
    },

    onTouchStart_: function(e) {
      this.storeLastTouchPositions_(e);
      this.focusElements_();
    },

    onTouchMove_: function(e) {
      e.preventDefault();
      this.onUpdateTransformForTouch_(e);
    },

    onTouchEnd_: function(e) {
      this.storeLastTouchPositions_(e);
      this.focusElements_();
    },

    addHotKeys_: function() {
      this.addKeyDownHotKeys_();
      this.addKeyPressHotKeys_();
    },

    addKeyPressHotKeys_: function() {
      var addBinding = function(dict) {
        dict.eventType = 'keypress';
        dict.useCapture = false;
        dict.thisArg = this;
        var binding = new tr.ui.b.HotKey(dict);
        this.$.hotkey_controller.addHotKey(binding);
      }.bind(this);

      addBinding({
        keyCodes: ['w'.charCodeAt(0), ','.charCodeAt(0)],
        callback: function(e) {
          this.zoomBy_(1.5, true);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCodes: ['s'.charCodeAt(0), 'o'.charCodeAt(0)],
        callback: function(e) {
          this.zoomBy_(1 / 1.5, true);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 'g'.charCodeAt(0),
        callback: function(e) {
          this.onGridToggle_(true);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 'G'.charCodeAt(0),
        callback: function(e) {
          this.onGridToggle_(false);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCodes: ['W'.charCodeAt(0), '<'.charCodeAt(0)],
        callback: function(e) {
          this.zoomBy_(10, true);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCodes: ['S'.charCodeAt(0), 'O'.charCodeAt(0)],
        callback: function(e) {
          this.zoomBy_(1 / 10, true);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 'a'.charCodeAt(0),
        callback: function(e) {
          this.queueSmoothPan_(this.viewWidth_ * 0.3, 0);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCodes: ['d'.charCodeAt(0), 'e'.charCodeAt(0)],
        callback: function(e) {
          this.queueSmoothPan_(this.viewWidth_ * -0.3, 0);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 'A'.charCodeAt(0),
        callback: function(e) {
          this.queueSmoothPan_(viewWidth * 0.5, 0);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 'D'.charCodeAt(0),
        callback: function(e) {
          this.queueSmoothPan_(viewWidth * -0.5, 0);
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: '0'.charCodeAt(0),
        callback: function(e) {
          this.setInitialViewport_();
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 'f'.charCodeAt(0),
        callback: function(e) {
          this.zoomToSelection();
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 'm'.charCodeAt(0),
        callback: function(e) {
          this.setCurrentSelectionAsInterestRange_();
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 'h'.charCodeAt(0),
        callback: function(e) {
          this.toggleHighDetails_();
          e.stopPropagation();
        }
      });
    },

    get viewWidth_() {
      return this.modelTrackContainer_.canvas.clientWidth;
    },

    addKeyDownHotKeys_: function() {
      var addBinding = function(dict) {
        dict.eventType = 'keydown';
        dict.useCapture = false;
        dict.thisArg = this;
        var binding = new tr.ui.b.HotKey(dict);
        this.$.hotkey_controller.addHotKey(binding);
      }.bind(this);

      addBinding({
        keyCode: 37,         callback: function(e) {
          var curSel = this.brushingStateController_.selection;
          var sel = this.viewport.getShiftedSelection(curSel, -1);

          if (sel) {
            this.brushingStateController.changeSelectionFromTimeline(sel);
            this.panToSelection();
          } else {
            this.queueSmoothPan_(this.viewWidth_ * 0.3, 0);
          }
          e.preventDefault();
          e.stopPropagation();
        }
      });

      addBinding({
        keyCode: 39,         callback: function(e) {
          var curSel = this.brushingStateController_.selection;
          var sel = this.viewport.getShiftedSelection(curSel, 1);
          if (sel) {
            this.brushingStateController.changeSelectionFromTimeline(sel);
            this.panToSelection();
          } else {
            this.queueSmoothPan_(-this.viewWidth_ * 0.3, 0);
          }
          e.preventDefault();
          e.stopPropagation();
        }
      });
    },

    onDblClick_: function(e) {
      if (this.mouseModeSelector_.mode !==
          tr.ui.b.MOUSE_SELECTOR_MODE.SELECTION)
        return;

      var curSelection = this.brushingStateController_.selection;
      if (!curSelection.length || !curSelection[0].title)
        return;

      var selection = new tr.model.EventSet();
      var filter = new tr.c.ExactTitleFilter(curSelection[0].title);
      this.modelTrack_.addAllEventsMatchingFilterToSelection(filter,
                                                              selection);

      this.brushingStateController.changeSelectionFromTimeline(selection);
    },

    onMouseWheel_: function(e) {
      if (!e.altKey)
        return;

      var delta = e.wheelDelta / 120;
      var zoomScale = Math.pow(1.5, delta);
      this.zoomBy_(zoomScale);
      e.preventDefault();
    },

    onMouseDown_: function(e) {
      if (this.mouseModeSelector_.mode !==
          tr.ui.b.MOUSE_SELECTOR_MODE.SELECTION)
        return;

            if (e.target !== this.rulerTrack_)
        return;

            this.dragBeginEvent_ = undefined;

                  if (this.xNavStringMarker_) {
        this.model.removeAnnotation(this.xNavStringMarker_);
        this.xNavStringMarker_ = undefined;
      }

      var dt = this.viewport_.currentDisplayTransform;
      tr.ui.b.trackMouseMovesUntilMouseUp(function(e) {                 if (e.target === this.rulerTrack_)
          return;

        var relativePosition = this.extractRelativeMousePosition_(e);
        var loc = tr.model.Location.fromViewCoordinates(
            this.viewport_, relativePosition.x, relativePosition.y);
                        if (!loc)
          return;

        if (this.guideLineAnnotation_ === undefined) {
          this.guideLineAnnotation_ =
              new tr.model.XMarkerAnnotation(loc.xWorld);
          this.model.addAnnotation(this.guideLineAnnotation_);
        } else {
          this.guideLineAnnotation_.timestamp = loc.xWorld;
          this.modelTrackContainer_.invalidate();
        }

                var state = new tr.ui.b.UIState(loc,
            this.viewport_.currentDisplayTransform.scaleX);
        this.timelineView_.setFindCtlText(
            state.toUserFriendlyString(this.viewport_));
      }.bind(this),
      undefined,       function onKeyUpDuringDrag() {
        if (this.dragBeginEvent_) {
          this.setDragBoxPosition_(this.dragBoxXStart_, this.dragBoxYStart_,
              this.dragBoxXEnd_, this.dragBoxYEnd_);
        }
      }.bind(this));
    },

    queueSmoothPan_: function(viewDeltaX, deltaY) {
      var deltaX = this.viewport_.currentDisplayTransform.xViewVectorToWorld(
          viewDeltaX);
      var animation = new tr.ui.TimelineDisplayTransformPanAnimation(
          deltaX, deltaY);
      this.viewport_.queueDisplayTransformAnimation(animation);
    },

    
    zoomBy_: function(scale, smooth) {
      if (scale <= 0) {
        return;
      }

      smooth = !!smooth;
      var vp = this.viewport_;
      var pixelRatio = window.devicePixelRatio || 1;

      var goalFocalPointXView = this.lastMouseViewPos_.x * pixelRatio;
      var goalFocalPointXWorld = vp.currentDisplayTransform.xViewToWorld(
          goalFocalPointXView);
      if (smooth) {
        var animation = new tr.ui.TimelineDisplayTransformZoomToAnimation(
            goalFocalPointXWorld, goalFocalPointXView,
            vp.currentDisplayTransform.panY,
            scale);
        vp.queueDisplayTransformAnimation(animation);
      } else {
        this.displayTransform_.set(vp.currentDisplayTransform);
        this.displayTransform_.scaleX *= scale;
        this.displayTransform_.xPanWorldPosToViewPos(
            goalFocalPointXWorld, goalFocalPointXView, this.viewWidth_);
        vp.setDisplayTransformImmediately(this.displayTransform_);
      }
    },

    
    zoomToSelection: function() {
      if (!this.brushingStateController.selectionOfInterest.length)
        return;

      var bounds = this.brushingStateController.selectionOfInterest.bounds;
      if (!bounds.range)
        return;

      var worldCenter = bounds.center;
      var viewCenter = this.modelTrackContainer_.canvas.width / 2;
      var adjustedWorldRange = bounds.range * 1.25;
      var newScale = this.modelTrackContainer_.canvas.width /
          adjustedWorldRange;
      var zoomInRatio = newScale /
          this.viewport_.currentDisplayTransform.scaleX;

      var animation = new tr.ui.TimelineDisplayTransformZoomToAnimation(
          worldCenter, viewCenter,
          this.viewport_.currentDisplayTransform.panY,
          zoomInRatio);
      this.viewport_.queueDisplayTransformAnimation(animation);
    },

    
    panToSelection: function() {
      if (!this.brushingStateController.selectionOfInterest.length)
        return;

      var bounds = this.brushingStateController.selectionOfInterest.bounds;
      var worldCenter = bounds.center;
      var viewWidth = this.viewWidth_;

      var dt = this.viewport_.currentDisplayTransform;
      if (false && !bounds.range) {
        if (dt.xWorldToView(bounds.center) < 0 ||
            dt.xWorldToView(bounds.center) > viewWidth) {
          this.displayTransform_.set(dt);
          this.displayTransform_.xPanWorldPosToViewPos(
              worldCenter, 'center', viewWidth);
          var deltaX = this.displayTransform_.panX - dt.panX;
          var animation = new tr.ui.TimelineDisplayTransformPanAnimation(
              deltaX, 0);
          this.viewport_.queueDisplayTransformAnimation(animation);
        }
        return;
      }

      this.displayTransform_.set(dt);
      this.displayTransform_.xPanWorldBoundsIntoView(
          bounds.min,
          bounds.max,
          viewWidth);
      var deltaX = this.displayTransform_.panX - dt.panX;
      var animation = new tr.ui.TimelineDisplayTransformPanAnimation(
          deltaX, 0);
      this.viewport_.queueDisplayTransformAnimation(animation);
    },

    navToPosition: function(uiState, showNavLine) {
      var location = uiState.location;
      var scaleX = uiState.scaleX;
      var track = location.getContainingTrack(this.viewport_);

      var worldCenter = location.xWorld;
      var viewCenter = this.modelTrackContainer_.canvas.width / 5;
      var zoomInRatio = scaleX /
          this.viewport_.currentDisplayTransform.scaleX;

            track.scrollIntoViewIfNeeded();

            var animation = new tr.ui.TimelineDisplayTransformZoomToAnimation(
          worldCenter, viewCenter,
          this.viewport_.currentDisplayTransform.panY,
          zoomInRatio);
      this.viewport_.queueDisplayTransformAnimation(animation);

      if (!showNavLine)
        return;
            if (this.xNavStringMarker_)
        this.model.removeAnnotation(this.xNavStringMarker_);
      this.xNavStringMarker_ =
          new tr.model.XMarkerAnnotation(worldCenter);
      this.model.addAnnotation(this.xNavStringMarker_);
    },

    setCurrentSelectionAsInterestRange_: function() {
      var selectionBounds = this.brushingStateController_.selection.bounds;
      if (selectionBounds.empty) {
        this.viewport_.interestRange.reset();
        return;
      }

      if (this.viewport_.interestRange.min == selectionBounds.min &&
          this.viewport_.interestRange.max == selectionBounds.max)
        this.viewport_.interestRange.reset();
      else
        this.viewport_.interestRange.set(selectionBounds);
    },

    toggleHighDetails_: function() {
      this.viewport_.highDetails = !this.viewport_.highDetails;
    },

    hideDragBox_: function() {
      this.$.drag_box.style.left = '-1000px';
      this.$.drag_box.style.top = '-1000px';
      this.$.drag_box.style.width = 0;
      this.$.drag_box.style.height = 0;
    },

    setDragBoxPosition_: function(xStart, yStart, xEnd, yEnd) {
      var loY = Math.min(yStart, yEnd);
      var hiY = Math.max(yStart, yEnd);
      var loX = Math.min(xStart, xEnd);
      var hiX = Math.max(xStart, xEnd);
      var modelTrackRect = this.modelTrack_.getBoundingClientRect();
      var dragRect = {left: loX, top: loY, width: hiX - loX, height: hiY - loY};

      dragRect.right = dragRect.left + dragRect.width;
      dragRect.bottom = dragRect.top + dragRect.height;

      var modelTrackContainerRect =
          this.modelTrackContainer_.getBoundingClientRect();
      var clipRect = {
        left: modelTrackContainerRect.left,
        top: modelTrackContainerRect.top,
        right: modelTrackContainerRect.right,
        bottom: modelTrackContainerRect.bottom
      };

      var headingWidth = window.getComputedStyle(
          this.querySelector('tr-ui-heading')).width;
      var trackTitleWidth = parseInt(headingWidth);
      clipRect.left = clipRect.left + trackTitleWidth;

      var intersectRect_ = function(r1, r2) {
        if (r2.left > r1.right || r2.right < r1.left ||
            r2.top > r1.bottom || r2.bottom < r1.top)
          return false;

        var results = {};
        results.left = Math.max(r1.left, r2.left);
        results.top = Math.max(r1.top, r2.top);
        results.right = Math.min(r1.right, r2.right);
        results.bottom = Math.min(r1.bottom, r2.bottom);
        results.width = results.right - results.left;
        results.height = results.bottom - results.top;
        return results;
      }

                        var finalDragBox = intersectRect_(clipRect, dragRect);

      this.$.drag_box.style.left = finalDragBox.left + 'px';
      this.$.drag_box.style.width = finalDragBox.width + 'px';
      this.$.drag_box.style.top = finalDragBox.top + 'px';
      this.$.drag_box.style.height = finalDragBox.height + 'px';
      this.$.drag_box.style.whiteSpace = 'nowrap';

      var pixelRatio = window.devicePixelRatio || 1;
      var canv = this.modelTrackContainer_.canvas;
      var dt = this.viewport_.currentDisplayTransform;
      var loWX = dt.xViewToWorld(
          (loX - canv.offsetLeft) * pixelRatio);
      var hiWX = dt.xViewToWorld(
          (hiX - canv.offsetLeft) * pixelRatio);

      this.$.drag_box.textContent = tr.b.u.TimeDuration.format(hiWX - loWX);

      var e = new tr.b.Event('selectionChanging');
      e.loWX = loWX;
      e.hiWX = hiWX;
      this.dispatchEvent(e);
    },

    onGridToggle_: function(left) {
      var selection = this.brushingStateController_.selection;
      var tb = left ? selection.bounds.min : selection.bounds.max;

                  if (this.viewport_.gridEnabled &&
          this.viewport_.gridSide === left &&
          this.viewport_.gridInitialTimebase === tb) {
        this.viewport_.gridside = undefined;
        this.viewport_.gridEnabled = false;
        this.viewport_.gridInitialTimebase = undefined;
        return;
      }

            var numIntervalsSinceStart = Math.ceil((tb - this.model_.bounds.min) /
          this.viewport_.gridStep_);

      this.viewport_.gridEnabled = true;
      this.viewport_.gridSide = left;
      this.viewport_.gridInitialTimebase = tb;
      this.viewport_.gridTimebase = tb -
          (numIntervalsSinceStart + 1) * this.viewport_.gridStep_;
    },

    storeLastMousePos_: function(e) {
      this.lastMouseViewPos_ = this.extractRelativeMousePosition_(e);
    },

    storeLastTouchPositions_: function(e) {
      this.lastTouchViewPositions_ = this.extractRelativeTouchPositions_(e);
    },

    extractRelativeMousePosition_: function(e) {
      var canv = this.modelTrackContainer_.canvas;
      return {
        x: e.clientX - canv.offsetLeft,
        y: e.clientY - canv.offsetTop
      };
    },

    extractRelativeTouchPositions_: function(e) {
      var canv = this.modelTrackContainer_.canvas;

      var touches = [];
      for (var i = 0; i < e.touches.length; ++i) {
        touches.push({
          x: e.touches[i].clientX - canv.offsetLeft,
          y: e.touches[i].clientY - canv.offsetTop
        });
      }
      return touches;
    },

    storeInitialMouseDownPos_: function(e) {

      var position = this.extractRelativeMousePosition_(e);

      this.mouseViewPosAtMouseDown_.x = position.x;
      this.mouseViewPosAtMouseDown_.y = position.y;
    },

    focusElements_: function() {
      this.$.hotkey_controller.childRequestsGeneralFocus(this);
    },

    storeInitialInteractionPositionsAndFocus_: function(e) {

      this.storeInitialMouseDownPos_(e);
      this.storeLastMousePos_(e);

      this.focusElements_();
    },

    onBeginPanScan_: function(e) {
      var vp = this.viewport_;
      this.viewportDisplayTransformAtMouseDown_ =
          vp.currentDisplayTransform.clone();
      this.isPanningAndScanning_ = true;

      this.storeInitialInteractionPositionsAndFocus_(e);
      e.preventDefault();
    },

    onUpdatePanScan_: function(e) {
      if (!this.isPanningAndScanning_)
        return;

      var viewWidth = this.viewWidth_;

      var pixelRatio = window.devicePixelRatio || 1;
      var xDeltaView = pixelRatio * (this.lastMouseViewPos_.x -
          this.mouseViewPosAtMouseDown_.x);

      var yDelta = this.lastMouseViewPos_.y -
          this.mouseViewPosAtMouseDown_.y;

      this.displayTransform_.set(this.viewportDisplayTransformAtMouseDown_);
      this.displayTransform_.incrementPanXInViewUnits(xDeltaView);
      this.displayTransform_.panY -= yDelta;
      this.viewport_.setDisplayTransformImmediately(this.displayTransform_);

      e.preventDefault();
      e.stopPropagation();

      this.storeLastMousePos_(e);
    },

    onEndPanScan_: function(e) {
      this.isPanningAndScanning_ = false;

      this.storeLastMousePos_(e);

      if (!e.isClick)
        e.preventDefault();
    },

    onBeginSelection_: function(e) {
      var canv = this.modelTrackContainer_.canvas;
      var rect = this.modelTrack_.getBoundingClientRect();
      var canvRect = canv.getBoundingClientRect();

      var inside = rect &&
          e.clientX >= rect.left &&
          e.clientX < rect.right &&
          e.clientY >= rect.top &&
          e.clientY < rect.bottom &&
          e.clientX >= canvRect.left &&
          e.clientX < canvRect.right;

      if (!inside)
        return;

      this.dragBeginEvent_ = e;

      this.storeInitialInteractionPositionsAndFocus_(e);
      e.preventDefault();
    },

    onUpdateSelection_: function(e) {
      if (!this.dragBeginEvent_)
        return;

            this.dragBoxXStart_ = this.dragBeginEvent_.clientX;
      this.dragBoxXEnd_ = e.clientX;
      this.dragBoxYStart_ = this.dragBeginEvent_.clientY;
      this.dragBoxYEnd_ = e.clientY;
      this.setDragBoxPosition_(this.dragBoxXStart_, this.dragBoxYStart_,
          this.dragBoxXEnd_, this.dragBoxYEnd_);

    },

    onEndSelection_: function(e) {
      e.preventDefault();

      if (!this.dragBeginEvent_)
        return;

            this.hideDragBox_();
      var eDown = this.dragBeginEvent_;
      this.dragBeginEvent_ = undefined;

            var loY = Math.min(eDown.clientY, e.clientY);
      var hiY = Math.max(eDown.clientY, e.clientY);
      var loX = Math.min(eDown.clientX, e.clientX);
      var hiX = Math.max(eDown.clientX, e.clientX);

            var canv = this.modelTrackContainer_.canvas;
      var worldOffset = canv.getBoundingClientRect().left;
      var loVX = loX - worldOffset;
      var hiVX = hiX - worldOffset;

            var selection = new tr.model.EventSet();
      this.modelTrack_.addIntersectingEventsInRangeToSelection(
          loVX, hiVX, loY, hiY, selection);

            this.brushingStateController_.changeSelectionFromTimeline(selection);
    },

    onBeginZoom_: function(e) {
      this.isZooming_ = true;

      this.storeInitialInteractionPositionsAndFocus_(e);
      e.preventDefault();
    },

    onUpdateZoom_: function(e) {
      if (!this.isZooming_)
        return;
      var newPosition = this.extractRelativeMousePosition_(e);

      var zoomScaleValue = 1 + (this.lastMouseViewPos_.y -
          newPosition.y) * 0.01;

      this.zoomBy_(zoomScaleValue, false);
      this.storeLastMousePos_(e);
    },

    onEndZoom_: function(e) {
      this.isZooming_ = false;

      if (!e.isClick)
        e.preventDefault();
    },

    computeTouchCenter_: function(positions) {
      var xSum = 0;
      var ySum = 0;
      for (var i = 0; i < positions.length; ++i) {
        xSum += positions[i].x;
        ySum += positions[i].y;
      }
      return {
        x: xSum / positions.length,
        y: ySum / positions.length
      };
    },

    computeTouchSpan_: function(positions) {
      var xMin = Number.MAX_VALUE;
      var yMin = Number.MAX_VALUE;
      var xMax = Number.MIN_VALUE;
      var yMax = Number.MIN_VALUE;
      for (var i = 0; i < positions.length; ++i) {
        xMin = Math.min(xMin, positions[i].x);
        yMin = Math.min(yMin, positions[i].y);
        xMax = Math.max(xMax, positions[i].x);
        yMax = Math.max(yMax, positions[i].y);
      }
      return Math.sqrt((xMin - xMax) * (xMin - xMax) +
          (yMin - yMax) * (yMin - yMax));
    },

    onUpdateTransformForTouch_: function(e) {
      var newPositions = this.extractRelativeTouchPositions_(e);
      var currentPositions = this.lastTouchViewPositions_;

      var newCenter = this.computeTouchCenter_(newPositions);
      var currentCenter = this.computeTouchCenter_(currentPositions);

      var newSpan = this.computeTouchSpan_(newPositions);
      var currentSpan = this.computeTouchSpan_(currentPositions);

      var vp = this.viewport_;
      var viewWidth = this.viewWidth_;
      var pixelRatio = window.devicePixelRatio || 1;

      var xDelta = pixelRatio * (newCenter.x - currentCenter.x);
      var yDelta = newCenter.y - currentCenter.y;
      var zoomScaleValue = currentSpan > 10 ? newSpan / currentSpan : 1;

      var viewFocus = pixelRatio * newCenter.x;
      var worldFocus = vp.currentDisplayTransform.xViewToWorld(viewFocus);

      this.displayTransform_.set(vp.currentDisplayTransform);
      this.displayTransform_.scaleX *= zoomScaleValue;
      this.displayTransform_.xPanWorldPosToViewPos(
          worldFocus, viewFocus, viewWidth);
      this.displayTransform_.incrementPanXInViewUnits(xDelta);
      this.displayTransform_.panY -= yDelta;
      vp.setDisplayTransformImmediately(this.displayTransform_);
      this.storeLastTouchPositions_(e);
    },

    initHintText_: function() {
      this.$.hint_text.style.display = 'none';

      this.pendingHintTextClearTimeout_ = undefined;
    },

    showHintText_: function(text) {
      if (this.pendingHintTextClearTimeout_) {
        window.clearTimeout(this.pendingHintTextClearTimeout_);
        this.pendingHintTextClearTimeout_ = undefined;
      }
      this.pendingHintTextClearTimeout_ = setTimeout(
          this.hideHintText_.bind(this), 1000);
      this.$.hint_text.textContent = text;
      this.$.hint_text.style.display = '';
    },

    hideHintText_: function() {
      this.pendingHintTextClearTimeout_ = undefined;
      this.$.hint_text.style.display = 'none';
    }
  });
  

  'use strict';

  Polymer('tr-ui-find-control', {
    filterKeyDown: function(e) {
      if (e.keyCode === 27) {
        var hkc = tr.b.getHotkeyControllerForElement(this);
        if (hkc) {
          hkc.childRequestsBlur(this);
        } else {
          this.blur();
        }
        e.preventDefault();
        e.stopPropagation();
        return;
      } else if (e.keyCode === 13) {
        if (e.shiftKey)
          this.findPrevious();
        else
          this.findNext();
      }
    },

    filterBlur: function(e) {
      this.updateHitCountEl();
    },

    filterFocus: function(e) {
      this.$.filter.select();
    },

            filterMouseUp: function(e) {
      e.preventDefault();
    },

    get controller() {
      return this.controller_;
    },

    set controller(c) {
      this.controller_ = c;
      this.updateHitCountEl();
    },

    focus: function() {
      this.$.filter.focus();
    },

    get hasFocus() {
      return this === document.activeElement;
    },

    filterTextChanged: function() {
      this.$.hitCount.textContent = '';
      this.$.spinner.style.visibility = 'visible';
      this.controller.startFiltering(this.$.filter.value).then(function() {
        this.$.spinner.style.visibility = 'hidden';
        this.updateHitCountEl();
      }.bind(this));
    },

    findNext: function() {
      if (this.controller)
        this.controller.findNext();
      this.updateHitCountEl();
    },

    findPrevious: function() {
      if (this.controller)
        this.controller.findPrevious();
      this.updateHitCountEl();
    },

    updateHitCountEl: function() {
      if (!this.controller || !this.hasFocus) {
        this.$.hitCount.textContent = '';
        return;
      }

      var n = this.controller.filterHits.length;
      var i = n === 0 ? -1 : this.controller.currentHitIndex;
      this.$.hitCount.textContent = (i + 1) + ' of ' + n;
    },

    setText: function(string) {
      this.$.filter.value = string;
    }
  });
  

'use strict';

tr.exportTo('tr.e.tquery', function() {
  function Context() {
    this.event = undefined;
    this.ancestors = [];
  }

  Context.prototype = {
    push: function(event) {
      var ctx = new Context();
      ctx.ancestors = this.ancestors.slice();
      ctx.ancestors.push(event);
      return ctx;
    },

    pop: function(event) {
      var ctx = new Context();
      ctx.event = this.ancestors[this.ancestors.length - 1];
      ctx.ancestors = this.ancestors.slice(0, this.ancestors.length - 1);
      return ctx;
    }
  };

  return {
    Context: Context
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function Filter() {
    tr.c.ScriptingObject.call(this);
  }

  Filter.normalizeFilterExpression = function(filterExpression) {
    // Shortcut: naked strings and regexps can be used to match against slice
    // titles.
    if (filterExpression instanceof String ||
        typeof(filterExpression) == 'string' ||
        filterExpression instanceof RegExp) {
      var filter = new tr.e.tquery.FilterHasTitle(filterExpression);
      return filter;
    }
    return filterExpression;
  };

  Filter.prototype = {
    __proto__: tr.c.ScriptingObject.prototype,

    evaluate: function(context) {
      throw new Error('Not implemented');
    },

    matchValue_: function(value, expected) {
      if (expected instanceof RegExp)
        return expected.test(value);
      else if (expected instanceof Function)
        return expected(value);
      return value === expected;
    }
  };

  return {
    Filter: Filter
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterAllOf(opt_subExpressions) {
    tr.e.tquery.Filter.call(this);
    this.subExpressions = opt_subExpressions || [];
  }

  FilterAllOf.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpressions(exprs) {
      this.subExpressions_ = [];
      for (var i = 0; i < exprs.length; i++) {
        this.subExpressions_.push(
            tr.e.tquery.Filter.normalizeFilterExpression(exprs[i]));
      }
    },

    get subExpressions() {
      return this.subExpressions_;
    },

    evaluate: function(context) {
      if (!this.subExpressions.length)
        return true;
      for (var i = 0; i < this.subExpressions.length; i++) {
        if (!this.subExpressions[i].evaluate(context))
          return false;
      }
      return true;
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function() {
        var exprs = [];
        for (var i = 0; i < arguments.length; i++) {
          exprs.push(arguments[i]);
        }
        return new FilterAllOf(exprs);
      },
      {
        name: 'allOf'
      }
  );
  return {
    FilterAllOf: FilterAllOf
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterAnyOf(opt_subExpressions) {
    tr.e.tquery.Filter.call(this);
    this.subExpressions = opt_subExpressions || [];
  };

  FilterAnyOf.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpressions(exprs) {
      this.subExpressions_ = [];
      for (var i = 0; i < exprs.length; i++) {
        this.subExpressions_.push(
            tr.e.tquery.Filter.normalizeFilterExpression(exprs[i]));
      }
    },

    get subExpressions() {
      return this.subExpressions_;
    },

    evaluate: function(context) {
      if (!this.subExpressions.length)
        return true;
      for (var i = 0; i < this.subExpressions.length; i++) {
        if (this.subExpressions[i].evaluate(context))
          return true;
      }
      return false;
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function() {
        var exprs = [];
        for (var i = 0; i < arguments.length; i++) {
          exprs.push(arguments[i]);
        }
        return new FilterAnyOf(exprs);
      },
      {
        name: 'anyOf'
      }
  );
  return {
    FilterAnyOf: FilterAnyOf
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterHasAncestor(opt_subExpression) {
    this.subExpression = opt_subExpression;
  };

  FilterHasAncestor.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpression(expr) {
      this.subExpression_ = tr.e.tquery.Filter.normalizeFilterExpression(expr);
    },

    get subExpression() {
      return this.subExpression_;
    },

    evaluate: function(context) {
      if (!this.subExpression)
        return context.ancestors.length > 0;
      while (context.ancestors.length) {
        context = context.pop();
        if (this.subExpression.evaluate(context))
          return true;
      }
      return false;
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function(subExpression) {
        return new FilterHasAncestor(subExpression);
      },
      {
        name: 'hasAncestor'
      }
  );
  return {
    FilterHasAncestor: FilterHasAncestor
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterHasDuration(minValueOrExpected, opt_maxValue) {
    if (minValueOrExpected !== undefined && opt_maxValue !== undefined) {
      this.minValue = minValueOrExpected;
      this.maxValue = opt_maxValue;
    } else {
      this.expected = minValueOrExpected;
    }
  };

  FilterHasDuration.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    evaluate: function(context) {
      if (context.event.duration === undefined)
        return false;
      if (this.minValue !== undefined && this.maxValue !== undefined) {
        return context.event.duration >= this.minValue &&
               context.event.duration <= this.maxValue;
      }
      return this.matchValue_(context.event.duration, this.expected);
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function(minValueOrExpected, opt_maxValue) {
        return new FilterHasDuration(minValueOrExpected, opt_maxValue);
      },
      {
        name: 'hasDuration'
      }
  );
  return {
    FilterHasDuration: FilterHasDuration
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterHasTitle(expected) {
    tr.e.tquery.Filter.call(this);
    this.expected = expected;
  }

  FilterHasTitle.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    evaluate: function(context) {
      return this.matchValue_(context.event.title, this.expected);
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function(expected) {
        var filter = new tr.e.tquery.FilterHasTitle(expected);
        return filter;
      },
      {
        name: 'hasTitle'
      }
  );

  return {
    FilterHasTitle: FilterHasTitle
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterIsTopLevel(opt_subExpression) {
    this.subExpression = opt_subExpression;
  }

  FilterIsTopLevel.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpression(expr) {
      this.subExpression_ = tr.e.tquery.Filter.normalizeFilterExpression(expr);
    },

    get subExpression() {
      return this.subExpression_;
    },

    evaluate: function(context) {
      if (context.ancestors.length > 0)
        return false;
      if (!this.subExpression)
        return true;
      return this.subExpression.evaluate(context);
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function(subExpression) {
        return new FilterIsTopLevel(subExpression);
      },
      {
        name: 'isTopLevel'
      }
  );
  return {
    FilterIsTopLevel: FilterIsTopLevel
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function TQuery(brushingStateController) {
    tr.c.ScriptingObject.call(this);

    this.brushingStateController_ = brushingStateController;
    this.parent_ = undefined;
    this.filterExpression_ = undefined;
    // Memoized filtering result.
    this.selection_ = undefined;
  };

  TQuery.prototype = {
    __proto__: tr.c.ScriptingObject.prototype,

    onModelChanged: function() {
      this.selection_ = undefined;
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    // Append a new filter expression to this query and return a query node
    // that represents the result.
    filter: function(filterExpression) {
      var result = new TQuery(this.brushingStateController_);
      result.parent_ = this;
      result.filterExpression_ =
          tr.e.tquery.Filter.normalizeFilterExpression(filterExpression);
      return result;
    },

    // Creates a graph of {Task} objects which will compute the selections for
    // this filter object and all of its parents. The return value is an object
    // with the following fields:
    //  - rootTask: {Task} which should be executed to kick off processing for
    //              the entire task graph.
    //  - lastTask: The final {Task} of the graph. Can be used by the caller to
    //              enqueue additional processing at the end.
    //  - lastNode: The last filter object in the task. It's selection property
    //              will contain the filtering result once |finalTask|
    //              completes.
    createFilterTaskGraph_: function() {
      // List of nodes in order from the current one to the root.
      var nodes = [];
      var node = this;
      while (node !== undefined) {
        nodes.push(node);
        node = node.parent_;
      }

      var rootTask = new tr.b.Task();
      var lastTask = rootTask;
      for (var i = nodes.length - 1; i >= 0; i--) {
        var node = nodes[i];
        // Reuse any memoized result.
        if (node.selection_ !== undefined)
          continue;
        node.selection_ = new tr.model.EventSet();
        if (node.parent_ === undefined) {
          // If this is the root, start by collecting all objects from the
          // brushing state controller.
          lastTask = lastTask.after(
              this.selectEverythingAsTask_(node.selection_));
        } else {
          // Otherwise execute the filter expression for this node and fill
          // in its selection.
          var prevNode = nodes[i + 1];
          lastTask = this.createFilterTaskForNode_(lastTask, node, prevNode);
        }
      }
      return {rootTask: rootTask, lastTask: lastTask, lastNode: node};
    },

    createFilterTaskForNode_: function(lastTask, node, prevNode) {
      return lastTask.after(function() {
        // TODO(skyostil): Break into subtasks.
        node.evaluateFilterExpression_(
            prevNode.selection_, node.selection_);
      }, this);
    },

    // Applies the result of a filter expression for a given event and all
    // of its subslices and adds the matching events to an output selection.
    evaluateFilterExpression_: function(inputSelection, outputSelection) {
      var seenEvents = {};
      inputSelection.forEach(function(event) {
        var context = new tr.e.tquery.Context();
        context.event = event;
        this.evaluateFilterExpressionForEvent_(
            context, inputSelection, outputSelection, seenEvents);
      }.bind(this));
    },

    evaluateFilterExpressionForEvent_: function(
        context, inputSelection, outputSelection, seenEvents) {
      var event = context.event;
      if (inputSelection.contains(event) && !seenEvents[event.guid]) {
        seenEvents[event.guid] = true;
        if (!this.filterExpression_ ||
            this.filterExpression_.evaluate(context))
          outputSelection.push(event);
      }
      if (!event.subSlices)
        return;
      context = context.push(event);
      for (var i = 0; i < event.subSlices.length; i++) {
        context.event = event.subSlices[i];
        this.evaluateFilterExpressionForEvent_(
            context, inputSelection, outputSelection, seenEvents);
      }
    },

    // Show the result as a highlight on the brushing state controller. Returns
    // a {Task} which runs the query and sets the highlight.
    show: function() {
      var graph = this.createFilterTaskGraph_();

      graph.lastTask = graph.lastTask.after(function() {
        this.brushingStateController.showScriptControlSelection(
            graph.lastNode.selection_);
      }, this);
      return graph.rootTask;
    },

    // Returns a task that fills the given selection with everything reachable
    // by the brushing state controller.
    selectEverythingAsTask_: function(selection) {
      var passThroughFilter = new tr.c.Filter();
      var filterTask = this.brushingStateController.
          addAllEventsMatchingFilterToSelectionAsTask(passThroughFilter,
              selection);
      return filterTask;
    },

    get selection() {
      if (this.selection_ === undefined) {
        var graph = this.createFilterTaskGraph_();
        tr.b.Task.RunSynchronously(graph.rootTask);
      }
      return this.selection_;
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      new TQuery(),
      {
        name: '$t'
      }
  );

  return {
    TQuery: TQuery
  };
});


  'use strict';

  Polymer('tr-ui-scripting-control', {
    _isEnterKey: function(event) {
            return event.keyCode !== 229 && event.keyIdentifier === 'Enter';
    },

    _setFocused: function(focused) {
      var promptEl = this.$.prompt;
      if (focused) {
        promptEl.focus();
        this.$.root.classList.add('focused');
                if (promptEl.innerText.length > 0) {
          var sel = window.getSelection();
          sel.collapse(promptEl.firstChild, promptEl.innerText.length);
        }
      } else {
        promptEl.blur();
        this.$.root.classList.remove('focused');
                        var parent = promptEl.parentElement;
        var nextEl = promptEl.nextSibling;
        promptEl.remove();
        parent.insertBefore(promptEl, nextEl);
      }
    },

    onConsoleFocus: function(e) {
      e.stopPropagation();
      this._setFocused(true);
    },

    onConsoleBlur: function(e) {
      e.stopPropagation();
      this._setFocused(false);
    },

    promptKeyDown: function(e) {
      e.stopPropagation();
      if (!this._isEnterKey(e))
        return;
      var promptEl = this.$.prompt;
      var command = promptEl.innerText;
      if (command.length === 0)
        return;
      promptEl.innerText = '';
      this.addLine_(String.fromCharCode(187) + ' ' + command);

      try {
        var result = this.controller_.executeCommand(command);
      } catch (e) {
        result = e.stack || e.stackTrace;
      }

      if (result instanceof tr.b.Task) {
                tr.b.Task.RunWhenIdle(result);
      } else {
        this.addLine_(result);
      }
    },

    addLine_: function(line) {
      var historyEl = this.$.history;
      if (historyEl.innerText.length !== 0)
        historyEl.innerText += '\n';
      historyEl.innerText += line;
    },

    promptKeyPress: function(e) {
      e.stopPropagation();
    },

    toggleVisibility: function() {
      var root = this.$.root;
      if (!this.visible) {
        root.classList.remove('hidden');
        this._setFocused(true);
      } else {
        root.classList.add('hidden');
        this._setFocused(false);
      }
    },

    get hasFocus() {
      return this === document.activeElement;
    },

    get visible() {
      var root = this.$.root;
      return !root.classList.contains('hidden');
    },

    get controller() {
      return this.controller_;
    },

    set controller(c) {
      this.controller_ = c;
    }
  });
  

  'use strict';
  Polymer('tr-ui-side-panel', {
    ready: function() {
    },

    get rangeOfInterest() {
      throw new Error('Not implemented');
    },

    set rangeOfInterest(rangeOfInterest) {
      throw new Error('Not implemented');
    },

    get selection() {
      throw new Error('Not implemented');
    },

    set selection(selection) {
      throw new Error('Not implemented');
    },

    get model() {
      throw new Error('Not implemented');
    },

    set model(model) {
      throw new Error('Not implemented');
    },

    get listeningToKeys() {
      throw new Error('Not implemented');
    },

    supportsModel: function(m) {
      throw new Error('Not implemented');
    }
  });
  

  'use strict';
  Polymer('tr-ui-side-panel-container', {
    ready: function() {
      this.activePanelContainer_ = this.$.active_panel_container;
      this.tabStrip_ = this.$.tab_strip;

      this.rangeOfInterest_ = new tr.b.Range();
      this.brushingStateController_ = undefined;
      this.onSelectionChanged_ = this.onSelectionChanged_.bind(this);
      this.onModelChanged_ = this.onModelChanged_.bind(this);
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    set brushingStateController(brushingStateController) {
      if (this.brushingStateController) {
        this.brushingStateController_.removeEventListener(
            'change', this.onSelectionChanged_);
        this.brushingStateController_.removeEventListener(
            'model-changed', this.onModelChanged_);
      }
      this.brushingStateController_ = brushingStateController;
      if (this.brushingStateController) {
        this.brushingStateController_.addEventListener(
            'change', this.onSelectionChanged_);
        this.brushingStateController_.addEventListener(
            'model-changed', this.onModelChanged_);
      }
    },

    get selection() {
      return this.brushingStateController_.selection;
    },

    onSelectionChanged_: function() {
      if (this.activePanel)
        this.activePanel.selection = this.selection;
    },

    get model() {
      return this.brushingStateController_.model;
    },

    onModelChanged_: function() {
      this.activePanelType_ = undefined;
      this.updateContents_();
    },

    get expanded() {
      this.hasAttribute('expanded');
    },

    get activePanel() {
      if (this.activePanelContainer_.children.length === 0)
        return undefined;
      return this.activePanelContainer_.children[0];
    },

    get activePanelType() {
      return this.activePanelType_;
    },

    set activePanelType(panelType) {
      if (this.model === undefined)
        throw new Error('Cannot activate panel without a model');

      var panel = undefined;
      if (panelType)
          panel = document.createElement(panelType);

      if (panel !== undefined && !panel.supportsModel(this.model))
        throw new Error('Cannot activate panel: does not support this model');

      if (this.activePanelType) {
        this.getLabelElementForPanelType_(
            this.activePanelType).removeAttribute('selected');
      }
      this.activePanelContainer_.textContent = '';

      if (panelType === undefined) {
        this.removeAttribute('expanded');
        this.activePanelType_ = undefined;
        return;
      }

      this.getLabelElementForPanelType_(panelType).
          setAttribute('selected', true);
      this.setAttribute('expanded', true);

      this.activePanelContainer_.appendChild(panel);
      panel.rangeOfInterest = this.rangeOfInterest_;
      panel.selection = this.selection_;
      panel.model = this.model;

      this.activePanelType_ = panelType;
    },

    getPanelTypeForConstructor_: function(constructor) {
      for (var i = 0; i < this.tabStrip_.children.length; i++) {
        if (this.tabStrip_.children[i].panelType.constructor == constructor)
          return this.tabStrip_.children[i].panelType;
      }
    },

    getLabelElementForPanelType_: function(panelType) {
      for (var i = 0; i < this.tabStrip_.children.length; i++) {
        if (this.tabStrip_.children[i].panelType == panelType)
          return this.tabStrip_.children[i];
      }
      return undefined;
    },

    updateContents_: function() {
      var previouslyActivePanelType = this.activePanelType;

      this.tabStrip_.textContent = '';
      var supportedPanelTypes = [];

      var panelTypes =
          tr.ui.b.getPolymerElementsThatSubclass('tr-ui-side-panel');
      panelTypes.forEach(function(panelType) {
        var labelEl = document.createElement('tab-strip-label');
        var panel = document.createElement(panelType);

        labelEl.textContent = panel.textLabel;
        labelEl.panelType = panelType;

        var supported = panel.supportsModel(this.model);
        if (this.model && supported.supported) {
          supportedPanelTypes.push(panelType);
          labelEl.setAttribute('enabled', true);
          labelEl.addEventListener('click', function() {
            this.activePanelType =
                this.activePanelType === panelType ? undefined : panelType;
          }.bind(this));
        } else {
          labelEl.title = 'Not supported for the current trace: ' +
              supported.reason;
          labelEl.style.display = 'none';
        }
        this.tabStrip_.appendChild(labelEl);
      }, this);

            if (previouslyActivePanelType &&
          supportedPanelTypes.indexOf(previouslyActivePanelType) != -1) {
        this.activePanelType = previouslyActivePanelType;
        this.setAttribute('expanded', true);
      } else {
        this.activePanelContainer_.textContent = '';
        this.removeAttribute('expanded');
      }
    },

    get rangeOfInterest() {
      return this.rangeOfInterest_;
    },

    set rangeOfInterest(range) {
      if (range == undefined)
        throw new Error('Must not be undefined');
      this.rangeOfInterest_ = range;
      if (this.activePanel)
        this.activePanel.rangeOfInterest = range;
    }
  });
  

  'use strict';

  Polymer('tr-ui-timeline-view-help-overlay', {
    ready: function() {
      var mod = tr.isMac ? 'cmd ' : 'ctrl';
      var spans = this.shadowRoot.querySelectorAll('span.mod');
      for (var i = 0; i < spans.length; i++) {
        spans[i].textContent = mod;
      }
    }
  });
  

'use strict';

tr.exportTo('tr.b.u', function() {
  /**
   * Tabular data wrapper. Simply wraps an array of items.
   */
  function GenericTable(items) {
    if (items !== undefined)
      this.items = items;
    else
      this.items = [];
  };

  GenericTable.prototype = {
  };

  return {
    GenericTable: GenericTable
  };
});


'use strict';
tr.exportTo('tr.ui.units', function() {
  var ArrayOfNumbersSummaryModes = {
    AVERAGE_MODE: 'average-mode',
    TOTAL_MODE: 'total-mode'
  };
  return {
    ArrayOfNumbersSummaryModes: ArrayOfNumbersSummaryModes
  };
});


  'use strict';

  Polymer('tr-ui-u-array-of-numbers-span', {
    created: function() {
      this.numbers_ = undefined;
      this.summaryMode_ = tr.ui.units.ArrayOfNumbersSummaryModes.AVERAGE_MODE;
    },

    get summaryMode() {
      return this.summaryMode_;
    },

    set summaryMode(summaryMode) {
      this.summaryMode_ = summaryMode;
      this.updateContents_();
    },

    get numbers() {
      return this.numbers_;
    },

    set numbers(numbers) {
      if (numbers === undefined) {
        this.numbers_ = undefined;
        this.updateContents_();
        return;
      }
      if (!(numbers instanceof Array))
        throw new Error('Must provide an array');
      this.numbers_ = numbers;
      this.updateContents_();
    },

    updateContents_: function() {
      if (this.numbers_ === undefined) {
        this.shadowRoot.textContent = '-';
        return;
      }

      var ArrayOfNumbersSummaryModes = tr.ui.units.ArrayOfNumbersSummaryModes;
      var value;
      if (this.summaryMode_ === ArrayOfNumbersSummaryModes.AVERAGE_MODE)
        value = tr.b.Statistics.mean(this.numbers_);
      else
        value = tr.b.Statistics.sum(this.numbers_);

      var valueRounded = Math.round(value * 1000.0) / 1000.0;
      this.shadowRoot.textContent = valueRounded;
    }
  });
  

'use strict';

tr.exportTo('tr.ui.units', function() {
  var TEXT_COLUMN_MODE = 1;
  var NUMERIC_COLUMN_MODE = 2;
  var ELEMENT_COLUMN_MODE = 3;

  function isNumeric(value) {
    // TODO(nduca): Also consider other units that are numeric.
    if ((typeof value) === 'number')
      return true;
    else if (value instanceof Number)
      return true;
    return false;
  }

  function GenericTableViewTotalsItem(opt_values) {
    if (opt_values !== undefined)
      this.values = opt_values;
    else
      this.values = [];
  }

  function GenericTableViewColumnDescriptor(fieldName, firstFieldValue) {
    this.title = fieldName;
    this.fieldName = fieldName;

    this.updateModeGivenValue(firstFieldValue);
  }

  GenericTableViewColumnDescriptor.prototype = {
    get columnMode() {
      return this.columnMode_;
    },

    get isInNumericMode() {
      return this.columnMode_ === NUMERIC_COLUMN_MODE;
    },

    cmp: function(a, b) {
      if (this.columnMode_ === ELEMENT_COLUMN_MODE)
        return 0;

      return tr.b.comparePossiblyUndefinedValues(a, b, function(a, b) {
        var vA = a[this.fieldName];
        var vB = b[this.fieldName];
        return tr.b.comparePossiblyUndefinedValues(vA, vB, function(vA, vB) {
          if (vA.localeCompare)
            return vA.localeCompare(vB);
          return vA - vB;
        }, this);
      }, this);
    },

    updateModeGivenValue: function(fieldValue) {
      if (this.columnMode_ === undefined) {
        if (fieldValue === undefined || fieldValue === null)
          return;

        if (isNumeric(fieldValue)) {
          this.columnMode_ = NUMERIC_COLUMN_MODE;
          return;
        }

        if (fieldValue instanceof HTMLElement) {
          this.columnMode_ = ELEMENT_COLUMN_MODE;
          return;
        }

        this.columnMode_ = TEXT_COLUMN_MODE;
        return;
      }

      // Undefineds & nulls shouldn't change the mode.
      if (fieldValue === undefined || fieldValue === null)
        return;

      // If we were already in numeric mode, then we don't
      // need to put it into numeric mode again. And, if we were
      // previously in text mode, then we can't go into numeric mode now.
      if (isNumeric(fieldValue))
        return;

      if (fieldValue instanceof HTMLElement) {
        this.columnMode_ = ELEMENT_COLUMN_MODE;
        return;
      }

      if (this.columnMode_ === NUMERIC_COLUMN_MODE)
        this.columnMode_ = TEXT_COLUMN_MODE;
    },

    value: function(item) {
      var fieldValue = item[this.fieldName];
      if (fieldValue instanceof GenericTableViewTotalsItem) {
        var span = document.createElement('tr-ui-u-array-of-numbers-span');
        span.summaryMode = tr.ui.units.ArrayOfNumbersSummaryModes.TOTAL_MODE;
        span.numbers = fieldValue.values;
        return span;
      }

      if (fieldValue === undefined)
        return '-';

      if (fieldValue instanceof HTMLElement)
        return fieldValue;

      if (fieldValue instanceof Object) {
        var gov = document.createElement('tr-ui-a-generic-object-view');
        gov.object = fieldValue;
        return gov;
      }

      // TODO(nduca): Use units objects if applicable.
      return fieldValue;
    }
  };

  Polymer('tr-ui-u-generic-table-view', {
    created: function() {
      this.items_ = undefined;
      this.importantColumNames_ = [];
    },

    get items() {
      return this.items_;
    },

    set items(itemsOrGenericTable) {
      if (itemsOrGenericTable === undefined) {
        this.items_ = undefined;
      } else if (itemsOrGenericTable instanceof Array) {
        this.items_ = itemsOrGenericTable;
      } else if (itemsOrGenericTable instanceof tr.b.u.GenericTable) {
        this.items_ = itemsOrGenericTable.items;
      }
      this.updateContents_();
    },

    get importantColumNames() {
      return this.importantColumNames_;
    },

    set importantColumNames(importantColumNames) {
      this.importantColumNames_ = importantColumNames;
      this.updateContents_();
    },

    createColumns_: function() {
      var columnsByName = {};
      this.items_.forEach(function(item) {
        tr.b.iterItems(item, function(itemFieldName, itemFieldValue) {
          var colDesc = columnsByName[itemFieldName];
          if (colDesc !== undefined) {
            colDesc.updateModeGivenValue(itemFieldValue);
            return;
          }

          colDesc = new GenericTableViewColumnDescriptor(
              itemFieldName, itemFieldValue);
          columnsByName[itemFieldName] = colDesc;
        }, this);
      }, this);

      var columns = tr.b.dictionaryValues(columnsByName);
      if (columns.length === 0)
        return undefined;

      // Sort by name.
      var isColumnNameImportant = {};
      var importantColumNames = this.importantColumNames || [];
      importantColumNames.forEach(function(icn) {
        isColumnNameImportant[icn] = true;
      });
      columns.sort(function(a, b) {
        var iA = isColumnNameImportant[a.title] ? 1 : 0;
        var iB = isColumnNameImportant[b.title] ? 1 : 0;
        if ((iB - iA) !== 0)
          return iB - iA;
        return a.title.localeCompare(b.title);
      });

      // Set sizes. This is convoluted by the fact that the first
      // table column must have fixed size.
      var colWidthPercentage;
      if (columns.length == 1)
        colWidthPercentage = '100%';
      else
        colWidthPercentage = (100 / (columns.length - 1)).toFixed(3) + '%';
      columns[0].width = '250px';
      for (var i = 1; i < columns.length; i++)
        columns[i].width = colWidthPercentage;

      return columns;
    },

    createFooterRowsIfNeeded_: function(columns) {
      // Make totals row if needed.
      var hasColumnThatIsNumeric = columns.some(function(column) {
        return column.isInNumericMode;
      });
      if (!hasColumnThatIsNumeric)
        return [];

      var totalsItems = {};
      columns.forEach(function(column) {
        if (!column.isInNumericMode)
          return;
        var totalsItem = new GenericTableViewTotalsItem();
        this.items_.forEach(function(item) {
          var fieldValue = item[column.fieldName];
          if (fieldValue === undefined || fieldValue === null)
            return;
          totalsItem.values.push(fieldValue);
        });
        totalsItems[column.fieldName] = totalsItem;
      }, this);

      return [totalsItems];
    },

    updateContents_: function() {
      var columns;
      if (this.items_ !== undefined)
        columns = this.createColumns_();

      if (!columns) {
        this.$.table.tableColumns = [];
        this.$.table.tableRows = [];
        this.$.table.footerRows = [];
        return;
      }

      this.$.table.tableColumns = columns;
      this.$.table.tableRows = this.items_;
      this.$.table.footerRows = this.createFooterRowsIfNeeded_(columns);
      this.$.table.rebuild();
    },

    get supportsSelection() {
      return this.$.supportsSelection;
    },

    set supportsSelection(supportsSelection) {
      this.$.table.supportsSelection = supportsSelection;
    },

    get rowHighlightEnabled() {
      return this.$.rowHighlightEnabled;
    },

    set rowHighlightEnabled(rowHighlightEnabled) {
      this.$.table.rowHighlightEnabled = rowHighlightEnabled;
    }
  });

  return {
    GenericTableViewTotalsItem: GenericTableViewTotalsItem,
    GenericTableViewColumnDescriptor: GenericTableViewColumnDescriptor
  };
});


  'use strict';

  Polymer('tr-ui-timeline-view-metadata-overlay', {
    created: function() {
      this.metadata_ = undefined;
    },

    get metadata() {
      return this.metadata_;
    },

    set metadata(metadata) {
      this.metadata_ = metadata;
      this.$.gtv.items = this.metadata_;
    }
  });
  

  'use strict';
  Polymer('tr-ui-u-preferred-display-unit', {
    ready: function() {
      this.preferredTimeDisplayMode_ = undefined;
    },

    attached: function() {
      tr.b.u.Units.didPreferredTimeDisplayUnitChange();
    },

    detached: function() {
      tr.b.u.Units.didPreferredTimeDisplayUnitChange();
    },

        get preferredTimeDisplayMode() {
      return this.preferredTimeDisplayMode_;
    },

    set preferredTimeDisplayMode(v) {
      if (this.preferredTimeDisplayMode_ === v)
        return;
      this.preferredTimeDisplayMode_ = v;
      tr.b.u.Units.didPreferredTimeDisplayUnitChange();
    }

  });
  

  'use strict';

  Polymer('tr-ui-timeline-view', {
    ready: function() {
      this.tabIndex = 0; 
      this.titleEl_ = this.$.title;
      this.leftControlsEl_ = this.$.left_controls;
      this.rightControlsEl_ = this.$.right_controls;
      this.collapsingControlsEl_ = this.$.collapsing_controls;
      this.sidePanelContainer_ = this.$.side_panel_container;

      this.brushingStateController_ = new tr.c.BrushingStateController(this);

      this.findCtl_ = this.$.view_find_control;
      this.findCtl_.controller = new tr.ui.FindController(
          this.brushingStateController_);

      this.scriptingCtl_ = document.createElement('tr-ui-scripting-control');
      this.scriptingCtl_.controller = new tr.c.ScriptingController(
          this.brushingStateController_);

      this.sidePanelContainer_.brushingStateController =
          this.brushingStateController_;

      if (window.tr.e && window.tr.e.rail && window.tr.e.rail.RAILScore) {
        this.railScoreSpan_ = document.createElement(
            'tr-ui-e-rail-rail-score-span');
        this.rightControls.appendChild(this.railScoreSpan_);
      } else {
        this.railScoreSpan_ = undefined;
      }

      this.optionsDropdown_ = this.$.view_options_dropdown;
      this.optionsDropdown_.iconElement.textContent = 'View Options';

      this.showFlowEvents_ = false;
      this.optionsDropdown_.appendChild(tr.ui.b.createCheckBox(
          this, 'showFlowEvents',
          'tr.ui.TimelineView.showFlowEvents', false,
          'Flow events'));
      this.highlightVSync_ = false;
      this.highlightVSyncCheckbox_ = tr.ui.b.createCheckBox(
          this, 'highlightVSync',
          'tr.ui.TimelineView.highlightVSync', false,
          'Highlight VSync');
      this.optionsDropdown_.appendChild(this.highlightVSyncCheckbox_);

      this.initMetadataButton_();
      this.initConsoleButton_();
      this.initHelpButton_();

      this.collapsingControls.appendChild(this.scriptingCtl_);

      this.dragEl_ = this.$.drag_handle;
      tr.ui.b.decorate(this.dragEl_, tr.ui.b.DragHandle);

      this.analysisEl_ = this.$.analysis;
      this.analysisEl_.brushingStateController = this.brushingStateController_;

      this.addEventListener(
          'requestSelectionChange',
          function(e) {
            var sc = this.brushingStateController_;
            sc.changeSelectionFromRequestSelectionChangeEvent(e.selection);
          }.bind(this));

            this.onViewportChanged_ = this.onViewportChanged_.bind(this);
      this.bindKeyListeners_();

      this.dragEl_.target = this.analysisEl_;
    },

    domReady: function() {
      this.trackViewContainer_ = this.querySelector('#track_view_container');
    },

    get globalMode() {
      return this.hotkeyController.globalMode;
    },

    set globalMode(globalMode) {
      globalMode = !!globalMode;
      this.brushingStateController_.historyEnabled = globalMode;
      this.hotkeyController.globalMode = globalMode;
    },

    get hotkeyController() {
      return this.$.hkc;
    },

    updateDocumentFavicon: function() {
      var hue;
      if (!this.model)
        hue = 'blue';
      else
        hue = this.model.faviconHue;

      var faviconData = tr.ui.b.FaviconsByHue[hue];
      if (faviconData === undefined)
        faviconData = tr.ui.b.FaviconsByHue['blue'];

            var link = document.head.querySelector('link[rel="shortcut icon"]');
      if (!link) {
        link = document.createElement('link');
        link.rel = 'shortcut icon';
        document.head.appendChild(link);
      }
      link.href = faviconData;
    },

    get showFlowEvents() {
      return this.showFlowEvents_;
    },

    set showFlowEvents(showFlowEvents) {
      this.showFlowEvents_ = showFlowEvents;
      if (!this.trackView_)
        return;
      this.trackView_.viewport.showFlowEvents = showFlowEvents;
    },

    get highlightVSync() {
      return this.highlightVSync_;
    },

    set highlightVSync(highlightVSync) {
      this.highlightVSync_ = highlightVSync;
      if (!this.trackView_)
        return;
      this.trackView_.viewport.highlightVSync = highlightVSync;
    },

    initHelpButton_: function() {
      var helpButtonEl = this.$.view_help_button;

      function onClick(e) {
        var dlg = new tr.ui.b.Overlay();
        dlg.title = 'Chrome Tracing Help';
        dlg.appendChild(
            document.createElement('tr-ui-timeline-view-help-overlay'));
        dlg.visible = true;

                e.stopPropagation();
      }
      helpButtonEl.addEventListener('click', onClick.bind(this));
    },

    initConsoleButton_: function() {
      var toggleEl = this.$.view_console_button;

      function onClick(e) {
        this.scriptingCtl_.toggleVisibility();
        e.stopPropagation();
        return false;
      }
      toggleEl.addEventListener('click', onClick.bind(this));
    },

    initMetadataButton_: function() {
      var showEl = this.$.view_metadata_button;

      function onClick(e) {
        var dlg = new tr.ui.b.Overlay();
        dlg.title = 'Metadata for trace';

        var metadataOverlay = document.createElement(
            'tr-ui-timeline-view-metadata-overlay');
        metadataOverlay.metadata = this.model.metadata;

        dlg.appendChild(metadataOverlay);
        dlg.visible = true;

        e.stopPropagation();
        return false;
      }
      showEl.addEventListener('click', onClick.bind(this));

      this.updateMetadataButtonVisibility_();
    },

    updateMetadataButtonVisibility_: function() {
      var showEl = this.$.view_metadata_button;
      showEl.style.display =
          (this.model && this.model.metadata.length) ? '' : 'none';
    },

    get leftControls() {
      return this.leftControlsEl_;
    },

    get rightControls() {
      return this.rightControlsEl_;
    },

    get collapsingControls() {
      return this.collapsingControlsEl_;
    },

    get viewTitle() {
      return this.titleEl_.textContent.substring(
          this.titleEl_.textContent.length - 2);
    },

    set viewTitle(text) {
      if (text === undefined) {
        this.titleEl_.textContent = '';
        this.titleEl_.hidden = true;
        return;
      }
      this.titleEl_.hidden = false;
      this.titleEl_.textContent = text;
    },

    get model() {
      if (this.trackView_)
        return this.trackView_.model;
      return undefined;
    },

    set model(model) {
      var modelInstanceChanged = model != this.model;
      var modelValid = model && !model.bounds.isEmpty;

            if (modelInstanceChanged) {
        if (this.railScoreSpan_)
          this.railScoreSpan_.railScore = undefined;
        this.trackViewContainer_.textContent = '';
        if (this.trackView_) {
          this.trackView_.viewport.removeEventListener(
              'change', this.onViewportChanged_);
          this.trackView_.brushingStateController = undefined;
          this.trackView_.detach();
          this.trackView_ = undefined;
        }
        this.brushingStateController_.modelWillChange();
      }

            if (modelValid && !this.trackView_) {
        this.trackView_ = document.createElement('tr-ui-timeline-track-view');
        this.trackView_.timelineView = this;

        this.trackView.brushingStateController = this.brushingStateController_;

        this.trackViewContainer_.appendChild(this.trackView_);
        this.trackView_.viewport.addEventListener(
            'change', this.onViewportChanged_);
      }

            if (modelValid) {
        this.trackView_.model = model;
        this.trackView_.viewport.showFlowEvents = this.showFlowEvents;
        this.trackView_.viewport.highlightVSync = this.highlightVSync;
        if (this.railScoreSpan_) {
          var railScore = tr.e.rail.RAILScore.fromModel(model);
          this.railScoreSpan_.railScore = railScore;
        }

        this.$.display_unit.preferredTimeDisplayMode = model.intrinsicTimeUnit;
      }

            if (modelInstanceChanged) {
        this.updateMetadataButtonVisibility_();
        this.brushingStateController_.modelDidChange();
        this.onViewportChanged_();
      }
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    get trackView() {
      return this.trackView_;
    },

    get settings() {
      if (!this.settings_)
        this.settings_ = new tr.b.Settings();
      return this.settings_;
    },

    
    set focusElement(value) {
      throw new Error('This is deprecated. Please set globalMode to true.');
    },

    bindKeyListeners_: function() {
      var hkc = this.hotkeyController;

                  hkc.addHotKey(new tr.ui.b.HotKey({
        eventType: 'keypress',
        keyCode: '`'.charCodeAt(0),
        useCapture: true,
        thisArg: this,
        callback: function(e) {
          this.scriptingCtl_.toggleVisibility();
          if (!this.scriptingCtl_.hasFocus)
            this.focus();
          e.stopPropagation();
        }
      }));

            hkc.addHotKey(new tr.ui.b.HotKey({
        eventType: 'keypress',
        keyCode: '/'.charCodeAt(0),
        useCapture: true,
        thisArg: this,
        callback: function(e) {
          if (this.scriptingCtl_.hasFocus)
            return;
          if (this.findCtl_.hasFocus)
            this.focus();
          else
            this.findCtl_.focus();
          e.preventDefault();
          e.stopPropagation();
        }
      }));

            hkc.addHotKey(new tr.ui.b.HotKey({
        eventType: 'keypress',
        keyCode: '?'.charCodeAt(0),
        useCapture: false,
        thisArg: this,
        callback: function(e) {
          this.$.view_help_button.click();
          e.stopPropagation();
        }
      }));

      hkc.addHotKey(new tr.ui.b.HotKey({
        eventType: 'keypress',
        keyCode: 'v'.charCodeAt(0),
        useCapture: false,
        thisArg: this,
        callback: function(e) {
          this.toggleHighlightVSync_();
          e.stopPropagation();
        }
      }));
    },

    onViewportChanged_: function(e) {
      var spc = this.sidePanelContainer_;
      if (!this.trackView_) {
        spc.rangeOfInterest.reset();
        return;
      }

      var vr = this.trackView_.viewport.interestRange.asRangeObject();
      if (!spc.rangeOfInterest.equals(vr))
        spc.rangeOfInterest = vr;
    },

    toggleHighlightVSync_: function() {
      this.highlightVSyncCheckbox_.checked =
          !this.highlightVSyncCheckbox_.checked;
    },

    setFindCtlText: function(string) {
      this.findCtl_.setText(string);
    }
  });
  

'use strict';

var g_timelineViewEl;

(function() {
  var styleEl = document.createElement('style');
  var lines = [
    'html, body {',
    '  box-sizing: border-box;',
    '  overflow: hidden;',
    '  margin: 0px;',
    '  padding: 0;',
    '  width: 100%;',
    '  height: 100%;',
    '}',
    'tr-ui-timeline-view {',
    '  width: 100%;',
    '  height: 100%;',
    '}',
    'tr-ui-timeline-view:focus {',
    '  outline: none;',
    '}'
  ];
  styleEl.textContent = lines.join('\n');
  document.head.appendChild(styleEl);
})();

document.addEventListener('DOMContentLoaded', function() {
  var container = document.createElement('track-view-container');
  container.id = 'track_view_container';

  g_timelineViewEl = document.createElement('tr-ui-timeline-view');
  g_timelineViewEl.appendChild(container);

  document.body.appendChild(g_timelineViewEl);

  var traces = [];
  var viewerDataScripts = document.querySelectorAll('#viewer-data');
  for (var i = 0; i < viewerDataScripts.length; i++) {
    var text = viewerDataScripts[i].textContent;
    // Trim leading newlines off the text. They happen during writing.
    while (text[0] == '\n')
      text = text.substring(1);
    traces.push(atob(text));
  }

  var m = new tr.Model();
  var i = new tr.importer.Import(m);
  var p = i.importTracesWithProgressDialog(traces);
  p.then(
      function() {
        g_timelineViewEl.model = m;
        g_timelineViewEl.updateDocumentFavicon();
        g_timelineViewEl.globalMode = true;
        g_timelineViewEl.viewTitle = document.title;
      },
      function(err) {
        var overlay = new tr.ui.b.Overlay();
        overlay.textContent = tr.b.normalizeException(err).message;
        overlay.title = 'Import error';
        overlay.visible = true;
      });
});

/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;"undefined"!=typeof window?b=window:"undefined"!=typeof global?b=global:"undefined"!=typeof self&&(b=self),b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);throw new Error("Cannot find module '"+g+"'")}var j=c[g]={exports:{}};b[g][0].call(j.exports,function(a){var c=b[g][1][a];return e(c?c:a)},j,j.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,f,g,h,i,j="",k=0;k<a.length;)b=a.charCodeAt(k++),c=a.charCodeAt(k++),e=a.charCodeAt(k++),f=b>>2,g=(3&b)<<4|c>>4,h=(15&c)<<2|e>>6,i=63&e,isNaN(c)?h=i=64:isNaN(e)&&(i=64),j=j+d.charAt(f)+d.charAt(g)+d.charAt(h)+d.charAt(i);return j},c.decode=function(a){var b,c,e,f,g,h,i,j="",k=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");k<a.length;)f=d.indexOf(a.charAt(k++)),g=d.indexOf(a.charAt(k++)),h=d.indexOf(a.charAt(k++)),i=d.indexOf(a.charAt(k++)),b=f<<2|g>>4,c=(15&g)<<4|h>>2,e=(3&h)<<6|i,j+=String.fromCharCode(b),64!=h&&(j+=String.fromCharCode(c)),64!=i&&(j+=String.fromCharCode(e));return j}},{}],2:[function(a,b){"use strict";function c(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}c.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},b.exports=c},{}],3:[function(a,b,c){"use strict";c.STORE={magic:"\x00\x00",compress:function(a){return a},uncompress:function(a){return a},compressInputType:null,uncompressInputType:null},c.DEFLATE=a("./flate")},{"./flate":8}],4:[function(a,b){"use strict";var c=a("./utils"),d=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var e="string"!==c.getTypeOf(a);"undefined"==typeof b&&(b=0);var f=0,g=0,h=0;b=-1^b;for(var i=0,j=a.length;j>i;i++)h=e?a[i]:a.charCodeAt(i),g=255&(b^h),f=d[g],b=b>>>8^f;return-1^b}},{"./utils":21}],5:[function(a,b){"use strict";function c(){this.data=null,this.length=0,this.index=0}var d=a("./utils");c.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<a||0>a)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return d.transformTo("string",this.readData(a))},readData:function(){},lastIndexOfSignature:function(){},readDate:function(){var a=this.readInt(4);return new Date((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1)}},b.exports=c},{"./utils":21}],6:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!1,c.date=null,c.compression=null,c.comment=null},{}],7:[function(a,b,c){"use strict";var d=a("./utils");c.string2binary=function(a){return d.string2binary(a)},c.string2Uint8Array=function(a){return d.transformTo("uint8array",a)},c.uint8Array2String=function(a){return d.transformTo("string",a)},c.string2Blob=function(a){var b=d.transformTo("arraybuffer",a);return d.arrayBuffer2Blob(b)},c.arrayBuffer2Blob=function(a){return d.arrayBuffer2Blob(a)},c.transformTo=function(a,b){return d.transformTo(a,b)},c.getTypeOf=function(a){return d.getTypeOf(a)},c.checkSupport=function(a){return d.checkSupport(a)},c.MAX_VALUE_16BITS=d.MAX_VALUE_16BITS,c.MAX_VALUE_32BITS=d.MAX_VALUE_32BITS,c.pretty=function(a){return d.pretty(a)},c.findCompression=function(a){return d.findCompression(a)},c.isRegExp=function(a){return d.isRegExp(a)}},{"./utils":21}],8:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,e=a("pako");c.uncompressInputType=d?"uint8array":"array",c.compressInputType=d?"uint8array":"array",c.magic="\b\x00",c.compress=function(a){return e.deflateRaw(a)},c.uncompress=function(a){return e.inflateRaw(a)}},{pako:24}],9:[function(a,b){"use strict";function c(a,b){return this instanceof c?(this.files={},this.comment=null,this.root="",a&&this.load(a,b),void(this.clone=function(){var a=new c;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a})):new c(a,b)}var d=a("./base64");c.prototype=a("./object"),c.prototype.load=a("./load"),c.support=a("./support"),c.defaults=a("./defaults"),c.utils=a("./deprecatedPublicUtils"),c.base64={encode:function(a){return d.encode(a)},decode:function(a){return d.decode(a)}},c.compressions=a("./compressions"),b.exports=c},{"./base64":1,"./compressions":3,"./defaults":6,"./deprecatedPublicUtils":7,"./load":10,"./object":13,"./support":17}],10:[function(a,b){"use strict";var c=a("./base64"),d=a("./zipEntries");b.exports=function(a,b){var e,f,g,h;for(b=b||{},b.base64&&(a=c.decode(a)),f=new d(a,b),e=f.files,g=0;g<e.length;g++)h=e[g],this.file(h.fileName,h.decompressed,{binary:!0,optimizedBinaryString:!0,date:h.date,dir:h.dir,comment:h.fileComment.length?h.fileComment:null,createFolders:b.createFolders});return f.zipComment.length&&(this.comment=f.zipComment),this}},{"./base64":1,"./zipEntries":22}],11:[function(a,b){(function(a){"use strict";b.exports=function(b,c){return new a(b,c)},b.exports.test=function(b){return a.isBuffer(b)}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],12:[function(a,b){"use strict";function c(a){this.data=a,this.length=this.data.length,this.index=0}var d=a("./uint8ArrayReader");c.prototype=new d,c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./uint8ArrayReader":18}],13:[function(a,b){"use strict";var c=a("./support"),d=a("./utils"),e=a("./crc32"),f=a("./signature"),g=a("./defaults"),h=a("./base64"),i=a("./compressions"),j=a("./compressedObject"),k=a("./nodeBuffer"),l=a("./utf8"),m=a("./stringWriter"),n=a("./uint8ArrayWriter"),o=function(a){if(a._data instanceof j&&(a._data=a._data.getContent(),a.options.binary=!0,a.options.base64=!1,"uint8array"===d.getTypeOf(a._data))){var b=a._data;a._data=new Uint8Array(b.length),0!==b.length&&a._data.set(b,0)}return a._data},p=function(a){var b=o(a),e=d.getTypeOf(b);return"string"===e?!a.options.binary&&c.nodebuffer?k(b,"utf-8"):a.asBinary():b},q=function(a){var b=o(this);return null===b||"undefined"==typeof b?"":(this.options.base64&&(b=h.decode(b)),b=a&&this.options.binary?A.utf8decode(b):d.transformTo("string",b),a||this.options.binary||(b=d.transformTo("string",A.utf8encode(b))),b)},r=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this._data=b,this.options=c,this._initialMetadata={dir:c.dir,date:c.date}};r.prototype={asText:function(){return q.call(this,!0)},asBinary:function(){return q.call(this,!1)},asNodeBuffer:function(){var a=p(this);return d.transformTo("nodebuffer",a)},asUint8Array:function(){var a=p(this);return d.transformTo("uint8array",a)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var s=function(a,b){var c,d="";for(c=0;b>c;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},t=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},u=function(a){return a=a||{},a.base64!==!0||null!==a.binary&&void 0!==a.binary||(a.binary=!0),a=t(a,g),a.date=a.date||new Date,null!==a.compression&&(a.compression=a.compression.toUpperCase()),a},v=function(a,b,c){var e,f=d.getTypeOf(b);if(c=u(c),c.createFolders&&(e=w(a))&&x.call(this,e,!0),c.dir||null===b||"undefined"==typeof b)c.base64=!1,c.binary=!1,b=null;else if("string"===f)c.binary&&!c.base64&&c.optimizedBinaryString!==!0&&(b=d.string2binary(b));else{if(c.base64=!1,c.binary=!0,!(f||b instanceof j))throw new Error("The data of '"+a+"' is in an unsupported format !");"arraybuffer"===f&&(b=d.transformTo("uint8array",b))}var g=new r(a,b,c);return this.files[a]=g,g},w=function(a){"/"==a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},x=function(a,b){return"/"!=a.slice(-1)&&(a+="/"),b="undefined"!=typeof b?b:!1,this.files[a]||v.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},y=function(a,b){var c,f=new j;return a._data instanceof j?(f.uncompressedSize=a._data.uncompressedSize,f.crc32=a._data.crc32,0===f.uncompressedSize||a.dir?(b=i.STORE,f.compressedContent="",f.crc32=0):a._data.compressionMethod===b.magic?f.compressedContent=a._data.getCompressedContent():(c=a._data.getContent(),f.compressedContent=b.compress(d.transformTo(b.compressInputType,c)))):(c=p(a),(!c||0===c.length||a.dir)&&(b=i.STORE,c=""),f.uncompressedSize=c.length,f.crc32=e(c),f.compressedContent=b.compress(d.transformTo(b.compressInputType,c))),f.compressedSize=f.compressedContent.length,f.compressionMethod=b.magic,f},z=function(a,b,c,g){var h,i,j,k,m=(c.compressedContent,d.transformTo("string",l.utf8encode(b.name))),n=b.comment||"",o=d.transformTo("string",l.utf8encode(n)),p=m.length!==b.name.length,q=o.length!==n.length,r=b.options,t="",u="",v="";j=b._initialMetadata.dir!==b.dir?b.dir:r.dir,k=b._initialMetadata.date!==b.date?b.date:r.date,h=k.getHours(),h<<=6,h|=k.getMinutes(),h<<=5,h|=k.getSeconds()/2,i=k.getFullYear()-1980,i<<=4,i|=k.getMonth()+1,i<<=5,i|=k.getDate(),p&&(u=s(1,1)+s(e(m),4)+m,t+="up"+s(u.length,2)+u),q&&(v=s(1,1)+s(this.crc32(o),4)+o,t+="uc"+s(v.length,2)+v);var w="";w+="\n\x00",w+=p||q?"\x00\b":"\x00\x00",w+=c.compressionMethod,w+=s(h,2),w+=s(i,2),w+=s(c.crc32,4),w+=s(c.compressedSize,4),w+=s(c.uncompressedSize,4),w+=s(m.length,2),w+=s(t.length,2);var x=f.LOCAL_FILE_HEADER+w+m+t,y=f.CENTRAL_FILE_HEADER+"\x00"+w+s(o.length,2)+"\x00\x00\x00\x00"+(j===!0?"\x00\x00\x00":"\x00\x00\x00\x00")+s(g,4)+m+t+o;return{fileRecord:x,dirRecord:y,compressedObject:c}},A={load:function(){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(a){var b,c,d,e,f=[];for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],e=new r(d.name,d._data,t(d.options)),c=b.slice(this.root.length,b.length),b.slice(0,this.root.length)===this.root&&a(c,e)&&f.push(e));return f},file:function(a,b,c){if(1===arguments.length){if(d.isRegExp(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}return this.filter(function(b,c){return!c.dir&&b===a})[0]||null}return a=this.root+a,v.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d.isRegExp(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=x.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!=a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){a=t(a||{},{base64:!0,compression:"STORE",type:"base64",comment:null}),d.checkSupport(a.type);var b,c,e=[],g=0,j=0,k=d.transformTo("string",this.utf8encode(a.comment||this.comment||""));for(var l in this.files)if(this.files.hasOwnProperty(l)){var o=this.files[l],p=o.options.compression||a.compression.toUpperCase(),q=i[p];if(!q)throw new Error(p+" is not a valid compression method !");var r=y.call(this,o,q),u=z.call(this,l,o,r,g);g+=u.fileRecord.length+r.compressedSize,j+=u.dirRecord.length,e.push(u)}var v="";v=f.CENTRAL_DIRECTORY_END+"\x00\x00\x00\x00"+s(e.length,2)+s(e.length,2)+s(j,4)+s(g,4)+s(k.length,2)+k;var w=a.type.toLowerCase();for(b="uint8array"===w||"arraybuffer"===w||"blob"===w||"nodebuffer"===w?new n(g+j+v.length):new m(g+j+v.length),c=0;c<e.length;c++)b.append(e[c].fileRecord),b.append(e[c].compressedObject.compressedContent);for(c=0;c<e.length;c++)b.append(e[c].dirRecord);b.append(v);var x=b.finalize();switch(a.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return d.transformTo(a.type.toLowerCase(),x);case"blob":return d.arrayBuffer2Blob(d.transformTo("arraybuffer",x));case"base64":return a.base64?h.encode(x):x;default:return x}},crc32:function(a,b){return e(a,b)},utf8encode:function(a){return d.transformTo("string",l.utf8encode(a))},utf8decode:function(a){return l.utf8decode(a)}};b.exports=A},{"./base64":1,"./compressedObject":2,"./compressions":3,"./crc32":4,"./defaults":6,"./nodeBuffer":11,"./signature":14,"./stringWriter":16,"./support":17,"./uint8ArrayWriter":19,"./utf8":20,"./utils":21}],14:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],15:[function(a,b){"use strict";function c(a,b){this.data=a,b||(this.data=e.string2binary(this.data)),this.length=this.data.length,this.index=0}var d=a("./dataReader"),e=a("./utils");c.prototype=new d,c.prototype.byteAt=function(a){return this.data.charCodeAt(a)},c.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)},c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":5,"./utils":21}],16:[function(a,b){"use strict";var c=a("./utils"),d=function(){this.data=[]};d.prototype={append:function(a){a=c.transformTo("string",a),this.data.push(a)},finalize:function(){return this.data.join("")}},b.exports=d},{"./utils":21}],17:[function(a,b,c){(function(a){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof a,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var b=new ArrayBuffer(0);try{c.blob=0===new Blob([b],{type:"application/zip"}).size}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;f.append(b),c.blob=0===f.getBlob("application/zip").size}catch(d){c.blob=!1}}}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],18:[function(a,b){"use strict";function c(a){a&&(this.data=a,this.length=this.data.length,this.index=0)}var d=a("./dataReader");c.prototype=new d,c.prototype.byteAt=function(a){return this.data[a]},c.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f;return-1},c.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":5}],19:[function(a,b){"use strict";var c=a("./utils"),d=function(a){this.data=new Uint8Array(a),this.index=0};d.prototype={append:function(a){0!==a.length&&(a=c.transformTo("uint8array",a),this.data.set(a,this.index),this.index+=a.length)},finalize:function(){return this.data}},b.exports=d},{"./utils":21}],20:[function(a,b,c){"use strict";for(var d=a("./utils"),e=a("./support"),f=a("./nodeBuffer"),g=new Array(256),h=0;256>h;h++)g[h]=h>=252?6:h>=248?5:h>=240?4:h>=224?3:h>=192?2:1;g[254]=g[254]=1;var i=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=e.uint8array?new Uint8Array(i):new Array(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},j=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+g[a[c]]>b?c:b},k=function(a){var b,c,e,f,h=a.length,i=new Array(2*h);for(c=0,b=0;h>b;)if(e=a[b++],128>e)i[c++]=e;else if(f=g[e],f>4)i[c++]=65533,b+=f-1;else{for(e&=2===f?31:3===f?15:7;f>1&&h>b;)e=e<<6|63&a[b++],f--;f>1?i[c++]=65533:65536>e?i[c++]=e:(e-=65536,i[c++]=55296|e>>10&1023,i[c++]=56320|1023&e)}return i.length!==c&&(i.subarray?i=i.subarray(0,c):i.length=c),d.applyFromCharCode(i)};c.utf8encode=function(a){return e.nodebuffer?f(a,"utf-8"):i(a)},c.utf8decode=function(a){if(e.nodebuffer)return d.transformTo("nodebuffer",a).toString("utf-8");a=d.transformTo(e.uint8array?"uint8array":"array",a);for(var b=[],c=0,f=a.length,g=65536;f>c;){var h=j(a,Math.min(c+g,f));b.push(e.uint8array?k(a.subarray(c,h)):k(a.slice(c,h))),c=h}return b.join("")}},{"./nodeBuffer":11,"./support":17,"./utils":21}],21:[function(a,b,c){"use strict";function d(a){return a}function e(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function f(a){var b=65536,d=[],e=a.length,f=c.getTypeOf(a),g=0,h=!0;try{switch(f){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,j(0))}}catch(i){h=!1}if(!h){for(var k="",l=0;l<a.length;l++)k+=String.fromCharCode(a[l]);return k}for(;e>g&&b>1;)try{d.push("array"===f||"nodebuffer"===f?String.fromCharCode.apply(null,a.slice(g,Math.min(g+b,e))):String.fromCharCode.apply(null,a.subarray(g,Math.min(g+b,e)))),g+=b}catch(i){b=Math.floor(b/2)}return d.join("")}function g(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var h=a("./support"),i=a("./compressions"),j=a("./nodeBuffer");c.string2binary=function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(255&a.charCodeAt(c));return b},c.arrayBuffer2Blob=function(a){c.checkSupport("blob");try{return new Blob([a],{type:"application/zip"})}catch(b){try{var d=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,e=new d;return e.append(a),e.getBlob("application/zip")}catch(b){throw new Error("Bug : can't construct the Blob.")}}},c.applyFromCharCode=f;var k={};k.string={string:d,array:function(a){return e(a,new Array(a.length))},arraybuffer:function(a){return k.string.uint8array(a).buffer},uint8array:function(a){return e(a,new Uint8Array(a.length))},nodebuffer:function(a){return e(a,j(a.length))}},k.array={string:f,array:d,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(a)}},k.arraybuffer={string:function(a){return f(new Uint8Array(a))},array:function(a){return g(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:d,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(new Uint8Array(a))}},k.uint8array={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:d,nodebuffer:function(a){return j(a)}},k.nodebuffer={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return k.nodebuffer.uint8array(a).buffer},uint8array:function(a){return g(a,new Uint8Array(a.length))},nodebuffer:d},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=k[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":h.nodebuffer&&j.test(a)?"nodebuffer":h.uint8array&&a instanceof Uint8Array?"uint8array":h.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=h[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this browser")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(16>b?"0":"")+b.toString(16).toUpperCase();return d},c.findCompression=function(a){for(var b in i)if(i.hasOwnProperty(b)&&i[b].magic===a)return i[b];return null},c.isRegExp=function(a){return"[object RegExp]"===Object.prototype.toString.call(a)}},{"./compressions":3,"./nodeBuffer":11,"./support":17}],22:[function(a,b){"use strict";function c(a,b){this.files=[],this.loadOptions=b,a&&this.load(a)}var d=a("./stringReader"),e=a("./nodeBufferReader"),f=a("./uint8ArrayReader"),g=a("./utils"),h=a("./signature"),i=a("./zipEntry"),j=a("./support"),k=a("./object");c.prototype={checkSignature:function(a){var b=this.reader.readString(4);if(b!==a)throw new Error("Corrupted zip or bug : unexpected signature ("+g.pretty(b)+", expected "+g.pretty(a)+")")},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2),this.zipComment=this.reader.readString(this.zipCommentLength),this.zipComment=k.utf8decode(this.zipComment)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;d>e;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readString(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(h.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===h.CENTRAL_FILE_HEADER;)a=new i({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);if(-1===a)throw new Error("Corrupted zip : can't find end of central directory");if(this.reader.setIndex(a),this.checkSignature(h.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===g.MAX_VALUE_16BITS||this.diskWithCentralDirStart===g.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===g.MAX_VALUE_16BITS||this.centralDirRecords===g.MAX_VALUE_16BITS||this.centralDirSize===g.MAX_VALUE_32BITS||this.centralDirOffset===g.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),-1===a)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");this.reader.setIndex(a),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}},prepareReader:function(a){var b=g.getTypeOf(a);this.reader="string"!==b||j.uint8array?"nodebuffer"===b?new e(a):new f(g.transformTo("uint8array",a)):new d(a,this.loadOptions.optimizedBinaryString)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=c},{"./nodeBufferReader":12,"./object":13,"./signature":14,"./stringReader":15,"./support":17,"./uint8ArrayReader":18,"./utils":21,"./zipEntry":23}],23:[function(a,b){"use strict";function c(a,b){this.options=a,this.loadOptions=b}var d=a("./stringReader"),e=a("./utils"),f=a("./compressedObject"),g=a("./object");c.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},prepareCompressedContent:function(a,b,c){return function(){var d=a.index;a.setIndex(b);var e=a.readData(c);return a.setIndex(d),e}},prepareContent:function(a,b,c,d,f){return function(){var a=e.transformTo(d.uncompressInputType,this.getCompressedContent()),b=d.uncompress(a);if(b.length!==f)throw new Error("Bug : uncompressed data size mismatch");return b}},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readString(this.fileNameLength),a.skip(c),-1==this.compressedSize||-1==this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(b=e.findCompression(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+e.pretty(this.compressionMethod)+" unknown (inner file : "+this.fileName+")");if(this.decompressed=new f,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(a,a.index,this.compressedSize,b),this.decompressed.getContent=this.prepareContent(a,a.index,this.compressedSize,b,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=e.transformTo("string",this.decompressed.getContent()),g.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch")},readCentralPart:function(a){if(this.versionMadeBy=a.readString(2),this.versionNeeded=a.readInt(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4),this.fileNameLength=a.readInt(2),this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=a.readString(this.fileNameLength),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readString(this.fileCommentLength),this.dir=16&this.externalFileAttributes?!0:!1},parseZIP64ExtraField:function(){if(this.extraFields[1]){var a=new d(this.extraFields[1].value);this.uncompressedSize===e.MAX_VALUE_32BITS&&(this.uncompressedSize=a.readInt(8)),this.compressedSize===e.MAX_VALUE_32BITS&&(this.compressedSize=a.readInt(8)),this.localHeaderOffset===e.MAX_VALUE_32BITS&&(this.localHeaderOffset=a.readInt(8)),this.diskNumberStart===e.MAX_VALUE_32BITS&&(this.diskNumberStart=a.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index;for(this.extraFields=this.extraFields||{};a.index<e+this.extraFieldsLength;)b=a.readInt(2),c=a.readInt(2),d=a.readString(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){if(this.useUTF8())this.fileName=g.utf8decode(this.fileName),this.fileComment=g.utf8decode(this.fileComment);else{var a=this.findExtraFieldUnicodePath();null!==a&&(this.fileName=a);var b=this.findExtraFieldUnicodeComment();null!==b&&(this.fileComment=b)}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileName)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileComment)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))}return null}},b.exports=c},{"./compressedObject":2,"./object":13,"./stringReader":15,"./utils":21}],24:[function(a,b){"use strict";var c=a("./lib/utils/common").assign,d=a("./lib/deflate"),e=a("./lib/inflate"),f=a("./lib/zlib/constants"),g={};c(g,d,e,f),b.exports=g},{"./lib/deflate":25,"./lib/inflate":26,"./lib/utils/common":27,"./lib/zlib/constants":30}],25:[function(a,b,c){"use strict";function d(a,b){var c=new s(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}function f(a,b){return b=b||{},b.gzip=!0,d(a,b)}var g=a("./zlib/deflate.js"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=0,m=4,n=0,o=1,p=-1,q=0,r=8,s=function(a){this.options=h.assign({level:p,method:r,chunkSize:16384,windowBits:15,memLevel:8,strategy:q,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=g.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==n)throw new Error(j[c]);b.header&&g.deflateSetHeader(this.strm,b.header)
};s.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?m:l,e.input="string"==typeof a?i.string2buf(a):a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new h.Buf8(f),e.next_out=0,e.avail_out=f),c=g.deflate(e,d),c!==o&&c!==n)return this.onEnd(c),this.ended=!0,!1;(0===e.avail_out||0===e.avail_in&&d===m)&&this.onData("string"===this.options.to?i.buf2binstring(h.shrinkBuf(e.output,e.next_out)):h.shrinkBuf(e.output,e.next_out))}while((e.avail_in>0||0===e.avail_out)&&c!==o);return d===m?(c=g.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===n):!0},s.prototype.onData=function(a){this.chunks.push(a)},s.prototype.onEnd=function(a){a===n&&(this.result="string"===this.options.to?this.chunks.join(""):h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=s,c.deflate=d,c.deflateRaw=e,c.gzip=f},{"./utils/common":27,"./utils/strings":28,"./zlib/deflate.js":32,"./zlib/messages":37,"./zlib/zstream":39}],26:[function(a,b,c){"use strict";function d(a,b){var c=new m(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}var f=a("./zlib/inflate.js"),g=a("./utils/common"),h=a("./utils/strings"),i=a("./zlib/constants"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=a("./zlib/gzheader"),m=function(a){this.options=g.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=f.inflateInit2(this.strm,b.windowBits);if(c!==i.Z_OK)throw new Error(j[c]);this.header=new l,f.inflateGetHeader(this.strm,this.header)};m.prototype.push=function(a,b){var c,d,e,j,k,l=this.strm,m=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?i.Z_FINISH:i.Z_NO_FLUSH,l.input="string"==typeof a?h.binstring2buf(a):a,l.next_in=0,l.avail_in=l.input.length;do{if(0===l.avail_out&&(l.output=new g.Buf8(m),l.next_out=0,l.avail_out=m),c=f.inflate(l,i.Z_NO_FLUSH),c!==i.Z_STREAM_END&&c!==i.Z_OK)return this.onEnd(c),this.ended=!0,!1;l.next_out&&(0===l.avail_out||c===i.Z_STREAM_END||0===l.avail_in&&d===i.Z_FINISH)&&("string"===this.options.to?(e=h.utf8border(l.output,l.next_out),j=l.next_out-e,k=h.buf2string(l.output,e),l.next_out=j,l.avail_out=m-j,j&&g.arraySet(l.output,l.output,e,j,0),this.onData(k)):this.onData(g.shrinkBuf(l.output,l.next_out)))}while(l.avail_in>0&&c!==i.Z_STREAM_END);return c===i.Z_STREAM_END&&(d=i.Z_FINISH),d===i.Z_FINISH?(c=f.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===i.Z_OK):!0},m.prototype.onData=function(a){this.chunks.push(a)},m.prototype.onEnd=function(a){a===i.Z_OK&&(this.result="string"===this.options.to?this.chunks.join(""):g.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=m,c.inflate=d,c.inflateRaw=e,c.ungzip=d},{"./utils/common":27,"./utils/strings":28,"./zlib/constants":30,"./zlib/gzheader":33,"./zlib/inflate.js":35,"./zlib/messages":37,"./zlib/zstream":39}],27:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;c>b;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;c>b;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],28:[function(a,b,c){"use strict";function d(a,b){if(65537>b&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;b>d;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;256>j;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=new e.Buf8(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;d>c;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;h>c;)if(f=a[c++],128>f)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&h>c;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:65536>f?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":27}],29:[function(a,b){"use strict";function c(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=c},{}],30:[function(a,b){b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],31:[function(a,b){"use strict";function c(){for(var a,b=[],c=0;256>c;c++){a=c;for(var d=0;8>d;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function d(a,b,c,d){var f=e,g=d+c;a=-1^a;for(var h=d;g>h;h++)a=a>>>8^f[255&(a^b[h])];return-1^a}var e=c();b.exports=d},{}],32:[function(a,b,c){"use strict";function d(a,b){return a.msg=G[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(C.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){D._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,C.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=E(a.adler,b,e,c):2===a.state.wrap&&(a.adler=F(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-jb?a.strstart-(a.w_size-jb):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ib,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&m>f);if(d=ib-(m-f),f=m-ib,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-jb)){C.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=hb)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+hb-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<hb)););}while(a.lookahead<jb&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===H)return sb;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return sb;if(a.strstart-a.block_start>=a.w_size-jb&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?sb:sb}function o(a,b){for(var c,d;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c)),a.match_length>=hb)if(d=D._tr_tally(a,a.strstart-a.match_start,a.match_length-hb),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=hb){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function p(a,b){for(var c,d,e;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=hb-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===S||a.match_length===hb&&a.strstart-a.match_start>4096)&&(a.match_length=hb-1)),a.prev_length>=hb&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-hb,d=D._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-hb),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=hb-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return sb}else if(a.match_available){if(d=D._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return sb}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=D._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ib){if(m(a),a.lookahead<=ib&&b===H)return sb;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=hb&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ib;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&f>e);a.match_length=ib-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=hb?(c=D._tr_tally(a,1,a.match_length-hb),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===H)return sb;break}if(a.match_length=0,c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function s(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=B[a.level].max_lazy,a.good_match=B[a.level].good_length,a.nice_match=B[a.level].nice_length,a.max_chain_length=B[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=hb-1,a.match_available=0,a.ins_h=0}function t(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Y,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new C.Buf16(2*fb),this.dyn_dtree=new C.Buf16(2*(2*db+1)),this.bl_tree=new C.Buf16(2*(2*eb+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new C.Buf16(gb+1),this.heap=new C.Buf16(2*cb+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new C.Buf16(2*cb+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function u(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=X,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?lb:qb,a.adler=2===b.wrap?0:1,b.last_flush=H,D._tr_init(b),M):d(a,O)}function v(a){var b=u(a);return b===M&&s(a.state),b}function w(a,b){return a&&a.state?2!==a.state.wrap?O:(a.state.gzhead=b,M):O}function x(a,b,c,e,f,g){if(!a)return O;var h=1;if(b===R&&(b=6),0>e?(h=0,e=-e):e>15&&(h=2,e-=16),1>f||f>Z||c!==Y||8>e||e>15||0>b||b>9||0>g||g>V)return d(a,O);8===e&&(e=9);var i=new t;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+hb-1)/hb),i.window=new C.Buf8(2*i.w_size),i.head=new C.Buf16(i.hash_size),i.prev=new C.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new C.Buf8(i.pending_buf_size),i.d_buf=i.lit_bufsize>>1,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,v(a)}function y(a,b){return x(a,b,Y,$,_,W)}function z(a,b){var c,h,k,l;if(!a||!a.state||b>L||0>b)return a?d(a,O):O;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===rb&&b!==K)return d(a,0===a.avail_out?Q:O);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===lb)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=F(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=mb):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,wb),h.status=qb);else{var m=Y+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=T||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=kb),m+=31-m%31,h.status=qb,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===mb)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=nb)}else h.status=nb;if(h.status===nb)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=ob)}else h.status=ob;if(h.status===ob)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=pb)}else h.status=pb;if(h.status===pb&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=qb)):h.status=qb),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,M}else if(0===a.avail_in&&e(b)<=e(c)&&b!==K)return d(a,Q);if(h.status===rb&&0!==a.avail_in)return d(a,Q);if(0!==a.avail_in||0!==h.lookahead||b!==H&&h.status!==rb){var o=h.strategy===T?r(h,b):h.strategy===U?q(h,b):B[h.level].func(h,b);if((o===ub||o===vb)&&(h.status=rb),o===sb||o===ub)return 0===a.avail_out&&(h.last_flush=-1),M;if(o===tb&&(b===I?D._tr_align(h):b!==L&&(D._tr_stored_block(h,0,0,!1),b===J&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,M}return b!==K?M:h.wrap<=0?N:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?M:N)}function A(a){var b;return a&&a.state?(b=a.state.status,b!==lb&&b!==mb&&b!==nb&&b!==ob&&b!==pb&&b!==qb&&b!==rb?d(a,O):(a.state=null,b===qb?d(a,P):M)):O}var B,C=a("../utils/common"),D=a("./trees"),E=a("./adler32"),F=a("./crc32"),G=a("./messages"),H=0,I=1,J=3,K=4,L=5,M=0,N=1,O=-2,P=-3,Q=-5,R=-1,S=1,T=2,U=3,V=4,W=0,X=2,Y=8,Z=9,$=15,_=8,ab=29,bb=256,cb=bb+1+ab,db=30,eb=19,fb=2*cb+1,gb=15,hb=3,ib=258,jb=ib+hb+1,kb=32,lb=42,mb=69,nb=73,ob=91,pb=103,qb=113,rb=666,sb=1,tb=2,ub=3,vb=4,wb=3,xb=function(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e};B=[new xb(0,0,0,0,n),new xb(4,4,8,4,o),new xb(4,5,16,8,o),new xb(4,6,32,32,o),new xb(4,4,16,16,p),new xb(8,16,32,32,p),new xb(8,16,128,128,p),new xb(8,32,128,256,p),new xb(32,128,258,1024,p),new xb(32,258,258,4096,p)],c.deflateInit=y,c.deflateInit2=x,c.deflateReset=v,c.deflateResetKeep=u,c.deflateSetHeader=w,c.deflate=z,c.deflateEnd=A,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./messages":37,"./trees":38}],33:[function(a,b){"use strict";function c(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=c},{}],34:[function(a,b){"use strict";var c=30,d=12;b.exports=function(a,b){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;e=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=e.dmax,l=e.wsize,m=e.whave,n=e.wnext,o=e.window,p=e.hold,q=e.bits,r=e.lencode,s=e.distcode,t=(1<<e.lenbits)-1,u=(1<<e.distbits)-1;a:do{15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){e.mode=d;break a}a.msg="invalid literal/length code",e.mode=c;break a}x=65535&v,w&=15,w&&(w>q&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",e.mode=c;break a}if(y=65535&v,w&=15,w>q&&(p+=B[f++]<<q,q+=8,w>q&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",e.mode=c;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&e.sane){a.msg="invalid distance too far back",e.mode=c;break a}if(z=0,A=o,0===n){if(z+=l-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(w>n){if(z+=l+n-w,w-=n,x>w){x-=w;do C[h++]=o[z++];while(--w);if(z=0,x>n){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(g>f&&j>h);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=g>f?5+(g-f):5-(f-g),a.avail_out=j>h?257+(j-h):257-(h-j),e.hold=p,e.bits=q}},{}],35:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=K,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new r.Buf32(ob),b.distcode=b.distdyn=new r.Buf32(pb),b.sane=1,b.back=-1,C):F}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):F}function h(a,b){var c,d;return a&&a.state?(d=a.state,0>b?(c=0,b=-b):(c=(b>>4)+1,48>b&&(b&=15)),b&&(8>b||b>15)?F:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):F}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==C&&(a.state=null),c):F}function j(a){return i(a,rb)}function k(a){if(sb){var b;for(p=new r.Buf32(512),q=new r.Buf32(32),b=0;144>b;)a.lens[b++]=8;for(;256>b;)a.lens[b++]=9;for(;280>b;)a.lens[b++]=7;for(;288>b;)a.lens[b++]=8;for(v(x,a.lens,0,288,p,0,a.work,{bits:9}),b=0;32>b;)a.lens[b++]=5;v(y,a.lens,0,32,q,0,a.work,{bits:5}),sb=!1}a.lencode=p,a.lenbits=9,a.distcode=q,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new r.Buf8(f.wsize)),d>=f.wsize?(r.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),r.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(r.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,ob,pb,qb,rb,sb,tb,ub,vb,wb,xb,yb,zb,Ab=0,Bb=new r.Buf8(4),Cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return F;c=a.state,c.mode===V&&(c.mode=W),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xb=C;a:for(;;)switch(c.mode){case K:if(0===c.wrap){c.mode=W;break}for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0),m=0,n=0,c.mode=L;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=lb;break}if((15&m)!==J){a.msg="unknown compression method",c.mode=lb;break}if(m>>>=4,n-=4,wb=(15&m)+8,0===c.wbits)c.wbits=wb;else if(wb>c.wbits){a.msg="invalid window size",c.mode=lb;break}c.dmax=1<<wb,a.adler=c.check=1,c.mode=512&m?T:V,m=0,n=0;break;case L:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==J){a.msg="unknown compression method",c.mode=lb;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=lb;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=M;case M:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,Bb[2]=m>>>16&255,Bb[3]=m>>>24&255,c.check=t(c.check,Bb,4,0)),m=0,n=0,c.mode=N;case N:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=O;case O:if(1024&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=P;case P:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wb=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),r.arraySet(c.head.extra,e,g,q,wb)),512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=Q;case Q:if(2048&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.name+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=R;case R:if(4096&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.comment+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.comment=null);c.mode=S;case S:if(512&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=lb;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=V;break;case T:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=U;case U:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,E;a.adler=c.check=1,c.mode=V;case V:if(b===A||b===B)break a;case W:if(c.last){m>>>=7&n,n-=7&n,c.mode=ib;break}for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=X;break;case 1:if(k(c),c.mode=bb,b===B){m>>>=2,n-=2;break a}break;case 2:c.mode=$;break;case 3:a.msg="invalid block type",c.mode=lb}m>>>=2,n-=2;break;case X:for(m>>>=7&n,n-=7&n;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=lb;break}if(c.length=65535&m,m=0,n=0,c.mode=Y,b===B)break a;case Y:c.mode=Z;case Z:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;r.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=V;break;case $:for(;14>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=lb;break}c.have=0,c.mode=_;case _:for(;c.have<c.ncode;){for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Cb[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Cb[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,yb={bits:c.lenbits},xb=v(w,c.lens,0,19,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid code lengths set",c.mode=lb;break}c.have=0,c.mode=ab;case ab:for(;c.have<c.nlen+c.ndist;){for(;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(16>sb)m>>>=qb,n-=qb,c.lens[c.have++]=sb;else{if(16===sb){for(zb=qb+2;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qb,n-=qb,0===c.have){a.msg="invalid bit length repeat",c.mode=lb;break}wb=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sb){for(zb=qb+3;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=3+(7&m),m>>>=3,n-=3}else{for(zb=qb+7;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=lb;break}for(;q--;)c.lens[c.have++]=wb}}if(c.mode===lb)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=lb;break}if(c.lenbits=9,yb={bits:c.lenbits},xb=v(x,c.lens,0,c.nlen,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid literal/lengths set",c.mode=lb;break}if(c.distbits=6,c.distcode=c.distdyn,yb={bits:c.distbits},xb=v(y,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,yb),c.distbits=yb.bits,xb){a.msg="invalid distances set",c.mode=lb;break}if(c.mode=bb,b===B)break a;case bb:c.mode=cb;case cb:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,u(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===V&&(c.back=-1);break}for(c.back=0;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(rb&&0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.lencode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,c.length=sb,0===rb){c.mode=hb;break}if(32&rb){c.back=-1,c.mode=V;break}if(64&rb){a.msg="invalid literal/length code",c.mode=lb;break}c.extra=15&rb,c.mode=db;case db:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=eb;case eb:for(;Ab=c.distcode[m&(1<<c.distbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.distcode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,64&rb){a.msg="invalid distance code",c.mode=lb;break}c.offset=sb,c.extra=15&rb,c.mode=fb;case fb:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=lb;break}c.mode=gb;case gb:if(0===j)break a;
if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=lb;break}q>c.wnext?(q-=c.wnext,ob=c.wsize-q):ob=c.wnext-q,q>c.length&&(q=c.length),pb=c.window}else pb=f,ob=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pb[ob++];while(--q);0===c.length&&(c.mode=cb);break;case hb:if(0===j)break a;f[h++]=c.length,j--,c.mode=cb;break;case ib:if(c.wrap){for(;32>n;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?t(c.check,f,p,h-p):s(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=lb;break}m=0,n=0}c.mode=jb;case jb:if(c.wrap&&c.flags){for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=lb;break}m=0,n=0}c.mode=kb;case kb:xb=D;break a;case lb:xb=G;break a;case mb:return H;case nb:default:return F}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<lb&&(c.mode<ib||b!==z))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=mb,H):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?t(c.check,f,p,a.next_out-p):s(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===V?128:0)+(c.mode===bb||c.mode===Y?256:0),(0===o&&0===p||b===z)&&xb===C&&(xb=I),xb)}function n(a){if(!a||!a.state)return F;var b=a.state;return b.window&&(b.window=null),a.state=null,C}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?F:(c.head=b,b.done=!1,C)):F}var p,q,r=a("../utils/common"),s=a("./adler32"),t=a("./crc32"),u=a("./inffast"),v=a("./inftrees"),w=0,x=1,y=2,z=4,A=5,B=6,C=0,D=1,E=2,F=-2,G=-3,H=-4,I=-5,J=8,K=1,L=2,M=3,N=4,O=5,P=6,Q=7,R=8,S=9,T=10,U=11,V=12,W=13,X=14,Y=15,Z=16,$=17,_=18,ab=19,bb=20,cb=21,db=22,eb=23,fb=24,gb=25,hb=26,ib=27,jb=28,kb=29,lb=30,mb=31,nb=32,ob=852,pb=592,qb=15,rb=qb,sb=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./inffast":34,"./inftrees":36}],36:[function(a,b){"use strict";var c=a("../utils/common"),d=15,e=852,f=592,g=0,h=1,i=2,j=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],k=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],l=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],m=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,n,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new c.Buf16(d+1),Q=new c.Buf16(d+1),R=null,S=0;for(D=0;d>=D;D++)P[D]=0;for(E=0;o>E;E++)P[b[n+E]]++;for(H=C,G=d;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;G>F&&0===P[F];F++);for(F>H&&(H=F),K=1,D=1;d>=D;D++)if(K<<=1,K-=P[D],0>K)return-1;if(K>0&&(a===g||1!==G))return-1;for(Q[1]=0,D=1;d>D;D++)Q[D+1]=Q[D]+P[D];for(E=0;o>E;E++)0!==b[n+E]&&(r[Q[b[n+E]]++]=E);if(a===g?(N=R=r,y=19):a===h?(N=j,O-=257,R=k,S-=257,y=256):(N=l,R=m,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===h&&L>e||a===i&&L>f)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[n+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;G>I+J&&(K-=P[I+J],!(0>=K));)I++,K<<=1;if(L+=1<<I,a===h&&L>e||a===i&&L>f)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":27}],37:[function(a,b){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],38:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a){return 256>a?gb[a]:gb[256+(a>>>7)]}function f(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function g(a,b,c){a.bi_valid>V-c?(a.bi_buf|=b<<a.bi_valid&65535,f(a,a.bi_buf),a.bi_buf=b>>V-a.bi_valid,a.bi_valid+=c-V):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function h(a,b,c){g(a,c[2*b],c[2*b+1])}function i(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function j(a){16===a.bi_valid?(f(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function k(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;U>=f;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;T>c;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function l(a,b,c){var d,e,f=new Array(U+1),g=0;for(d=1;U>=d;d++)f[d]=g=g+c[d-1]<<1;for(e=0;b>=e;e++){var h=a[2*e+1];0!==h&&(a[2*e]=i(f[h]++,h))}}function m(){var a,b,c,d,e,f=new Array(U+1);for(c=0,d=0;O-1>d;d++)for(ib[d]=c,a=0;a<1<<_[d];a++)hb[c++]=d;for(hb[c-1]=d,e=0,d=0;16>d;d++)for(jb[d]=e,a=0;a<1<<ab[d];a++)gb[e++]=d;for(e>>=7;R>d;d++)for(jb[d]=e<<7,a=0;a<1<<ab[d]-7;a++)gb[256+e++]=d;for(b=0;U>=b;b++)f[b]=0;for(a=0;143>=a;)eb[2*a+1]=8,a++,f[8]++;for(;255>=a;)eb[2*a+1]=9,a++,f[9]++;for(;279>=a;)eb[2*a+1]=7,a++,f[7]++;for(;287>=a;)eb[2*a+1]=8,a++,f[8]++;for(l(eb,Q+1,f),a=0;R>a;a++)fb[2*a+1]=5,fb[2*a]=i(a,5);kb=new nb(eb,_,P+1,Q,U),lb=new nb(fb,ab,0,R,U),mb=new nb(new Array(0),bb,0,S,W)}function n(a){var b;for(b=0;Q>b;b++)a.dyn_ltree[2*b]=0;for(b=0;R>b;b++)a.dyn_dtree[2*b]=0;for(b=0;S>b;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*X]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function o(a){a.bi_valid>8?f(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function p(a,b,c,d){o(a),d&&(f(a,c),f(a,~c)),E.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function q(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function r(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&q(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!q(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function s(a,b,c){var d,f,i,j,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],f=a.pending_buf[a.l_buf+k],k++,0===d?h(a,f,b):(i=hb[f],h(a,i+P+1,b),j=_[i],0!==j&&(f-=ib[i],g(a,f,j)),d--,i=e(d),h(a,i,c),j=ab[i],0!==j&&(d-=jb[i],g(a,d,j)));while(k<a.last_lit);h(a,X,b)}function t(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=T,c=0;i>c;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=2>j?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)r(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],r(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,r(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],k(a,b),l(f,j,a.bl_count)}function u(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;c>=d;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(j>h?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*Y]++):10>=h?a.bl_tree[2*Z]++:a.bl_tree[2*$]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function v(a,b,c){var d,e,f=-1,i=b[1],j=0,k=7,l=4;for(0===i&&(k=138,l=3),d=0;c>=d;d++)if(e=i,i=b[2*(d+1)+1],!(++j<k&&e===i)){if(l>j){do h(a,e,a.bl_tree);while(0!==--j)}else 0!==e?(e!==f&&(h(a,e,a.bl_tree),j--),h(a,Y,a.bl_tree),g(a,j-3,2)):10>=j?(h(a,Z,a.bl_tree),g(a,j-3,3)):(h(a,$,a.bl_tree),g(a,j-11,7));j=0,f=e,0===i?(k=138,l=3):e===i?(k=6,l=3):(k=7,l=4)}}function w(a){var b;for(u(a,a.dyn_ltree,a.l_desc.max_code),u(a,a.dyn_dtree,a.d_desc.max_code),t(a,a.bl_desc),b=S-1;b>=3&&0===a.bl_tree[2*cb[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function x(a,b,c,d){var e;for(g(a,b-257,5),g(a,c-1,5),g(a,d-4,4),e=0;d>e;e++)g(a,a.bl_tree[2*cb[e]+1],3);v(a,a.dyn_ltree,b-1),v(a,a.dyn_dtree,c-1)}function y(a){var b,c=4093624447;for(b=0;31>=b;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return G;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return H;for(b=32;P>b;b++)if(0!==a.dyn_ltree[2*b])return H;return G}function z(a){pb||(m(),pb=!0),a.l_desc=new ob(a.dyn_ltree,kb),a.d_desc=new ob(a.dyn_dtree,lb),a.bl_desc=new ob(a.bl_tree,mb),a.bi_buf=0,a.bi_valid=0,n(a)}function A(a,b,c,d){g(a,(J<<1)+(d?1:0),3),p(a,b,c,!0)}function B(a){g(a,K<<1,3),h(a,X,eb),j(a)}function C(a,b,c,d){var e,f,h=0;a.level>0?(a.strm.data_type===I&&(a.strm.data_type=y(a)),t(a,a.l_desc),t(a,a.d_desc),h=w(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,e>=f&&(e=f)):e=f=c+5,e>=c+4&&-1!==b?A(a,b,c,d):a.strategy===F||f===e?(g(a,(K<<1)+(d?1:0),3),s(a,eb,fb)):(g(a,(L<<1)+(d?1:0),3),x(a,a.l_desc.max_code+1,a.d_desc.max_code+1,h+1),s(a,a.dyn_ltree,a.dyn_dtree)),n(a),d&&o(a)}function D(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(hb[c]+P+1)]++,a.dyn_dtree[2*e(b)]++),a.last_lit===a.lit_bufsize-1}var E=a("../utils/common"),F=4,G=0,H=1,I=2,J=0,K=1,L=2,M=3,N=258,O=29,P=256,Q=P+1+O,R=30,S=19,T=2*Q+1,U=15,V=16,W=7,X=256,Y=16,Z=17,$=18,_=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ab=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],bb=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],db=512,eb=new Array(2*(Q+2));d(eb);var fb=new Array(2*R);d(fb);var gb=new Array(db);d(gb);var hb=new Array(N-M+1);d(hb);var ib=new Array(O);d(ib);var jb=new Array(R);d(jb);var kb,lb,mb,nb=function(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length},ob=function(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b},pb=!1;c._tr_init=z,c._tr_stored_block=A,c._tr_flush_block=C,c._tr_tally=D,c._tr_align=B},{"../utils/common":27}],39:[function(a,b){"use strict";function c(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=c},{}]},{},[9])(9)});

'use strict';
// Workaround for JSzip requiring window.
if (tr.isHeadless) {
  /**
   * Hack.
   */
  global.window = {};
}


'use strict';
// Workaround for JSzip requiring window.
if (tr.isHeadless) {
  /**
   * Hack.
   */
  global.JSZip = global.window.JSZip;
  global.window = undefined;
}


'use strict';

/**
 * @fileoverview Base class for trace data importers.
 */
tr.exportTo('tr.importer', function() {
  function Importer() { }

  Importer.prototype = {
    __proto__: Object.prototype,

    /**
     * Called by the Model to check whether the importer type stores the actual
     * trace data or just holds it as container for further extraction.
     */
    isTraceDataContainer: function() {
      return false;
    },

    /**
     * Called by the Model to extract one or more subtraces from the event data.
     */
    extractSubtraces: function() {
      return [];
    },

    /**
     * Called to import events into the Model.
     */
    importEvents: function() {
    },

    /**
     * Called to import sample data into the Model.
     */
    importSampleData: function() {
    },

    /**
     * Called by the Model after all other importers have imported their
     * events.
     */
    finalizeImport: function() {
    },

    /**
     * Called by the Model to join references between objects, after final
     * model bounds have been computed.
     */
    joinRefs: function() {
    }
  };


  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Importer;
  tr.b.decorateExtensionRegistry(Importer, options);

  Importer.findImporterFor = function(eventData) {
    var typeInfo = Importer.findTypeInfoMatching(function(ti) {
      return ti.constructor.canImport(eventData);
    });
    if (typeInfo)
      return typeInfo.constructor;
    return undefined;
  };

  return {
    Importer: Importer
  };
});


'use strict';

/**
 * @fileoverview GzipImporter inflates gzip compressed data and passes it along
 * to an actual importer.
 */
tr.exportTo('tr.e.importer', function() {
  var GZIP_MEMBER_HEADER_ID_SIZE = 3;

  var GZIP_HEADER_ID1 = 0x1f;
  var GZIP_HEADER_ID2 = 0x8b;
  var GZIP_DEFLATE_COMPRESSION = 8;

  function GzipImporter(model, eventData) {
    // Normalize the data into an Uint8Array.
    if (typeof(eventData) === 'string' || eventData instanceof String) {
      eventData = JSZip.utils.transformTo('uint8array', eventData);
    } else if (eventData instanceof ArrayBuffer) {
      eventData = new Uint8Array(eventData);
    } else
      throw new Error('Unknown gzip data format');
    this.model_ = model;
    this.gzipData_ = eventData;
  }

  /**
   * @param {eventData} Possibly gzip compressed data as a string or an
   *                    ArrayBuffer.
   * @return {boolean} Whether obj looks like gzip compressed data.
   */
  GzipImporter.canImport = function(eventData) {
    var header;
    if (eventData instanceof ArrayBuffer)
      header = new Uint8Array(eventData.slice(0, GZIP_MEMBER_HEADER_ID_SIZE));
    else if (typeof(eventData) === 'string' || eventData instanceof String) {
      header = eventData.substring(0, GZIP_MEMBER_HEADER_ID_SIZE);
      // Convert the string to a byteArray for correct value comparison.
      header = JSZip.utils.transformTo('uint8array', header);
    } else
      return false;
    return header[0] == GZIP_HEADER_ID1 &&
        header[1] == GZIP_HEADER_ID2 &&
        header[2] == GZIP_DEFLATE_COMPRESSION;
  };

  /**
   * Inflates (decompresses) the data stored in the given gzip bitstream.
   * @return {string} Inflated data.
   */
  GzipImporter.inflateGzipData_ = function(data) {
    var position = 0;

    function getByte() {
      if (position >= data.length)
        throw new Error('Unexpected end of gzip data');
      return data[position++];
    }

    function getWord() {
      var low = getByte();
      var high = getByte();
      return (high << 8) + low;
    }

    function skipBytes(amount) {
      position += amount;
    }

    function skipZeroTerminatedString() {
      while (getByte() != 0) {}
    }

    var id1 = getByte();
    var id2 = getByte();
    if (id1 !== GZIP_HEADER_ID1 || id2 !== GZIP_HEADER_ID2)
      throw new Error('Not gzip data');
    var compression_method = getByte();
    if (compression_method !== GZIP_DEFLATE_COMPRESSION)
      throw new Error('Unsupported compression method: ' + compression_method);
    var flags = getByte();
    var have_header_crc = flags & (1 << 1);
    var have_extra_fields = flags & (1 << 2);
    var have_file_name = flags & (1 << 3);
    var have_comment = flags & (1 << 4);

    // Skip modification time, extra flags and OS.
    skipBytes(4 + 1 + 1);

    // Skip remaining fields before compressed data.
    if (have_extra_fields) {
      var bytes_to_skip = getWord();
      skipBytes(bytes_to_skip);
    }
    if (have_file_name)
      skipZeroTerminatedString();
    if (have_comment)
      skipZeroTerminatedString();
    if (have_header_crc)
      getWord();

    // Inflate the data using jszip.
    var inflated_data =
        JSZip.compressions['DEFLATE'].uncompress(data.subarray(position));
    return JSZip.utils.transformTo('string', inflated_data);
  },

  GzipImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    /**
     * Called by the Model to check whether the importer just encapsulates
     * the actual trace data which needs to be imported by another importer.
     */
    isTraceDataContainer: function() {
      return true;
    },

    /**
     * Called by the Model to extract subtraces from the event data. The
     * subtraces are passed on to other importers that can recognize them.
     */
    extractSubtraces: function() {
      var eventData = GzipImporter.inflateGzipData_(this.gzipData_);
      return eventData ? [eventData] : [];
    }
  };

  tr.importer.Importer.register(GzipImporter);

  return {
    GzipImporter: GzipImporter
  };
});



'use strict';

/**
 * @fileoverview GcloudTraceImporter imports JSON data from Google Cloud Trace.
 */
tr.exportTo('tr.e.importer.gcloud_trace', function() {
  function GcloudTraceImporter(model, eventData) {
    this.importPriority = 2;
    this.eventData_ = eventData;
  }

  /**
   * @return {boolean} Whether obj looks like the JSON output from Cloud Trace.
   */
  GcloudTraceImporter.canImport = function(eventData) {
    if (typeof(eventData) !== 'string' && !(eventData instanceof String))
      return false;

    // Slice the data so we don't potentially do a replace on a gigantic string.
    var normalizedEventData = eventData.slice(0, 20).replace(/\s/g, '');
    if (normalizedEventData.length < 14)
      return false;

    return normalizedEventData.slice(0, 14) == '{"projectId":"';
  };

  GcloudTraceImporter.prototype = {

    __proto__: tr.importer.Importer.prototype,

    /**
     * Called by the Model to extract subtraces from the event data. The
     * subtraces are passed on to other importers that can recognize them.
     */
    extractSubtraces: function() {
      var traceEvents = this.createEventsForTrace();
      return traceEvents ? [traceEvents] : [];
    },

    createEventsForTrace: function() {
      var events = [];
      var trace = JSON.parse(this.eventData_);
      var spanLength = trace.spans.length;
      for (var i = 0; i < spanLength; i++) {
        events.push(this.createEventForSpan(trace.traceId, trace.spans[i]));
      }
      return {
        'traceEvents': events
      };
    },

    createEventForSpan: function(traceId, span) {
      var newArgs = {};
      if (span.labels) {
        newArgs = JSON.parse(JSON.stringify(span.labels));
      }
      newArgs['Span ID'] = span.spanId;
      newArgs['Start Time'] = span.startTime;
      newArgs['End Time'] = span.endTime;
      if (span.parentSpanId) {
        newArgs['Parent Span ID'] = span.parentSpanId;
      }
      // The timestamps are ISO-standard strings, which are parsed to millis,
      // then converted to the micros that the trace viewer expects.
      return {
        name: span.name,
        args: newArgs,
        pid: traceId,
        ts: Date.parse(span.startTime) * 1000,
        dur: (Date.parse(span.endTime) - Date.parse(span.startTime)) * 1000,
        cat: 'tracespan',
        tid: traceId,
        ph: 'X'
      };
    }
  };

  tr.importer.Importer.register(GcloudTraceImporter);

  return {
    GcloudTraceImporter: GcloudTraceImporter
  };
});


'use strict';

/**
 * @fileoverview Base class for trace data importers.
 */
tr.exportTo('tr.importer', function() {
  /**
   * Importer for empty strings and arrays.
   * @constructor
   */
  function EmptyImporter(events) {
    this.importPriority = 0;
  };

  EmptyImporter.canImport = function(eventData) {
    if (eventData instanceof Array && eventData.length == 0)
      return true;
    if (typeof(eventData) === 'string' || eventData instanceof String) {
      return eventData.length == 0;
    }
    return false;
  };

  EmptyImporter.prototype = {
    __proto__: tr.importer.Importer.prototype
  };

  tr.importer.Importer.register(EmptyImporter);

  return {
    EmptyImporter: EmptyImporter
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  function ImportOptions() {
    this.shiftWorldToZero = true;
    this.pruneEmptyContainers = true;
    this.showImportWarnings = true;

    // Callback called after
    // importers run in which more data can be added to the model, before it is
    // finalized.
    this.customizeModelCallback = undefined;

    var auditorTypes = tr.c.Auditor.getAllRegisteredTypeInfos();
    this.auditorConstructors = auditorTypes.map(function(typeInfo) {
      return typeInfo.constructor;
    });
  }

  function Import(model, opt_options) {
    if (model === undefined)
      throw new Error('Must provide model to import into.');

    // TODO(dsinclair): Check the model is empty.

    this.importing_ = false;
    this.importOptions_ = opt_options || new ImportOptions();

    this.model_ = model;
    this.model_.importOptions = this.importOptions_;
  }

  Import.prototype = {
    __proto__: Object.prototype,

    /**
     * Imports the provided traces into the model. The eventData type
     * is undefined and will be passed to all the importers registered
     * via Importer.register. The first importer that returns true
     * for canImport(events) will be used to import the events.
     *
     * The primary trace is provided via the eventData variable. If multiple
     * traces are to be imported, specify the first one as events, and the
     * remainder in the opt_additionalEventData array.
     *
     * @param {Array} traces An array of eventData to be imported. Each
     * eventData should correspond to a single trace file and will be handled by
     * a separate importer.
     */
    importTraces: function(traces) {
      var progressMeter = {
        update: function(msg) {}
      };

      tr.b.Task.RunSynchronously(
          this.createImportTracesTask(progressMeter, traces));
    },

    /**
     * Imports a trace with the usual options from importTraces, but
     * does so using idle callbacks, putting up an import dialog
     * during the import process.
     */
    importTracesWithProgressDialog: function(traces) {
      if (tr.isHeadless)
        throw new Error('Cannot use this method in headless mode.');

      var overlay = tr.ui.b.Overlay();
      overlay.title = 'Importing...';
      overlay.userCanClose = false;
      overlay.msgEl = document.createElement('div');
      overlay.appendChild(overlay.msgEl);
      overlay.msgEl.style.margin = '20px';
      overlay.update = function(msg) {
        this.msgEl.textContent = msg;
      }
      overlay.visible = true;

      var promise =
          tr.b.Task.RunWhenIdle(this.createImportTracesTask(overlay, traces));
      promise.then(
          function() { overlay.visible = false; },
          function(err) { overlay.visible = false; }
      );
      return promise;
    },

    /**
     * Creates a task that will import the provided traces into the model,
     * updating the progressMeter as it goes. Parameters are as defined in
     * importTraces.
     */
    createImportTracesTask: function(progressMeter, traces) {
      if (this.importing_)
        throw new Error('Already importing.');
      this.importing_ = true;

      // Just some simple setup. It is useful to have a no-op first
      // task so that we can set up the lastTask = lastTask.after()
      // pattern that follows.
      var importTask = new tr.b.Task(function() {
        progressMeter.update('I will now import your traces for you...');
      }, this);
      var lastTask = importTask;

      var importers = [];

      lastTask = lastTask.after(function() {
        // Copy the traces array, we may mutate it.
        traces = traces.slice(0);
        progressMeter.update('Creating importers...');
        // Figure out which importers to use.
        for (var i = 0; i < traces.length; ++i)
          importers.push(this.createImporter_(traces[i]));

        // Some traces have other traces inside them. Before doing the full
        // import, ask the importer if it has any subtraces, and if so, create
        // importers for them, also.
        for (var i = 0; i < importers.length; i++) {
          var subtraces = importers[i].extractSubtraces();
          for (var j = 0; j < subtraces.length; j++) {
            try {
              traces.push(subtraces[j]);
              importers.push(this.createImporter_(subtraces[j]));
            } catch (error) {
              // TODO(kphanee): Log the subtrace file which has failed.
              console.warn(error.name + ': ' + error.message);
              continue;
            }
          }
        }

        if (traces.length && !this.hasEventDataDecoder_(importers)) {
          throw new Error(
              'Could not find an importer for the provided eventData.');
        }

        // Sort them on priority. This ensures importing happens in a
        // predictable order, e.g. ftrace_importer before
        // trace_event_importer.
        importers.sort(function(x, y) {
          return x.importPriority - y.importPriority;
        });
      }, this);

      // Run the import.
      lastTask = lastTask.after(function(task) {
        importers.forEach(function(importer, index) {
          task.subTask(function() {
            progressMeter.update(
                'Importing ' + (index + 1) + ' of ' + importers.length);
            importer.importEvents();
          }, this);
        }, this);
      }, this);

      // Run the cusomizeModelCallback if needed.
      if (this.importOptions_.customizeModelCallback) {
        lastTask = lastTask.after(function(task) {
          this.importOptions_.customizeModelCallback(this.model_);
        }, this);
      }

      // Import sample data.
      lastTask = lastTask.after(function(task) {
        importers.forEach(function(importer, index) {
          progressMeter.update(
              'Importing sample data ' + (index + 1) + '/' + importers.length);
          importer.importSampleData();
        }, this);
      }, this);

      // Autoclose open slices and create subSlices.
      lastTask = lastTask.after(function() {
        progressMeter.update('Autoclosing open slices...');
        this.model_.autoCloseOpenSlices();
        this.model_.createSubSlices();
      }, this);

      // Finalize import.
      lastTask = lastTask.after(function(task) {
        importers.forEach(function(importer, index) {
          progressMeter.update(
              'Finalizing import ' + (index + 1) + '/' + importers.length);
          importer.finalizeImport();
        }, this);
      }, this);

      // Run preinit.
      lastTask = lastTask.after(function() {
        progressMeter.update('Initializing objects (step 1/2)...');
        this.model_.preInitializeObjects();
      }, this);

      // Prune empty containers.
      if (this.importOptions_.pruneEmptyContainers) {
        lastTask = lastTask.after(function() {
          progressMeter.update('Pruning empty containers...');
          this.model_.pruneEmptyContainers();
        }, this);
      }

      // Merge kernel and userland slices on each thread.
      lastTask = lastTask.after(function() {
        progressMeter.update('Merging kernel with userland...');
        this.model_.mergeKernelWithUserland();
      }, this);

      // Create auditors
      var auditors = [];
      lastTask = lastTask.after(function() {
        progressMeter.update('Adding arbitrary data to model...');
        auditors = this.importOptions_.auditorConstructors.map(
          function(auditorConstructor) {
            return new auditorConstructor(this.model_);
          }, this);
        auditors.forEach(function(auditor) {
          auditor.runAnnotate();
        });
      }, this);

      lastTask = lastTask.after(function() {
        progressMeter.update('Computing final world bounds...');
        this.model_.computeWorldBounds(this.importOptions_.shiftWorldToZero);
      }, this);

      // Build the flow event interval tree.
      lastTask = lastTask.after(function() {
        progressMeter.update('Building flow event map...');
        this.model_.buildFlowEventIntervalTree();
      }, this);

      // Join refs.
      lastTask = lastTask.after(function() {
        progressMeter.update('Joining object refs...');
        for (var i = 0; i < importers.length; i++)
          importers[i].joinRefs();
      }, this);

      // Delete any undeleted objects.
      lastTask = lastTask.after(function() {
        progressMeter.update('Cleaning up undeleted objects...');
        this.model_.cleanupUndeletedObjects();
      }, this);

      // Sort global and process memory dumps.
      lastTask = lastTask.after(function() {
        progressMeter.update('Sorting memory dumps...');
        this.model_.sortMemoryDumps();
      }, this);

      // Calculate memory dump graph attributes.
      lastTask = lastTask.after(function() {
        progressMeter.update('Calculating memory dump graph attributes...');
        this.model_.calculateMemoryGraphAttributes();
      }, this);

      // Run initializers.
      lastTask = lastTask.after(function() {
        progressMeter.update('Initializing objects (step 2/2)...');
        this.model_.initializeObjects();
      }, this);

      // Build event indices mapping from an event id to all flow events.
      lastTask = lastTask.after(function() {
        progressMeter.update('Building flow event indices...');
        this.model_.buildEventIndices();
      }, this);

      // Run audits.
      lastTask = lastTask.after(function() {
        progressMeter.update('Running auditors...');
        auditors.forEach(function(auditor) {
          auditor.runAudit();
        });
      }, this);

      lastTask = lastTask.after(function() {
        progressMeter.update('Updating interaction records...');
        this.model_.sortInteractionRecords();
      }, this);

      lastTask = lastTask.after(function() {
        progressMeter.update('Updating alerts...');
        this.model_.sortAlerts();
      }, this);

      lastTask = lastTask.after(function() {
        progressMeter.update('Update bounds...');
        this.model_.updateBounds();
      }, this);

      // Cleanup.
      lastTask.after(function() {
        this.importing_ = false;
      }, this);
      return importTask;
    },

    createImporter_: function(eventData) {
      var importerConstructor = tr.importer.Importer.findImporterFor(eventData);
      if (!importerConstructor) {
        throw new Error('Couldn\'t create an importer for the provided ' +
                        'eventData.');
      }
      return new importerConstructor(this.model_, eventData);
    },

    hasEventDataDecoder_: function(importers) {
      if (importers.length === 0)
        return false;

      for (var i = 0; i < importers.length; ++i) {
        if (!importers[i].isTraceDataContainer())
          return true;
      }
      return false;
    }
  };

  return {
    ImportOptions: ImportOptions,
    Import: Import
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  /**
   * @constructor
   */
  function SimpleLineReader(text) {
    this.lines_ = text.split('\n');
    this.curLine_ = 0;

    this.savedLines_ = undefined;
  }

  SimpleLineReader.prototype = {
    advanceToLineMatching: function(regex) {
      for (; this.curLine_ < this.lines_.length; this.curLine_++) {
        var line = this.lines_[this.curLine_];
        if (this.savedLines_ !== undefined)
          this.savedLines_.push(line);
        if (regex.test(line))
          return true;
      }
      return false;
    },

    get curLineNumber() {
      return this.curLine_;
    },

    beginSavingLines: function() {
      this.savedLines_ = [];
    },

    endSavingLinesAndGetResult: function() {
      var tmp = this.savedLines_;
      this.savedLines_ = undefined;
      return tmp;
    }
  };

  return {
    SimpleLineReader: SimpleLineReader
  };
});


'use strict';

/**
 * @fileoverview Class representing a user activity that is running
 * in the process.
 * On the Android platform, activities are mapped to Android Activities
 * running in the foreground of the process.
 * On Windows/OS X this could for example represent
 * the currently active window of the process.
 */
tr.exportTo('tr.model', function() {
  /**
   * @constructor
   * @param {String} name Name of the activity
   * @param {String} category Category of the activities
   * @param {String} range The time range where the activity was running
   * @param {String} args Additional arguments
   */
  function Activity(name, category, range, args) {
    tr.model.TimedEvent.call(this, range.min);
    this.title = name;
    this.category = category;
    this.colorId = tr.ui.b.getColorIdForGeneralPurposeString(name);
    this.duration = range.duration;
    this.args = args;
    this.name = name;
  };

  Activity.prototype = {
     __proto__: tr.model.TimedEvent.prototype,

    shiftTimestampsForward: function(amount) {
      this.start += amount;
    },

    addBoundsToRange: function(range) {
      range.addValue(this.start);
      range.addValue(this.end);
    }
  };
  return {
    Activity: Activity
  };
});


/**
 * @fileoverview Imports android event log data into the trace model.
 * Android event log data contains information about activities that
 * are launched/paused, processes that are started, memory usage, etc.
 *
 * The current implementation only parses activity events, with the goal of
 * determining which Activity is running in the foreground for a process.
 *
 * This importer assumes the events arrive as a string. The unit tests provide
 * examples of the trace format.
 */
'use strict';

tr.exportTo('tr.e.importer.android', function() {
  var Importer = tr.importer.Importer;

  var ACTIVITY_STATE = {
    NONE: 'none',
    CREATED: 'created',
    STARTED: 'started',
    RESUMED: 'resumed',
    PAUSED: 'paused',
    STOPPED: 'stopped',
    DESTROYED: 'destroyed'
  };

  var activityMap = {};

  /**
   * Imports android event log data (adb logcat -b events)
   * @constructor
   */
  function EventLogImporter(model, events) {
     this.model_ = model;
     this.events_ = events;
     this.importPriority = 3;
  }

  // Generic format of event log entries.
  // Sample event log entry that this matches (split over 2 lines):
  // 08-11 13:12:31.405   880  2645 I am_focused_activity: [0,com.google.android.googlequicksearchbox/com.google.android.launcher.GEL] // @suppress longLineCheck
  var eventLogActivityRE = new RegExp(
      '(\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d+)' +
      '\\s+(\\d+)\\s+(\\d+)\\s+([A-Z])\\s*' +
      '(am_\\w+)\\s*:(.*)');

  // 08-28 03:58:21.834   888  3177 I am_create_activity: [0,5972200,30,com.nxp.taginfolite/.activities.MainView,android.intent.action.MAIN,NULL,NULL,270532608] // @suppress longLineCheck
  // Store the name of the created activity only
  var amCreateRE = new RegExp('\s*\\[.*,.*,.*,(.*),.*,.*,.*,.*\\]');

  // 07-22 12:22:19.504   920  2504 I am_focused_activity: [0,com.android.systemui/.recents.RecentsActivity] // @suppress longLineCheck
  //Store the name of the focused activity only
  var amFocusedRE = new RegExp('\s*\\[\\d+,(.*)\\]');

  // 07-21 19:56:12.315   920  2261 I am_proc_start: [0,19942,10062,com.google.android.talk,broadcast,com.google.android.talk/com.google.android.apps.hangouts.realtimechat.RealTimeChatService$AlarmReceiver] // @suppress longLineCheck
  // We care about proc starts on behalf of activities, and store the activity
  var amProcStartRE = new RegExp('\s*\\[\\d+,\\d+,\\d+,.*,activity,(.*)\\]');

  // 07-22 12:21:43.490  2893  2893 I am_on_resume_called: [0,com.google.android.launcher.GEL] // @suppress longLineCheck
  // Store the activity name only
  var amOnResumeRE = new RegExp('\s*\\[\\d+,(.*)\\]');

  // 07-22 12:22:19.545  2893  2893 I am_on_paused_called: [0,com.google.android.launcher.GEL] // @suppress longLineCheck
  // Store the activity name only
  var amOnPauseRE = new RegExp('\s*\\[\\d+,(.*)\\]');

  // 08-28 03:51:54.456   888   907 I am_activity_launch_time: [0,185307115,com.google.android.googlequicksearchbox/com.google.android.launcher.GEL,1174,1174] // @suppress longLineCheck
  // Store the activity name and launch times
  var amLaunchTimeRE = new RegExp('\s*\\[\\d+,\\d+,(.*),(\\d+),(\\d+)');

  // 08-28 03:58:15.854   888   902 I am_destroy_activity: [0,203516597,29,com.android.chrome/com.google.android.apps.chrome.Main,finish-idle] // @suppress longLineCheck
  // Store the activity name only
  var amDestroyRE = new RegExp('\s*\\[\\d+,\\d+,\\d+,(.*)\\]');

  /**
   * @return {boolean} True when events is an android event log array.
   */
  EventLogImporter.canImport = function(events) {
    if (!(typeof(events) === 'string' || events instanceof String))
      return false;

    return eventLogActivityRE.test(events);
  };

  EventLogImporter.prototype = {
    __proto__: Importer.prototype,

    get model() {
      return this.model_;
    },

    /**
     * @return {string} the full activity name (including package) from
     * a component
     */
    getFullActivityName: function(component) {
      var componentSplit = component.split('/');
      if (componentSplit[1].startsWith('.'))
         return componentSplit[0] + componentSplit[1];

      return componentSplit[1];
    },

    /**
     * @return {string} the process name of a component
     */
    getProcName: function(component) {
      var componentSplit = component.split('/');
      return componentSplit[0];
    },

    findOrCreateActivity: function(activityName) {
      if (activityName in activityMap)
        return activityMap[activityName];
      var activity = {
        state: ACTIVITY_STATE.NONE,
        name: activityName
      };
      activityMap[activityName] = activity;
      return activity;
    },

    deleteActivity: function(activityName) {
      delete activityMap[activityName];
    },

    handleCreateActivity: function(ts, activityName) {
      var activity = this.findOrCreateActivity(activityName);
      activity.state = ACTIVITY_STATE.CREATED;
      activity.createdTs = ts;
    },

    handleFocusActivity: function(ts, procName, activityName) {
      var activity = this.findOrCreateActivity(activityName);
      activity.lastFocusedTs = ts;
    },

    handleProcStartForActivity: function(ts, activityName) {
      var activity = this.findOrCreateActivity(activityName);
      activity.procStartTs = ts;
    },

    handleOnResumeCalled: function(ts, pid, activityName) {
      var activity = this.findOrCreateActivity(activityName);
      activity.state = ACTIVITY_STATE.RESUMED;
      activity.lastResumeTs = ts;
      // on_resume_called shows the actual PID; use this
      // to link the activity up with a process later
      activity.pid = pid;
    },

    handleOnPauseCalled: function(ts, activityName) {
      var activity = this.findOrCreateActivity(activityName);
      activity.state = ACTIVITY_STATE.PAUSED;
      activity.lastPauseTs = ts;
      // Create a new AndroidActivity representing the foreground state,
      // but only if the pause happened within the model bounds
      if (ts > this.model_.bounds.min && ts < this.model_.bounds.max)
        this.addActivityToProcess(activity);
    },

    handleLaunchTime: function(ts, activityName, launchTime) {
      var activity = this.findOrCreateActivity(activityName);
      activity.launchTime = launchTime;
    },

    handleDestroyActivity: function(ts, activityName) {
      this.deleteActivity(activityName);
    },

    addActivityToProcess: function(activity) {
      if (activity.pid === undefined)
        return;
      var process = this.model_.getOrCreateProcess(activity.pid);
      // The range of the activity is the time from resume to time
      // of pause; limit the start time to the beginning of the model
      var range = tr.b.Range.fromExplicitRange(
          Math.max(this.model_.bounds.min, activity.lastResumeTs),
          activity.lastPauseTs);
      var newActivity = new tr.model.Activity(activity.name,
          'Android Activity', range,
          {created: activity.createdTs,
           procstart: activity.procStartTs,
           lastfocus: activity.lastFocusedTs});
      process.activities.push(newActivity);
    },

    parseAmLine_: function(line) {
      var match = eventLogActivityRE.exec(line);
      if (!match)
        return;

      // Possible activity life-cycles:
      // 1) Launch from scratch:
      //   - am_create_activity
      //   - am_focused_activity
      //   - am_proc_start
      //   - am_proc_bound
      //   - am_restart_activity
      //   - am_on_resume_called
      // 2) Re-open existing activity
      //   - am_focused_activity
      //   - am_on_resume_called

      // HACK: event log date format is "MM-DD" and doesn't contain the year;
      // to figure out the year, take the min bound of the model, convert
      // to real-time and use that as the year.
      // The Android event log will eventually contain the year once this
      // CL is in a release:
      // https://android-review.googlesource.com/#/c/168900
      var first_realtime_ts = this.model_.bounds.min -
          this.model_.realtime_to_monotonic_offset_ms;
      var year = new Date(first_realtime_ts).getFullYear();
      var ts = match[1].substring(0, 5) + '-' + year + ' ' +
          match[1].substring(5, match[1].length);

      var monotonic_ts = Date.parse(ts) +
          this.model_.realtime_to_monotonic_offset_ms;

      var pid = match[2];
      var action = match[5];
      var data = match[6];

      if (action === 'am_create_activity') {
        match = amCreateRE.exec(data);
        if (match && match.length >= 2) {
          this.handleCreateActivity(monotonic_ts,
              this.getFullActivityName(match[1]));
        }
      } else if (action === 'am_focused_activity') {
        match = amFocusedRE.exec(data);
        if (match && match.length >= 2) {
          this.handleFocusActivity(monotonic_ts,
              this.getProcName(match[1]), this.getFullActivityName(match[1]));
        }
      } else if (action === 'am_proc_start') {
        match = amProcStartRE.exec(data);
        if (match && match.length >= 2) {
          this.handleProcStartForActivity(monotonic_ts,
              this.getFullActivityName(match[1]));
        }
      } else if (action === 'am_on_resume_called') {
        match = amOnResumeRE.exec(data);
        if (match && match.length >= 2)
          this.handleOnResumeCalled(monotonic_ts, pid, match[1]);
      } else if (action === 'am_on_paused_called') {
        match = amOnPauseRE.exec(data);
        if (match && match.length >= 2)
          this.handleOnPauseCalled(monotonic_ts, match[1]);
      } else if (action === 'am_activity_launch_time') {
        match = amLaunchTimeRE.exec(data);
        this.handleLaunchTime(monotonic_ts,
            this.getFullActivityName(match[1]), match[2]);
      } else if (action === 'am_destroy_activity') {
        match = amDestroyRE.exec(data);
        if (match && match.length == 2) {
          this.handleDestroyActivity(monotonic_ts,
             this.getFullActivityName(match[1]));
        }
      }
    },

    importEvents: function(isSecondaryImport) {
      // Check if we have a mapping from real-time to CLOCK_MONOTONIC
      if (isNaN(this.model_.realtime_to_monotonic_offset_ms)) {
        this.model_.importWarning({
          type: 'eveng_log_clock_sync',
          message: 'Need a trace_event_clock_sync to map realtime to import.'
        });
        return;
      }
      // Since the event log typically spans a much larger timeframe
      // than the ftrace data, we want to calculate the bounds of the existing
      // model, and dump all event log data outside of those bounds
      this.model_.updateBounds();

      var lines = this.events_.split('\n');
      lines.forEach(this.parseAmLine_, this);

      // Iterate over all created activities that are not destroyed yet
      for (var activityName in activityMap) {
        var activity = activityMap[activityName];
        // If we're still in the foreground, store the activity anyway
        if (activity.state == ACTIVITY_STATE.RESUMED) {
          // Set the pause timestamp to the end of the model bounds
          activity.lastPauseTs = this.model_.bounds.max;
          this.addActivityToProcess(activity);
        }
      }
    }
  };

  Importer.register(EventLogImporter);

  return {
    EventLogImporter: EventLogImporter
  };
});


/**
 * @fileoverview Imports text files in the BattOr format into the
 * Model. This format is output by the BattOr executable.
 *
 * This importer assumes the events arrive as a string. The unit tests provide
 * examples of the trace format.
 */
'use strict';

tr.exportTo('tr.e.importer.battor', function() {
  /**
   * Imports linux perf events into a specified model.
   * @constructor
   */
  function BattorImporter(model, events) {
    this.importPriority = 3; // runs after the linux_perf importer
    this.sampleRate_ = undefined;
    this.model_ = model;
    this.events_ = events;
  }

  var TestExports = {};

  var battorDataLineRE = /^(\d+\.\d+)\s+(\d+\.\d+)\s+(\d+\.\d+)$/;
  var battorHeaderLineRE = /^# BattOr/;
  var sampleRateLineRE = /^# sample_rate=(\d+)Hz/;

  /**
   * Guesses whether the provided events is a BattOr string.
   * Looks for the magic string "# BattOr" at the start of the file,
   *
   * @return {boolean} True when events is a BattOr array.
   */
  BattorImporter.canImport = function(events) {
    if (!(typeof(events) === 'string' || events instanceof String))
      return false;

    return battorHeaderLineRE.test(events);
  };

  BattorImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get model() {
      return this.model_;
    },

    /**
     * Imports the data in this.events_ into model_.
     */
    importEvents: function(isSecondaryImport) {
      // Fail if the model already has a Power counter.
      if (this.model_.device.powerSeries) {
        this.model_.importWarning({
          type: 'import_error',
          message: 'Power counter exists, can not import BattOr power trace.'
        });
        return;
      }

      // Create series and import power samples into it.
      var name = 'power';
      var series = new tr.model.PowerSeries(this.model_.device);
      this.importPowerSamples(series);

      // Find the sync markers.
      var syncMarks = this.model_.getClockSyncRecordsNamed('battor');
      if (syncMarks.length < 1) {
        this.model_.importWarning({
          type: 'clock_sync',
          message: 'Cannot import BattOr power trace without a sync signal.'
        });
        return;
      }

      // Try each of the clock sync techinques in order of their accuracy.
      var shiftTs = this.correlationClockSync(syncMarks, series);

      if (shiftTs === undefined) {
        this.model_.importWarning({
          type: 'clock_sync',
          message: 'All of the BattOr power trace clock sync techinques failed.'
        });
        return;
      }

      series.shiftTimestampsForward(shiftTs);
      this.model_.device.powerSeries = series;
    },

    /**
     * Walks the events and populates a time series with power samples.
     */
    importPowerSamples: function(series) {
      var lines = this.events_.split('\n');

      // Update the model's bounds.
      this.model_.updateBounds();
      var minTs = 0;
      if (this.model_.bounds.min !== undefined)
        minTs = this.model_.bounds.min;

      lines.forEach(function(line) {
        line = line.trim();
        if (line.length === 0)
          return;

        if (/^#/.test(line)) {
          // Parse sample rate.
          groups = sampleRateLineRE.exec(line);
          if (!groups)
            return;
          this.sampleRate_ = parseInt(groups[1]);
        } else {
          // Parse power sample.
          var groups = battorDataLineRE.exec(line);
          if (!groups) {
            this.model_.importWarning({
              type: 'parse_error',
              message: 'Unrecognized line: ' + line
            });
            return;
          }

          var time = parseFloat(groups[1]) + minTs;
          var voltage_mV = parseFloat(groups[2]);
          var current_mA = parseFloat(groups[3]);
          series.addPowerSample(time, (voltage_mV * current_mA) / 1000);
        }
      }, this);
    },

    correlationClockSync: function(syncMarks, series) {
      // Find the regulator counter for the sync.
      var syncCtr = this.model_.kernel.counters[
          'null.vreg ' + syncMarks[0].args['regulator'] + ' enabled'];
      if (syncCtr === undefined) {
        this.model_.importWarning({
          type: 'clock_sync',
          message: 'Cannot correlate BattOr power trace without sync vreg.'
        });
        return undefined;
      }

      // Store the sync events from the regulator counter.
      var syncEvents = [];
      var firstSyncEventTs = undefined;
      syncCtr.series[0].iterateAllEvents(function(event) {
        if (event.timestamp >= syncMarks[0].ts &&
            event.timestamp <= syncMarks[1].ts) {
          if (firstSyncEventTs === undefined)
            firstSyncEventTs = event.timestamp;
          var newEvent = {
              'ts': (event.timestamp - firstSyncEventTs) / 1000, // msec -> sec
              'val': event.value};
          syncEvents.push(newEvent);
        }
      });

      // Generate samples from sync events to be cross-correlated with power.
      var syncSamples = [];
      var syncNumSamples = Math.ceil(
          syncEvents[syncEvents.length - 1].ts * this.sampleRate_
      );

      for (var i = 1; i < syncEvents.length; i++) {
        var sampleStartIdx = Math.ceil(
            syncEvents[i - 1].ts * this.sampleRate_
        );
        var sampleEndIdx = Math.ceil(
            syncEvents[i].ts * this.sampleRate_
        );

        for (var j = sampleStartIdx; j < sampleEndIdx; j++) {
          syncSamples[j] = syncEvents[i - 1].val;
        }
      }

      // TODO(aschulman) Low-pass the samples to improve the cross-correlation.

      var powerSamples = series.samples;
      // Check to make sure there are enough power samples.
      if (powerSamples.length < syncSamples.length) {
        this.model_.importWarning({
          type: 'not_enough_samples',
          message: 'Not enough power samples to correlate with sync signal.'
        });
        return undefined;
      }

      // Cross-correlate the ground truth with the last 5s of power samples.
      var maxShift = powerSamples.length - syncSamples.length;
      var minShift = 0;
      var corrNumSamples = this.sampleRate_ * 5.0;
      if (powerSamples.length > corrNumSamples)
        minShift = powerSamples.length - corrNumSamples;

      var corr = [];
      for (var shift = minShift; shift <= maxShift; shift++) {
        var corrSum = 0;
        var powerAvg = 0;
        for (var i = 0; i < syncSamples.length; i++) {
          corrSum += (powerSamples[i + shift].power * syncSamples[i]);
          powerAvg += powerSamples[i + shift].power;
        }
        powerAvg = powerAvg / syncSamples.length;
        corr.push(corrSum / powerAvg);
      }

      // Find the sync start time (peak of the cross-correlation).
      var corrPeakIdx = 0;
      var corrPeak = 0;
      for (var i = 0; i < powerSamples.length; i++) {
        if (corr[i] > corrPeak) {
          corrPeak = corr[i];
          corrPeakIdx = i;
        }
      }

      // Shift the time of the power samples by the recovered sync start time.
      var corrPeakTs = ((minShift + corrPeakIdx) / this.sampleRate_);
      corrPeakTs *= 1000; // sec -> msec
      var syncStartTs = firstSyncEventTs - this.model_.bounds.min;
      var shiftTs = syncStartTs - corrPeakTs;

      return shiftTs;
    }
  };

  tr.importer.Importer.register(BattorImporter);

  return {
    BattorImporter: BattorImporter,
    _BattorImporterTestExports: TestExports
  };
});



/**
 * @fileoverview Blah.
 */
'use strict';

tr.exportTo('tr.e.importer.ddms', function() {
  var kPid = 0;
  var kCategory = 'java';
  var kMethodLutEndMarker = '\n*end\n';
  var kThreadsStart = '\n*threads\n';
  var kMethodsStart = '\n*methods\n';

  var kTraceMethodEnter = 0x00;       // method entry
  var kTraceMethodExit = 0x01;        // method exit
  var kTraceUnroll = 0x02;            // method exited by exception unrolling
  // 0x03 currently unused
  var kTraceMethodActionMask = 0x03;  // two bits

  var kTraceHeaderLength = 32;
  var kTraceMagicValue = 0x574f4c53;
  var kTraceVersionSingleClock = 2;
  var kTraceVersionDualClock = 3;
  var kTraceRecordSizeSingleClock = 10;  // using v2
  var kTraceRecordSizeDualClock = 14;  // using v3 with two timestamps

  function Reader(string_payload) {
    this.position_ = 0;
    this.data_ = JSZip.utils.transformTo('uint8array', string_payload);
  }

  Reader.prototype = {
    __proto__: Object.prototype,

    uint8: function() {
      var result = this.data_[this.position_];
      this.position_ += 1;
      return result;
    },

    uint16: function() {
      var result = 0;
      result += this.uint8();
      result += this.uint8() << 8;
      return result;
    },

    uint32: function() {
      var result = 0;
      result += this.uint8();
      result += this.uint8() << 8;
      result += this.uint8() << 16;
      result += this.uint8() << 24;
      return result;
    },

    uint64: function() {
      // Javascript isn't able to manage 64-bit numeric values.
      var low = this.uint32();
      var high = this.uint32();
      var low_str = ('0000000' + low.toString(16)).substr(-8);
      var high_str = ('0000000' + high.toString(16)).substr(-8);
      var result = high_str + low_str;
      return result;
    },

    seekTo: function(position) {
      this.position_ = position;
    },

    hasMore: function() {
      return this.position_ < this.data_.length;
    }
  };

  /**
   * Imports DDMS method tracing events into a specified model.
   * @constructor
   */
  function DdmsImporter(model, data) {
    this.importPriority = 3;
    this.model_ = model;
    this.data_ = data;
  }

  /**
   * Guesses whether the provided events is from a DDMS method trace.
   * @return {boolean} True when events is a DDMS method trace.
   */
  DdmsImporter.canImport = function(data) {
    if (typeof(data) === 'string' || data instanceof String) {
      var header = data.slice(0, 1000);
      return header.startsWith('*version\n') &&
        header.indexOf('\nvm=') >= 0 &&
        header.indexOf(kThreadsStart) >= 0;
    }
    /* key bit */
    return false;
  };

  DdmsImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get model() {
      return this.model_;
    },

    /**
     * Imports the data in this.data_ into this.model_.
     */
    importEvents: function(isSecondaryImport) {
      var divider = this.data_.indexOf(kMethodLutEndMarker) +
          kMethodLutEndMarker.length;
      this.metadata_ = this.data_.slice(0, divider);
      this.methods_ = {};
      this.parseThreads();
      this.parseMethods();

      var traceReader = new Reader(this.data_.slice(divider));
      var magic = traceReader.uint32();
      if (magic != kTraceMagicValue) {
        throw Error('Failed to match magic value');
      }
      this.version_ = traceReader.uint16();
      if (this.version_ != kTraceVersionDualClock) {
        throw Error('Unknown version');
      }
      var dataOffest = traceReader.uint16();
      var startDateTime = traceReader.uint64();
      var recordSize = traceReader.uint16();

      traceReader.seekTo(dataOffest);

      while (traceReader.hasMore()) {
        this.parseTraceEntry(traceReader);
      }
    },

    parseTraceEntry: function(reader) {
      var tid = reader.uint16();
      var methodPacked = reader.uint32();
      var cpuSinceStart = reader.uint32();
      var wallClockSinceStart = reader.uint32();
      var method = methodPacked & ~kTraceMethodActionMask;
      var action = methodPacked & kTraceMethodActionMask;
      var thread = this.getTid(tid);
      method = this.getMethodName(method);
      if (action == kTraceMethodEnter) {
        thread.sliceGroup.beginSlice(kCategory, method, wallClockSinceStart,
            undefined, cpuSinceStart);
      } else if (thread.sliceGroup.openSliceCount) {
        thread.sliceGroup.endSlice(wallClockSinceStart, cpuSinceStart);
      }
    },

    parseThreads: function() {
      var threads = this.metadata_.slice(this.metadata_.indexOf(kThreadsStart) +
          kThreadsStart.length);
      threads = threads.slice(0, threads.indexOf('\n*'));
      threads = threads.split('\n');
      threads.forEach(this.parseThread.bind(this));
    },

    parseThread: function(thread_line) {
      var tid = thread_line.slice(0, thread_line.indexOf('\t'));
      var thread = this.getTid(parseInt(tid));
      thread.name = thread_line.slice(thread_line.indexOf('\t') + 1);
    },

    getTid: function(tid) {
      return this.model_.getOrCreateProcess(kPid)
        .getOrCreateThread(tid);
    },

    parseMethods: function() {
      var methods = this.metadata_.slice(this.metadata_.indexOf(kMethodsStart) +
          kMethodsStart.length);
      methods = methods.slice(0, methods.indexOf('\n*'));
      methods = methods.split('\n');
      methods.forEach(this.parseMethod.bind(this));
    },

    parseMethod: function(method_line) {
      var data = method_line.split('\t');
      var methodId = parseInt(data[0]);
      var methodName = data[1] + '.' + data[2] + data[3];
      this.addMethod(methodId, methodName);
    },

    addMethod: function(methodId, methodName) {
      this.methods_[methodId] = methodName;
    },

    getMethodName: function(methodId) {
      return this.methods_[methodId];
    }
  };

  // Register the DdmsImporter to the Importer.
  tr.importer.Importer.register(DdmsImporter);

  return {
    DdmsImporter: DdmsImporter
  };
});


'use strict';

/**
 * @fileoverview Base class for linux perf event parsers.
 *
 * The linux perf trace event importer depends on subclasses of
 * Parser to parse event data.  Each subclass corresponds
 * to a group of trace events; e.g. SchedParser implements
 * parsing of sched:* kernel trace events.  Parser subclasses must
 * call Parser.register to arrange to be instantiated
 * and their constructor must register their event handlers with the
 * importer.  For example,
 *
 * var Parser = tr.e.importer.linux_perf.Parser;
 *
 * function WorkqueueParser(importer) {
 *   Parser.call(this, importer);
 *
 *   importer.registerEventHandler('workqueue_execute_start',
 *       WorkqueueParser.prototype.executeStartEvent.bind(this));
 *   importer.registerEventHandler('workqueue_execute_end',
 *       WorkqueueParser.prototype.executeEndEvent.bind(this));
 * }
 *
 * Parser.register(WorkqueueParser);
 *
 * When a registered event name is found in the data stream the associated
 * event handler is invoked:
 *
 *   executeStartEvent: function(eventName, cpuNumber, ts, eventBase)
 *
 * If the routine returns false the caller will generate an import error
 * saying there was a problem parsing it.  Handlers can also emit import
 * messages using this.importer.model.importWarning.  If this is done in lieu of
 * the generic import error it may be desirable for the handler to return
 * true.
 *
 * Trace events generated by writing to the trace_marker file are expected
 * to have a leading text marker followed by a ':'; e.g. the trace clock
 * synchronization event is:
 *
 *  tracing_mark_write: trace_event_clock_sync: parent_ts=0
 *
 * To register an event handler for these events, prepend the marker with
 * 'tracing_mark_write:'; e.g.
 *
 *    this.registerEventHandler('tracing_mark_write:trace_event_clock_sync',
 *
 * All subclasses should depend on importer.linux_perf.parser, e.g.
 *
 * tr.defineModule('importer.linux_perf.workqueue_parser')
 *   .dependsOn('importer.linux_perf.parser')
 *   .exportsTo('tracing', function()
 *
 * and be listed in the dependsOn of LinuxPerfImporter.  Beware that after
 * adding a new subclass you must run build/generate_about_tracing_contents.py
 * to regenerate tr.ui.e.about_tracing.*.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  /**
   * Parses linux perf events.
   * @constructor
   */
  function Parser(importer) {
    this.importer = importer;
    this.model = importer.model;
  }

  Parser.prototype = {
    __proto__: Object.prototype
  };

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.mandatoryBaseClass = Parser;
  tr.b.decorateExtensionRegistry(Parser, options);

  return {
    Parser: Parser
  };
});


'use strict';

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function BusParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('memory_bus_usage',
        BusParser.prototype.traceMarkWriteBusEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  BusParser.prototype = {
    __proto__: Parser.prototype,

    traceMarkWriteBusEvent: function(eventName, cpuNumber, pid, ts,
                                  eventBase, threadName) {
      var re = new RegExp('bus=(\\S+) rw_bytes=(\\d+) r_bytes=(\\d+) ' +
                            'w_bytes=(\\d+) cycles=(\\d+) ns=(\\d+)');
      var event = re.exec(eventBase.details);

      var name = event[1];
      var rw_bytes = parseInt(event[2]);
      var r_bytes = parseInt(event[3]);
      var w_bytes = parseInt(event[4]);
      var cycles = parseInt(event[5]);
      var ns = parseInt(event[6]);

      // BW in MB/s
      var r_bw = r_bytes * 1000000000 / ns;
      r_bw /= 1024 * 1024;
      var w_bw = w_bytes * 1000000000 / ns;
      w_bw /= 1024 * 1024;

      var ctr = this.model_.kernel
              .getOrCreateCounter(null, 'bus ' + name + ' read');
      if (ctr.numSeries === 0) {
        ctr.addSeries(new tr.model.CounterSeries('value',
            tr.ui.b.getColorIdForGeneralPurposeString(
                ctr.name + '.' + 'value')));
      }
      ctr.series.forEach(function(series) {
        series.addCounterSample(ts, r_bw);
      });

      ctr = this.model_.kernel
              .getOrCreateCounter(null, 'bus ' + name + ' write');
      if (ctr.numSeries === 0) {
        ctr.addSeries(new tr.model.CounterSeries('value',
            tr.ui.b.getColorIdForGeneralPurposeString(
                ctr.name + '.' + 'value')));
      }
      ctr.series.forEach(function(series) {
        series.addCounterSample(ts, r_bw);
      });

      return true;
    }
  };

  Parser.register(BusParser);

  return {
    BusParser: BusParser
  };
});


'use strict';

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function ClockParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('clock_set_rate',
        ClockParser.prototype.traceMarkWriteClockEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  ClockParser.prototype = {
    __proto__: Parser.prototype,

    traceMarkWriteClockEvent: function(eventName, cpuNumber, pid, ts,
                                       eventBase, threadName) {
      var event = /(\S+) state=(\d+) cpu_id=(\d+)/.exec(eventBase.details);


      var name = event[1];
      var rate = parseInt(event[2]);

      var ctr = this.model_.kernel
              .getOrCreateCounter(null, name);
      // Initialize the counter's series fields if needed.
      if (ctr.numSeries === 0) {
        ctr.addSeries(new tr.model.CounterSeries('value',
            tr.ui.b.getColorIdForGeneralPurposeString(
                ctr.name + '.' + 'value')));
      }
      ctr.series.forEach(function(series) {
        series.addCounterSample(ts, rate);
      });

      return true;
    }
  };

  Parser.register(ClockParser);

  return {
    ClockParser: ClockParser
  };
});


'use strict';

/**
 * @fileoverview Parses cpufreq events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux cpufreq trace events.
   * @constructor
   */
  function CpufreqParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('cpufreq_interactive_up',
        CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_down',
        CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_already',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_notyet',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_setspeed',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_target',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_boost',
        CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_unboost',
        CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
  }

  function splitData(input) {
    // TODO(sleffler) split by cpu
    var data = {};
    var args = input.split(/\s+/);
    var len = args.length;
    for (var i = 0; i < len; i++) {
      var item = args[i].split('=');
      data[item[0]] = parseInt(item[1]);
    }
    return data;
  }

  CpufreqParser.prototype = {
    __proto__: Parser.prototype,

    cpufreqSlice: function(ts, eventName, cpu, args) {
      // TODO(sleffler) should be per-cpu
      var kthread = this.importer.getOrCreatePseudoThread('cpufreq');
      kthread.openSlice = eventName;
      var slice = new tr.model.Slice('', kthread.openSlice,
          tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    cpufreqBoostSlice: function(ts, eventName, args) {
      var kthread = this.importer.getOrCreatePseudoThread('cpufreq_boost');
      kthread.openSlice = eventName;
      var slice = new tr.model.Slice('', kthread.openSlice,
          tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    /**
     * Parses cpufreq events and sets up state in the importer.
     */
    cpufreqUpDownEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var data = splitData(eventBase.details);
      this.cpufreqSlice(ts, eventName, data.cpu, data);
      return true;
    },

    cpufreqTargetEvent: function(eventName, cpuNumber, pid, ts,
                                 eventBase) {
      var data = splitData(eventBase.details);
      this.cpufreqSlice(ts, eventName, data.cpu, data);
      return true;
    },

    cpufreqBoostUnboostEvent: function(eventName, cpuNumber, pid, ts,
                                       eventBase) {
      this.cpufreqBoostSlice(ts, eventName,
          {
            type: eventBase.details
          });
      return true;
    }
  };

  Parser.register(CpufreqParser);

  return {
    CpufreqParser: CpufreqParser
  };
});


'use strict';

/**
 * @fileoverview Parses filesystem and block device events in the Linux event
 * trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux filesystem and block device trace events.
   * @constructor
   */
  function DiskParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('f2fs_write_begin',
        DiskParser.prototype.f2fsWriteBeginEvent.bind(this));
    importer.registerEventHandler('f2fs_write_end',
        DiskParser.prototype.f2fsWriteEndEvent.bind(this));
    importer.registerEventHandler('f2fs_sync_file_enter',
        DiskParser.prototype.f2fsSyncFileEnterEvent.bind(this));
    importer.registerEventHandler('f2fs_sync_file_exit',
        DiskParser.prototype.f2fsSyncFileExitEvent.bind(this));
    importer.registerEventHandler('ext4_sync_file_enter',
        DiskParser.prototype.ext4SyncFileEnterEvent.bind(this));
    importer.registerEventHandler('ext4_sync_file_exit',
        DiskParser.prototype.ext4SyncFileExitEvent.bind(this));
    importer.registerEventHandler('ext4_da_write_begin',
        DiskParser.prototype.ext4WriteBeginEvent.bind(this));
    importer.registerEventHandler('ext4_da_write_end',
        DiskParser.prototype.ext4WriteEndEvent.bind(this));
    importer.registerEventHandler('block_rq_issue',
        DiskParser.prototype.blockRqIssueEvent.bind(this));
    importer.registerEventHandler('block_rq_complete',
        DiskParser.prototype.blockRqCompleteEvent.bind(this));
  }

  DiskParser.prototype = {
    __proto__: Parser.prototype,

    openAsyncSlice: function(ts, category, threadName, pid, key, name) {
      var kthread = this.importer.getOrCreateKernelThread(
          category + ':' + threadName, pid);
      var asyncSliceConstructor =
         tr.model.AsyncSlice.getConstructor(
            category, name);
      var slice = new asyncSliceConstructor(
          category, name,
          tr.ui.b.getColorIdForGeneralPurposeString(name),
          ts);
      slice.startThread = kthread.thread;

      if (!kthread.openAsyncSlices) {
        kthread.openAsyncSlices = { };
      }
      kthread.openAsyncSlices[key] = slice;
    },

    closeAsyncSlice: function(ts, category, threadName, pid, key, args) {
      var kthread = this.importer.getOrCreateKernelThread(
          category + ':' + threadName, pid);
      if (kthread.openAsyncSlices) {
        var slice = kthread.openAsyncSlices[key];
        if (slice) {
          slice.duration = ts - slice.start;
          slice.args = args;
          slice.endThread = kthread.thread;
          slice.subSlices = [
            new tr.model.AsyncSlice(category, slice.title,
                slice.colorId, slice.start, slice.args, slice.duration)
          ];
          kthread.thread.asyncSliceGroup.push(slice);
          delete kthread.openAsyncSlices[key];
        }
      }
    },

    /**
     * Parses events and sets up state in the importer.
     */
    f2fsWriteBeginEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev = \((\d+,\d+)\), ino = (\d+), pos = (\d+), len = (\d+), flags = (\d+)/. // @suppress longLineCheck
          exec(eventBase.details);
      if (!event)
        return false;
      var device = event[1];
      var inode = parseInt(event[2]);
      var pos = parseInt(event[3]);
      var len = parseInt(event[4]);
      var key = device + '-' + inode + '-' + pos + '-' + len;
      this.openAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid,
          key, 'f2fs_write');
      return true;
    },

    f2fsWriteEndEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev = \((\d+,\d+)\), ino = (\d+), pos = (\d+), len = (\d+), copied = (\d+)/. // @suppress longLineCheck
          exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var inode = parseInt(event[2]);
      var pos = parseInt(event[3]);
      var len = parseInt(event[4]);
      var error = parseInt(event[5]) !== len;
      var key = device + '-' + inode + '-' + pos + '-' + len;
      this.closeAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid,
          key, {
            device: device,
            inode: inode,
            error: error
          });
      return true;
    },

    ext4WriteBeginEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev (\d+,\d+) ino (\d+) pos (\d+) len (\d+) flags (\d+)/.
          exec(eventBase.details);
      if (!event)
        return false;
      var device = event[1];
      var inode = parseInt(event[2]);
      var pos = parseInt(event[3]);
      var len = parseInt(event[4]);
      var key = device + '-' + inode + '-' + pos + '-' + len;
      this.openAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, 'ext4_write');
      return true;
    },

    ext4WriteEndEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev (\d+,\d+) ino (\d+) pos (\d+) len (\d+) copied (\d+)/.
          exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var inode = parseInt(event[2]);
      var pos = parseInt(event[3]);
      var len = parseInt(event[4]);
      var error = parseInt(event[5]) !== len;
      var key = device + '-' + inode + '-' + pos + '-' + len;
      this.closeAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, {
            device: device,
            inode: inode,
            error: error
          });
      return true;
    },

    f2fsSyncFileEnterEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = new RegExp(
          'dev = \\((\\d+,\\d+)\\), ino = (\\d+), pino = (\\d+), i_mode = (\\S+), ' + // @suppress longLineCheck
          'i_size = (\\d+), i_nlink = (\\d+), i_blocks = (\\d+), i_advise = (\\d+)'). // @suppress longLineCheck
          exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var inode = parseInt(event[2]);
      var key = device + '-' + inode;
      this.openAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid,
          key, 'fsync');
      return true;
    },

    f2fsSyncFileExitEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = new RegExp('dev = \\((\\d+,\\d+)\\), ino = (\\d+), checkpoint is (\\S+), ' + // @suppress longLineCheck
          'datasync = (\\d+), ret = (\\d+)').
          exec(eventBase.details.replace('not needed', 'not_needed'));
      if (!event)
        return false;

      var device = event[1];
      var inode = parseInt(event[2]);
      var error = parseInt(event[5]);
      var key = device + '-' + inode;
      this.closeAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid,
          key, {
            device: device,
            inode: inode,
            error: error
          });
      return true;
    },

    ext4SyncFileEnterEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev (\d+,\d+) ino (\d+) parent (\d+) datasync (\d+)/.
          exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var inode = parseInt(event[2]);
      var datasync = event[4] == 1;
      var key = device + '-' + inode;
      var action = datasync ? 'fdatasync' : 'fsync';
      this.openAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, action);
      return true;
    },

    ext4SyncFileExitEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev (\d+,\d+) ino (\d+) ret (\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var inode = parseInt(event[2]);
      var error = parseInt(event[3]);
      var key = device + '-' + inode;
      this.closeAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, {
            device: device,
            inode: inode,
            error: error
          });
      return true;
    },

    blockRqIssueEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = new RegExp('(\\d+,\\d+) (F)?([DWRN])(F)?(A)?(S)?(M)? ' +
          '\\d+ \\(.*\\) (\\d+) \\+ (\\d+) \\[.*\\]').exec(eventBase.details);
      if (!event)
        return false;

      var action;
      switch (event[3]) {
        case 'D':
          action = 'discard';
          break;
        case 'W':
          action = 'write';
          break;
        case 'R':
          action = 'read';
          break;
        case 'N':
          action = 'none';
          break;
        default:
          action = 'unknown';
          break;
      }

      if (event[2]) {
        action += ' flush';
      }
      if (event[4] == 'F') {
        action += ' fua';
      }
      if (event[5] == 'A') {
        action += ' ahead';
      }
      if (event[6] == 'S') {
        action += ' sync';
      }
      if (event[7] == 'M') {
        action += ' meta';
      }
      var device = event[1];
      var sector = parseInt(event[8]);
      var numSectors = parseInt(event[9]);
      var key = device + '-' + sector + '-' + numSectors;
      this.openAsyncSlice(ts, 'block', eventBase.threadName, eventBase.pid,
          key, action);
      return true;
    },

    blockRqCompleteEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = new RegExp('(\\d+,\\d+) (F)?([DWRN])(F)?(A)?(S)?(M)? ' +
          '\\(.*\\) (\\d+) \\+ (\\d+) \\[(.*)\\]').exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var sector = parseInt(event[8]);
      var numSectors = parseInt(event[9]);
      var error = parseInt(event[10]);
      var key = device + '-' + sector + '-' + numSectors;
      this.closeAsyncSlice(ts, 'block', eventBase.threadName, eventBase.pid,
          key, {
            device: device,
            sector: sector,
            numSectors: numSectors,
            error: error
          });
      return true;
    }
  };

  Parser.register(DiskParser);

  return {
    DiskParser: DiskParser
  };
});


'use strict';

/**
 * @fileoverview Parses drm driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux drm trace events.
   * @constructor
   */
  function DrmParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('drm_vblank_event',
        DrmParser.prototype.vblankEvent.bind(this));
  }

  DrmParser.prototype = {
    __proto__: Parser.prototype,

    drmVblankSlice: function(ts, eventName, args) {
      var kthread = this.importer.getOrCreatePseudoThread('drm_vblank');
      kthread.openSlice = eventName;
      var slice = new tr.model.Slice('', kthread.openSlice,
          tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    /**
     * Parses drm driver events and sets up state in the importer.
     */
    vblankEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /crtc=(\d+), seq=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var crtc = parseInt(event[1]);
      var seq = parseInt(event[2]);
      this.drmVblankSlice(ts, 'vblank:' + crtc,
          {
            crtc: crtc,
            seq: seq
          });
      return true;
    }
  };

  Parser.register(DrmParser);

  return {
    DrmParser: DrmParser
  };
});


'use strict';

/**
 * @fileoverview Parses drm driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux irq trace events.
   * @constructor
   */
  function IrqParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('irq_handler_entry',
        IrqParser.prototype.irqHandlerEntryEvent.bind(this));
    importer.registerEventHandler('irq_handler_exit',
        IrqParser.prototype.irqHandlerExitEvent.bind(this));
    importer.registerEventHandler('softirq_raise',
        IrqParser.prototype.softirqRaiseEvent.bind(this));
    importer.registerEventHandler('softirq_entry',
        IrqParser.prototype.softirqEntryEvent.bind(this));
    importer.registerEventHandler('softirq_exit',
        IrqParser.prototype.softirqExitEvent.bind(this));
  }

  // Matches the irq_handler_entry record
  var irqHandlerEntryRE = /irq=(\d+) name=(.+)/;

  // Matches the irq_handler_exit record
  var irqHandlerExitRE = /irq=(\d+) ret=(.+)/;

  // Matches the softirq_raise record
  var softirqRE = /vec=(\d+) \[action=(.+)\]/;

  IrqParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses irq events and sets up state in the mporter.
     */
    irqHandlerEntryEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = irqHandlerEntryRE.exec(eventBase.details);
      if (!event)
        return false;

      var irq = parseInt(event[1]);
      var name = event[2];

      var thread = this.importer.getOrCreatePseudoThread(
          'irqs cpu ' + cpuNumber);
      thread.lastEntryTs = ts;
      thread.irqName = name;

      return true;
    },

    irqHandlerExitEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = irqHandlerExitRE.exec(eventBase.details);
      if (!event)
        return false;

      var irq = parseInt(event[1]);
      var ret = event[2];
      var thread = this.importer.getOrCreatePseudoThread(
          'irqs cpu ' + cpuNumber);

      if (thread.lastEntryTs !== undefined) {
        var duration = ts - thread.lastEntryTs;
        var slice = new tr.model.Slice(
            '', thread.irqName,
            tr.ui.b.getColorIdForGeneralPurposeString(event[1]),
            thread.lastEntryTs, { ret: ret },
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastEntryTs = undefined;
      thread.irqName = undefined;
      return true;
    },

    softirqRaiseEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      return true;
    },

    softirqEntryEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = softirqRE.exec(eventBase.details);
      if (!event)
        return false;

      var action = event[2];
      var thread = this.importer.getOrCreatePseudoThread(
          'softirq cpu ' + cpuNumber);
      thread.lastEntryTs = ts;

      return true;
    },

    softirqExitEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = softirqRE.exec(eventBase.details);
      if (!event)
        return false;

      var vec = parseInt(event[1]);
      var action = event[2];
      var thread = this.importer.getOrCreatePseudoThread(
          'softirq cpu ' + cpuNumber);

      if (thread.lastEntryTs !== undefined) {
        var duration = ts - thread.lastEntryTs;
        var slice = new tr.model.Slice(
            '', action,
            tr.ui.b.getColorIdForGeneralPurposeString(event[1]),
            thread.lastEntryTs, { vec: vec },
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastEntryTs = undefined;
      return true;
    }
  };

  Parser.register(IrqParser);

  return {
    IrqParser: IrqParser
  };
});


'use strict';

/**
 * @fileoverview Parses exynos events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux exynos trace events.
   * @constructor
   */
  function ExynosParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('exynos_busfreq_target_int',
        ExynosParser.prototype.busfreqTargetIntEvent.bind(this));
    importer.registerEventHandler('exynos_busfreq_target_mif',
        ExynosParser.prototype.busfreqTargetMifEvent.bind(this));

    importer.registerEventHandler('exynos_page_flip_state',
        ExynosParser.prototype.pageFlipStateEvent.bind(this));
  }

  ExynosParser.prototype = {
    __proto__: Parser.prototype,

    exynosBusfreqSample: function(name, ts, frequency) {
      var targetCpu = this.importer.getOrCreateCpu(0);
      var counter = targetCpu.getOrCreateCounter('', name);
      if (counter.numSeries === 0) {
        counter.addSeries(new tr.model.CounterSeries('frequency',
            tr.ui.b.getColorIdForGeneralPurposeString(
                counter.name + '.' + 'frequency')));
      }
      counter.series.forEach(function(series) {
        series.addCounterSample(ts, frequency);
      });
    },

    /**
     * Parses exynos_busfreq_target_int events and sets up state.
     */
    busfreqTargetIntEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.exynosBusfreqSample('INT Frequency', ts, parseInt(event[1]));
      return true;
    },

    /**
     * Parses exynos_busfreq_target_mif events and sets up state.
     */
    busfreqTargetMifEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.exynosBusfreqSample('MIF Frequency', ts, parseInt(event[1]));
      return true;
    },

    exynosPageFlipStateOpenSlice: function(ts, pipe, fb, state) {
      var kthread = this.importer.getOrCreatePseudoThread(
          'exynos_flip_state (pipe:' + pipe + ', fb:' + fb + ')');
      kthread.openSliceTS = ts;
      kthread.openSlice = state;
    },

    exynosPageFlipStateCloseSlice: function(ts, pipe, fb, args) {
      var kthread = this.importer.getOrCreatePseudoThread(
          'exynos_flip_state (pipe:' + pipe + ', fb:' + fb + ')');
      if (kthread.openSlice) {
        var slice = new tr.model.Slice('', kthread.openSlice,
            tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
            kthread.openSliceTS,
            args,
            ts - kthread.openSliceTS);
        kthread.thread.sliceGroup.pushSlice(slice);
      }
      kthread.openSlice = undefined;
    },

    /**
     * Parses page_flip_state events and sets up state in the importer.
     */
    pageFlipStateEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /pipe=(\d+), fb=(\d+), state=(.*)/.exec(eventBase.details);
      if (!event)
        return false;

      var pipe = parseInt(event[1]);
      var fb = parseInt(event[2]);
      var state = event[3];

      this.exynosPageFlipStateCloseSlice(ts, pipe, fb,
          {
            pipe: pipe,
            fb: fb
          });
      if (state !== 'flipped')
        this.exynosPageFlipStateOpenSlice(ts, pipe, fb, state);
      return true;
    }
  };

  Parser.register(ExynosParser);

  return {
    ExynosParser: ExynosParser
  };
});


'use strict';

/**
 * @fileoverview Parses gesture events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses trace events generated by gesture library for touchpad.
   * @constructor
   */
  function GestureParser(importer) {
    Parser.call(this, importer);
    importer.registerEventHandler('tracing_mark_write:log',
        GestureParser.prototype.logEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:SyncInterpret',
        GestureParser.prototype.syncEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:HandleTimer',
        GestureParser.prototype.timerEvent.bind(this));
  }

  GestureParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parse events generate by gesture library.
     * gestureOpenSlice and gestureCloseSlice are two common
     * functions to store the begin time and end time for all
     * events in gesture library
     */
    gestureOpenSlice: function(title, ts, opt_args) {
      var thread = this.importer.getOrCreatePseudoThread('gesture').thread;
      thread.sliceGroup.beginSlice(
          'touchpad_gesture', title, ts, opt_args);
    },

    gestureCloseSlice: function(title, ts) {
      var thread = this.importer.getOrCreatePseudoThread('gesture').thread;
      if (thread.sliceGroup.openSliceCount) {
        var slice = thread.sliceGroup.mostRecentlyOpenedPartialSlice;
        if (slice.title != title) {
          this.importer.model.importWarning({
            type: 'title_match_error',
            message: 'Titles do not match. Title is ' +
                slice.title + ' in openSlice, and is ' +
                title + ' in endSlice'
          });
        } else {
          thread.sliceGroup.endSlice(ts);
        }
      }
    },

    /**
     * For log events, events will come in pairs with a tag log:
     * like this:
     * tracing_mark_write: log: start: TimerLogOutputs
     * tracing_mark_write: log: end: TimerLogOutputs
     * which represent the start and the end time of certain log behavior
     * Take these logs above for example, they are the start and end time
     * of logging Output for HandleTimer function
     */
    logEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var innerEvent =
          /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('GestureLog', ts, {name: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('GestureLog', ts);
      }
      return true;
    },

    /**
     * For SyncInterpret events, events will come in pairs with
     * a tag SyncInterpret:
     * like this:
     * tracing_mark_write: SyncInterpret: start: ClickWiggleFilterInterpreter
     * tracing_mark_write: SyncInterpret: end: ClickWiggleFilterInterpreter
     * which represent the start and the end time of SyncInterpret function
     * inside the certain interpreter in the gesture library.
     * Take the logs above for example, they are the start and end time
     * of the SyncInterpret function inside ClickWiggleFilterInterpreter
     */
    syncEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('SyncInterpret', ts,
                                {interpreter: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('SyncInterpret', ts);
      }
      return true;
    },

    /**
     * For HandleTimer events, events will come in pairs with
     * a tag HandleTimer:
     * like this:
     * tracing_mark_write: HandleTimer: start: LookaheadFilterInterpreter
     * tracing_mark_write: HandleTimer: end: LookaheadFilterInterpreter
     * which represent the start and the end time of HandleTimer function
     * inside the certain interpreter in the gesture library.
     * Take the logs above for example, they are the start and end time
     * of the HandleTimer function inside LookaheadFilterInterpreter
     */
    timerEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('HandleTimer', ts,
                                {interpreter: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('HandleTimer', ts);
      }
      return true;
    }
  };

  Parser.register(GestureParser);

  return {
    GestureParser: GestureParser
  };
});


'use strict';

/**
 * @fileoverview Parses i915 driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux i915 trace events.
   * @constructor
   */
  function I915Parser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('i915_gem_object_create',
        I915Parser.prototype.gemObjectCreateEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_bind',
        I915Parser.prototype.gemObjectBindEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_unbind',
        I915Parser.prototype.gemObjectBindEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_change_domain',
        I915Parser.prototype.gemObjectChangeDomainEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_pread',
        I915Parser.prototype.gemObjectPreadWriteEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_pwrite',
        I915Parser.prototype.gemObjectPreadWriteEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_fault',
        I915Parser.prototype.gemObjectFaultEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_clflush',
        // NB: reuse destroy handler
        I915Parser.prototype.gemObjectDestroyEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_destroy',
        I915Parser.prototype.gemObjectDestroyEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_dispatch',
        I915Parser.prototype.gemRingDispatchEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_flush',
        I915Parser.prototype.gemRingFlushEvent.bind(this));
    importer.registerEventHandler('i915_gem_request',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_add',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_complete',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_retire',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_wait_begin',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_wait_end',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_wait_begin',
        I915Parser.prototype.gemRingWaitEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_wait_end',
        I915Parser.prototype.gemRingWaitEvent.bind(this));
    importer.registerEventHandler('i915_reg_rw',
        I915Parser.prototype.regRWEvent.bind(this));
    importer.registerEventHandler('i915_flip_request',
        I915Parser.prototype.flipEvent.bind(this));
    importer.registerEventHandler('i915_flip_complete',
        I915Parser.prototype.flipEvent.bind(this));
    importer.registerEventHandler('intel_gpu_freq_change',
        I915Parser.prototype.gpuFrequency.bind(this));
  }

  I915Parser.prototype = {
    __proto__: Parser.prototype,

    i915FlipOpenSlice: function(ts, obj, plane) {
      // use i915_flip_obj_plane?
      var kthread = this.importer.getOrCreatePseudoThread('i915_flip');
      kthread.openSliceTS = ts;
      kthread.openSlice = 'flip:' + obj + '/' + plane;
    },

    i915FlipCloseSlice: function(ts, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_flip');
      if (kthread.openSlice) {
        var slice = new tr.model.Slice('', kthread.openSlice,
            tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
            kthread.openSliceTS,
            args,
            ts - kthread.openSliceTS);

        kthread.thread.sliceGroup.pushSlice(slice);
      }
      kthread.openSlice = undefined;
    },

    i915GemObjectSlice: function(ts, eventName, obj, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_gem');
      kthread.openSlice = eventName + ':' + obj;
      var slice = new tr.model.Slice('', kthread.openSlice,
          tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    i915GemRingSlice: function(ts, eventName, dev, ring, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_gem_ring');
      kthread.openSlice = eventName + ':' + dev + '.' + ring;
      var slice = new tr.model.Slice('', kthread.openSlice,
          tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    i915RegSlice: function(ts, eventName, reg, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_reg');
      kthread.openSlice = eventName + ':' + reg;
      var slice = new tr.model.Slice('', kthread.openSlice,
          tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    i915FreqChangeSlice: function(ts, eventName, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_gpu_freq');
      kthread.openSlice = eventName;
      var slice = new tr.model.Slice('', kthread.openSlice,
          tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    /**
     * Parses i915 driver events and sets up state in the importer.
     */
    gemObjectCreateEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /obj=(\w+), size=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var size = parseInt(event[2]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj,
            size: size
          });
      return true;
    },

    gemObjectBindEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO(sleffler) mappable
      var event = /obj=(\w+), offset=(\w+), size=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var offset = event[2];
      var size = parseInt(event[3]);
      this.i915ObjectGemSlice(ts, eventName + ':' + obj,
          {
            obj: obj,
            offset: offset,
            size: size
          });
      return true;
    },

    gemObjectChangeDomainEvent: function(eventName, cpuNumber, pid, ts,
                                         eventBase) {
      var event = /obj=(\w+), read=(\w+=>\w+), write=(\w+=>\w+)/
          .exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var read = event[2];
      var write = event[3];
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj,
            read: read,
            write: write
          });
      return true;
    },

    gemObjectPreadWriteEvent: function(eventName, cpuNumber, pid, ts,
                                       eventBase) {
      var event = /obj=(\w+), offset=(\d+), len=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var offset = parseInt(event[2]);
      var len = parseInt(event[3]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj,
            offset: offset,
            len: len
          });
      return true;
    },

    gemObjectFaultEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO(sleffler) writable
      var event = /obj=(\w+), (\w+) index=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var type = event[2];
      var index = parseInt(event[3]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj,
            type: type,
            index: index
          });
      return true;
    },

    gemObjectDestroyEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /obj=(\w+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj
          });
      return true;
    },

    gemRingDispatchEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev=(\d+), ring=(\d+), seqno=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var dev = parseInt(event[1]);
      var ring = parseInt(event[2]);
      var seqno = parseInt(event[3]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev: dev,
            ring: ring,
            seqno: seqno
          });
      return true;
    },

    gemRingFlushEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev=(\d+), ring=(\w+), invalidate=(\w+), flush=(\w+)/
          .exec(eventBase.details);
      if (!event)
        return false;

      var dev = parseInt(event[1]);
      var ring = parseInt(event[2]);
      var invalidate = event[3];
      var flush = event[4];
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev: dev,
            ring: ring,
            invalidate: invalidate,
            flush: flush
          });
      return true;
    },

    gemRequestEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev=(\d+), ring=(\d+), seqno=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var dev = parseInt(event[1]);
      var ring = parseInt(event[2]);
      var seqno = parseInt(event[3]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev: dev,
            ring: ring,
            seqno: seqno
          });
      return true;
    },

    gemRingWaitEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev=(\d+), ring=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var dev = parseInt(event[1]);
      var ring = parseInt(event[2]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev: dev,
            ring: ring
          });
      return true;
    },

    regRWEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /(\w+) reg=(\w+), len=(\d+), val=(\(\w+, \w+\))/
          .exec(eventBase.details);
      if (!event)
        return false;

      var rw = event[1];
      var reg = event[2];
      var len = event[3];
      var data = event[3];
      this.i915RegSlice(ts, rw, reg,
          {
            rw: rw,
            reg: reg,
            len: len,
            data: data
          });
      return true;
    },

    flipEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /plane=(\d+), obj=(\w+)/.exec(eventBase.details);
      if (!event)
        return false;

      var plane = parseInt(event[1]);
      var obj = event[2];
      if (eventName == 'i915_flip_request')
        this.i915FlipOpenSlice(ts, obj, plane);
      else
        this.i915FlipCloseSlice(ts,
            {
              obj: obj,
              plane: plane
            });
      return true;
    },

    gpuFrequency: function(eventName, cpuNumver, pid, ts, eventBase) {
      var event = /new_freq=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;
      var freq = parseInt(event[1]);

      this.i915FreqChangeSlice(ts, eventName, {
            freq: freq
          });
      return true;
    }
  };

  Parser.register(I915Parser);

  return {
    I915Parser: I915Parser
  };
});


'use strict';

/**
 * @fileoverview Parses Mali DDK/kernel events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses Mali DDK/kernel trace events.
   * @constructor
   */
  function MaliParser(importer) {
    Parser.call(this, importer);

    // kernel DVFS events
    importer.registerEventHandler('mali_dvfs_event',
        MaliParser.prototype.dvfsEventEvent.bind(this));
    importer.registerEventHandler('mali_dvfs_set_clock',
        MaliParser.prototype.dvfsSetClockEvent.bind(this));
    importer.registerEventHandler('mali_dvfs_set_voltage',
        MaliParser.prototype.dvfsSetVoltageEvent.bind(this));

    // kernel Mali hw counter events
    this.addJMCounter('mali_hwc_MESSAGES_SENT', 'Messages Sent');
    this.addJMCounter('mali_hwc_MESSAGES_RECEIVED', 'Messages Received');
    this.addJMCycles('mali_hwc_GPU_ACTIVE', 'GPU Active');
    this.addJMCycles('mali_hwc_IRQ_ACTIVE', 'IRQ Active');

    for (var i = 0; i < 7; i++) {
      var jobStr = 'JS' + i;
      var jobHWCStr = 'mali_hwc_' + jobStr;
      this.addJMCounter(jobHWCStr + '_JOBS', jobStr + ' Jobs');
      this.addJMCounter(jobHWCStr + '_TASKS', jobStr + ' Tasks');
      this.addJMCycles(jobHWCStr + '_ACTIVE', jobStr + ' Active');
      this.addJMCycles(jobHWCStr + '_WAIT_READ', jobStr + ' Wait Read');
      this.addJMCycles(jobHWCStr + '_WAIT_ISSUE', jobStr + ' Wait Issue');
      this.addJMCycles(jobHWCStr + '_WAIT_DEPEND', jobStr + ' Wait Depend');
      this.addJMCycles(jobHWCStr + '_WAIT_FINISH', jobStr + ' Wait Finish');
    }

    this.addTilerCounter('mali_hwc_TRIANGLES', 'Triangles');
    this.addTilerCounter('mali_hwc_QUADS', 'Quads');
    this.addTilerCounter('mali_hwc_POLYGONS', 'Polygons');
    this.addTilerCounter('mali_hwc_POINTS', 'Points');
    this.addTilerCounter('mali_hwc_LINES', 'Lines');
    this.addTilerCounter('mali_hwc_VCACHE_HIT', 'VCache Hit');
    this.addTilerCounter('mali_hwc_VCACHE_MISS', 'VCache Miss');
    this.addTilerCounter('mali_hwc_FRONT_FACING', 'Front Facing');
    this.addTilerCounter('mali_hwc_BACK_FACING', 'Back Facing');
    this.addTilerCounter('mali_hwc_PRIM_VISIBLE', 'Prim Visible');
    this.addTilerCounter('mali_hwc_PRIM_CULLED', 'Prim Culled');
    this.addTilerCounter('mali_hwc_PRIM_CLIPPED', 'Prim Clipped');

    this.addTilerCounter('mali_hwc_WRBUF_HIT', 'Wrbuf Hit');
    this.addTilerCounter('mali_hwc_WRBUF_MISS', 'Wrbuf Miss');
    this.addTilerCounter('mali_hwc_WRBUF_LINE', 'Wrbuf Line');
    this.addTilerCounter('mali_hwc_WRBUF_PARTIAL', 'Wrbuf Partial');
    this.addTilerCounter('mali_hwc_WRBUF_STALL', 'Wrbuf Stall');

    this.addTilerCycles('mali_hwc_ACTIVE', 'Tiler Active');
    this.addTilerCycles('mali_hwc_INDEX_WAIT', 'Index Wait');
    this.addTilerCycles('mali_hwc_INDEX_RANGE_WAIT', 'Index Range Wait');
    this.addTilerCycles('mali_hwc_VERTEX_WAIT', 'Vertex Wait');
    this.addTilerCycles('mali_hwc_PCACHE_WAIT', 'Pcache Wait');
    this.addTilerCycles('mali_hwc_WRBUF_WAIT', 'Wrbuf Wait');
    this.addTilerCycles('mali_hwc_BUS_READ', 'Bus Read');
    this.addTilerCycles('mali_hwc_BUS_WRITE', 'Bus Write');

    this.addTilerCycles('mali_hwc_TILER_UTLB_STALL', 'Tiler UTLB Stall');
    this.addTilerCycles('mali_hwc_TILER_UTLB_HIT', 'Tiler UTLB Hit');

    this.addFragCycles('mali_hwc_FRAG_ACTIVE', 'Active');
    /* NB: don't propagate spelling mistakes to labels */
    this.addFragCounter('mali_hwc_FRAG_PRIMATIVES', 'Primitives');
    this.addFragCounter('mali_hwc_FRAG_PRIMATIVES_DROPPED',
        'Primitives Dropped');
    this.addFragCycles('mali_hwc_FRAG_CYCLE_DESC', 'Descriptor Processing');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_PLR', 'PLR Processing??');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_VERT', 'Vertex Processing');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_TRISETUP', 'Triangle Setup');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_RAST', 'Rasterization???');
    this.addFragCounter('mali_hwc_FRAG_THREADS', 'Threads');
    this.addFragCounter('mali_hwc_FRAG_DUMMY_THREADS', 'Dummy Threads');
    this.addFragCounter('mali_hwc_FRAG_QUADS_RAST', 'Quads Rast');
    this.addFragCounter('mali_hwc_FRAG_QUADS_EZS_TEST', 'Quads EZS Test');
    this.addFragCounter('mali_hwc_FRAG_QUADS_EZS_KILLED', 'Quads EZS Killed');
    this.addFragCounter('mali_hwc_FRAG_QUADS_LZS_TEST', 'Quads LZS Test');
    this.addFragCounter('mali_hwc_FRAG_QUADS_LZS_KILLED', 'Quads LZS Killed');
    this.addFragCycles('mali_hwc_FRAG_CYCLE_NO_TILE', 'No Tiles');
    this.addFragCounter('mali_hwc_FRAG_NUM_TILES', 'Tiles');
    this.addFragCounter('mali_hwc_FRAG_TRANS_ELIM', 'Transactions Eliminated');

    this.addComputeCycles('mali_hwc_COMPUTE_ACTIVE', 'Active');
    this.addComputeCounter('mali_hwc_COMPUTE_TASKS', 'Tasks');
    this.addComputeCounter('mali_hwc_COMPUTE_THREADS', 'Threads Started');
    this.addComputeCycles('mali_hwc_COMPUTE_CYCLES_DESC',
        'Waiting for Descriptors');

    this.addTripipeCycles('mali_hwc_TRIPIPE_ACTIVE', 'Active');

    this.addArithCounter('mali_hwc_ARITH_WORDS', 'Instructions (/Pipes)');
    this.addArithCycles('mali_hwc_ARITH_CYCLES_REG',
        'Reg scheduling stalls (/Pipes)');
    this.addArithCycles('mali_hwc_ARITH_CYCLES_L0',
        'L0 cache miss stalls (/Pipes)');
    this.addArithCounter('mali_hwc_ARITH_FRAG_DEPEND',
        'Frag dep check failures (/Pipes)');

    this.addLSCounter('mali_hwc_LS_WORDS', 'Instruction Words Completed');
    this.addLSCounter('mali_hwc_LS_ISSUES', 'Full Pipeline Issues');
    this.addLSCounter('mali_hwc_LS_RESTARTS', 'Restarts (unpairable insts)');
    this.addLSCounter('mali_hwc_LS_REISSUES_MISS',
        'Pipeline reissue (cache miss/uTLB)');
    this.addLSCounter('mali_hwc_LS_REISSUES_VD',
        'Pipeline reissue (varying data)');
    /* TODO(sleffler) fix kernel event typo */
    this.addLSCounter('mali_hwc_LS_REISSUE_ATTRIB_MISS',
        'Pipeline reissue (attribute cache miss)');
    this.addLSCounter('mali_hwc_LS_REISSUE_NO_WB', 'Writeback not used');

    this.addTexCounter('mali_hwc_TEX_WORDS', 'Words');
    this.addTexCounter('mali_hwc_TEX_BUBBLES', 'Bubbles');
    this.addTexCounter('mali_hwc_TEX_WORDS_L0', 'Words L0');
    this.addTexCounter('mali_hwc_TEX_WORDS_DESC', 'Words Desc');
    this.addTexCounter('mali_hwc_TEX_THREADS', 'Threads');
    this.addTexCounter('mali_hwc_TEX_RECIRC_FMISS', 'Recirc due to Full Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_DESC', 'Recirc due to Desc Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_MULTI', 'Recirc due to Multipass');
    this.addTexCounter('mali_hwc_TEX_RECIRC_PMISS',
        'Recirc due to Partial Cache Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_CONF',
        'Recirc due to Cache Conflict');

    this.addLSCCounter('mali_hwc_LSC_READ_HITS', 'Read Hits');
    this.addLSCCounter('mali_hwc_LSC_READ_MISSES', 'Read Misses');
    this.addLSCCounter('mali_hwc_LSC_WRITE_HITS', 'Write Hits');
    this.addLSCCounter('mali_hwc_LSC_WRITE_MISSES', 'Write Misses');
    this.addLSCCounter('mali_hwc_LSC_ATOMIC_HITS', 'Atomic Hits');
    this.addLSCCounter('mali_hwc_LSC_ATOMIC_MISSES', 'Atomic Misses');
    this.addLSCCounter('mali_hwc_LSC_LINE_FETCHES', 'Line Fetches');
    this.addLSCCounter('mali_hwc_LSC_DIRTY_LINE', 'Dirty Lines');
    this.addLSCCounter('mali_hwc_LSC_SNOOPS', 'Snoops');

    this.addAXICounter('mali_hwc_AXI_TLB_STALL', 'Address channel stall');
    this.addAXICounter('mali_hwc_AXI_TLB_MISS', 'Cache Miss');
    this.addAXICounter('mali_hwc_AXI_TLB_TRANSACTION', 'Transactions');
    this.addAXICounter('mali_hwc_LS_TLB_MISS', 'LS Cache Miss');
    this.addAXICounter('mali_hwc_LS_TLB_HIT', 'LS Cache Hit');
    this.addAXICounter('mali_hwc_AXI_BEATS_READ', 'Read Beats');
    this.addAXICounter('mali_hwc_AXI_BEATS_WRITE', 'Write Beats');

    this.addMMUCounter('mali_hwc_MMU_TABLE_WALK', 'Page Table Walks');
    this.addMMUCounter('mali_hwc_MMU_REPLAY_MISS',
        'Cache Miss from Replay Buffer');
    this.addMMUCounter('mali_hwc_MMU_REPLAY_FULL', 'Replay Buffer Full');
    this.addMMUCounter('mali_hwc_MMU_NEW_MISS', 'Cache Miss on New Request');
    this.addMMUCounter('mali_hwc_MMU_HIT', 'Cache Hit');

    this.addMMUCycles('mali_hwc_UTLB_STALL', 'UTLB Stalled');
    this.addMMUCycles('mali_hwc_UTLB_REPLAY_MISS', 'UTLB Replay Miss');
    this.addMMUCycles('mali_hwc_UTLB_REPLAY_FULL', 'UTLB Replay Full');
    this.addMMUCycles('mali_hwc_UTLB_NEW_MISS', 'UTLB New Miss');
    this.addMMUCycles('mali_hwc_UTLB_HIT', 'UTLB Hit');

    this.addL2Counter('mali_hwc_L2_READ_BEATS', 'Read Beats');
    this.addL2Counter('mali_hwc_L2_WRITE_BEATS', 'Write Beats');
    this.addL2Counter('mali_hwc_L2_ANY_LOOKUP', 'Any Lookup');
    this.addL2Counter('mali_hwc_L2_READ_LOOKUP', 'Read Lookup');
    this.addL2Counter('mali_hwc_L2_SREAD_LOOKUP', 'Shareable Read Lookup');
    this.addL2Counter('mali_hwc_L2_READ_REPLAY', 'Read Replayed');
    this.addL2Counter('mali_hwc_L2_READ_SNOOP', 'Read Snoop');
    this.addL2Counter('mali_hwc_L2_READ_HIT', 'Read Cache Hit');
    this.addL2Counter('mali_hwc_L2_CLEAN_MISS', 'CleanUnique Miss');
    this.addL2Counter('mali_hwc_L2_WRITE_LOOKUP', 'Write Lookup');
    this.addL2Counter('mali_hwc_L2_SWRITE_LOOKUP', 'Shareable Write Lookup');
    this.addL2Counter('mali_hwc_L2_WRITE_REPLAY', 'Write Replayed');
    this.addL2Counter('mali_hwc_L2_WRITE_SNOOP', 'Write Snoop');
    this.addL2Counter('mali_hwc_L2_WRITE_HIT', 'Write Cache Hit');
    this.addL2Counter('mali_hwc_L2_EXT_READ_FULL', 'ExtRD with BIU Full');
    this.addL2Counter('mali_hwc_L2_EXT_READ_HALF', 'ExtRD with BIU >1/2 Full');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_FULL', 'ExtWR with BIU Full');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_HALF', 'ExtWR with BIU >1/2 Full');

    this.addL2Counter('mali_hwc_L2_EXT_READ', 'External Read (ExtRD)');
    this.addL2Counter('mali_hwc_L2_EXT_READ_LINE', 'ExtRD (linefill)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE', 'External Write (ExtWR)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_LINE', 'ExtWR (linefill)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_SMALL', 'ExtWR (burst size <64B)');
    this.addL2Counter('mali_hwc_L2_EXT_BARRIER', 'External Barrier');
    this.addL2Counter('mali_hwc_L2_EXT_AR_STALL', 'Address Read stalls');
    this.addL2Counter('mali_hwc_L2_EXT_R_BUF_FULL',
        'Response Buffer full stalls');
    this.addL2Counter('mali_hwc_L2_EXT_RD_BUF_FULL',
        'Read Data Buffer full stalls');
    this.addL2Counter('mali_hwc_L2_EXT_R_RAW', 'RAW hazard stalls');
    this.addL2Counter('mali_hwc_L2_EXT_W_STALL', 'Write Data stalls');
    this.addL2Counter('mali_hwc_L2_EXT_W_BUF_FULL', 'Write Data Buffer full');
    this.addL2Counter('mali_hwc_L2_EXT_R_W_HAZARD', 'WAW or WAR hazard stalls');
    this.addL2Counter('mali_hwc_L2_TAG_HAZARD', 'Tag hazard replays');
    this.addL2Cycles('mali_hwc_L2_SNOOP_FULL', 'Snoop buffer full');
    this.addL2Cycles('mali_hwc_L2_REPLAY_FULL', 'Replay buffer full');

    // DDK events (from X server)
    importer.registerEventHandler('tracing_mark_write:mali_driver',
        MaliParser.prototype.maliDDKEvent.bind(this));

    this.model_ = importer.model_;
  }

  MaliParser.prototype = {
    __proto__: Parser.prototype,

    maliDDKOpenSlice: function(pid, tid, ts, func, blockinfo) {
      var thread = this.importer.model_.getOrCreateProcess(pid)
        .getOrCreateThread(tid);
      var funcArgs = /^([\w\d_]*)(?:\(\))?:?\s*(.*)$/.exec(func);
      thread.sliceGroup.beginSlice('gpu-driver', funcArgs[1], ts,
          { 'args': funcArgs[2],
            'blockinfo': blockinfo });
    },

    maliDDKCloseSlice: function(pid, tid, ts, args, blockinfo) {
      var thread = this.importer.model_.getOrCreateProcess(pid)
        .getOrCreateThread(tid);
      if (!thread.sliceGroup.openSliceCount) {
        // Discard unmatched ends.
        return;
      }
      thread.sliceGroup.endSlice(ts);
    },

    /**
     * Deduce the format of Mali perf events.
     *
     * @return {RegExp} the regular expression for parsing data when the format
     * is recognized; otherwise null.
     */
    autoDetectLineRE: function(line) {
      // Matches Mali perf events with thread info
      var lineREWithThread =
          /^\s*\(([\w\-]*)\)\s*(\w+):\s*([\w\\\/\.\-]*@\d*):?\s*(.*)$/;
      if (lineREWithThread.test(line))
        return lineREWithThread;

      // Matches old-style Mali perf events
      var lineRENoThread = /^s*()(\w+):\s*([\w\\\/.\-]*):?\s*(.*)$/;
      if (lineRENoThread.test(line))
        return lineRENoThread;
      return null;
    },

    lineRE: null,

    /**
     * Parses maliDDK events and sets up state in the importer.
     * events will come in pairs with a cros_trace_print_enter
     * like this (line broken here for formatting):
     *
     * tracing_mark_write: mali_driver: (mali-012345) cros_trace_print_enter: \
     *   gles/src/texture/mali_gles_texture_slave.c@1505: gles2_texturep_upload
     *
     * and a cros_trace_print_exit like this:
     *
     * tracing_mark_write: mali_driver: (mali-012345) cros_trace_print_exit: \
     *   gles/src/texture/mali_gles_texture_slave.c@1505:
     */
    maliDDKEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      if (this.lineRE == null) {
        this.lineRE = this.autoDetectLineRE(eventBase.details);
        if (this.lineRE == null)
          return false;
      }
      var maliEvent = this.lineRE.exec(eventBase.details);
      // Old-style Mali perf events have no thread id, so make one.
      var tid = (maliEvent[1] === '' ? 'mali' : maliEvent[1]);
      switch (maliEvent[2]) {
        case 'cros_trace_print_enter':
          this.maliDDKOpenSlice(pid, tid, ts, maliEvent[4],
              maliEvent[3]);
          break;
        case 'cros_trace_print_exit':
          this.maliDDKCloseSlice(pid, tid, ts, [], maliEvent[3]);
      }
      return true;
    },

    /*
     * Kernel event support.
     */

    dvfsSample: function(counterName, seriesName, ts, s) {
      var value = parseInt(s);
      var counter = this.model_.kernel.
          getOrCreateCounter('DVFS', counterName);
      if (counter.numSeries === 0) {
        counter.addSeries(new tr.model.CounterSeries(seriesName,
            tr.ui.b.getColorIdForGeneralPurposeString(counter.name)));
      }
      counter.series.forEach(function(series) {
        series.addCounterSample(ts, value);
      });
    },

    dvfsEventEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /utilization=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.dvfsSample('DVFS Utilization', 'utilization', ts, event[1]);
      return true;
    },

    dvfsSetClockEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.dvfsSample('DVFS Frequency', 'frequency', ts, event[1]);
      return true;
    },

    dvfsSetVoltageEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /voltage=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.dvfsSample('DVFS Voltage', 'voltage', ts, event[1]);
      return true;
    },

    hwcSample: function(cat, counterName, seriesName, ts, eventBase) {
      var event = /val=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;
      var value = parseInt(event[1]);

      var counter = this.model_.kernel.
          getOrCreateCounter(cat, counterName);
      if (counter.numSeries === 0) {
        counter.addSeries(new tr.model.CounterSeries(seriesName,
            tr.ui.b.getColorIdForGeneralPurposeString(counter.name)));
      }
      counter.series.forEach(function(series) {
        series.addCounterSample(ts, value);
      });
      return true;
    },

    /*
     * Job Manager block counters.
     */
    jmSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:jm', 'JM: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addJMCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.jmSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addJMCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.jmSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Tiler block counters.
     */
    tilerSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:tiler', 'Tiler: ' + ctrName, seriesName,
          ts, eventBase);
    },
    addTilerCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.tilerSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addTilerCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.tilerSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Fragment counters.
     */
    fragSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:fragment', 'Fragment: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addFragCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.fragSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addFragCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.fragSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Compute counters.
     */
    computeSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:compute', 'Compute: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addComputeCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.computeSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addComputeCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.computeSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Tripipe counters.
     */
    addTripipeCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:shader', 'Tripipe: ' + hwcTitle, 'cycles',
            ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Arith counters.
     */
    arithSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:arith', 'Arith: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addArithCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.arithSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addArithCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.arithSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Load/Store counters.
     */
    addLSCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:ls', 'LS: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Texture counters.
     */
    textureSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:texture', 'Texture: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addTexCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.textureSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * LSC counters.
     */
    addLSCCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:lsc', 'LSC: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * TLB counters.
     */
    addAXICounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:axi', 'AXI: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * MMU counters.
     */
    mmuSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:mmu', 'MMU: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addMMUCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.mmuSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addMMUCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.mmuSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * L2 counters.
     */
    l2Sample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:l2', 'L2: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addL2Counter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.l2Sample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addL2Cycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.l2Sample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    }
  };

  Parser.register(MaliParser);

  return {
    MaliParser: MaliParser
  };
});


'use strict';

/**
 * @fileoverview Parses drm driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux vmscan trace events.
   * @constructor
   */
  function MemReclaimParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('mm_vmscan_kswapd_wake',
        MemReclaimParser.prototype.kswapdWake.bind(this));
    importer.registerEventHandler('mm_vmscan_kswapd_sleep',
        MemReclaimParser.prototype.kswapdSleep.bind(this));
    importer.registerEventHandler('mm_vmscan_direct_reclaim_begin',
        MemReclaimParser.prototype.reclaimBegin.bind(this));
    importer.registerEventHandler('mm_vmscan_direct_reclaim_end',
        MemReclaimParser.prototype.reclaimEnd.bind(this));
  }

  // Matches the mm_vmscan_kswapd_wake record
  //  mm_vmscan_kswapd_wake: nid=%d order=%d
  var kswapdWakeRE = /nid=(\d+) order=(\d+)/;

  // Matches the mm_vmscan_kswapd_sleep record
  //  mm_vmscan_kswapd_sleep: order=%d
  var kswapdSleepRE = /nid=(\d+)/;

  // Matches the mm_vmscan_direct_reclaim_begin record
  //  mm_vmscan_direct_reclaim_begin: order=%d may_writepage=%d gfp_flags=%s
  var reclaimBeginRE = /order=(\d+) may_writepage=\d+ gfp_flags=(.+)/;

  // Matches the mm_vmscan_direct_reclaim_end record
  //  mm_vmscan_direct_reclaim_end: nr_reclaimed=%lu
  var reclaimEndRE = /nr_reclaimed=(\d+)/;

  MemReclaimParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses memreclaim events and sets up state in the importer.
     */
    kswapdWake: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = kswapdWakeRE.exec(eventBase.details);
      if (!event)
        return false;

      var tgid = parseInt(eventBase.tgid);

      var nid = parseInt(event[1]);
      var order = parseInt(event[2]);

      var kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      if (kthread.openSliceTS) {
        if (order > kthread.order) {
          kthread.order = order;
        }
      } else {
        kthread.openSliceTS = ts;
        kthread.order = order;
      }
      return true;
    },

    kswapdSleep: function(eventName, cpuNumber, pid, ts, eventBase) {
      var tgid = parseInt(eventBase.tgid);

      var kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      if (kthread.openSliceTS) {

        kthread.thread.sliceGroup.pushCompleteSlice(
            'memreclaim', eventBase.threadName, kthread.openSliceTS,
            ts - kthread.openSliceTS, 0, 0,
            {
              order: kthread.order
            });
      }
      kthread.openSliceTS = undefined;
      kthread.order = undefined;
      return true;
    },

    reclaimBegin: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = reclaimBeginRE.exec(eventBase.details);
      if (!event)
        return false;

      var order = parseInt(event[1]);
      var gfp = event[2];
      var tgid = parseInt(eventBase.tgid);

      var kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      kthread.openSliceTS = ts;
      kthread.order = order;
      kthread.gfp = gfp;
      return true;
    },

    reclaimEnd: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = reclaimEndRE.exec(eventBase.details);
      if (!event)
        return false;

      var nr_reclaimed = parseInt(event[1]);
      var tgid = parseInt(eventBase.tgid);

      var kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      if (kthread.openSliceTS !== undefined) {
        kthread.thread.sliceGroup.pushCompleteSlice('memreclaim',
            'direct reclaim', kthread.openSliceTS, ts - kthread.openSliceTS,
            0, 0,
            {
              order: kthread.order,
              gfp: kthread.gfp,
              nr_reclaimed: nr_reclaimed
            });
      }
      kthread.openSliceTS = undefined;
      kthread.order = undefined;
      kthread.gfp = undefined;
      return true;
    }

  };

  Parser.register(MemReclaimParser);

  return {
    MemReclaimParser: MemReclaimParser
  };
});


'use strict';

/**
 * @fileoverview Parses Binder events
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  var Parser = tr.e.importer.linux_perf.Parser;

  // Matches binder transactions:
  // transaction=%d dest_node=%d dest_proc=%d dest_thread=%d reply=%d flags=0x%x
  // code=0x%x
  var binderTransRE = new RegExp('transaction=(\\d+) dest_node=(\\d+) ' +
                                 'dest_proc=(\\d+) dest_thread=(\\d+) ' +
                                 'reply=(\\d+) flags=(0x[0-9a-fA-F]+) ' +
                                 'code=(0x[0-9a-fA-F]+)');

  var binderTransReceivedRE = /transaction=(\d+)/;

  function isBinderThread(name) {
    return (name.indexOf('Binder') > -1);
  }

  // Taken from kernel source: include/uapi/linux/android/binder.h.
  var TF_ONE_WAY = 0x01;
  var TF_ROOT_OBJECT = 0x04;
  var TF_STATUS_CODE = 0x08;
  var TF_ACCEPT_FDS = 0x10;
  var NO_FLAGS = 0;

  function binderFlagsToHuman(num) {
    var flag = parseInt(num, 16);
    var str = '';

    if (flag & TF_ONE_WAY)
      str += 'this is a one-way call: async, no return; ';
    if (flag & TF_ROOT_OBJECT)
      str += 'contents are the components root object; ';
    if (flag & TF_STATUS_CODE)
      str += 'contents are a 32-bit status code; ';
    if (flag & TF_ACCEPT_FDS)
      str += 'allow replies with file descriptors; ';
    if (flag === NO_FLAGS)
      str += 'No Flags Set';

    return str;
  }

  function isReplyToOrigin(calling, called) {
    return (called.dest_proc === calling.calling_pid ||
            called.dest_thread === calling.calling_pid);
  }

  function binderCodeToHuman(code) {
    return 'Java Layer Dependent';
  }

  function doInternalSlice(trans, slice, ts) {
    if (slice.subSlices.length !== 0) {
      /* We want to make sure we keep moving the small slice to the end of
         the big slice or else the arrows will not point to the end.
      */
      slice.subSlices[0].start = ts;
      return slice.subSlices[0];
    }
    var kthread = trans.calling_kthread.thread;
    var internal_slice = kthread.sliceGroup.pushCompleteSlice('binder',
                             slice.title,
                             ts, .001, 0, 0,
                             slice.args);

    internal_slice.title = slice.title;
    internal_slice.id = slice.id;
    internal_slice.colorId = slice.colorId;
    slice.subSlices.push(internal_slice);
    return internal_slice;
  }

  function generateBinderArgsForSlice(trans, c_threadName) {
    return {
      'Transaction Id': trans.transaction_key,
      'Destination Node': trans.dest_node,
      'Destination Process': trans.dest_proc,
      'Destination Thread': trans.dest_thread,
      'Destination Name': c_threadName,
      'Reply transaction?': trans.is_reply_transaction,
      'Flags': trans.flags + ' ' +
           binderFlagsToHuman(trans.flags),

      'Code': trans.code + ' ' +
           binderCodeToHuman(trans.code),

      'Calling PID': trans.calling_pid,
      'Calling tgid': trans.calling_kthread.thread.parent.pid
    };
  }

  /** @constructor */
  function BinderTransaction(events, calling_pid, calling_ts, calling_kthread) {
    this.transaction_key = parseInt(events[1]);
    this.dest_node = parseInt(events[2]);
    this.dest_proc = parseInt(events[3]);
    this.dest_thread = parseInt(events[4]);
    this.is_reply_transaction = parseInt(events[5]) === 1 ? true : false;
    this.expect_reply = ((this.is_reply_transaction === false) &&
        (parseInt(events[6], 16) & TF_ONE_WAY) === 0);

    this.flags = events[6];
    this.code = events[7];
    this.calling_pid = calling_pid;
    this.calling_ts = calling_ts;
    this.calling_kthread = calling_kthread;
  }


  /** @constructor */
  function BinderParser(importer) {
    Parser.call(this, importer);
    importer.registerEventHandler('binder_locked',
        BinderParser.prototype.
        binderLocked.bind(this));
    importer.registerEventHandler('binder_unlock',
        BinderParser.prototype.
        binderUnlock.bind(this));
    importer.registerEventHandler('binder_lock',
        BinderParser.prototype.binderLock.bind(this));
    importer.registerEventHandler('binder_transaction',
        BinderParser.prototype.
        binderTransaction.bind(this));
    importer.registerEventHandler('binder_transaction_received',
        BinderParser.prototype.
        binderTransactionReceived.bind(this));

    this.model_ = importer.model;
    this.kthreadlookup = {};
    this.importer_ = importer;
    this.transWaitingRecv = {};
    this.syncTransWaitingCompletion = {};
    this.recursiveSyncTransWaitingCompletion_ByPID = {};
    this.receivedTransWaitingConversion = {};
  }

  BinderParser.prototype = {
    __proto__: Parser.prototype,

    binderLock: function(eventName, cpuNumber, pid, ts, eventBase) {
      var tgid = parseInt(eventBase.tgid);
      this.doNameMappings(pid, tgid, eventName.threadName);

      var kthread = this.importer_.
          getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);

      kthread.binderAttemptLockTS = ts;
      kthread.binderOpenTsA = ts;
      return true;
    },

    binderLocked: function(eventName, cpuNumber, pid, ts, eventBase) {
      var binder_thread = isBinderThread(eventBase.threadName);
      var tgid, name;
      var as_slice;
      var need_push = false;
      var kthread, rthread;

      tgid = parseInt(eventBase.tgid);
      name = eventBase.threadName;

      kthread = this.importer_.
          getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);

      this.doNameMappings(pid, tgid, name);

      rthread = kthread.thread;
      kthread.binderLockAquiredTS = ts;

      if (kthread.binderAttemptLockTS === undefined)
        return false;

      var args = this.generateArgsForSlice(tgid, pid, name, kthread);
      rthread.sliceGroup.pushCompleteSlice('binder', 'binder lock waiting',
          kthread.binderAttemptLockTS,
          ts - kthread.binderAttemptLockTS,
          0, 0, args);

      kthread.binderAttemptLockTS = undefined;
      return true;
    },

    binderUnlock: function(eventName, cpuNumber, pid, ts, eventBase) {
      var tgid = parseInt(eventBase.tgid);
      var kthread = this.importer_.
          getOrCreateBinderKernelThread(
          eventBase.threadName, tgid, pid);

      if (kthread.binderLockAquiredTS === undefined)
        return false;

      args = this.generateArgsForSlice(tgid, pid, eventBase.threadName,
          kthread);
      kthread.thread.sliceGroup.pushCompleteSlice(
          'binder',
          'binder lock held',
           kthread.binderLockAquiredTS,
           ts - kthread.binderLockAquiredTS,
           0, 0, args);

      kthread.binderLockAquiredTS = undefined;
      return true;
    },

    /** There are a few transaction status changes that signify
     *  progress through a binder transaction:
     *
     * Case One: Sync transaction.
     *  Thread A calls a blocking function on Thread B. We receive a
     *  binder_transaction msg From thread A stating that it is going to Call
     *  thread B. We create a slice and a binder object for this transaction and
     *  add it to addTransactionWaitingForRecv(transaction key, binder object)
     *  This notifies thread B and passes the slice, binder object and time
     *  stamp.
     *
     * Case Two: Async transaction.
     *  Thread A calls an async function on Thread B. Like above we receive a
     *  binder_transaction message, but the flags differ from above. The
     *  TF_ONEWAY flags are set so we know that when Thread B gets the
     *  binder_transaction_received with the same transaciton key the total
     *  transaction is complete.
     *
     * Case Three: 'Prior_receive'
     *  Prior_receive occurs when the thread being called (think A calls B),
     *  receives a binder_transaction_received message, but cannot correlate it
     *  to any current outstanding recursive transactions. That means the
     *  message it just received is the start of some communication, not some
     *  ongoing communication.
     *  Once the execution flow has been passed to thread B, from A:
     *  Thread B enters binder_transaction_received() we see that Thread A
     *  had notified us that it sent us a message by calling
     *  getTransactionWaitingForRecv(transaction key);
     *  What can happen now is either this was a simple Call reply,
     *  or this is a call -> recursion -> reply. We call modelPriorReceive()
     *  which sets up the slices accordingly.
     *  If this is a call -> recursion -> reply
     *  we will go to case 4 by calling addRecursiveSyncTransNeedingCompletion()
     *  The function takes B's PID, the binder object from A and the current
     *  binder object from B. This function adds outstanding non-complete
     *  transactions to a stack on thread B.
     *
     * Case Four: 'recursive_trans'
     *  This case follows Like above:
     *  A sent binder_transaction
     *  B got binder_transaction_received
     *  B instead of replying to A can Call C or call 'into' A, ie recursion
     *  Case four also deals with setting up a large slice to 'contain'
     *  all the recursive transactions that happen until B finally replies to
     *  A.
     *
     *
     * An example: A-> B-> C-> B-> A
     *
     * (1) A starts a synchronous transaction to B.
     * (2) A enters binderTransaction() event handler, hits the else statement
     * (3) A calls addTransactionWaitingForRecv(trans key, object) to notify
     *     Thread B.
     * (4) B Enters binderTransactionReceived().
     * (5) B hits the second if after calling
     *     getTransactionWaitingForRecv(trans key)
     *     This function returns us the object set up in step (3).
     * (6) This is not an async transaction, B calls
     *      setCurrentReceiveOnPID(B's PID, [ts for (4), object from (3)]).
     *
     * (7) B enters binderTransaction() event handler, first if triggers after
     *     calling getPriorReceiveOnPID(B's PID) the tuple from (6) is returned.
     *
     * (8) Execution enters modelPriorReceive().
     * (8a) A slice is setup for this binder transaction in B's timeline.
     * (9) This is not a reply to thread A, B is going to call Thread C.
     * (10) else statement is hit.
     * (11) We set the tile from (8a) to be binder_reply this is the
     *     'containg slice' for the recursion
     * (12) We create a new slice 'binder_transaction' this slice is the
     *      recursive slice that will have arrows to Thread C's slice.
     * (13) addRecursiveSyncTransNeedingCompletion(B's PID,
     *                                            [obj from (3), obj from 7])
     *      this sets up notification that B's pid has outstanding recursive
     *      transactions that need to be completed.
     * (14) B notifies C that a transaction is waiting for it by calling
     *      addTransactionWaitingForRecv like in step (3).
     * (15) C enters binderTransactionReceived() step 5 6 7 8 8a happen, but in
     *      the context of Thread C.
     * (16) C is in modelPriorReceive(), it hits the first if statement,
     *      this transaction _IS_ a reply, and it is a reply to B.
     * (17) C calls addSyncTransNeedingCompletion(trans key,
     *                                       [object from(3), object from 15-5])
     * (18) B enters binderTransactionReceived() hits the first if after calling
     *      getSyncTransNeedingCompletion(trans key from (17)) the tuple from
     *     (17) gets returned.
     *
     * (19) B scales up the slice created in (12) and sets up flows from 15-8a
     *      slice.
     * (20) B enters BinderTransaction() event handler and the second if is hit
     *      after calling getRecursiveTransactionNeedingCompletion(B's pid).
     * (21) modelRecursiveTransactions() gets called, first if executes.
     * (22) slice durations are fixed up.
     * (23) B notifies A via
     *      addSyncTransNeedingCompletion(trans key, binder obj from 8a).
     * (24) B deletes the outstanding asynctrans via
     (      removeRecursiveTransaction(B's pid).
     * (25) A enters binderTransactionReceived() event handler and finishes up
     *      some flows, and slices.
     */
    binderTransaction: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = binderTransRE.exec(eventBase.details);
      if (event === undefined)
        return false;

      var tgid = parseInt(eventBase.tgid);

      this.doNameMappings(pid, tgid, eventBase.threadName);

      var kthread;
      kthread = this.importer_.
          getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);

      var trans = new BinderTransaction(event, pid, ts, kthread);
      var args = generateBinderArgsForSlice(trans, eventBase.threadName);
      /**
       * This thread previously ack'd the transaction with a
       * transaction_received. That means someone sent us a message we processed
       * it and are now sending a transaction.
       * The transaction could be a response, or it could be recursive.
       */
      var prior_receive = this.getPriorReceiveOnPID(pid);

      if (prior_receive !== false) {
        return this.modelPriorReceive(prior_receive, ts, pid, tgid, kthread,
            trans, args, event);
      }
      /**
       * This Thread has an already established recursive slice. We will now
       * either complete the entire transaction, OR do more recursive calls.
       */
      var recursive_trans = this.getRecursiveTransactionNeedingCompletion(pid);

      if (recursive_trans !== false)
        return this.modelRecursiveTransactions(recursive_trans, ts, pid,
            kthread, trans, args);

      /**
       * Start of a Transaction. This thread is the initiator of either a call
       * response, an async call -> ack, or a call -> recursion -> response.
       * Note, we put a fake duration into this slice and patch it up later.
       */
      var slice = kthread.thread.sliceGroup.pushCompleteSlice('binder',
          '', ts, .03, 0, 0, args);

      slice.colorId = tr.ui.b.
          getColorIdForGeneralPurposeString(ts.toString());
      trans.slice = slice;

      if (trans.expect_reply)
        slice.title = 'binder transaction';
      else
        slice.title = 'binder transaction async';

      this.addTransactionWaitingForRecv(trans.transaction_key, trans);

      return true;
    },

    binderTransactionReceived: function(eventName, cpuNumber, pid, ts,
                                        eventBase) {
      var event = binderTransReceivedRE.exec(eventBase.details);

      if (event === undefined)
        return false;

      var transactionkey = parseInt(event[1]);
      var tgid = parseInt(eventBase.tgid);
      var kthread;
      kthread = this.importer_.
          getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);

      var syncComplete = this.getSyncTransNeedsCompletion(transactionkey);

      if (syncComplete !== false) {
        /* This recv is the completion of a synchronous transaction.
         * We need to scale the slice up to the current ts and finish
         * creating some flows.
         */
        var sync_trans = syncComplete[0];
        var sync_slice = sync_trans.slice;
        var response_trans = syncComplete[1];
        var response_slice = response_trans.slice;

        sync_slice.duration = ts - sync_slice.start;
        /** These calls are a little hack that places a very small slice at
         *  the end of the sync slice and the response slice. This allows us
         *  to hook flow events (arrows) from the start to the end of the
         *  slices.
         */
        var sync_internal = doInternalSlice(sync_trans, sync_slice, ts);
        var response_ts = response_slice.start + response_slice.duration;
        var response_internal = doInternalSlice(response_trans,
            response_slice, response_ts);

        if (response_slice.outFlowEvents.length === 0 ||
            sync_slice.inFlowEvents.length === 0) {
          var flow = this.generateFlow(response_internal, sync_internal,
              response_trans, sync_trans);

          sync_slice.inFlowEvents.push(flow);
          response_slice.outFlowEvents.push(flow);
          this.model_.flowEvents.push(flow);
        }
        // Move flow arrows -- but not the first one.
        for (var i = 1; i < sync_slice.inFlowEvents.length; i++) {
          sync_slice.inFlowEvents[i].duration =
              ts - sync_slice.inFlowEvents[i].start;
        }
        return true;
      }

      var tr_for_recv = this.getTransactionWaitingForRecv(transactionkey);

      if (tr_for_recv !== false) {
        if (!tr_for_recv.expect_reply) {
          // This is an async call place an Async slice.
          var args = generateBinderArgsForSlice(tr_for_recv,
              eventBase.threadName);
          var slice = kthread.thread.sliceGroup.
              pushCompleteSlice('binder',
              'binder Async recv',
              ts, .03, 0, 0,
              args);

          var fake_event = [0, 0, 0, 0, 0, 0, 0];
          var fake_trans = new BinderTransaction(fake_event, pid, ts, kthread);
          var flow = this.generateFlow(tr_for_recv.slice, slice,
              tr_for_recv, fake_trans);

          this.model_.flowEvents.push(flow);
          tr_for_recv.slice.title = 'binder transaction async';
          tr_for_recv.slice.duration = .03;
          return true;
        }
        // Setup prior receive.
        tr_for_recv.slice.title = 'binder transaction';
        this.setCurrentReceiveOnPID(pid, [ts, tr_for_recv]);
        return true;
      }
      /** This case is when we received an ack for a transaction we have
       *  never seen before. This usually happens at the start of a trace.
       *  We will get incomplete transactions that started before started
       *  tracing. Just discard them.
       */
      return false;
    },

    // helper functions
    modelRecursiveTransactions: function(recursive_trans, ts, pid, kthread,
                                         trans, args) {

      var recursive_slice = recursive_trans[1].slice;
      var orig_slice = recursive_trans[0].slice;
      recursive_slice.duration = ts - recursive_slice.start;
      trans.slice = recursive_slice;

      if (trans.is_reply_transaction) {
        /* Case one:
         * This transaction is finally the reply of the recursion.
         */
        orig_slice.duration = ts - orig_slice.start;
        this.addSyncTransNeedingCompletion(trans.transaction_key,
             recursive_trans);

        if (isReplyToOrigin(recursive_trans[0], trans))
          this.removeRecursiveTransaction(pid);
      } else {
        /**
         *  Case two:
         *  This transaction is more recursive calls.
         *  This is a nested call within an already started transaction,
         *  it can either be a async or a normal sync transaction.
         */
        var slice = kthread.thread.sliceGroup.pushCompleteSlice('binder',
            '' , ts, .03, 0,
            0, args);

        trans.slice = slice;
        this.addTransactionWaitingForRecv(trans.transaction_key, trans);
      }
      return true;
    },

    modelPriorReceive: function(prior_receive, ts, pid, tgid, kthread, trans,
                                args, event) {
      var callee_slice = prior_receive[1].slice;
      var callee_trans = prior_receive[1];
      var recv_ts = prior_receive[0];
      var slice = kthread.thread.sliceGroup.pushCompleteSlice('binder',
          '', recv_ts, ts - recv_ts, 0, 0, args);

      var flow = this.generateFlow(callee_slice, slice, callee_trans, trans);
      this.model_.flowEvents.push(flow);
      trans.slice = slice;

      if (trans.is_reply_transaction) {
        /* This is a response to a synchronous or a recursive sync
         * transaction.
         */
        slice.title = 'binder reply';
        /* Notify this transaction key that when it recv's it is completing
         * a sync transaction.
         */
        this.addSyncTransNeedingCompletion(trans.transaction_key,
            [callee_trans, trans]);
      } else {
        /**
         * Recursive calls and or calls around, either way it's not
         * going to complete a transaction.
         */
          slice.title = 'binder reply';
          /* Since this is a recursive transaction we want to create the main
           * large slice which will contain all these recursive transactions.
           * For that we created the main slice above and this is a recursive
           * transaction that will be placed right below it. Note, that this
           * is only for the first recursive transaction. If more come they will
           * be handled below in the getRecursiveTransactionNeedingCompletion
           */
          var trans1 = new BinderTransaction(event, pid, ts, kthread);

          slice = kthread.thread.sliceGroup.
          pushCompleteSlice('binder',
              'binder transaction',
              recv_ts,
              (ts - recv_ts), 0,
              0, args);

          /* could be a async trans if so set the length to be a small one */
          if (!trans.expect_reply) {
            slice.title = 'binder transaction async';
            slice.duration = .03;
          } else {
            /* stupid hack to stop merging of AIDL slices and
             * this slice. This is currently disabled, if AIDL tracing is on we
             * will see merging of this slice and the AIDL slice. Once upstream
             * has a solution for flow events to be placed in the middle of
             * slices this part can be fixed.
             *
             * This is commented out because AIDL tracing doesn't exit yet.
             */
            //slice.start += .15;
          }
          trans1.slice = slice;
          this.addRecursiveSyncTransNeedingCompletion(pid,
              [callee_trans, trans]);
          this.addTransactionWaitingForRecv(trans.transaction_key, trans1);
      }
      return true;
    },

    getRecursiveTransactionNeedingCompletion: function(pid) {
      if (this.recursiveSyncTransWaitingCompletion_ByPID[pid] === undefined)
        return false;

      var len = this.recursiveSyncTransWaitingCompletion_ByPID[pid].length;
      if (len === 0)
        return false;

      return this.recursiveSyncTransWaitingCompletion_ByPID[pid][len - 1];
    },

    addRecursiveSyncTransNeedingCompletion: function(pid, tuple) {
      if (this.recursiveSyncTransWaitingCompletion_ByPID[pid] === undefined)
        this.recursiveSyncTransWaitingCompletion_ByPID[pid] = [];

      this.recursiveSyncTransWaitingCompletion_ByPID[pid].push(tuple);
    },

    removeRecursiveTransaction: function(pid) {
      var len = this.recursiveSyncTransWaitingCompletion_ByPID[pid].length;
      if (len === 0) {
        delete this.recursiveSyncTransWaitingCompletion_ByPID[pid];
        return;
      }

      this.recursiveSyncTransWaitingCompletion_ByPID[pid].splice(len - 1, 1);
    },

    setCurrentReceiveOnPID: function(pid, tuple) {
      if (this.receivedTransWaitingConversion[pid] === undefined) {
        this.receivedTransWaitingConversion[pid] = [];
      }
      this.receivedTransWaitingConversion[pid].push(tuple);
    },

    getPriorReceiveOnPID: function(pid) {
      if (this.receivedTransWaitingConversion[pid] === undefined)
        return false;

      var len = this.receivedTransWaitingConversion[pid].length;
      if (len === 0)
        return false;

      return this.receivedTransWaitingConversion[pid].splice(len - 1, 1)[0];
    },

    addSyncTransNeedingCompletion: function(transactionkey, tuple) {
      var dict = this.syncTransWaitingCompletion;
      dict[transactionkey] = tuple;
    },

    getSyncTransNeedsCompletion: function(transactionkey) {
      var ret = this.syncTransWaitingCompletion[transactionkey];
      if (ret === undefined)
        return false;

      delete this.syncTransWaitingCompletion[transactionkey];
      return ret;
    },

    getTransactionWaitingForRecv: function(transactionkey) {
      var ret = this.transWaitingRecv[transactionkey];
      if (ret === undefined)
        return false;

      delete this.transWaitingRecv[transactionkey];
      return ret;
    },

    addTransactionWaitingForRecv: function(transactionkey, transaction) {
      this.transWaitingRecv[transactionkey] = transaction;
    },

    generateFlow: function(from, to, from_trans, to_trans) {
      var title = 'Transaction from : ' +
        this.pid2name(from_trans.calling_pid) +
        ' From PID: ' + from_trans.calling_pid + ' to pid: ' +
        to_trans.calling_pid +
        ' Thread Name: ' + this.pid2name(to_trans.calling_pid);

      var ts = from.start;
      var flow = new tr.model.FlowEvent('binder', 'binder',
          title, 1, ts, []);
      flow.startSlice = from;
      flow.endSlice = to;
      flow.start = from.start;
      flow.duration = to.start - ts;

      from.outFlowEvents.push(flow);
      to.inFlowEvents.push(flow);

      return flow;
    },

    generateArgsForSlice: function(tgid, pid, name, kthread) {
      return {
        'Thread Name': name,
        'pid': pid,
        'gid': tgid
      };
    },

    pid2name: function(pid) {
      return this.kthreadlookup[pid];
    },

    doNameMappings: function(pid, tgid, name) {
      this.registerPidName(pid, name);
      this.registerPidName(tgid, name);
    },

    registerPidName: function(pid, name) {
      if (this.pid2name(pid) === undefined)
        this.kthreadlookup[pid] = name;
    }
  };

  Parser.register(BinderParser);
  return {
    BinderParser: BinderParser
  };
});


'use strict';

/**
 * @fileoverview Parses power events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux power trace events.
   * @constructor
   */
  function PowerParser(importer) {
    Parser.call(this, importer);

    // NB: old-style power events, deprecated
    importer.registerEventHandler('power_start',
        PowerParser.prototype.powerStartEvent.bind(this));
    importer.registerEventHandler('power_frequency',
        PowerParser.prototype.powerFrequencyEvent.bind(this));

    importer.registerEventHandler('cpu_frequency',
        PowerParser.prototype.cpuFrequencyEvent.bind(this));
    importer.registerEventHandler('cpu_idle',
        PowerParser.prototype.cpuIdleEvent.bind(this));
  }

  PowerParser.prototype = {
    __proto__: Parser.prototype,

    cpuStateSlice: function(ts, targetCpuNumber, eventType, cpuState) {
      var targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
      var powerCounter;
      if (eventType != '1') {
        this.importer.model.importWarning({
          type: 'parse_error',
          message: 'Don\'t understand power_start events of ' +
              'type ' + eventType
        });
        return;
      }
      powerCounter = targetCpu.getOrCreateCounter('', 'C-State');
      if (powerCounter.numSeries === 0) {
        powerCounter.addSeries(new tr.model.CounterSeries('state',
            tr.ui.b.getColorIdForGeneralPurposeString(
                powerCounter.name + '.' + 'state')));
      }
      powerCounter.series.forEach(function(series) {
        series.addCounterSample(ts, cpuState);
      });
    },

    cpuIdleSlice: function(ts, targetCpuNumber, cpuState) {
      var targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
      var powerCounter = targetCpu.getOrCreateCounter('', 'C-State');
      if (powerCounter.numSeries === 0) {
        powerCounter.addSeries(new tr.model.CounterSeries('state',
            tr.ui.b.getColorIdForGeneralPurposeString(powerCounter.name)));
      }
      // NB: 4294967295/-1 means an exit from the current state
      var val = (cpuState != 4294967295 ? cpuState + 1 : 0);
      powerCounter.series.forEach(function(series) {
        series.addCounterSample(ts, val);
      });
    },

    cpuFrequencySlice: function(ts, targetCpuNumber, powerState) {
      var targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
      var powerCounter =
          targetCpu.getOrCreateCounter('', 'Clock Frequency');
      if (powerCounter.numSeries === 0) {
        powerCounter.addSeries(new tr.model.CounterSeries('state',
            tr.ui.b.getColorIdForGeneralPurposeString(
                powerCounter.name + '.' + 'state')));
      }
      powerCounter.series.forEach(function(series) {
        series.addCounterSample(ts, powerState);
      });
    },

    /**
     * Parses power events and sets up state in the importer.
     */
    powerStartEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /type=(\d+) state=(\d) cpu_id=(\d)+/.exec(eventBase.details);
      if (!event)
        return false;

      var targetCpuNumber = parseInt(event[3]);
      var cpuState = parseInt(event[2]);
      this.cpuStateSlice(ts, targetCpuNumber, event[1], cpuState);
      return true;
    },

    powerFrequencyEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /type=(\d+) state=(\d+) cpu_id=(\d)+/
          .exec(eventBase.details);
      if (!event)
        return false;

      var targetCpuNumber = parseInt(event[3]);
      var powerState = parseInt(event[2]);
      this.cpuFrequencySlice(ts, targetCpuNumber, powerState);
      return true;
    },

    cpuFrequencyEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /state=(\d+) cpu_id=(\d)+/.exec(eventBase.details);
      if (!event)
        return false;

      var targetCpuNumber = parseInt(event[2]);
      var powerState = parseInt(event[1]);
      this.cpuFrequencySlice(ts, targetCpuNumber, powerState);
      return true;
    },

    cpuIdleEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /state=(\d+) cpu_id=(\d)+/.exec(eventBase.details);
      if (!event)
        return false;

      var targetCpuNumber = parseInt(event[2]);
      var cpuState = parseInt(event[1]);
      this.cpuIdleSlice(ts, targetCpuNumber, cpuState);
      return true;
    }
  };

  Parser.register(PowerParser);

  return {
    PowerParser: PowerParser
  };
});


'use strict';

/**
 * @fileoverview Parses regulator events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux regulator trace events.
   * @constructor
   */
  function RegulatorParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('regulator_enable',
        RegulatorParser.prototype.regulatorEnableEvent.bind(this));
    importer.registerEventHandler('regulator_enable_delay',
        RegulatorParser.prototype.regulatorEnableDelayEvent.bind(this));
    importer.registerEventHandler('regulator_enable_complete',
        RegulatorParser.prototype.regulatorEnableCompleteEvent.bind(this));
    importer.registerEventHandler('regulator_disable',
        RegulatorParser.prototype.regulatorDisableEvent.bind(this));
    importer.registerEventHandler('regulator_disable_complete',
        RegulatorParser.prototype.regulatorDisableCompleteEvent.bind(this));
    importer.registerEventHandler('regulator_set_voltage',
        RegulatorParser.prototype.regulatorSetVoltageEvent.bind(this));
    importer.registerEventHandler('regulator_set_voltage_complete',
        RegulatorParser.prototype.regulatorSetVoltageCompleteEvent.bind(this));

    this.model_ = importer.model_;
  }

  // Matches the regulator_enable record
  var regulatorEnableRE = /name=(.+)/;

  // Matches the regulator_disable record
  var regulatorDisableRE = /name=(.+)/;

  // Matches the regulator_set_voltage_complete record
  var regulatorSetVoltageCompleteRE = /name=(\S+), val=(\d+)/;

  RegulatorParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Get or create a counter with one series.
     */
    getCtr_: function(ctrName, valueName) {
      var ctr = this.model_.kernel
        .getOrCreateCounter(null, 'vreg ' + ctrName + ' ' + valueName);
      // Initialize the counter's series fields if needed.
      if (ctr.series[0] === undefined) {
        ctr.addSeries(new tr.model.CounterSeries(valueName,
        tr.ui.b.getColorIdForGeneralPurposeString(
        ctrName + '.' + valueName)));
      }
      return ctr;
    },

    /**
     * Parses regulator events and sets up state in the importer.
     */
    regulatorEnableEvent: function(eventName, cpuNum, pid, ts, eventBase) {
      var event = regulatorEnableRE.exec(eventBase.details);
      if (!event)
        return false;

      var name = event[1];

      var ctr = this.getCtr_(name, 'enabled');
      ctr.series[0].addCounterSample(ts, 1);

      return true;
    },

    regulatorEnableDelayEvent: function(eventName, cpuNum, pid, ts, eventBase) {
      return true;
    },

    regulatorEnableCompleteEvent: function(eventName, cpuNum, pid, ts,
                                           eventBase) {
      return true;
    },

    regulatorDisableEvent: function(eventName, cpuNum, pid, ts, eventBase) {
      var event = regulatorDisableRE.exec(eventBase.details);
      if (!event)
        return false;

      var name = event[1];

      var ctr = this.getCtr_(name, 'enabled');
      ctr.series[0].addCounterSample(ts, 0);

      return true;
    },

    regulatorDisableCompleteEvent: function(eventName, cpuNum, pid, ts,
                                            eventBase) {
      return true;
    },

    regulatorSetVoltageEvent: function(eventName, cpuNum, pid, ts, eventBase) {
      return true;
    },

    regulatorSetVoltageCompleteEvent: function(eventName, cpuNum, pid, ts,
                                               eventBase) {
      var event = regulatorSetVoltageCompleteRE.exec(eventBase.details);
      if (!event)
        return false;

      var name = event[1];
      var voltage = parseInt(event[2]);

      var ctr = this.getCtr_(name, 'voltage');
      ctr.series[0].addCounterSample(ts, voltage);

      return true;
    }

  };

  Parser.register(RegulatorParser);

  return {
    RegulatorParser: RegulatorParser
  };
});


'use strict';

/**
 * @fileoverview Parses scheduler events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux sched trace events.
   * @constructor
   */
  function SchedParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('sched_switch',
        SchedParser.prototype.schedSwitchEvent.bind(this));
    importer.registerEventHandler('sched_wakeup',
        SchedParser.prototype.schedWakeupEvent.bind(this));
  }

  var TestExports = {};

  // Matches the sched_switch record
  var schedSwitchRE = new RegExp(
      'prev_comm=(.+) prev_pid=(\\d+) prev_prio=(\\d+) ' +
      'prev_state=(\\S\\+?|\\S\\|\\S) ==> ' +
      'next_comm=(.+) next_pid=(\\d+) next_prio=(\\d+)');
  TestExports.schedSwitchRE = schedSwitchRE;

  // Matches the sched_wakeup record
  var schedWakeupRE =
      /comm=(.+) pid=(\d+) prio=(\d+) success=(\d+) target_cpu=(\d+)/;
  TestExports.schedWakeupRE = schedWakeupRE;

  SchedParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses scheduler events and sets up state in the CPUs of the importer.
     */
    schedSwitchEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = schedSwitchRE.exec(eventBase.details);
      if (!event)
        return false;

      var prevState = event[4];
      var nextComm = event[5];
      var nextPid = parseInt(event[6]);
      var nextPrio = parseInt(event[7]);

      var nextThread = this.importer.threadsByLinuxPid[nextPid];
      var nextName;
      if (nextThread)
        nextName = nextThread.userFriendlyName;
      else
        nextName = nextComm;

      var cpu = this.importer.getOrCreateCpu(cpuNumber);
      cpu.switchActiveThread(
          ts,
          {stateWhenDescheduled: prevState},
          nextPid,
          nextName,
          {
            comm: nextComm,
            tid: nextPid,
            prio: nextPrio
          });

      return true;
    },

    schedWakeupEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = schedWakeupRE.exec(eventBase.details);
      if (!event)
        return false;

      var fromPid = pid;
      var comm = event[1];
      var pid = parseInt(event[2]);
      var prio = parseInt(event[3]);
      this.importer.markPidRunnable(ts, pid, comm, prio, fromPid);
      return true;
    }
  };

  Parser.register(SchedParser);

  return {
    SchedParser: SchedParser,
    _SchedParserTestExports: TestExports
  };
});


'use strict';

/**
 * @fileoverview Parses sync events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux sync trace events.
   * @constructor
   */
  function SyncParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler(
        'sync_timeline',
        SyncParser.prototype.timelineEvent.bind(this));
    importer.registerEventHandler(
        'sync_wait',
        SyncParser.prototype.syncWaitEvent.bind(this));
    importer.registerEventHandler(
        'sync_pt',
        SyncParser.prototype.syncPtEvent.bind(this));
    this.model_ = importer.model_;
  }

  var syncTimelineRE = /name=(\S+) value=(\S*)/;
  var syncWaitRE = /(\S+) name=(\S+) state=(\d+)/;
  var syncPtRE = /name=(\S+) value=(\S*)/;

  SyncParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses sync events and sets up state in the importer.
     */
    timelineEvent: function(eventName, cpuNumber, pid,
                            ts, eventBase) {
      var event = syncTimelineRE.exec(eventBase.details);
      if (!event)
        return false;

      var thread = this.importer.getOrCreatePseudoThread(event[1]);

      if (thread.lastActiveTs !== undefined) {
        var duration = ts - thread.lastActiveTs;
        var value = thread.lastActiveValue;
        if (value == undefined)
          value = ' ';
        var slice = new tr.model.Slice(
            '', value,
            tr.ui.b.getColorIdForGeneralPurposeString(value),
            thread.lastActiveTs, {},
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastActiveTs = ts;
      thread.lastActiveValue = event[2];
      return true;
    },

    syncWaitEvent: function(eventName, cpuNumber, pid, ts,
                            eventBase) {
      var event = syncWaitRE.exec(eventBase.details);
      if (!event)
        return false;

      if (eventBase.tgid === undefined) {
        return false;
      }

      var tgid = parseInt(eventBase.tgid);
      var thread = this.model_.getOrCreateProcess(tgid)
        .getOrCreateThread(pid);
      thread.name = eventBase.threadName;
      var slices = thread.kernelSliceGroup;
      if (!slices.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Timestamps are moving backward.'
        });
        return false;
      }

      var name = 'fence_wait("' + event[2] + '")';
      if (event[1] == 'begin') {
        var slice = slices.beginSlice(null, name, ts, {
          'Start state': event[3]
        });
      } else if (event[1] == 'end') {
        if (slices.openSliceCount > 0) {
          slices.endSlice(ts);
        }
      } else {
        return false;
      }

      return true;
    },

    syncPtEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = syncPtRE.exec(eventBase.details);
      if (!event)
        return false;

      return true;

      var thread = this.importer.getOrCreateKernelThread(
          eventBase[1]).thread;
      thread.syncWaitSyncPts[event[1]] = event[2];
      return true;
    }
  };

  Parser.register(SyncParser);

  return {
    SyncParser: SyncParser
  };
});


'use strict';

/**
 * @fileoverview Parses workqueue events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux workqueue trace events.
   * @constructor
   */
  function WorkqueueParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('workqueue_execute_start',
        WorkqueueParser.prototype.executeStartEvent.bind(this));
    importer.registerEventHandler('workqueue_execute_end',
        WorkqueueParser.prototype.executeEndEvent.bind(this));
    importer.registerEventHandler('workqueue_queue_work',
        WorkqueueParser.prototype.executeQueueWork.bind(this));
    importer.registerEventHandler('workqueue_activate_work',
        WorkqueueParser.prototype.executeActivateWork.bind(this));
  }

  // Matches the workqueue_execute_start record
  //  workqueue_execute_start: work struct c7a8a89c: function MISRWrapper
  var workqueueExecuteStartRE = /work struct (.+): function (\S+)/;

  // Matches the workqueue_execute_start record
  //  workqueue_execute_end: work struct c7a8a89c
  var workqueueExecuteEndRE = /work struct (.+)/;

  WorkqueueParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses workqueue events and sets up state in the importer.
     */
    executeStartEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = workqueueExecuteStartRE.exec(eventBase.details);
      if (!event)
        return false;

      var kthread = this.importer.getOrCreateKernelThread(eventBase.threadName,
          pid, pid);
      kthread.openSliceTS = ts;
      kthread.openSlice = event[2];
      return true;
    },

    executeEndEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = workqueueExecuteEndRE.exec(eventBase.details);
      if (!event)
        return false;

      var kthread = this.importer.getOrCreateKernelThread(eventBase.threadName,
          pid, pid);
      if (kthread.openSlice) {
        var slice = new tr.model.Slice('', kthread.openSlice,
            tr.ui.b.getColorIdForGeneralPurposeString(kthread.openSlice),
            kthread.openSliceTS,
            {},
            ts - kthread.openSliceTS);

        kthread.thread.sliceGroup.pushSlice(slice);
      }
      kthread.openSlice = undefined;
      return true;
    },

    executeQueueWork: function(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO: Do something with this event?
      return true;
    },

    executeActivateWork: function(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO: Do something with this event?
      return true;
    }

  };

  Parser.register(WorkqueueParser);

  return {
    WorkqueueParser: WorkqueueParser
  };
});


'use strict';

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function AndroidParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('tracing_mark_write:android',
        AndroidParser.prototype.traceMarkWriteAndroidEvent.bind(this));
    importer.registerEventHandler('0:android',
        AndroidParser.prototype.traceMarkWriteAndroidEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  function parseArgs(argsString) {
    var args = {};
    if (argsString) {
      var argsArray = argsString.split(';');
      for (var i = 0; i < argsArray.length; ++i) {
        var parts = argsArray[i].split('=');
        if (parts[0])
          args[parts.shift()] = parts.join('=');
      }
    }
    return args;
  }

  AndroidParser.prototype = {
    __proto__: Parser.prototype,

    openAsyncSlice: function(thread, category, name, cookie, ts, args) {
      var asyncSliceConstructor =
         tr.model.AsyncSlice.getConstructor(
            category, name);
      var slice = new asyncSliceConstructor(
          category, name,
          tr.ui.b.getColorIdForGeneralPurposeString(name), ts, args);
      var key = category + ':' + name + ':' + cookie;
      slice.id = cookie;
      slice.startThread = thread;

      if (!this.openAsyncSlices) {
        this.openAsyncSlices = { };
      }
      this.openAsyncSlices[key] = slice;
    },

    closeAsyncSlice: function(thread, category, name, cookie, ts, args) {
      if (!this.openAsyncSlices) {
        // No async slices have been started.
        return;
      }

      var key = category + ':' + name + ':' + cookie;
      var slice = this.openAsyncSlices[key];
      if (!slice) {
        // No async slices w/ this key have been started.
        return;
      }

      for (var arg in args) {
        if (slice.args[arg] !== undefined) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Both the S and F events of ' + slice.title +
                ' provided values for argument ' + arg + '.' +
                ' The value of the F event will be used.'
          });
        }
        slice.args[arg] = args[arg];
      }

      slice.endThread = thread;
      slice.duration = ts - slice.start;
      slice.startThread.asyncSliceGroup.push(slice);
      slice.subSlices = [new tr.model.AsyncSlice(slice.category,
          slice.title, slice.colorId, slice.start, slice.args, slice.duration)];
      delete this.openAsyncSlices[key];
    },

    traceMarkWriteAndroidEvent: function(eventName, cpuNumber, pid, ts,
                                  eventBase) {
      var eventData = eventBase.details.split('|');
      switch (eventData[0]) {
        case 'B':
          var ppid = parseInt(eventData[1]);
          var title = eventData[2];
          var args = parseArgs(eventData[3]);
          var category = eventData[4];
          if (category === undefined)
            category = 'android';

          var thread = this.model_.getOrCreateProcess(ppid)
              .getOrCreateThread(pid);
          thread.name = eventBase.threadName;
          if (!thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)) {
            this.model_.importWarning({
              type: 'parse_error',
              message: 'Timestamps are moving backward.'
            });
            return false;
          }

          this.ppids_[pid] = ppid;
          thread.sliceGroup.beginSlice(category, title, ts, args);

          break;

        case 'E':
          var ppid = this.ppids_[pid];
          if (ppid === undefined) {
            // Silently ignore unmatched E events.
            break;
          }

          var thread = this.model_.getOrCreateProcess(ppid)
              .getOrCreateThread(pid);
          if (!thread.sliceGroup.openSliceCount) {
            // Silently ignore unmatched E events.
            break;
          }

          var slice = thread.sliceGroup.endSlice(ts);

          var args = parseArgs(eventData[3]);
          for (var arg in args) {
            if (slice.args[arg] !== undefined) {
              this.model_.importWarning({
                type: 'parse_error',
                message: 'Both the B and E events of ' + slice.title +
                    ' provided values for argument ' + arg + '.' +
                    ' The value of the E event will be used.'
              });
            }
            slice.args[arg] = args[arg];
          }

          break;

        case 'C':
          var ppid = parseInt(eventData[1]);
          var name = eventData[2];
          var value = parseInt(eventData[3]);
          var category = eventData[4];
          if (category === undefined)
            category = 'android';

          var ctr = this.model_.getOrCreateProcess(ppid)
              .getOrCreateCounter(category, name);
          // Initialize the counter's series fields if needed.
          if (ctr.numSeries === 0) {
            ctr.addSeries(new tr.model.CounterSeries(value,
                tr.ui.b.getColorIdForGeneralPurposeString(
                    ctr.name + '.' + 'value')));
          }

          ctr.series.forEach(function(series) {
            series.addCounterSample(ts, value);
          });

          break;

        case 'S':
          var ppid = parseInt(eventData[1]);
          var name = eventData[2];
          var cookie = parseInt(eventData[3]);
          var args = parseArgs(eventData[4]);
          var category = eventData[5];
          if (category === undefined)
            category = 'android';


          var thread = this.model_.getOrCreateProcess(ppid)
            .getOrCreateThread(pid);
          thread.name = eventBase.threadName;

          this.ppids_[pid] = ppid;
          this.openAsyncSlice(thread, category, name, cookie, ts, args);

          break;

        case 'F':
          // Note: An async slice may end on a different thread from the one
          // that started it so this thread may not have been seen yet.
          var ppid = parseInt(eventData[1]);

          var name = eventData[2];
          var cookie = parseInt(eventData[3]);
          var args = parseArgs(eventData[4]);
          var category = eventData[5];
          if (category === undefined)
            category = 'android';

          var thread = this.model_.getOrCreateProcess(ppid)
            .getOrCreateThread(pid);
          thread.name = eventBase.threadName;

          this.ppids_[pid] = ppid;
          this.closeAsyncSlice(thread, category, name, cookie, ts, args);

          break;

        default:
          return false;
      }

      return true;
    }
  };

  Parser.register(AndroidParser);

  return {
    AndroidParser: AndroidParser
  };
});


'use strict';

/**
 * @fileoverview Parses graph_ent and graph_ret events that were inserted by
 * the Linux kernel's function graph trace.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var LinuxPerfParser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses graph_ent and graph_ret events that were inserted by the Linux
   * kernel's function graph trace.
   * @constructor
   */
  function KernelFuncParser(importer) {
    LinuxPerfParser.call(this, importer);

    importer.registerEventHandler('graph_ent',
        KernelFuncParser.prototype.traceKernelFuncEnterEvent.
            bind(this));
    importer.registerEventHandler('graph_ret',
        KernelFuncParser.prototype.traceKernelFuncReturnEvent.
            bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  var TestExports = {};

  var funcEnterRE = new RegExp('func=(.+)');
  TestExports.funcEnterRE = funcEnterRE;

  KernelFuncParser.prototype = {
    __proto__: LinuxPerfParser.prototype,

    traceKernelFuncEnterEvent: function(eventName, cpuNumber, pid, ts,
                                        eventBase) {
      var eventData = funcEnterRE.exec(eventBase.details);
      if (!eventData)
        return false;

      if (eventBase.tgid === undefined) {
        return false;
      }

      var tgid = parseInt(eventBase.tgid);
      var name = eventData[1];
      var thread = this.model_.getOrCreateProcess(tgid)
        .getOrCreateThread(pid);
      thread.name = eventBase.threadName;

      var slices = thread.kernelSliceGroup;
      if (!slices.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Timestamps are moving backward.'
        });
        return false;
      }

      var slice = slices.beginSlice(null, name, ts, {});

      return true;
    },

    traceKernelFuncReturnEvent: function(eventName, cpuNumber, pid, ts,
                                         eventBase) {
      if (eventBase.tgid === undefined) {
        return false;
      }

      var tgid = parseInt(eventBase.tgid);
      var thread = this.model_.getOrCreateProcess(tgid)
        .getOrCreateThread(pid);
      thread.name = eventBase.threadName;

      var slices = thread.kernelSliceGroup;
      if (!slices.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Timestamps are moving backward.'
        });
        return false;
      }

      if (slices.openSliceCount > 0) {
        slices.endSlice(ts);
      }

      return true;
    }
  };

  LinuxPerfParser.register(KernelFuncParser);

  return {
    KernelFuncParser: KernelFuncParser
  };
});


/**
 * @fileoverview Imports text files in the Linux event trace format into the
 * Model. This format is output both by sched_trace and by Linux's perf tool.
 *
 * This importer assumes the events arrive as a string. The unit tests provide
 * examples of the trace format.
 *
 * Linux scheduler traces use a definition for 'pid' that is different than
 * tracing uses. Whereas tracing uses pid to identify a specific process, a pid
 * in a linux trace refers to a specific thread within a process. Within this
 * file, we the definition used in Linux traces, as it improves the importing
 * code's readability.
 */
'use strict';

tr.exportTo('tr.e.importer.linux_perf', function() {
  var ClockSyncRecord = tr.ClockSyncRecord;

  /**
   * Imports linux perf events into a specified model.
   * @constructor
   */
  function LinuxPerfImporter(model, events) {
    this.importPriority = 2;
    this.model_ = model;
    this.events_ = events;
    this.newlyAddedClockSyncRecords_ = [];
    this.wakeups_ = [];
    this.kernelThreadStates_ = {};
    this.buildMapFromLinuxPidsToThreads();
    this.lines_ = [];
    this.pseudoThreadCounter = 1;
    this.parsers_ = [];
    this.eventHandlers_ = {};
  }

  var TestExports = {};

  // Matches the trace record in 3.2 and later with the print-tgid option:
  //          <idle>-0    0 [001] d...  1.23: sched_switch
  //
  // A TGID (Thread Group ID) is basically what the Linux kernel calls what
  // userland refers to as a process ID (as opposed to a Linux pid, which is
  // what userland calls a thread ID).
  var lineREWithTGID = new RegExp(
      '^\\s*(.+)-(\\d+)\\s+\\(\\s*(\\d+|-+)\\)\\s\\[(\\d+)\\]' +
      '\\s+[dX.][Nnp.][Hhs.][0-9a-f.]' +
      '\\s+(\\d+\\.\\d+):\\s+(\\S+):\\s(.*)$');
  var lineParserWithTGID = function(line) {
    var groups = lineREWithTGID.exec(line);
    if (!groups) {
      return groups;
    }

    var tgid = groups[3];
    if (tgid[0] === '-')
      tgid = undefined;

    return {
      threadName: groups[1],
      pid: groups[2],
      tgid: tgid,
      cpuNumber: groups[4],
      timestamp: groups[5],
      eventName: groups[6],
      details: groups[7]
    };
  };
  TestExports.lineParserWithTGID = lineParserWithTGID;

  // Matches the default trace record in 3.2 and later (includes irq-info):
  //          <idle>-0     [001] d...  1.23: sched_switch
  var lineREWithIRQInfo = new RegExp(
      '^\\s*(.+)-(\\d+)\\s+\\[(\\d+)\\]' +
      '\\s+[dX.][Nnp.][Hhs.][0-9a-f.]' +
      '\\s+(\\d+\\.\\d+):\\s+(\\S+):\\s(.*)$');
  var lineParserWithIRQInfo = function(line) {
    var groups = lineREWithIRQInfo.exec(line);
    if (!groups) {
      return groups;
    }
    return {
      threadName: groups[1],
      pid: groups[2],
      cpuNumber: groups[3],
      timestamp: groups[4],
      eventName: groups[5],
      details: groups[6]
    };
  };
  TestExports.lineParserWithIRQInfo = lineParserWithIRQInfo;

  // Matches the default trace record pre-3.2:
  //          <idle>-0     [001]  1.23: sched_switch
  var lineREWithLegacyFmt =
      /^\s*(.+)-(\d+)\s+\[(\d+)\]\s*(\d+\.\d+):\s+(\S+):\s(.*)$/;
  var lineParserWithLegacyFmt = function(line) {
    var groups = lineREWithLegacyFmt.exec(line);
    if (!groups) {
      return groups;
    }
    return {
      threadName: groups[1],
      pid: groups[2],
      cpuNumber: groups[3],
      timestamp: groups[4],
      eventName: groups[5],
      details: groups[6]
    };
  };
  TestExports.lineParserWithLegacyFmt = lineParserWithLegacyFmt;

  // Matches the trace_event_clock_sync record
  //  0: trace_event_clock_sync: parent_ts=19581477508
  var traceEventClockSyncRE = /trace_event_clock_sync: parent_ts=(\d+\.?\d*)/;
  TestExports.traceEventClockSyncRE = traceEventClockSyncRE;

  var realTimeClockSyncRE = /trace_event_clock_sync: realtime_ts=(\d+)/;
  var genericClockSyncRE = /trace_event_clock_sync: name=(\w+)/;

  // Some kernel trace events are manually classified in slices and
  // hand-assigned a pseudo PID.
  var pseudoKernelPID = 0;

  /**
   * Deduce the format of trace data. Linux kernels prior to 3.3 used one
   * format (by default); 3.4 and later used another.  Additionally, newer
   * kernels can optionally trace the TGID.
   *
   * @return {function} the function for parsing data when the format is
   * recognized; otherwise null.
   */
  function autoDetectLineParser(line) {
    if (line[0] == '{')
      return false;
    if (lineREWithTGID.test(line))
      return lineParserWithTGID;
    if (lineREWithIRQInfo.test(line))
      return lineParserWithIRQInfo;
    if (lineREWithLegacyFmt.test(line))
      return lineParserWithLegacyFmt;
    return null;
  };
  TestExports.autoDetectLineParser = autoDetectLineParser;

  /**
   * Guesses whether the provided events is a Linux perf string.
   * Looks for the magic string "# tracer" at the start of the file,
   * or the typical task-pid-cpu-timestamp-function sequence of a typical
   * trace's body.
   *
   * @return {boolean} True when events is a linux perf array.
   */
  LinuxPerfImporter.canImport = function(events) {
    if (!(typeof(events) === 'string' || events instanceof String))
      return false;

    if (LinuxPerfImporter._extractEventsFromSystraceHTML(events, false).ok)
      return true;

    if (LinuxPerfImporter._extractEventsFromSystraceMultiHTML(events, false).ok)
      return true;

    if (/^# tracer:/.test(events))
      return true;

    var lineBreakIndex = events.indexOf('\n');
    if (lineBreakIndex > -1)
      events = events.substring(0, lineBreakIndex);

    if (autoDetectLineParser(events))
      return true;

    return false;
  };

  LinuxPerfImporter._extractEventsFromSystraceHTML = function(
      incoming_events, produce_result) {
    var failure = {ok: false};
    if (produce_result === undefined)
      produce_result = true;

    if (/^<!DOCTYPE HTML>/.test(incoming_events) == false)
      return failure;
    var r = new tr.importer.SimpleLineReader(incoming_events);

    // Try to find the data...
    if (!r.advanceToLineMatching(/^  <script>$/))
      return failure;
    if (!r.advanceToLineMatching(/^  var linuxPerfData = "\\$/))
      return failure;

    var events_begin_at_line = r.curLineNumber + 1;
    r.beginSavingLines();
    if (!r.advanceToLineMatching(/^  <\/script>$/))
      return failure;

    var raw_events = r.endSavingLinesAndGetResult();

    // Drop off first and last event as it contains the tag.
    raw_events = raw_events.slice(1, raw_events.length - 1);

    if (!r.advanceToLineMatching(/^<\/body>$/))
      return failure;
    if (!r.advanceToLineMatching(/^<\/html>$/))
      return failure;

    function endsWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    function stripSuffix(str, suffix) {
      if (!endsWith(str, suffix))
        return str;
      return str.substring(str, str.length - suffix.length);
    }

    // Strip off escaping in the file needed to preserve linebreaks.
    var events = [];
    if (produce_result) {
      for (var i = 0; i < raw_events.length; i++) {
        var event = raw_events[i];
        event = stripSuffix(event, '\\n\\');
        events.push(event);
      }
    } else {
      events = [raw_events[raw_events.length - 1]];
    }

    // Last event ends differently. Strip that off too,
    // treating absence of that trailing string as a failure.
    var oldLastEvent = events[events.length - 1];
    var newLastEvent = stripSuffix(oldLastEvent, '\\n";');
    if (newLastEvent == oldLastEvent)
      return failure;
    events[events.length - 1] = newLastEvent;

    return {ok: true,
      lines: produce_result ? events : undefined,
      events_begin_at_line: events_begin_at_line};
  };

  LinuxPerfImporter._extractEventsFromSystraceMultiHTML = function(
      incoming_events, produce_result) {
    var failure = {ok: false};
    if (produce_result === undefined)
      produce_result = true;

    if (/^<!DOCTYPE HTML>/.test(incoming_events) == false)
      return failure;
    var r = new tr.importer.SimpleLineReader(incoming_events);

    // Try to find the Linux perf trace in any of the trace-data tags
    var events = [];
    while (!/^# tracer:/.test(events)) {
      if (!r.advanceToLineMatching(
          /^  <script class="trace-data" type="application\/text">$/))
        return failure;

      var events_begin_at_line = r.curLineNumber + 1;

      r.beginSavingLines();
      if (!r.advanceToLineMatching(/^  <\/script>$/))
        return failure;

      events = r.endSavingLinesAndGetResult();

      // Drop off first and last event as it contains the tag.
      events = events.slice(1, events.length - 1);
    }

    if (!r.advanceToLineMatching(/^<\/body>$/))
      return failure;
    if (!r.advanceToLineMatching(/^<\/html>$/))
      return failure;

    return {ok: true,
      lines: produce_result ? events : undefined,
      events_begin_at_line: events_begin_at_line};
  };

  LinuxPerfImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get model() {
      return this.model_;
    },

    /**
     * Precomputes a lookup table from linux pids back to existing
     * Threads. This is used during importing to add information to each
     * thread about whether it was running, descheduled, sleeping, et
     * cetera.
     */
    buildMapFromLinuxPidsToThreads: function() {
      this.threadsByLinuxPid = {};
      this.model_.getAllThreads().forEach(
          function(thread) {
            this.threadsByLinuxPid[thread.tid] = thread;
          }.bind(this));
    },

    /**
     * @return {Cpu} A Cpu corresponding to the given cpuNumber.
     */
    getOrCreateCpu: function(cpuNumber) {
      return this.model_.kernel.getOrCreateCpu(cpuNumber);
    },

    /**
     * @return {TimelineThread} A thread corresponding to the kernelThreadName.
     */
    getOrCreateKernelThread: function(kernelThreadName, pid, tid) {
      if (!this.kernelThreadStates_[kernelThreadName]) {
        var thread = this.model_.getOrCreateProcess(pid).getOrCreateThread(tid);
        thread.name = kernelThreadName;
        this.kernelThreadStates_[kernelThreadName] = {
          pid: pid,
          thread: thread,
          openSlice: undefined,
          openSliceTS: undefined
        };
        this.threadsByLinuxPid[pid] = thread;
      }
      return this.kernelThreadStates_[kernelThreadName];
    },

    /**
     * Processes can have multiple binder threads.
     * Binder thread names are not unique across processes we therefore need to
     * keep more information in order to return the correct threads.
     */
    getOrCreateBinderKernelThread: function(kernelThreadName, pid, tid) {
      var key = kernelThreadName + pid + tid;
      if (!this.kernelThreadStates_[key]) {
        var thread = this.model_.getOrCreateProcess(pid).getOrCreateThread(tid);
        thread.name = kernelThreadName;
        this.kernelThreadStates_[key] = {
          pid: pid,
          thread: thread,
          openSlice: undefined,
          openSliceTS: undefined
        };
        this.threadsByLinuxPid[pid] = thread;
      }
      return this.kernelThreadStates_[key];
    },

    /**
     * @return {TimelineThread} A pseudo thread corresponding to the
     * threadName.  Pseudo threads are for events that we want to break
     * out to a separate timeline but would not otherwise happen.
     * These threads are assigned to pseudoKernelPID and given a
     * unique (incrementing) TID.
     */
    getOrCreatePseudoThread: function(threadName) {
      var thread = this.kernelThreadStates_[threadName];
      if (!thread) {
        thread = this.getOrCreateKernelThread(threadName, pseudoKernelPID,
            this.pseudoThreadCounter);
        this.pseudoThreadCounter++;
      }
      return thread;
    },

    /**
     * Imports the data in this.events_ into model_.
     */
    importEvents: function(isSecondaryImport) {
      this.parsers_ = this.createParsers_();
      this.registerDefaultHandlers_();
      this.parseLines();
      this.importClockSyncRecords();
      var timeShift = this.computeTimeTransform();
      if (timeShift === undefined) {
        this.model_.importWarning({
          type: 'clock_sync',
          message: 'Cannot import kernel trace without a clock sync.'
        });
        return;
      }
      this.shiftNewlyAddedClockSyncRecords(timeShift);
      this.importCpuData(timeShift);
      this.buildMapFromLinuxPidsToThreads();
      this.buildPerThreadCpuSlicesFromCpuState();
      this.computeCpuTimestampsForSlicesAsNeeded();
    },

    /**
     * Builds the timeSlices array on each thread based on our knowledge of what
     * each Cpu is doing.  This is done only for Threads that are
     * already in the model, on the assumption that not having any traced data
     * on a thread means that it is not of interest to the user.
     */
    buildPerThreadCpuSlicesFromCpuState: function() {
      var SCHEDULING_STATE = tr.model.SCHEDULING_STATE;

      // Push the cpu slices to the threads that they run on.
      for (var cpuNumber in this.model_.kernel.cpus) {
        var cpu = this.model_.kernel.cpus[cpuNumber];

        for (var i = 0; i < cpu.slices.length; i++) {
          var cpuSlice = cpu.slices[i];

          var thread = this.threadsByLinuxPid[cpuSlice.args.tid];
          if (!thread)
            continue;

          cpuSlice.threadThatWasRunning = thread;

          if (!thread.tempCpuSlices)
            thread.tempCpuSlices = [];
          thread.tempCpuSlices.push(cpuSlice);
        }
      }

      for (var i in this.wakeups_) {
        var wakeup = this.wakeups_[i];
        var thread = this.threadsByLinuxPid[wakeup.tid];
        if (!thread)
          continue;
        thread.tempWakeups = thread.tempWakeups || [];
        thread.tempWakeups.push(wakeup);
      }

      // Create slices for when the thread is not running.
      this.model_.getAllThreads().forEach(function(thread) {
        if (thread.tempCpuSlices === undefined)
          return;
        var origSlices = thread.tempCpuSlices;
        delete thread.tempCpuSlices;

        origSlices.sort(function(x, y) {
          return x.start - y.start;
        });

        var wakeups = thread.tempWakeups || [];
        delete thread.tempWakeups;
        wakeups.sort(function(x, y) {
          return x.ts - y.ts;
        });

        // Walk the slice list and put slices between each original slice to
        // show when the thread isn't running.
        var slices = [];

        if (origSlices.length) {
          var slice = origSlices[0];

          if (wakeups.length && wakeups[0].ts < slice.start) {
            var wakeup = wakeups.shift();
            var wakeupDuration = slice.start - wakeup.ts;
            var args = {'wakeup from tid': wakeup.fromTid};
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.RUNNABLE, '',
                wakeup.ts, args, wakeupDuration));
          }

          var runningSlice = new tr.model.ThreadTimeSlice(
              thread, SCHEDULING_STATE.RUNNING, '',
              slice.start, {}, slice.duration);
          runningSlice.cpuOnWhichThreadWasRunning = slice.cpu;
          slices.push(runningSlice);
        }

        var wakeup = undefined;
        for (var i = 1; i < origSlices.length; i++) {
          var prevSlice = origSlices[i - 1];
          var nextSlice = origSlices[i];
          var midDuration = nextSlice.start - prevSlice.end;
          while (wakeups.length && wakeups[0].ts < nextSlice.start) {
            var w = wakeups.shift();
            if (wakeup === undefined && w.ts > prevSlice.end) {
              wakeup = w;
            }
          }

          // Push a sleep slice onto the slices list, interrupting it with a
          // wakeup if appropriate.
          var pushSleep = function(state) {
            if (wakeup !== undefined) {
              midDuration = wakeup.ts - prevSlice.end;
            }
            slices.push(new tr.model.ThreadTimeSlice(
                thread,
                state, '', prevSlice.end, {}, midDuration));
            if (wakeup !== undefined) {
              var wakeupDuration = nextSlice.start - wakeup.ts;
              var args = {'wakeup from tid': wakeup.fromTid};
              slices.push(new tr.model.ThreadTimeSlice(
                  thread, SCHEDULING_STATE.RUNNABLE, '',
                  wakeup.ts, args, wakeupDuration));
              wakeup = undefined;
            }
          };

          if (prevSlice.args.stateWhenDescheduled == 'S') {
            pushSleep(SCHEDULING_STATE.SLEEPING);
          } else if (prevSlice.args.stateWhenDescheduled == 'R' ||
                     prevSlice.args.stateWhenDescheduled == 'R+') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.RUNNABLE, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'D') {
            pushSleep(SCHEDULING_STATE.UNINTR_SLEEP);
          } else if (prevSlice.args.stateWhenDescheduled == 'T') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.STOPPED, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 't') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.DEBUG, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'Z') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.ZOMBIE, '', ioWaitId,
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'X') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.EXIT_DEAD, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'x') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.TASK_DEAD, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'K') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.WAKE_KILL, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'W') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.WAKING, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'D|K') {
            pushSleep(SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL);
          } else if (prevSlice.args.stateWhenDescheduled == 'D|W') {
            pushSleep(SCHEDULING_STATE.UNINTR_SLEEP_WAKING);
          } else {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.UNKNOWN, '',
                prevSlice.end, {}, midDuration));
            this.model_.importWarning({
              type: 'parse_error',
              message: 'Unrecognized sleep state: ' +
                  prevSlice.args.stateWhenDescheduled
            });
          }

          var runningSlice = new tr.model.ThreadTimeSlice(
              thread, SCHEDULING_STATE.RUNNING, '',
              nextSlice.start, {}, nextSlice.duration);
          runningSlice.cpuOnWhichThreadWasRunning = prevSlice.cpu;
          slices.push(runningSlice);
        }
        thread.timeSlices = slices;
      }, this);
    },

    computeCpuTimestampsForSlicesAsNeeded: function() {
      /* iterate all slices and try to figure out cpuStart/endTimes */

    },

    /**
     * Computes a time transform from perf time to parent time based on the
     * imported clock sync records.
     * @return {number} offset from perf time to parent time or undefined if
     * the necessary sync records were not found.
     */
    computeTimeTransform: function() {
      var isSecondaryImport = this.model.getClockSyncRecordsNamed(
          'ftrace_importer').length !== 0;

      var mSyncs = this.model_.getClockSyncRecordsNamed('monotonic');
      // If this is a secondary import, and no clock syncing records were
      // found, then abort the import. Otherwise, just skip clock alignment.
      if (mSyncs.length == 0)
        return isSecondaryImport ? undefined : 0;

      // Shift all the slice times based on the sync record.
      // TODO(skyostil): Compute a scaling factor if we have multiple clock sync
      // records.
      var sync = mSyncs[0].args;
      // NB: parentTS of zero denotes no times-shift; this is
      // used when user and kernel event clocks are identical.
      if (sync.parentTS == 0 || sync.parentTS == sync.perfTS)
        return 0;
      return sync.parentTS - sync.perfTS;
    },

    /**
     * Creates an instance of each registered linux perf event parser.
     * This allows the parsers to register handlers for the events they
     * understand.  We also register our own special handlers (for the
     * timestamp synchronization markers).
     */
    createParsers_: function() {
      // Instantiate the parsers; this will register handlers for known events
      var allTypeInfos = tr.e.importer.linux_perf.
          Parser.getAllRegisteredTypeInfos();
      var parsers = allTypeInfos.map(
          function(typeInfo) {
            return new typeInfo.constructor(this);
          }, this);

      return parsers;
    },

    registerDefaultHandlers_: function() {
      this.registerEventHandler('tracing_mark_write',
          LinuxPerfImporter.prototype.traceMarkingWriteEvent.bind(this));
      // NB: old-style trace markers; deprecated
      this.registerEventHandler('0',
          LinuxPerfImporter.prototype.traceMarkingWriteEvent.bind(this));
      // Register dummy clock sync handlers to avoid warnings in the log.
      this.registerEventHandler('tracing_mark_write:trace_event_clock_sync',
          function() { return true; });
      this.registerEventHandler('0:trace_event_clock_sync',
          function() { return true; });
    },

    /**
     * Registers a linux perf event parser used by importCpuData.
     */
    registerEventHandler: function(eventName, handler) {
      // TODO(sleffler) how to handle conflicts?
      this.eventHandlers_[eventName] = handler;
    },

    /**
     * Records the fact that a pid has become runnable. This data will
     * eventually get used to derive each thread's timeSlices array.
     */
    markPidRunnable: function(ts, pid, comm, prio, fromPid) {
      // The the pids that get passed in to this function are Linux kernel
      // pids, which identify threads.  The rest of trace-viewer refers to
      // these as tids, so the change of nomenclature happens in the following
      // construction of the wakeup object.
      this.wakeups_.push({ts: ts, tid: pid, fromTid: fromPid});
    },

    /**
     * Processes a trace_event_clock_sync event.
     */
    traceClockSyncEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      // Check for new-style clock sync records.
      var event = /name=(\w+?)\s(.+)/.exec(eventBase.details);
      if (event) {
        var name = event[1];
        var pieces = event[2].split(' ');
        var args = {
          perfTS: ts
        };
        for (var i = 0; i < pieces.length; i++) {
          var parts = pieces[i].split('=');
          if (parts.length != 2)
            throw new Error('omgbbq');
          args[parts[0]] = parts[1];
        }
        this.addClockSyncRecord(new ClockSyncRecord(name, ts, args));
        return true;
      }

      // Old-style clock sync records from chromium
      event = /parent_ts=(\d+\.?\d*)/.exec(eventBase.details);
      if (!event)
        return false;

      this.addClockSyncRecord(new ClockSyncRecord('monotonic', ts, {
        perfTS: ts,
        parentTS: event[1] * 1000
      }));
      return true;
    },

    /**
     * Processes a trace_marking_write event.
     */
    traceMarkingWriteEvent: function(eventName, cpuNumber, pid, ts, eventBase,
                                     threadName) {

      // Some profiles end up with a \n\ on the end of each line. Strip it
      // before we do the comparisons.
      eventBase.details = eventBase.details.replace(/\\n.*$/, '');

      var event = /^\s*(\w+):\s*(.*)$/.exec(eventBase.details);
      if (!event) {
        // Check if the event matches events traced by the Android framework
        var tag = eventBase.details.substring(0, 2);
        if (tag == 'B|' || tag == 'E' || tag == 'E|' || tag == 'X|' ||
            tag == 'C|' || tag == 'S|' || tag == 'F|') {
          eventBase.subEventName = 'android';
        } else {
          return false;
        }
      } else {
        eventBase.subEventName = event[1];
        eventBase.details = event[2];
      }

      var writeEventName = eventName + ':' + eventBase.subEventName;
      var handler = this.eventHandlers_[writeEventName];
      if (!handler) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Unknown trace_marking_write event ' + writeEventName
        });
        return true;
      }
      return handler(writeEventName, cpuNumber, pid, ts, eventBase, threadName);
    },

    /**
     * Populates model clockSyncRecords with found clock sync markers.
     */
    importClockSyncRecords: function() {
      this.forEachLine(function(text, eventBase, cpuNumber, pid, ts) {
        var eventName = eventBase.eventName;
        if (eventName !== 'tracing_mark_write' && eventName !== '0')
          return;
        if (traceEventClockSyncRE.exec(eventBase.details))
          this.traceClockSyncEvent(eventName, cpuNumber, pid, ts, eventBase);
        if (realTimeClockSyncRE.exec(eventBase.details)) {
          // This entry maps realtime to clock_monotonic; store in the model
          // so that importers parsing files with realtime timestamps can
          // map this back to monotonic.
          var match = realTimeClockSyncRE.exec(eventBase.details);
          this.model_.realtime_to_monotonic_offset_ms = ts - match[1];
        }
        if (genericClockSyncRE.exec(eventBase.details))
          this.traceClockSyncEvent(eventName, cpuNumber, pid, ts, eventBase);
      }.bind(this));
    },
    addClockSyncRecord: function(csr) {
      this.newlyAddedClockSyncRecords_.push(csr);
      this.model_.clockSyncRecords.push(csr);
    },

    shiftNewlyAddedClockSyncRecords: function(timeShift) {
      this.newlyAddedClockSyncRecords_.forEach(function(csr) {
        csr.ts += timeShift;
      });
    },

    /**
     * Walks the this.events_ structure and creates Cpu objects.
     */
    importCpuData: function(timeShift) {
      this.forEachLine(function(text, eventBase, cpuNumber, pid, ts) {
        var eventName = eventBase.eventName;
        var handler = this.eventHandlers_[eventName];
        if (!handler) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Unknown event ' + eventName + ' (' + text + ')'
          });
          return;
        }
        ts += timeShift;
        if (!handler(eventName, cpuNumber, pid, ts, eventBase)) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Malformed ' + eventName + ' event (' + text + ')'
          });
        }
      }.bind(this));
    },

    /**
     * Walks the this.events_ structure and populates this.lines_.
     */
    parseLines: function() {
      var lines = [];
      var extractResult = LinuxPerfImporter._extractEventsFromSystraceHTML(
          this.events_, true);
      if (!extractResult.ok)
        extractResult = LinuxPerfImporter._extractEventsFromSystraceMultiHTML(
            this.events_, true);
      var lines = extractResult.ok ?
        extractResult.lines : this.events_.split('\n');

      var lineParser = null;
      for (var lineNumber = 0; lineNumber < lines.length; ++lineNumber) {
        var line = lines[lineNumber].trim();
        if (line.length == 0 || /^#/.test(line))
          continue;
        if (lineParser == null) {
          lineParser = autoDetectLineParser(line);
          if (lineParser == null) {
            this.model_.importWarning({
              type: 'parse_error',
              message: 'Cannot parse line: ' + line
            });
            continue;
          }
        }
        var eventBase = lineParser(line);
        if (!eventBase) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Unrecognized line: ' + line
          });
          continue;
        }

        this.lines_.push([
          line,
          eventBase,
          parseInt(eventBase.cpuNumber),
          parseInt(eventBase.pid),
          parseFloat(eventBase.timestamp) * 1000
        ]);
      }
    },

    /**
     * Calls |handler| for every parsed line.
     */
    forEachLine: function(handler) {
      for (var i = 0; i < this.lines_.length; ++i) {
        var line = this.lines_[i];
        handler.apply(this, line);
      }
    }
  };

  tr.importer.Importer.register(LinuxPerfImporter);

  return {
    LinuxPerfImporter: LinuxPerfImporter,
    _LinuxPerfImporterTestExports: TestExports
  };
});


'use strict';

/**
 * @fileoverview Provides event merging functionality for grouping/analysis.
 */
tr.exportTo('tr.b', function() {
  function convertEventsToRanges(events) {
    return events.map(function(event) {
      return tr.b.Range.fromExplicitRange(event.start, event.end);
    });
  }

  function mergeRanges(inRanges, mergeThreshold, mergeFunction) {
    var remainingEvents = inRanges.slice();
    remainingEvents.sort(function(x, y) {
      return x.min - y.min;
    });

    if (remainingEvents.length <= 1) {
      var merged = [];
      if (remainingEvents.length == 1) {
        merged.push(mergeFunction(remainingEvents));
      }
      return merged;
    }

    var mergedEvents = [];

    var currentMergeBuffer = [];
    var rightEdge;
    function beginMerging() {
      currentMergeBuffer.push(remainingEvents[0]);
      remainingEvents.splice(0, 1);
      rightEdge = currentMergeBuffer[0].max;
    }

    function flushCurrentMergeBuffer() {
      if (currentMergeBuffer.length == 0)
        return;

      mergedEvents.push(mergeFunction(currentMergeBuffer));
      currentMergeBuffer = [];

      // Refill merge buffer if needed.
      if (remainingEvents.length != 0)
        beginMerging();
    }

    beginMerging();

    while (remainingEvents.length) {
      var currentEvent = remainingEvents[0];

      var distanceFromRightEdge = currentEvent.min - rightEdge;
      if (distanceFromRightEdge < mergeThreshold) {
        rightEdge = Math.max(rightEdge, currentEvent.max);
        remainingEvents.splice(0, 1);
        currentMergeBuffer.push(currentEvent);
        continue;
      }

      // Too big a gap.
      flushCurrentMergeBuffer();
    }
    flushCurrentMergeBuffer();

    return mergedEvents;
  }

  // Pass in |opt_totalRange| in order to find empty ranges before the first of
  // |inRanges| and after the last of |inRanges|.
  function findEmptyRangesBetweenRanges(inRanges, opt_totalRange) {
    if (opt_totalRange && opt_totalRange.isEmpty)
      opt_totalRange = undefined;

    var emptyRanges = [];
    if (!inRanges.length) {
      if (opt_totalRange)
        emptyRanges.push(opt_totalRange);
      return emptyRanges;
    }

    inRanges = inRanges.slice();
    inRanges.sort(function(x, y) {
      return x.min - y.min;
    });
    if (opt_totalRange &&
        (opt_totalRange.min < inRanges[0].min)) {
      emptyRanges.push(tr.b.Range.fromExplicitRange(
          opt_totalRange.min, inRanges[0].min));
    }

    inRanges.forEach(function(range, index) {
      for (var otherIndex = 0; otherIndex < inRanges.length; ++otherIndex) {
        if (index === otherIndex)
          continue;
        var other = inRanges[otherIndex];

        if (other.min > range.max) {
          // |inRanges| is sorted, so |other| is the first range after |range|,
          // and there is an empty range between them.
          emptyRanges.push(tr.b.Range.fromExplicitRange(
              range.max, other.min));
          return;
        }
        // Otherwise, |other| starts before |range| ends, so |other| might
        // possibly contain the end of |range|.

        if (other.max > range.max) {
          // |other| does contain the end of |range|, so no empty range starts
          // at the end of this |range|.
          return;
        }
      }
      if (opt_totalRange && (range.max < opt_totalRange.max)) {
        emptyRanges.push(tr.b.Range.fromExplicitRange(
            range.max, opt_totalRange.max));
      }
    });
    return emptyRanges;
  }

  return {
    convertEventsToRanges: convertEventsToRanges,
    findEmptyRangesBetweenRanges: findEmptyRangesBetweenRanges,
    mergeRanges: mergeRanges
  };
});


'use strict';

/**
 * @fileoverview Class for managing android-specific model meta data,
 * such as rendering apps, and frames rendered.
 */
tr.exportTo('tr.e.audits', function() {
  var Frame = tr.model.Frame;
  var Statistics = tr.b.Statistics;

  var UI_DRAW_TYPE = {
    NONE: 'none',
    LEGACY: 'legacy',
    MARSHMALLOW: 'marshmallow'
  };

  var UI_THREAD_DRAW_NAMES = {
    'performTraversals': UI_DRAW_TYPE.LEGACY,
    'Choreographer#doFrame': UI_DRAW_TYPE.MARSHMALLOW
  };

  var RENDER_THREAD_DRAW_NAME = 'DrawFrame';
  var RENDER_THREAD_INDEP_DRAW_NAME = 'doFrame';
  var THREAD_SYNC_NAME = 'syncFrameState';

  function getSlicesForThreadTimeRanges(threadTimeRanges) {
    var ret = [];
    threadTimeRanges.forEach(function(threadTimeRange) {
      var slices = [];

      threadTimeRange.thread.sliceGroup.iterSlicesInTimeRange(
        function(slice) { slices.push(slice); },
        threadTimeRange.start, threadTimeRange.end);
      ret.push.apply(ret, slices);
    });
    return ret;
  }

  function makeFrame(threadTimeRanges, surfaceFlinger) {
    var args = {};
    if (surfaceFlinger && surfaceFlinger.hasVsyncs) {
      var start = Statistics.min(threadTimeRanges,
          function(threadTimeRanges) { return threadTimeRanges.start; });
      args['deadline'] = surfaceFlinger.getFrameDeadline(start);
      args['frameKickoff'] = surfaceFlinger.getFrameKickoff(start);
    }
    var events = getSlicesForThreadTimeRanges(threadTimeRanges);
    return new Frame(events, threadTimeRanges, args);
  }

  function findOverlappingDrawFrame(renderThread, time) {
    if (!renderThread)
      return undefined;

    var slices = renderThread.sliceGroup.slices;
    for (var i = 0; i < slices.length; i++) {
      var slice = slices[i];
      if (slice.title == RENDER_THREAD_DRAW_NAME &&
          slice.start <= time &&
          time <= slice.end) {
        return slice;
      }
    }
    return undefined;
  }

  /**
   * Builds an array of {start, end} ranges grouping common work of a frame
   * that occurs just before performTraversals().
   *
   * Only necessary before Choreographer#doFrame tracing existed.
   */
  function getPreTraversalWorkRanges(uiThread) {
    if (!uiThread)
      return [];

    // gather all frame work that occurs outside of performTraversals
    var preFrameEvents = [];
    uiThread.sliceGroup.slices.forEach(function(slice) {
      if (slice.title == 'obtainView' ||
          slice.title == 'setupListItem' ||
          slice.title == 'deliverInputEvent' ||
          slice.title == 'RV Scroll')
        preFrameEvents.push(slice);
    });
    uiThread.asyncSliceGroup.slices.forEach(function(slice) {
      if (slice.title == 'deliverInputEvent')
        preFrameEvents.push(slice);
    });

    return tr.b.mergeRanges(
        tr.b.convertEventsToRanges(preFrameEvents),
        3,
        function(events) {
      return {
        start: events[0].min,
        end: events[events.length - 1].max
      };
    });
  }

  function getFrameStartTime(traversalStart, preTraversalWorkRanges) {
    var preTraversalWorkRange = tr.b.findClosestIntervalInSortedIntervals(
        preTraversalWorkRanges,
        function(range) { return range.start },
        function(range) { return range.end },
        traversalStart,
        3);

    if (preTraversalWorkRange)
      return preTraversalWorkRange.start;
    return traversalStart;
  }

  function getUiThreadDrivenFrames(app) {
    if (!app.uiThread)
      return [];

    var preTraversalWorkRanges = [];
    if (app.uiDrawType == UI_DRAW_TYPE.LEGACY)
      preTraversalWorkRanges = getPreTraversalWorkRanges(app.uiThread);

    var frames = [];
    app.uiThread.sliceGroup.slices.forEach(function(slice) {
      if (!(slice.title in UI_THREAD_DRAW_NAMES)) {
        return;
      }

      var threadTimeRanges = [];
      var uiThreadTimeRange = {
        thread: app.uiThread,
        start: getFrameStartTime(slice.start, preTraversalWorkRanges),
        end: slice.end
      };
      threadTimeRanges.push(uiThreadTimeRange);

      // on SDK 21+ devices with RenderThread,
      // account for time taken on RenderThread
      var rtDrawSlice = findOverlappingDrawFrame(
          app.renderThread, slice.end);
      if (rtDrawSlice) {
        var rtSyncSlice = rtDrawSlice.findDescendentSlice(THREAD_SYNC_NAME);
        if (rtSyncSlice) {
          // Generally, the UI thread is only on the critical path
          // until the start of sync.
          uiThreadTimeRange.end = Math.min(uiThreadTimeRange.end,
                                           rtSyncSlice.start);
        }

        threadTimeRanges.push({
          thread: app.renderThread,
          start: rtDrawSlice.start,
          end: rtDrawSlice.end
        });
      }
      frames.push(makeFrame(threadTimeRanges, app.surfaceFlinger));
    });
    return frames;
  }

  function getRenderThreadDrivenFrames(app) {
    if (!app.renderThread)
      return [];

    var frames = [];
    app.renderThread.sliceGroup.getSlicesOfName(RENDER_THREAD_INDEP_DRAW_NAME)
        .forEach(function(slice) {
      var threadTimeRanges = [{
        thread: app.renderThread,
        start: slice.start,
        end: slice.end
      }];
      frames.push(makeFrame(threadTimeRanges, app.surfaceFlinger));
    });
    return frames;
  }

  function getUiDrawType(uiThread) {
    if (!uiThread)
      return UI_DRAW_TYPE.NONE;

    var slices = uiThread.sliceGroup.slices;
    for (var i = 0; i < slices.length; i++) {
      if (slices[i].title in UI_THREAD_DRAW_NAMES) {
        return UI_THREAD_DRAW_NAMES[slices[i].title];
      }
    }
    return UI_DRAW_TYPE.NONE;
  }

  function getInputSamples(process) {
    var samples = undefined;
    for (var counterName in process.counters) {
          if (/^android\.aq\:pending/.test(counterName) &&
        process.counters[counterName].numSeries == 1) {
        samples = process.counters[counterName].series[0].samples;
        break;
      }
    }

    if (!samples)
      return [];

    // output rising edges only, since those are user inputs
    var inputSamples = [];
    var lastValue = 0;
    samples.forEach(function(sample) {
      if (sample.value > lastValue) {
        inputSamples.push(sample);
      }
      lastValue = sample.value;
    });
    return inputSamples;
  }

  function getAnimationAsyncSlices(uiThread) {
    if (!uiThread)
      return [];

    var slices = [];
    uiThread.asyncSliceGroup.iterateAllEvents(function(slice) {
      if (/^animator\:/.test(slice.title))
        slices.push(slice);
    });
    return slices;
  }

  /**
   * Model for Android App specific data.
   * @constructor
   */
  function AndroidApp(process, uiThread, renderThread, surfaceFlinger,
      uiDrawType) {
    this.process = process;
    this.uiThread = uiThread;
    this.renderThread = renderThread;
    this.surfaceFlinger = surfaceFlinger;
    this.uiDrawType = uiDrawType;

    this.frames_ = undefined;
    this.inputs_ = undefined;
  };

  AndroidApp.createForProcessIfPossible = function(process, surfaceFlinger) {
    var uiThread = process.getThread(process.pid);
    var uiDrawType = getUiDrawType(uiThread);
    if (uiDrawType == UI_DRAW_TYPE.NONE) {
      uiThread = undefined;
    }
    var renderThreads = process.findAllThreadsNamed('RenderThread');
    var renderThread = renderThreads.length == 1 ? renderThreads[0] : undefined;

    if (uiThread || renderThread) {
      return new AndroidApp(process, uiThread, renderThread, surfaceFlinger,
        uiDrawType);
    }
  }

  AndroidApp.prototype = {
  /**
   * Returns a list of all frames in the trace for the app,
   * constructed on first query.
   */
    getFrames: function() {
      if (!this.frames_) {
        var uiFrames = getUiThreadDrivenFrames(this);
        var rtFrames = getRenderThreadDrivenFrames(this);
        this.frames_ = uiFrames.concat(rtFrames);

        // merge frames by sorting by end timestamp
        this.frames_.sort(function(a, b) { a.end - b.end });
      }
      return this.frames_;
    },

    /**
     * Returns list of CounterSamples for each input event enqueued to the app.
     */
    getInputSamples: function() {
      if (!this.inputs_) {
        this.inputs_ = getInputSamples(this.process);
      }
      return this.inputs_;
    },

    getAnimationAsyncSlices: function() {
      if (!this.animations_) {
        this.animations_ = getAnimationAsyncSlices(this.uiThread);
      }
      return this.animations_;
    }
  };

  return {
    AndroidApp: AndroidApp
  };
});


'use strict';

/**
 * @fileoverview Class for representing SurfaceFlinger process and its Vsyncs.
 */
tr.exportTo('tr.e.audits', function() {
  var findLowIndexInSortedArray = tr.b.findLowIndexInSortedArray;

  var VSYNC_SF_NAME = 'android.VSYNC-sf';
  var VSYNC_APP_NAME = 'android.VSYNC-app';
  var VSYNC_FALLBACK_NAME = 'android.VSYNC';

  // when sampling vsync, push samples back by this much to ensure
  // frame start samples *between* vsyncs
  var TIMESTAMP_FUDGE_MS = 0.01;

  function getVsyncTimestamps(process, counterName) {

    var vsync = process.counters[counterName];
    if (!vsync)
      vsync = process.counters[VSYNC_FALLBACK_NAME];

    if (vsync && vsync.numSeries == 1 && vsync.numSamples > 1)
      return vsync.series[0].timestamps;
    return undefined;
  }

  /**
   * Model for SurfaceFlinger specific data.
   * @constructor
   */
  function AndroidSurfaceFlinger(process, thread) {
    this.process = process;
    this.thread = thread;

    this.appVsync_ = undefined;
    this.sfVsync_ = undefined;

    this.appVsyncTimestamps_ = getVsyncTimestamps(process, VSYNC_APP_NAME);
    this.sfVsyncTimestamps_ = getVsyncTimestamps(process, VSYNC_SF_NAME);
  };

  AndroidSurfaceFlinger.createForProcessIfPossible = function(process) {
    var mainThread = process.getThread(process.pid);

    // newer versions - main thread, lowercase name, preceeding forward slash
    if (mainThread && mainThread.name &&
        /surfaceflinger/.test(mainThread.name))
      return new AndroidSurfaceFlinger(process, mainThread);

    // older versions - another thread is named SurfaceFlinger
    var primaryThreads = process.findAllThreadsNamed('SurfaceFlinger');
    if (primaryThreads.length == 1)
      return new AndroidSurfaceFlinger(process, primaryThreads[0]);
    return undefined;
  };

  AndroidSurfaceFlinger.prototype = {
    get hasVsyncs() {
      return !!this.appVsyncTimestamps_ && !!this.sfVsyncTimestamps_;
    },

    getFrameKickoff: function(timestamp) {
      if (!this.hasVsyncs)
        throw new Error('cannot query vsync info without vsyncs');

      var firstGreaterIndex =
          findLowIndexInSortedArray(this.appVsyncTimestamps_,
                                    function(x) { return x; },
                                    timestamp + TIMESTAMP_FUDGE_MS);

      if (firstGreaterIndex < 1)
        return undefined;
      return this.appVsyncTimestamps_[firstGreaterIndex - 1];
    },

    getFrameDeadline: function(timestamp) {
      if (!this.hasVsyncs)
        throw new Error('cannot query vsync info without vsyncs');

      var firstGreaterIndex =
          findLowIndexInSortedArray(this.sfVsyncTimestamps_,
                                    function(x) { return x; },
                                    timestamp + TIMESTAMP_FUDGE_MS);
      if (firstGreaterIndex >= this.sfVsyncTimestamps_.length)
        return undefined;
      return this.sfVsyncTimestamps_[firstGreaterIndex];
    }
  };

  return {
    AndroidSurfaceFlinger: AndroidSurfaceFlinger
  };
});


'use strict';

/**
 * @fileoverview Class for managing android-specific model meta data,
 * such as rendering apps, frames rendered, and SurfaceFlinger.
 */
tr.exportTo('tr.e.audits', function() {
  var AndroidApp = tr.e.audits.AndroidApp;
  var AndroidSurfaceFlinger = tr.e.audits.AndroidSurfaceFlinger;

  var IMPORTANT_SURFACE_FLINGER_SLICES = {
    'doComposition' : true,
    'updateTexImage' : true,
    'postFramebuffer' : true
  };
  var IMPORTANT_UI_THREAD_SLICES = {
    'Choreographer#doFrame' : true,
    'performTraversals' : true,
    'deliverInputEvent' : true
  };
  var IMPORTANT_RENDER_THREAD_SLICES = {
    'doFrame' : true
  };

  function iterateImportantThreadSlices(thread, important, callback) {
    if (!thread)
      return;

    thread.sliceGroup.slices.forEach(function(slice) {
      if (slice.title in important)
        callback(slice);
    });
  }

  /**
   * Model for Android-specific data.
   * @constructor
   */
  function AndroidModelHelper(model) {
    this.model = model;
    this.apps = [];
    this.surfaceFlinger = undefined;

    var processes = model.getAllProcesses();
    for (var i = 0; i < processes.length && !this.surfaceFlinger; i++) {
      this.surfaceFlinger =
          AndroidSurfaceFlinger.createForProcessIfPossible(processes[i]);
    }

    model.getAllProcesses().forEach(function(process) {
      var app = AndroidApp.createForProcessIfPossible(
          process, this.surfaceFlinger);
      if (app)
        this.apps.push(app);
    }, this);
  };

  AndroidModelHelper.prototype = {
    iterateImportantSlices: function(callback) {
      if (this.surfaceFlinger) {
        iterateImportantThreadSlices(
            this.surfaceFlinger.thread,
            IMPORTANT_SURFACE_FLINGER_SLICES,
            callback);
      }

      this.apps.forEach(function(app) {
        iterateImportantThreadSlices(
            app.uiThread,
            IMPORTANT_UI_THREAD_SLICES,
            callback);
        iterateImportantThreadSlices(
            app.renderThread,
            IMPORTANT_RENDER_THREAD_SLICES,
            callback);
      });
    }
  };

  return {
    AndroidModelHelper: AndroidModelHelper
  };
});


'use strict';

/**
 * @fileoverview Class for Android-specific Auditing.
 */
tr.exportTo('tr.e.audits', function() {
  var SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
  var Auditor = tr.c.Auditor;
  var AndroidModelHelper = tr.e.audits.AndroidModelHelper;
  var Statistics = tr.b.Statistics;
  var FRAME_PERF_CLASS = tr.model.FRAME_PERF_CLASS;
  var InteractionRecord = tr.model.InteractionRecord;
  var Alert = tr.model.Alert;
  var EventInfo = tr.model.EventInfo;
  var TimeDuration = tr.b.u.TimeDuration;

  // TODO: extract from VSYNC, since not all devices have vsync near 60fps
  var EXPECTED_FRAME_TIME_MS = 16.67;

  function getStart(e) { return e.start; }
  function getDuration(e) { return e.duration; }
  // used for general UI thread responsiveness alerts, falls back to duration
  function getCpuDuration(e) {
    return (e.cpuDuration !== undefined) ? e.cpuDuration : e.duration;
  }

  function frameIsActivityStart(frame) {
    for (var i = 0; i < frame.associatedEvents.length; i++) {
      if (frame.associatedEvents[i].title == 'activityStart')
        return true;
    }
    return false;
  }

  var Auditor = tr.c.Auditor;
  var AndroidModelHelper = tr.e.audits.AndroidModelHelper;

  function frameMissedDeadline(frame) {
    return frame.args['deadline'] && frame.args['deadline'] < frame.end;
  }

  /** Builder object for EventInfo docLink structures */
  function DocLinkBuilder() {
    this.docLinks = [];
  }
  DocLinkBuilder.prototype = {
    addAppVideo: function(name, videoId) {
      this.docLinks.push({
        label: 'Video Link',
        textContent: ('Android Performance Patterns: ' + name),
        href: 'https://www.youtube.com/watch?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&v=' + videoId // @suppress longLineCheck
      });
      return this;
    },
    addDacRef: function(name, link) {
      this.docLinks.push({
          label: 'Doc Link',
          textContent: (name + ' documentation'),
          href: 'https://developer.android.com/reference/' + link
      });
      return this;
    },
    build: function() {
      return this.docLinks;
    }
  };

  /**
   * Auditor for Android-specific traces.
   * @constructor
   */
  function AndroidAuditor(model) {
    Auditor.call(this, model);

    var helper = new AndroidModelHelper(model);
    if (helper.apps.length || helper.surfaceFlinger)
      this.helper = helper;
  };

  //////////////////////////////////////////////////////////////////////////////
  // Rendering / RenderThread alerts - only available on SDK 22+
  //////////////////////////////////////////////////////////////////////////////

  AndroidAuditor.viewAlphaAlertInfo_ = new EventInfo(
      'Inefficient View alpha usage',
      'Setting an alpha between 0 and 1 has significant performance costs, if one of the fast alpha paths is not used.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Hidden Cost of Transparency', 'wIy8g8yNhNk')
          .addDacRef('View#setAlpha()', 'android/view/View.html#setAlpha(float)') // @suppress longLineCheck
          .build());
  AndroidAuditor.saveLayerAlertInfo_ = new EventInfo(
      'Expensive rendering with Canvas#saveLayer()',
      'Canvas#saveLayer() incurs extremely high rendering cost. They disrupt the rendering pipeline when drawn, forcing a flush of drawing content. Instead use View hardware layers, or static Bitmaps. This enables the offscreen buffers to be reused in between frames, and avoids the disruptive render target switch.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Hidden Cost of Transparency', 'wIy8g8yNhNk')
          .addDacRef('Canvas#saveLayerAlpha()', 'android/graphics/Canvas.html#saveLayerAlpha(android.graphics.RectF, int, int)') // @suppress longLineCheck
          .build());
  AndroidAuditor.getSaveLayerAlerts_ = function(frame) {
    var badAlphaRegEx =
        /^(.+) alpha caused (unclipped )?saveLayer (\d+)x(\d+)$/;
    var saveLayerRegEx = /^(unclipped )?saveLayer (\d+)x(\d+)$/;

    var ret = [];
    var events = [];

    frame.associatedEvents.forEach(function(slice) {
      var match = badAlphaRegEx.exec(slice.title);
      if (match) {
        // due to bug in tracing code on SDK 22, ignore
        // presence of 'unclipped' string in View alpha slices
        var args = { 'view name': match[1],
                     width: parseInt(match[3]),
                     height: parseInt(match[4]) };
        ret.push(new Alert(AndroidAuditor.viewAlphaAlertInfo_,
                           slice.start, [slice], args));
      } else if (saveLayerRegEx.test(slice.title))
        events.push(slice);
    }, this);

    if (events.length > ret.length) {
      // more saveLayers than bad alpha can account for - add another alert

      var unclippedSeen = Statistics.sum(events, function(slice) {
        return saveLayerRegEx.exec(slice.title)[1] ? 1 : 0;
      });
      var clippedSeen = events.length - unclippedSeen;
      var earliestStart = Statistics.min(events, function(slice) {
        return slice.start;
      });

      var args = {
        'Unclipped saveLayer count (especially bad!)': unclippedSeen,
        'Clipped saveLayer count': clippedSeen
      };

      events.push(frame);
      ret.push(new Alert(AndroidAuditor.saveLayerAlertInfo_,
                         earliestStart, events, args));
    }

    return ret;
  };


  AndroidAuditor.pathAlertInfo_ = new EventInfo(
      'Path texture churn',
      'Paths are drawn with a mask texture, so when a path is modified / newly drawn, that texture must be generated and uploaded to the GPU. Ensure that you cache paths between frames and do not unnecessarily call Path#reset(). You can cut down on this cost by sharing Path object instances between drawables/views.'); // @suppress longLineCheck
  AndroidAuditor.getPathAlert_ = function(frame) {
    var uploadRegEx = /^Generate Path Texture$/;

    var events = frame.associatedEvents.filter(function(event) {
      return event.title == 'Generate Path Texture';
    });
    var start = Statistics.min(events, getStart);
    var duration = Statistics.sum(events, getDuration);

    if (duration < 3)
      return undefined;

    events.push(frame);
    return new Alert(AndroidAuditor.pathAlertInfo_, start, events,
                     { 'Time spent': new TimeDuration(duration) });
  }


  AndroidAuditor.uploadAlertInfo_ = new EventInfo(
      'Expensive Bitmap uploads',
      'Bitmaps that have been modified / newly drawn must be uploaded to the GPU. Since this is expensive if the total number of pixels uploaded is large, reduce the amount of Bitmap churn in this animation/context, per frame.'); // @suppress longLineCheck
  AndroidAuditor.getUploadAlert_ = function(frame) {
    var uploadRegEx = /^Upload (\d+)x(\d+) Texture$/;

    var events = [];
    var start = Number.POSITIVE_INFINITY;
    var duration = 0;
    var pixelsUploaded = 0;
    frame.associatedEvents.forEach(function(event) {
      var match = uploadRegEx.exec(event.title);
      if (match) {
        events.push(event);
        start = Math.min(start, event.start);
        duration += event.duration;
        pixelsUploaded += parseInt(match[1]) * parseInt(match[2]);
      }
    });
    if (events.length == 0 || duration < 3)
      return undefined;

    var mPixels = (pixelsUploaded / 1000000).toFixed(2) + ' million';
    var args = { 'Pixels uploaded': mPixels,
                 'Time spent': new TimeDuration(duration) };
    events.push(frame);
    return new Alert(AndroidAuditor.uploadAlertInfo_, start, events, args);
  }

  //////////////////////////////////////////////////////////////////////////////
  // UI responsiveness alerts
  //////////////////////////////////////////////////////////////////////////////

  AndroidAuditor.ListViewInflateAlertInfo_ = new EventInfo(
      'Inflation during ListView recycling',
      'ListView item recycling involved inflating views. Ensure your Adapter#getView() recycles the incoming View, instead of constructing a new one.'); // @suppress longLineCheck
  AndroidAuditor.ListViewBindAlertInfo_ = new EventInfo(
      'Inefficient ListView recycling/rebinding',
      'ListView recycling taking too much time per frame. Ensure your Adapter#getView() binds data efficiently.'); // @suppress longLineCheck
  AndroidAuditor.getListViewAlert_ = function(frame) {
    var events = frame.associatedEvents.filter(function(event) {
      return event.title == 'obtainView' || event.title == 'setupListItem';
    });
    var duration = Statistics.sum(events, getCpuDuration);

    if (events.length == 0 || duration < 3)
      return undefined;

    // simplifying assumption - check for *any* inflation.
    // TODO(ccraik): make 'inflate' slices associated events.
    var hasInflation = false;
    for (var i = 0; i < events.length; i++) {
      if (events[i] instanceof tr.model.Slice &&
          events[i].findDescendentSlice('inflate')) {
        hasInflation = true;
        break;
      }
    }

    var start = Statistics.min(events, getStart);
    var args = { 'Time spent': new TimeDuration(duration) };
    args['ListView items ' + (hasInflation ? 'inflated' : 'rebound')] =
        events.length / 2;
    var eventInfo = hasInflation ? AndroidAuditor.ListViewInflateAlertInfo_ :
        AndroidAuditor.ListViewBindAlertInfo_;
    events.push(frame);
    return new Alert(eventInfo, start, events, args);
  }


  AndroidAuditor.measureLayoutAlertInfo_ = new EventInfo(
      'Expensive measure/layout pass',
      'Measure/Layout took a significant time, contributing to jank. Avoid triggering layout during animations.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Invalidations, Layouts, and Performance', 'we6poP0kw6E')
          .build());
  AndroidAuditor.getMeasureLayoutAlert_ = function(frame) {
    var events = frame.associatedEvents.filter(function(event) {
      return event.title == 'measure' || event.title == 'layout';
    });
    var duration = Statistics.sum(events, getCpuDuration);

    if (events.length == 0 || duration < 3)
      return undefined;

    var start = Statistics.min(events, getStart);
    events.push(frame);
    return new Alert(AndroidAuditor.measureLayoutAlertInfo_, start, events,
                     { 'Time spent': new TimeDuration(duration) });
  }


  AndroidAuditor.viewDrawAlertInfo_ = new EventInfo(
      'Long View#draw()',
      'Recording the drawing commands of invalidated Views took a long time. Avoid significant work in View or Drawable custom drawing, especially allocations or drawing to Bitmaps.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Invalidations, Layouts, and Performance', 'we6poP0kw6E')
          .addAppVideo('Avoiding Allocations in onDraw()', 'HAK5acHQ53E')
          .build());
  AndroidAuditor.getViewDrawAlert_ = function(frame) {
    var slice = undefined;
    for (var i = 0; i < frame.associatedEvents.length; i++) {
      if (frame.associatedEvents[i].title == 'getDisplayList' ||
          frame.associatedEvents[i].title == 'Record View#draw()') {
        slice = frame.associatedEvents[i];
        break;
      }
    }

    if (!slice || getCpuDuration(slice) < 3)
      return undefined;
    return new Alert(AndroidAuditor.viewDrawAlertInfo_, slice.start,
                     [slice, frame],
                     { 'Time spent': new TimeDuration(getCpuDuration(slice)) });
  }


  //////////////////////////////////////////////////////////////////////////////
  // Runtime alerts
  //////////////////////////////////////////////////////////////////////////////

  AndroidAuditor.blockingGcAlertInfo_ = new EventInfo(
      'Blocking Garbage Collection',
      'Blocking GCs are caused by object churn, and made worse by having large numbers of objects in the heap. Avoid allocating objects during animations/scrolling, and recycle Bitmaps to avoid triggering garbage collection.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Garbage Collection in Android', 'pzfzz50W5Uo')
          .addAppVideo('Avoiding Allocations in onDraw()', 'HAK5acHQ53E')
          .build());
  AndroidAuditor.getBlockingGcAlert_ = function(frame) {
    var events = frame.associatedEvents.filter(function(event) {
      return event.title == 'DVM Suspend' ||
          event.title == 'GC: Wait For Concurrent';
    });
    var blockedDuration = Statistics.sum(events, getDuration);
    if (blockedDuration < 3)
      return undefined;

    var start = Statistics.min(events, getStart);
    events.push(frame);
    return new Alert(AndroidAuditor.blockingGcAlertInfo_, start, events,
                     { 'Blocked duration': new TimeDuration(blockedDuration) });
  };


  AndroidAuditor.lockContentionAlertInfo_ = new EventInfo(
      'Lock contention',
      'UI thread lock contention is caused when another thread holds a lock that the UI thread is trying to use. UI thread progress is blocked until the lock is released. Inspect locking done within the UI thread, and ensure critical sections are short.'); // @suppress longLineCheck
  AndroidAuditor.getLockContentionAlert_ = function(frame) {
    var events = frame.associatedEvents.filter(function(event) {
      return /^Lock Contention on /.test(event.title);
    });

    var blockedDuration = Statistics.sum(events, getDuration);
    if (blockedDuration < 1)
      return undefined;

    var start = Statistics.min(events, getStart);
    events.push(frame);
    return new Alert(AndroidAuditor.lockContentionAlertInfo_, start, events,
                     { 'Blocked duration': new TimeDuration(blockedDuration) });
  };

  AndroidAuditor.schedulingAlertInfo_ = new EventInfo(
      'Scheduling delay',
      'Work to produce this frame was descheduled for several milliseconds, contributing to jank. Ensure that code on the UI thread doesn\'t block on work being done on other threads, and that background threads (doing e.g. network or bitmap loading) are running at android.os.Process#THREAD_PRIORITY_BACKGROUND or lower so they are less likely to interrupt the UI thread. These background threads should show up with a priority number of 130 or higher in the scheduling section under the Kernel process.'); // @suppress longLineCheck
  AndroidAuditor.getSchedulingAlert_ = function(frame) {
    var totalDuration = 0;
    var totalStats = {};
    frame.threadTimeRanges.forEach(function(ttr) {
      var stats = ttr.thread.getSchedulingStatsForRange(ttr.start, ttr.end);
      tr.b.iterItems(stats, function(key, value) {
        if (!(key in totalStats))
          totalStats[key] = 0;
        totalStats[key] += value;
        totalDuration += value;
      });
    });

    // only alert if frame not running for > 3ms. Note that we expect a frame
    // to never describe intentionally idle time.
    if (!(SCHEDULING_STATE.RUNNING in totalStats) ||
        totalDuration == 0 ||
        totalDuration - totalStats[SCHEDULING_STATE.RUNNING] < 3)
      return;

    var args = {};
    tr.b.iterItems(totalStats, function(key, value) {
      if (key === SCHEDULING_STATE.RUNNABLE)
        key = 'Not scheduled, but runnable';
      else if (key === SCHEDULING_STATE.UNINTR_SLEEP)
        key = 'Blocking I/O delay';
      args[key] = new TimeDuration(value);
    });

    return new Alert(AndroidAuditor.schedulingAlertInfo_, frame.start, [frame],
                     args);
  };

  AndroidAuditor.prototype = {
    __proto__: Auditor.prototype,

    renameAndSort_: function() {
      this.model.kernel.important = false;// auto collapse
      // SurfaceFlinger first, other processes sorted by slice count
      this.model.getAllProcesses().forEach(function(process) {
        if (this.helper.surfaceFlinger &&
            process == this.helper.surfaceFlinger.process) {
          if (!process.name)
            process.name = 'SurfaceFlinger';
          process.sortIndex = Number.NEGATIVE_INFINITY;
          process.important = false; // auto collapse
          return;
        }

        var uiThread = process.getThread(process.pid);
        if (!process.name && uiThread && uiThread.name) {
          if (/^ndroid\./.test(uiThread.name))
            uiThread.name = 'a' + uiThread.name;
          process.name = uiThread.name;

          uiThread.name = 'UI Thread';
        }

        process.sortIndex = 0;
        for (var tid in process.threads) {
          process.sortIndex -= process.threads[tid].sliceGroup.slices.length;
        }
      }, this);

      // ensure sequential, relative order for UI/Render/Worker threads
      this.model.getAllThreads().forEach(function(thread) {
        if (thread.tid == thread.parent.pid)
          thread.sortIndex = -3;
        if (thread.name == 'RenderThread')
          thread.sortIndex = -2;
        if (/^hwuiTask/.test(thread.name))
          thread.sortIndex = -1;
      });
    },

    pushFramesAndJudgeJank_: function() {
      var badFramesObserved = 0;
      var framesObserved = 0;
      var surfaceFlinger = this.helper.surfaceFlinger;

      this.helper.apps.forEach(function(app) {
        // override frame list
        app.process.frames = app.getFrames();

        app.process.frames.forEach(function(frame) {
          if (frame.totalDuration > EXPECTED_FRAME_TIME_MS * 2) {
            badFramesObserved += 2;
            frame.perfClass = FRAME_PERF_CLASS.TERRIBLE;
          } else if (frame.totalDuration > EXPECTED_FRAME_TIME_MS ||
              frameMissedDeadline(frame)) {
            badFramesObserved++;
            frame.perfClass = FRAME_PERF_CLASS.BAD;
          } else {
            frame.perfClass = FRAME_PERF_CLASS.GOOD;
          }
        });
        framesObserved += app.process.frames.length;
      });

      if (framesObserved) {
        var portionBad = badFramesObserved / framesObserved;
        if (portionBad > 0.3)
          this.model.faviconHue = 'red';
        else if (portionBad > 0.05)
          this.model.faviconHue = 'yellow';
        else
          this.model.faviconHue = 'green';
      }
    },

    pushEventInfo_: function() {
      var appAnnotator = new AppAnnotator();
      this.helper.apps.forEach(function(app) {
        if (app.uiThread)
          appAnnotator.applyEventInfos(app.uiThread.sliceGroup);
        if (app.renderThread)
          appAnnotator.applyEventInfos(app.renderThread.sliceGroup);
      });
    },

    runAnnotate: function() {
      if (!this.helper)
        return;

      this.renameAndSort_();
      this.pushFramesAndJudgeJank_();
      this.pushEventInfo_();

      this.helper.iterateImportantSlices(function(slice) {
        slice.important = true;
      });
    },

    runAudit: function() {
      if (!this.helper)
        return;

      var alerts = this.model.alerts;
      this.helper.apps.forEach(function(app) {
        app.getFrames().forEach(function(frame) {
          alerts.push.apply(alerts, AndroidAuditor.getSaveLayerAlerts_(frame));

          // skip most alerts for neutral or good frames
          if (frame.perfClass == FRAME_PERF_CLASS.NEUTRAL ||
              frame.perfClass == FRAME_PERF_CLASS.GOOD)
            return;

          var alert = AndroidAuditor.getPathAlert_(frame);
          if (alert)
            alerts.push(alert);
          var alert = AndroidAuditor.getUploadAlert_(frame);
          if (alert)
            alerts.push(alert);
          var alert = AndroidAuditor.getListViewAlert_(frame);
          if (alert)
            alerts.push(alert);
          var alert = AndroidAuditor.getMeasureLayoutAlert_(frame);
          if (alert)
            alerts.push(alert);
          var alert = AndroidAuditor.getViewDrawAlert_(frame);
          if (alert)
            alerts.push(alert);
          var alert = AndroidAuditor.getBlockingGcAlert_(frame);
          if (alert)
            alerts.push(alert);
          var alert = AndroidAuditor.getLockContentionAlert_(frame);
          if (alert)
            alerts.push(alert);
          var alert = AndroidAuditor.getSchedulingAlert_(frame);
          if (alert)
            alerts.push(alert);
        });
      }, this);

      this.addRenderingInteractionRecords();
      this.addInputInteractionRecords();
    },

    addRenderingInteractionRecords: function() {
      var events = [];
      this.helper.apps.forEach(function(app) {
        events.push.apply(events, app.getAnimationAsyncSlices());
        events.push.apply(events, app.getFrames());
      });

      var mergerFunction = function(events) {
        var ir = new InteractionRecord('Rendering',
            tr.ui.b.getColorIdForGeneralPurposeString('mt_rendering'),
            events[0].min,
            events[events.length - 1].max - events[0].min);
        this.model.addInteractionRecord(ir);
      }.bind(this);
      tr.b.mergeRanges(tr.b.convertEventsToRanges(events), 30, mergerFunction);
    },

    addInputInteractionRecords: function() {
      var inputSamples = [];
      this.helper.apps.forEach(function(app) {
        inputSamples.push.apply(inputSamples, app.getInputSamples());
      });

      var mergerFunction = function(events) {
        var ir = new InteractionRecord('Input',
            tr.ui.b.getColorIdForGeneralPurposeString('mt_input'),
            events[0].min,
            events[events.length - 1].max - events[0].min);
        this.model.addInteractionRecord(ir);
      }.bind(this);
      var inputRanges = inputSamples.map(function(sample) {
        return tr.b.Range.fromExplicitRange(sample.timestamp, sample.timestamp);
      });
      tr.b.mergeRanges(inputRanges, 30, mergerFunction);
    }
  };

  Auditor.register(AndroidAuditor);

  function AppAnnotator() {
    this.titleInfoLookup = {};
    this.titleParentLookup = {};
    this.build_();
  }

  AppAnnotator.prototype = {
    build_: function() {
      var registerEventInfo = function(dict) {
        this.titleInfoLookup[dict.title] = new EventInfo(
            dict.title, dict.description, dict.docLinks);
        if (dict.parents)
          this.titleParentLookup[dict.title] = dict.parents;
      }.bind(this);

      registerEventInfo({
          title: 'inflate',
          description: 'Constructing a View hierarchy from pre-processed XML via LayoutInflater#layout. This includes constructing all of the View objects in the hierarchy, and applying styled attributes.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // Adapter view
      //////////////////////////////////////////////////////////////////////////
      registerEventInfo({
          title: 'obtainView',
          description: 'Adapter#getView() called to bind content to a recycled View that is being presented.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'setupListItem',
          description: 'Attached a newly-bound, recycled View to its parent ListView.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'setupGridItem',
          description: 'Attached a newly-bound, recycled View to its parent GridView.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // Choreographer (tracing enabled on M+)
      //////////////////////////////////////////////////////////////////////////
      var choreographerLinks = new DocLinkBuilder()
          .addDacRef('Choreographer', 'android/view/Choreographer.html') // @suppress longLineCheck
          .build();
      registerEventInfo({
          title: 'Choreographer#doFrame',
          docLinks: choreographerLinks,
          description: 'Choreographer executes frame callbacks for inputs, animations, and rendering traversals. When this work is done, a frame will be presented to the user.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'input',
          parents: ['Choreographer#doFrame'],
          docLinks: choreographerLinks,
          description: 'Input callbacks are processed. This generally encompasses dispatching input to Views, as well as any work the Views do to process this input/gesture.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'animation',
          parents: ['Choreographer#doFrame'],
          docLinks: choreographerLinks,
          description: 'Animation callbacks are processed. This is generally minimal work, as animations determine progress for the frame, and push new state to animated objects (such as setting View properties).'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'traversals',
          parents: ['Choreographer#doFrame'],
          docLinks: choreographerLinks,
          description: 'Primary draw traversals. This is the primary traversal of the View hierarchy, including layout and draw passes.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // performTraversals + sub methods
      //////////////////////////////////////////////////////////////////////////
      var traversalParents = ['Choreographer#doFrame', 'performTraversals'];
      var layoutLinks = new DocLinkBuilder()
          .addDacRef('View#Layout', 'android/view/View.html#Layout')
          .build();
      registerEventInfo({
          title: 'performTraversals',
          description: 'A drawing traversal of the View hierarchy, comprised of all layout and drawing needed to produce the frame.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'measure',
          parents: traversalParents,
          docLinks: layoutLinks,
          description: 'First of two phases in view hierarchy layout. Views are asked to size themselves according to constraints supplied by their parent. Some ViewGroups may measure a child more than once to help satisfy their own constraints. Nesting ViewGroups that measure children more than once can lead to excessive and repeated work.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'layout',
          parents: traversalParents,
          docLinks: layoutLinks,
          description: 'Second of two phases in view hierarchy layout, repositioning content and child Views into their new locations.'}); // @suppress longLineCheck
      var drawString = 'Draw pass over the View hierarchy. Every invalidated View will have its drawing commands recorded. On Android versions prior to Lollipop, this would also include the issuing of draw commands to the GPU. Starting with Lollipop, it only includes the recording of commands, and syncing that information to the RenderThread.'; // @suppress longLineCheck
      registerEventInfo({
          title: 'draw',
          parents: traversalParents,
          description: drawString});

      var recordString = 'Every invalidated View\'s drawing commands are recorded. Each will have View#draw() called, and is passed a Canvas that will record and store its drawing commands until it is next invalidated/rerecorded.'; // @suppress longLineCheck
      registerEventInfo({
          title: 'getDisplayList', // Legacy name for compatibility.
          parents: ['draw'],
          description: recordString});
      registerEventInfo({
          title: 'Record View#draw()',
          parents: ['draw'],
          description: recordString});

      registerEventInfo({
          title: 'drawDisplayList',
          parents: ['draw'],
          description: 'Execution of recorded draw commands to generate a frame. This represents the actual formation and issuing of drawing commands to the GPU. On Android L and higher devices, this work is done on a dedicated RenderThread, instead of on the UI Thread.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // RenderThread
      //////////////////////////////////////////////////////////////////////////
      registerEventInfo({
          title: 'DrawFrame',
          description: 'RenderThread portion of the standard UI/RenderThread split frame. This represents the actual formation and issuing of drawing commands to the GPU.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'doFrame',
          description: 'RenderThread animation frame. Represents drawing work done by the RenderThread on a frame where the UI thread did not produce new drawing content.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'syncFrameState',
          description: 'Sync stage between the UI thread and the RenderThread, where the UI thread hands off a frame (including information about modified Views). Time in this method primarily consists of uploading modified Bitmaps to the GPU. After this sync is completed, the UI thread is unblocked, and the RenderThread starts to render the frame.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'flush drawing commands',
          description: 'Issuing the now complete drawing commands to the GPU.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'eglSwapBuffers',
          description: 'Complete GPU rendering of the frame.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // RecyclerView
      //////////////////////////////////////////////////////////////////////////
      registerEventInfo({
          title: 'RV Scroll',
          description: 'RecyclerView is calculating a scroll. If there are too many of these in Systrace, some Views inside RecyclerView might be causing it. Try to avoid using EditText, focusable views or handle them with care.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'RV OnLayout',
          description: 'OnLayout has been called by the View system. If this shows up too many times in Systrace, make sure the children of RecyclerView do not update themselves directly. This will cause a full re-layout but when it happens via the Adapter notifyItemChanged, RecyclerView can avoid full layout calculation.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'RV FullInvalidate',
          description: 'NotifyDataSetChanged or equal has been called. If this is taking a long time, try sending granular notify adapter changes instead of just calling notifyDataSetChanged or setAdapter / swapAdapter. Adding stable ids to your adapter might help.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'RV PartialInvalidate',
          description: 'RecyclerView is rebinding a View. If this is taking a lot of time, consider optimizing your layout or make sure you are not doing extra operations in onBindViewHolder call.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'RV OnBindView',
          description: 'RecyclerView is rebinding a View. If this is taking a lot of time, consider optimizing your layout or make sure you are not doing extra operations in onBindViewHolder call.'}); // @suppress longLineCheck
      registerEventInfo({
          title: 'RV CreateView',
          description: 'RecyclerView is creating a new View. If too many of these are present: 1) There might be a problem in Recycling (e.g. custom Animations that set transient state and prevent recycling or ItemAnimator not implementing the contract properly. See Adapter#onFailedToRecycleView(ViewHolder). 2) There may be too many item view types. Try merging them. 3) There might be too many itemChange animations and not enough space in RecyclerPool. Try increasing your pool size and item cache size.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // Graphics + Composition
      //////////////////////////////////////////////////////////////////////////
      // TODO(ccraik): SurfaceFlinger work
      registerEventInfo({
          title: 'eglSwapBuffers',
          description: 'The CPU has finished producing drawing commands, and is flushing drawing work to the GPU, and posting that buffer to the consumer (which is often SurfaceFlinger window composition). Once this is completed, the GPU can produce the frame content without any involvement from the CPU.'}); // @suppress longLineCheck
    },

    applyEventInfosRecursive_: function(parentNames, slice) {
      var checkExpectedParentNames = function(expectedParentNames) {
        if (!expectedParentNames)
          return true;
        return expectedParentNames.some(function(name) {
          return name in parentNames;
        });
      }


      // Set EventInfo on the slice if it matches title, and parent.
      if (slice.title in this.titleInfoLookup) {
        if (checkExpectedParentNames(this.titleParentLookup[slice.title]))
          slice.info = this.titleInfoLookup[slice.title];
      }

      // Push slice into parentNames, and recurse over subSlices.
      if (slice.subSlices.length > 0) {
        // Increment title in parentName dict.
        if (!(slice.title in parentNames))
          parentNames[slice.title] = 0;
        parentNames[slice.title]++;

        // Recurse over subSlices.
        slice.subSlices.forEach(function(subSlice) {
          this.applyEventInfosRecursive_(parentNames, subSlice);
        }, this);

        // Decrement title in parentName dict.
        parentNames[slice.title]--;
        if (parentNames[slice.title] == 0)
          delete parentNames[slice.title];
      }
    },

    applyEventInfos: function(sliceGroup) {
      sliceGroup.topLevelSlices.forEach(function(slice) {
        this.applyEventInfosRecursive_({}, slice);
      }, this);
    }
  };

  return {
    AndroidAuditor: AndroidAuditor
  };
});


'use strict';

tr.exportTo('tr.e.audits', function() {

  var VSYNC_COUNTER_PRECISIONS = {
    // Android. Some versions have VSYNC split out into VSYNC-app and VSYNC-sf.
    // Requires "gfx" systrace category to be enabled.
    'android.VSYNC-app': 15,
    'android.VSYNC': 15
  };

  var VSYNC_SLICE_PRECISIONS = {
    // Android.
    'RenderWidgetHostViewAndroid::OnVSync': 5,
    // Android. Very precise. Requires "gfx" systrace category to be enabled.
    'VSYNC': 10,
    // Linux. Very precise. Requires "gpu" tracing category to be enabled.
    'vblank': 10,
    // Mac. Derived from a Mac callback (CVDisplayLinkSetOutputCallback).
    'DisplayLinkMac::GetVSyncParameters': 5
  };

  var BEGIN_FRAME_SLICE_PRECISION = {
    'Scheduler::BeginFrame': 10
  };

  /**
   * Auditor that analyzes the model and, if possible, adds data to it
   * indicating when vertical sync events took place.
   *
   * @constructor
   * @extends {tr.c.Auditor}
   */
  function VSyncAuditor(model) {
    tr.c.Auditor.call(this, model);
  };

  VSyncAuditor.prototype = {
    __proto__: tr.c.Auditor.prototype,

    runAnnotate: function() {
      this.model.device.vSyncTimestamps = this.findVSyncTimestamps(this.model);
    },

    /**
     * Returns an array of the most accurate VSync times available in the model.
     */
    findVSyncTimestamps: function(model) {
      var times = [];

      // Only keep the most precise VSync data.
      var maxPrecision = Number.NEGATIVE_INFINITY;
      var maxTitle = undefined;

      function useInstead(title, precisions) {
        var precision = precisions[title];
        if (precision === undefined)
          return false;

        if (title === maxTitle)
          return true;

        if (precision <= maxPrecision) {
          if (precision === maxPrecision) {
            console.warn('Encountered two different VSync events (' +
                maxTitle + ', ' + title + ') with the same precision, ' +
               'ignoring the newer one (' + title + ')');
          }
          return false;
        }
        maxPrecision = precision;
        maxTitle = title;
        times = [];

        return true;
      }

      for (var pid in model.processes) {
        var process = model.processes[pid];
        // Traverse process counters.
        for (var cid in process.counters) {
          if (useInstead(cid, VSYNC_COUNTER_PRECISIONS)) {
            var counter = process.counters[cid];
            for (var i = 0; i < counter.series.length; i++) {
              var series = counter.series[i];
              Array.prototype.push.apply(times, series.timestamps);
            }
          }
        }

        // Traverse thread slices.
        for (var tid in process.threads) {
          var thread = process.threads[tid];
          for (var i = 0; i < thread.sliceGroup.slices.length; i++) {
            var slice = thread.sliceGroup.slices[i];
            if (useInstead(slice.title, VSYNC_SLICE_PRECISIONS))
              times.push(slice.start);
            else if (useInstead(slice.title, BEGIN_FRAME_SLICE_PRECISION))
              times.push(slice.args.frame_time_us / 1000.0);
          }
        }
      }
      times.sort(function(x, y) { return x - y; });
      return times;
    }
  };

  tr.c.Auditor.register(VSyncAuditor);

  return {
    VSyncAuditor: VSyncAuditor
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  var tmpVec2s = [];
  for (var i = 0; i < 8; i++)
    tmpVec2s[i] = vec2.create();

  var tmpVec2a = vec4.create();
  var tmpVec4a = vec4.create();
  var tmpVec4b = vec4.create();
  var tmpMat4 = mat4.create();
  var tmpMat4b = mat4.create();

  var p00 = vec2.createXY(0, 0);
  var p10 = vec2.createXY(1, 0);
  var p01 = vec2.createXY(0, 1);
  var p11 = vec2.createXY(1, 1);

  var lerpingVecA = vec2.create();
  var lerpingVecB = vec2.create();
  function lerpVec2(out, a, b, amt) {
    vec2.scale(lerpingVecA, a, amt);
    vec2.scale(lerpingVecB, b, 1 - amt);
    vec2.add(out, lerpingVecA, lerpingVecB);
    vec2.normalize(out, out);
    return out;
  }

  /**
   * @constructor
   */
  function Quad() {
    this.p1 = vec2.create();
    this.p2 = vec2.create();
    this.p3 = vec2.create();
    this.p4 = vec2.create();
  }

  Quad.fromXYWH = function(x, y, w, h) {
    var q = new Quad();
    vec2.set(q.p1, x, y);
    vec2.set(q.p2, x + w, y);
    vec2.set(q.p3, x + w, y + h);
    vec2.set(q.p4, x, y + h);
    return q;
  }

  Quad.fromRect = function(r) {
    return new Quad.fromXYWH(
        r.x, r.y,
        r.width, r.height);
  }

  Quad.from4Vecs = function(p1, p2, p3, p4) {
    var q = new Quad();
    vec2.set(q.p1, p1[0], p1[1]);
    vec2.set(q.p2, p2[0], p2[1]);
    vec2.set(q.p3, p3[0], p3[1]);
    vec2.set(q.p4, p4[0], p4[1]);
    return q;
  }

  Quad.from8Array = function(arr) {
    if (arr.length != 8)
      throw new Error('Array must be 8 long');
    var q = new Quad();
    q.p1[0] = arr[0];
    q.p1[1] = arr[1];
    q.p2[0] = arr[2];
    q.p2[1] = arr[3];
    q.p3[0] = arr[4];
    q.p3[1] = arr[5];
    q.p4[0] = arr[6];
    q.p4[1] = arr[7];
    return q;
  };

  Quad.prototype = {
    pointInside: function(point) {
      return pointInImplicitQuad(point,
                                 this.p1, this.p2, this.p3, this.p4);
    },

    boundingRect: function() {
      var x0 = Math.min(this.p1[0], this.p2[0], this.p3[0], this.p4[0]);
      var y0 = Math.min(this.p1[1], this.p2[1], this.p3[1], this.p4[1]);

      var x1 = Math.max(this.p1[0], this.p2[0], this.p3[0], this.p4[0]);
      var y1 = Math.max(this.p1[1], this.p2[1], this.p3[1], this.p4[1]);

      return new tr.b.Rect.fromXYWH(x0, y0, x1 - x0, y1 - y0);
    },

    clone: function() {
      var q = new Quad();
      vec2.copy(q.p1, this.p1);
      vec2.copy(q.p2, this.p2);
      vec2.copy(q.p3, this.p3);
      vec2.copy(q.p4, this.p4);
      return q;
    },

    scale: function(s) {
      var q = new Quad();
      this.scaleFast(q, s);
      return q;
    },

    scaleFast: function(dstQuad, s) {
      vec2.copy(dstQuad.p1, this.p1, s);
      vec2.copy(dstQuad.p2, this.p2, s);
      vec2.copy(dstQuad.p3, this.p3, s);
      vec2.copy(dstQuad.p3, this.p3, s);
    },

    isRectangle: function() {
      // Simple rectangle check. Note: will not handle out-of-order components.
      var bounds = this.boundingRect();
      return (
          bounds.x == this.p1[0] &&
          bounds.y == this.p1[1] &&
          bounds.width == this.p2[0] - this.p1[0] &&
          bounds.y == this.p2[1] &&
          bounds.width == this.p3[0] - this.p1[0] &&
          bounds.height == this.p3[1] - this.p2[1] &&
          bounds.x == this.p4[0] &&
          bounds.height == this.p4[1] - this.p2[1]
      );
    },

    projectUnitRect: function(rect) {
      var q = new Quad();
      this.projectUnitRectFast(q, rect);
      return q;
    },

    projectUnitRectFast: function(dstQuad, rect) {
      var v12 = tmpVec2s[0];
      var v14 = tmpVec2s[1];
      var v23 = tmpVec2s[2];
      var v43 = tmpVec2s[3];
      var l12, l14, l23, l43;

      vec2.sub(v12, this.p2, this.p1);
      l12 = vec2.length(v12);
      vec2.scale(v12, v12, 1 / l12);

      vec2.sub(v14, this.p4, this.p1);
      l14 = vec2.length(v14);
      vec2.scale(v14, v14, 1 / l14);

      vec2.sub(v23, this.p3, this.p2);
      l23 = vec2.length(v23);
      vec2.scale(v23, v23, 1 / l23);

      vec2.sub(v43, this.p3, this.p4);
      l43 = vec2.length(v43);
      vec2.scale(v43, v43, 1 / l43);

      var b12 = tmpVec2s[0];
      var b14 = tmpVec2s[1];
      var b23 = tmpVec2s[2];
      var b43 = tmpVec2s[3];
      lerpVec2(b12, v12, v43, rect.y);
      lerpVec2(b43, v12, v43, 1 - rect.bottom);
      lerpVec2(b14, v14, v23, rect.x);
      lerpVec2(b23, v14, v23, 1 - rect.right);

      vec2.addTwoScaledUnitVectors(tmpVec2a,
                                   b12, l12 * rect.x,
                                   b14, l14 * rect.y);
      vec2.add(dstQuad.p1, this.p1, tmpVec2a);

      vec2.addTwoScaledUnitVectors(tmpVec2a,
                                   b12, l12 * -(1.0 - rect.right),
                                   b23, l23 * rect.y);
      vec2.add(dstQuad.p2, this.p2, tmpVec2a);


      vec2.addTwoScaledUnitVectors(tmpVec2a,
                                   b43, l43 * -(1.0 - rect.right),
                                   b23, l23 * -(1.0 - rect.bottom));
      vec2.add(dstQuad.p3, this.p3, tmpVec2a);

      vec2.addTwoScaledUnitVectors(tmpVec2a,
                                   b43, l43 * rect.left,
                                   b14, l14 * -(1.0 - rect.bottom));
      vec2.add(dstQuad.p4, this.p4, tmpVec2a);
    },

    toString: function() {
      return 'Quad(' +
          vec2.toString(this.p1) + ', ' +
          vec2.toString(this.p2) + ', ' +
          vec2.toString(this.p3) + ', ' +
          vec2.toString(this.p4) + ')';
    }
  };

  function sign(p1, p2, p3) {
    return (p1[0] - p3[0]) * (p2[1] - p3[1]) -
        (p2[0] - p3[0]) * (p1[1] - p3[1]);
  }

  function pointInTriangle2(pt, p1, p2, p3) {
    var b1 = sign(pt, p1, p2) < 0.0;
    var b2 = sign(pt, p2, p3) < 0.0;
    var b3 = sign(pt, p3, p1) < 0.0;
    return ((b1 == b2) && (b2 == b3));
  }

  function pointInImplicitQuad(point, p1, p2, p3, p4) {
    return pointInTriangle2(point, p1, p2, p3) ||
        pointInTriangle2(point, p1, p3, p4);
  }

  return {
    pointInTriangle2: pointInTriangle2,
    pointInImplicitQuad: pointInImplicitQuad,
    Quad: Quad
  };
});


'use strict';

/**
 * @fileoverview Splay tree used by CodeMap.
 */
tr.exportTo('tr.e.importer.v8', function() {
  /**
   * Constructs a Splay tree.  A splay tree is a self-balancing binary
   * search tree with the additional property that recently accessed
   * elements are quick to access again. It performs basic operations
   * such as insertion, look-up and removal in O(log(n)) amortized time.
   *
   * @constructor
   */
  function SplayTree() { };

  /**
   * Pointer to the root node of the tree.
   *
   * @type {SplayTree.Node}
   * @private
   */
  SplayTree.prototype.root_ = null;

  /**
   * @return {boolean} Whether the tree is empty.
   */
  SplayTree.prototype.isEmpty = function() {
    return !this.root_;
  };

  /**
   * Inserts a node into the tree with the specified key and value if
   * the tree does not already contain a node with the specified key. If
   * the value is inserted, it becomes the root of the tree.
   *
   * @param {number} key Key to insert into the tree.
   * @param {*} value Value to insert into the tree.
   */
  SplayTree.prototype.insert = function(key, value) {
    if (this.isEmpty()) {
      this.root_ = new SplayTree.Node(key, value);
      return;
    }
    // Splay on the key to move the last node on the search path for
    // the key to the root of the tree.
    this.splay_(key);
    if (this.root_.key == key) {
      return;
    }
    var node = new SplayTree.Node(key, value);
    if (key > this.root_.key) {
      node.left = this.root_;
      node.right = this.root_.right;
      this.root_.right = null;
    } else {
      node.right = this.root_;
      node.left = this.root_.left;
      this.root_.left = null;
    }
    this.root_ = node;
  };


  /**
   * Removes a node with the specified key from the tree if the tree
   * contains a node with this key. The removed node is returned. If the
   * key is not found, an exception is thrown.
   *
   * @param {number} key Key to find and remove from the tree.
   * @return {SplayTree.Node} The removed node.
   */
  SplayTree.prototype.remove = function(key) {
    if (this.isEmpty()) {
      throw Error('Key not found: ' + key);
    }
    this.splay_(key);
    if (this.root_.key != key) {
      throw Error('Key not found: ' + key);
    }
    var removed = this.root_;
    if (!this.root_.left) {
      this.root_ = this.root_.right;
    } else {
      var right = this.root_.right;
      this.root_ = this.root_.left;
      // Splay to make sure that the new root has an empty right child.
      this.splay_(key);
      // Insert the original right child as the right child of the new
      // root.
      this.root_.right = right;
    }
    return removed;
  };


  /**
   * Returns the node having the specified key or null if the tree doesn't
   * contain a node with the specified key.
   *
   *
   * @param {number} key Key to find in the tree.
   * @return {SplayTree.Node} Node having the specified key.
   */
  SplayTree.prototype.find = function(key) {
    if (this.isEmpty()) {
      return null;
    }
    this.splay_(key);
    return this.root_.key == key ? this.root_ : null;
  };

  /**
   * @return {SplayTree.Node} Node having the minimum key value.
   */
  SplayTree.prototype.findMin = function() {
    if (this.isEmpty()) {
      return null;
    }
    var current = this.root_;
    while (current.left) {
      current = current.left;
    }
    return current;
  };

  /**
   * @return {SplayTree.Node} Node having the maximum key value.
   */
  SplayTree.prototype.findMax = function(opt_startNode) {
    if (this.isEmpty()) {
      return null;
    }
    var current = opt_startNode || this.root_;
    while (current.right) {
      current = current.right;
    }
    return current;
  };

  /**
   * @return {SplayTree.Node} Node having the maximum key value that
   *     is less or equal to the specified key value.
   */
  SplayTree.prototype.findGreatestLessThan = function(key) {
    if (this.isEmpty()) {
      return null;
    }
    // Splay on the key to move the node with the given key or the last
    // node on the search path to the top of the tree.
    this.splay_(key);
    // Now the result is either the root node or the greatest node in
    // the left subtree.
    if (this.root_.key <= key) {
      return this.root_;
    } else if (this.root_.left) {
      return this.findMax(this.root_.left);
    } else {
      return null;
    }
  };

  /**
   * @return {Array<*>} An array containing all the values of tree's nodes
   * paired with keys.
   *
   */
  SplayTree.prototype.exportKeysAndValues = function() {
    var result = [];
    this.traverse_(function(node) { result.push([node.key, node.value]); });
    return result;
  };

  /**
   * @return {Array<*>} An array containing all the values of tree's nodes.
   */
  SplayTree.prototype.exportValues = function() {
    var result = [];
    this.traverse_(function(node) { result.push(node.value); });
    return result;
  };

  /**
   * Perform the splay operation for the given key. Moves the node with
   * the given key to the top of the tree.  If no node has the given
   * key, the last node on the search path is moved to the top of the
   * tree. This is the simplified top-down splaying algorithm from:
   * "Self-adjusting Binary Search Trees" by Sleator and Tarjan
   *
   * @param {number} key Key to splay the tree on.
   * @private
   */
  SplayTree.prototype.splay_ = function(key) {
    if (this.isEmpty()) {
      return;
    }
    // Create a dummy node.  The use of the dummy node is a bit
    // counter-intuitive: The right child of the dummy node will hold
    // the L tree of the algorithm.  The left child of the dummy node
    // will hold the R tree of the algorithm.  Using a dummy node, left
    // and right will always be nodes and we avoid special cases.
    var dummy, left, right;
    dummy = left = right = new SplayTree.Node(null, null);
    var current = this.root_;
    while (true) {
      if (key < current.key) {
        if (!current.left) {
          break;
        }
        if (key < current.left.key) {
          // Rotate right.
          var tmp = current.left;
          current.left = tmp.right;
          tmp.right = current;
          current = tmp;
          if (!current.left) {
            break;
          }
        }
        // Link right.
        right.left = current;
        right = current;
        current = current.left;
      } else if (key > current.key) {
        if (!current.right) {
          break;
        }
        if (key > current.right.key) {
          // Rotate left.
          var tmp = current.right;
          current.right = tmp.left;
          tmp.left = current;
          current = tmp;
          if (!current.right) {
            break;
          }
        }
        // Link left.
        left.right = current;
        left = current;
        current = current.right;
      } else {
        break;
      }
    }
    // Assemble.
    left.right = current.left;
    right.left = current.right;
    current.left = dummy.right;
    current.right = dummy.left;
    this.root_ = current;
  };

  /**
   * Performs a preorder traversal of the tree.
   *
   * @param {function(SplayTree.Node)} f Visitor function.
   * @private
   */
  SplayTree.prototype.traverse_ = function(f) {
    var nodesToVisit = [this.root_];
    while (nodesToVisit.length > 0) {
      var node = nodesToVisit.shift();
      if (node == null) {
        continue;
      }
      f(node);
      nodesToVisit.push(node.left);
      nodesToVisit.push(node.right);
    }
  };

  /**
   * Constructs a Splay tree node.
   *
   * @param {number} key Key.
   * @param {*} value Value.
   */
  SplayTree.Node = function(key, value) {
    this.key = key;
    this.value = value;
  };

  /**
   * @type {SplayTree.Node}
   */
  SplayTree.Node.prototype.left = null;

  /**
   * @type {SplayTree.Node}
   */
  SplayTree.Node.prototype.right = null;

  return {
    SplayTree: SplayTree
  };
});


'use strict';

/**
 * @fileoverview Map addresses to dynamically created functions.
 */
tr.exportTo('tr.e.importer.v8', function() {
  /**
   * Constructs a mapper that maps addresses into code entries.
   *
   * @constructor
   */
  function CodeMap() {
    /**
     * Dynamic code entries. Used for JIT compiled code.
     */
    this.dynamics_ = new tr.e.importer.v8.SplayTree();

    /**
     * Name generator for entries having duplicate names.
     */
    this.dynamicsNameGen_ = new tr.e.importer.v8.CodeMap.NameGenerator();

    /**
     * Static code entries. Used for statically compiled code.
     */
    this.statics_ = new tr.e.importer.v8.SplayTree();

    /**
     * Libraries entries. Used for the whole static code libraries.
     */
    this.libraries_ = new tr.e.importer.v8.SplayTree();

    /**
     * Map of memory pages occupied with static code.
     */
    this.pages_ = [];
  };

  /**
   * The number of alignment bits in a page address.
   */
  CodeMap.PAGE_ALIGNMENT = 12;

  /**
   * Page size in bytes.
   */
  CodeMap.PAGE_SIZE = 1 << CodeMap.PAGE_ALIGNMENT;

  /**
   * Adds a dynamic (i.e. moveable and discardable) code entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addCode = function(start, codeEntry) {
    this.deleteAllCoveredNodes_(this.dynamics_, start, start + codeEntry.size);
    this.dynamics_.insert(start, codeEntry);
  };

  /**
   * Moves a dynamic code entry. Throws an exception if there is no dynamic
   * code entry with the specified starting address.
   *
   * @param {number} from The starting address of the entry being moved.
   * @param {number} to The destination address.
   */
  CodeMap.prototype.moveCode = function(from, to) {
    var removedNode = this.dynamics_.remove(from);
    this.deleteAllCoveredNodes_(this.dynamics_, to,
                                to + removedNode.value.size);
    this.dynamics_.insert(to, removedNode.value);
  };

  /**
   * Discards a dynamic code entry. Throws an exception if there is no dynamic
   * code entry with the specified starting address.
   *
   * @param {number} start The starting address of the entry being deleted.
   */
  CodeMap.prototype.deleteCode = function(start) {
    var removedNode = this.dynamics_.remove(start);
  };

  /**
   * Adds a library entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addLibrary = function(
      start, codeEntry) {
    this.markPages_(start, start + codeEntry.size);
    this.libraries_.insert(start, codeEntry);
  };

  /**
   * Adds a static code entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addStaticCode = function(
      start, codeEntry) {
    this.statics_.insert(start, codeEntry);
  };

  /**
   * @private
   */
  CodeMap.prototype.markPages_ = function(start, end) {
    for (var addr = start; addr <= end;
         addr += CodeMap.PAGE_SIZE) {
      this.pages_[addr >>> CodeMap.PAGE_ALIGNMENT] = 1;
    }
  };

  /**
   * @private
   */
  CodeMap.prototype.deleteAllCoveredNodes_ = function(tree, start, end) {
    var to_delete = [];
    var addr = end - 1;
    while (addr >= start) {
      var node = tree.findGreatestLessThan(addr);
      if (!node) break;
      var start2 = node.key, end2 = start2 + node.value.size;
      if (start2 < end && start < end2) to_delete.push(start2);
      addr = start2 - 1;
    }
    for (var i = 0, l = to_delete.length; i < l; ++i) tree.remove(to_delete[i]);
  };

  /**
   * @private
   */
  CodeMap.prototype.isAddressBelongsTo_ = function(addr, node) {
    return addr >= node.key && addr < (node.key + node.value.size);
  };

  /**
   * @private
   */
  CodeMap.prototype.findInTree_ = function(tree, addr) {
    var node = tree.findGreatestLessThan(addr);
    return node && this.isAddressBelongsTo_(addr, node) ? node.value : null;
  };

  /**
   * Finds a code entry that contains the specified address. Both static and
   * dynamic code entries are considered.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findEntry = function(addr) {
    var pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
    if (pageAddr in this.pages_) {
      // Static code entries can contain "holes" of unnamed code.
      // In this case, the whole library is assigned to this address.
      return this.findInTree_(this.statics_, addr) ||
          this.findInTree_(this.libraries_, addr);
    }
    var min = this.dynamics_.findMin();
    var max = this.dynamics_.findMax();
    if (max != null && addr < (max.key + max.value.size) && addr >= min.key) {
      var dynaEntry = this.findInTree_(this.dynamics_, addr);
      if (dynaEntry == null) return null;
      // Dedupe entry name.
      if (!dynaEntry.nameUpdated_) {
        dynaEntry.name = this.dynamicsNameGen_.getName(dynaEntry.name);
        dynaEntry.nameUpdated_ = true;
      }
      return dynaEntry;
    }
    return null;
  };

  /**
   * Returns a dynamic code entry using its starting address.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findDynamicEntryByStartAddress =
      function(addr) {
    var node = this.dynamics_.find(addr);
    return node ? node.value : null;
  };

  /**
   * Returns an array of all dynamic code entries.
   */
  CodeMap.prototype.getAllDynamicEntries = function() {
    return this.dynamics_.exportValues();
  };

  /**
   * Returns an array of pairs of all dynamic code entries and their addresses.
   */
  CodeMap.prototype.getAllDynamicEntriesWithAddresses = function() {
    return this.dynamics_.exportKeysAndValues();
  };

  /**
   * Returns an array of all static code entries.
   */
  CodeMap.prototype.getAllStaticEntries = function() {
    return this.statics_.exportValues();
  };

  /**
   * Returns an array of all libraries entries.
   */
  CodeMap.prototype.getAllLibrariesEntries = function() {
    return this.libraries_.exportValues();
  };

  /**
   * Creates a code entry object.
   *
   * @param {number} size Code entry size in bytes.
   * @param {string=} opt_name Code entry name.
   * @constructor
   */
  CodeMap.CodeEntry = function(size, opt_name) {
    this.id = tr.b.GUID.allocate();
    this.size = size;
    this.name = opt_name || '';
    this.nameUpdated_ = false;
  };

  CodeMap.CodeEntry.prototype.getName = function() {
    return this.name;
  };

  CodeMap.CodeEntry.prototype.toString = function() {
    return this.name + ': ' + this.size.toString(16);
  };

  CodeMap.NameGenerator = function() {
    this.knownNames_ = {};
  };

  CodeMap.NameGenerator.prototype.getName = function(name) {
    if (!(name in this.knownNames_)) {
      this.knownNames_[name] = 0;
      return name;
    }
    var count = ++this.knownNames_[name];
    return name + ' {' + count + '}';
  };
  return {
    CodeMap: CodeMap
  };
});


'use strict';

tr.exportTo('tr.model.source_info', function() {
  function SourceInfo(file, opt_line, opt_column) {
    this.file_ = file;
    this.line_ = opt_line || -1;
    this.column_ = opt_column || -1;
  }

  SourceInfo.prototype = {
    get file() {
      return this.file_;
    },

    get line() {
      return this.line_;
    },

    get column() {
      return this.column_;
    },

    get domain() {
      if (!this.file_)
        return undefined;
      var domain = this.file_.match(/(.*:\/\/[^:\/]*)/i);
      return domain ? domain[1] : undefined;
    },

    toString: function() {
      var str = '';

      if (this.file_)
        str += this.file_;
      if (this.line_ > 0)
        str += ':' + this.line_;
      if (this.column_ > 0)
        str += ':' + this.column_;
      return str;
    }
  };

  return {
    SourceInfo: SourceInfo
  };
});


'use strict';

tr.exportTo('tr.model.source_info', function() {
  function JSSourceInfo(file, line, column, isNative, scriptId) {
    tr.model.source_info.SourceInfo.call(this, file, line, column);

    this.isNative_ = isNative;
    this.scriptId_ = scriptId;
  }

  JSSourceInfo.prototype = {
    __proto__: tr.model.source_info.SourceInfo.prototype,

    get isNative() {
      return this.isNative_;
    },

    get scriptId() {
      return this.scriptId_;
    },

    toString: function() {
      var str = this.isNative_ ? '[native v8] ' : '';
      return str +
          tr.model.source_info.SourceInfo.prototype.toString.call(this);
    }
  };

  return {
    JSSourceInfo: JSSourceInfo
  };
});


'use strict';

/**
 * @fileoverview TraceCodeEntry is a wrapper around the V8 CodeEntry that
 * extracts extra context information for each item. This includes things like
 * the source file, line and if the function is a native method or not.
 */
tr.exportTo('tr.e.importer', function() {
  function TraceCodeEntry(size, name, scriptId) {
    // Stolen from DevTools TimelineJSProfileProcessor._buildCallFrame
    // Code states:
    // (empty) -> compiled
    //    ~    -> optimizable
    //    *    -> optimized
    var rePrefix = /^(\w*:)?[*~]?(.*)$/m;
    var tokens = rePrefix.exec(name);
    var prefix = tokens[1];
    var body = tokens[2];

    var rawName;
    var rawUrl;
    if (prefix === 'Script:') {
        rawName = '';
        rawUrl = body;
    } else {
        var spacePos = body.lastIndexOf(' ');
        rawName = spacePos !== -1 ? body.substr(0, spacePos) : body;
        rawUrl = spacePos !== -1 ? body.substr(spacePos + 1) : '';
    }

    function splitLineAndColumn(url) {
      var lineColumnRegEx = /(?::(\d+))?(?::(\d+))?$/;
      var lineColumnMatch = lineColumnRegEx.exec(url);
      var lineNumber;
      var columnNumber;

      if (typeof(lineColumnMatch[1]) === 'string') {
        lineNumber = parseInt(lineColumnMatch[1], 10);
        // Immediately convert line and column to 0-based numbers.
        lineNumber = isNaN(lineNumber) ? undefined : lineNumber - 1;
      }
      if (typeof(lineColumnMatch[2]) === 'string') {
        columnNumber = parseInt(lineColumnMatch[2], 10);
        columnNumber = isNaN(columnNumber) ? undefined : columnNumber - 1;
      }

      return {
        url: url.substring(0, url.length - lineColumnMatch[0].length),
        lineNumber: lineNumber,
        columnNumber: columnNumber
      };
    }

    var nativeSuffix = ' native';
    var isNative = rawName.endsWith(nativeSuffix);
    var functionName =
        isNative ? rawName.slice(0, -nativeSuffix.length) : rawName;
    var urlData = splitLineAndColumn(rawUrl);
    var url = urlData.url || '';
    var line = urlData.lineNumber || 0;
    var column = urlData.columnNumber || 0;

    tr.e.importer.v8.CodeMap.CodeEntry.call(this, size, functionName);

    this.sourceInfo_ = new tr.model.source_info.JSSourceInfo(
        url, line, column, isNative, scriptId);
  };

  TraceCodeEntry.prototype = {
    __proto__: tr.e.importer.v8.CodeMap.CodeEntry.prototype,

    get sourceInfo() {
      return this.sourceInfo_;
    }
  };

  return {
    TraceCodeEntry: TraceCodeEntry
  };
});


'use strict';

tr.exportTo('tr.ui.annotations', function() {
  /**
   * A view responsible for drawing a single highlight rectangle box on
   * the timeline.
   * @extends {AnnotationView}
   * @constructor
   */
  function RectAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
  }

  RectAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    draw: function(ctx) {
      var dt = this.viewport_.currentDisplayTransform;
      var startCoords =
          this.annotation_.startLocation.toViewCoordinates(this.viewport_);
      var endCoords =
          this.annotation_.endLocation.toViewCoordinates(this.viewport_);

      // Prevent drawing into the ruler track by clamping the initial Y
      // point and the rect's Y size.
      var startY = startCoords.viewY - ctx.canvas.getBoundingClientRect().top;
      var sizeY = endCoords.viewY - startCoords.viewY;
      if (startY + sizeY < 0) {
        // In this case sizeY is negative. If final Y is negative,
        // overwrite startY so that the rectangle ends at y=0.
        startY = sizeY;
      } else if (startY < 0) {
        startY = 0;
      }

      ctx.fillStyle = this.annotation_.fillStyle;
      ctx.fillRect(startCoords.viewX, startY,
          endCoords.viewX - startCoords.viewX, sizeY);
    }
  };

  return {
    RectAnnotationView: RectAnnotationView
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  function RectAnnotation(start, end) {
    tr.model.Annotation.apply(this, arguments);

    this.startLocation_ = start; // Location of top-left corner.
    this.endLocation_ = end; // Location of bottom-right corner.
    this.fillStyle = 'rgba(255, 180, 0, 0.3)';
  }

  RectAnnotation.fromDict = function(dict) {
    var args = dict.args;
    var startLoc =
        new tr.model.Location(args.start.xWorld, args.start.yComponents);
    var endLoc =
        new tr.model.Location(args.end.xWorld, args.end.yComponents);
    return new tr.model.RectAnnotation(startLoc, endLoc);
  }

  RectAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    get startLocation() {
      return this.startLocation_;
    },

    get endLocation() {
      return this.endLocation_;
    },

    toDict: function() {
      return {
        typeName: 'rect',
        args: {
          start: this.startLocation.toDict(),
          end: this.endLocation.toDict()
        }
      };
    },

    createView_: function(viewport) {
      return new tr.ui.annotations.RectAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(RectAnnotation, {typeName: 'rect'});

  return {
    RectAnnotation: RectAnnotation
  };
});


'use strict';

tr.exportTo('tr.ui.annotations', function() {
  /**
   * A view of a comment box consisting of a textarea and a line to the
   * actual location.
   * @extends {AnnotationView}
   * @constructor
   */
  function CommentBoxAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
    this.textArea_ = undefined;

    this.styleWidth = 250;
    this.styleHeight = 50;
    this.fontSize = 10;
    this.rightOffset = 50;
    this.topOffset = 25;
  }

  CommentBoxAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    removeTextArea: function() {
      this.textArea_.parentNode.removeChild(this.textArea_);
    },

    draw: function(ctx) {
      var coords = this.annotation_.location.toViewCoordinates(this.viewport_);
      if (coords.viewX < 0) {
        if (this.textArea_)
          this.textArea_.style.visibility = 'hidden';
        return;
      }

      // Set up textarea element.
      if (!this.textArea_) {
        this.textArea_ = document.createElement('textarea');
        this.textArea_.style.position = 'absolute';
        this.textArea_.readOnly = true;
        this.textArea_.value = this.annotation_.text;
        // Set the z-index so that this is shown on top of canvas.
        this.textArea_.style.zIndex = 1;
        ctx.canvas.parentNode.appendChild(this.textArea_);
      }

      this.textArea_.style.width = this.styleWidth + 'px';
      this.textArea_.style.height = this.styleHeight + 'px';
      this.textArea_.style.fontSize = this.fontSize + 'px';
      this.textArea_.style.visibility = 'visible';

      // Update positions to latest coordinate.
      this.textArea_.style.left =
          coords.viewX + ctx.canvas.getBoundingClientRect().left +
          this.rightOffset + 'px';
      this.textArea_.style.top =
          coords.viewY - ctx.canvas.getBoundingClientRect().top -
          this.topOffset + 'px';

      // Draw pointer line from offset to actual location.
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      tr.ui.b.drawLine(ctx, coords.viewX,
          coords.viewY - ctx.canvas.getBoundingClientRect().top,
          coords.viewX + this.rightOffset,
          coords.viewY - this.topOffset -
            ctx.canvas.getBoundingClientRect().top);
      ctx.stroke();
    }
  };

  return {
    CommentBoxAnnotationView: CommentBoxAnnotationView
  };
});


'use strict';

tr.exportTo('tr.model', function() {

  function CommentBoxAnnotation(location, text) {
    tr.model.Annotation.apply(this, arguments);

    this.location = location;
    this.text = text;
  }

  CommentBoxAnnotation.fromDict = function(dict) {
    var args = dict.args;
    var location =
        new tr.model.Location(args.location.xWorld, args.location.yComponents);
    return new tr.model.CommentBoxAnnotation(location, args.text);
  };

  CommentBoxAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    onRemove: function() {
      this.view_.removeTextArea();
    },

    toDict: function() {
      return {
        typeName: 'comment_box',
        args: {
          text: this.text,
          location: this.location.toDict()
        }
      };
    },

    createView_: function(viewport) {
      return new tr.ui.annotations.CommentBoxAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(
      CommentBoxAnnotation, {typeName: 'comment_box'});

  return {
    CommentBoxAnnotation: CommentBoxAnnotation
  };
});


'use strict';

/**
 * @fileoverview TraceEventImporter imports TraceEvent-formatted data
 * into the provided model.
 */
tr.exportTo('tr.e.importer', function() {
  var deepCopy = tr.b.deepCopy;

  function getEventColor(event, opt_customName) {
    if (event.cname)
      return tr.ui.b.getColorIdForReservedName(event.cname);
    else if (opt_customName || event.name) {
      return tr.ui.b.getColorIdForGeneralPurposeString(
          opt_customName || event.name);
    }
  }

  var timestampFromUs = tr.b.u.Units.timestampFromUs;
  var maybeTimestampFromUs = tr.b.u.Units.maybeTimestampFromUs;

  var PRODUCER = 'producer';
  var CONSUMER = 'consumer';
  var STEP = 'step';

  function TraceEventImporter(model, eventData) {
    this.importPriority = 1;
    this.model_ = model;
    this.events_ = undefined;
    this.sampleEvents_ = undefined;
    this.stackFrameEvents_ = undefined;
    this.systemTraceEvents_ = undefined;
    this.battorData_ = undefined;
    this.eventsWereFromString_ = false;
    this.softwareMeasuredCpuCount_ = undefined;

    this.allAsyncEvents_ = [];
    this.allFlowEvents_ = [];
    this.allObjectEvents_ = [];

    this.traceEventSampleStackFramesByName_ = {};

    this.v8ProcessCodeMaps_ = {};
    this.v8ProcessRootStackFrame_ = {};

    // Dump ID -> {global: (event | undefined), process: [events]}
    this.allMemoryDumpEvents_ = {};

    if (typeof(eventData) === 'string' || eventData instanceof String) {
      eventData = eventData.trim();
      // If the event data begins with a [, then we know it should end with a ].
      // The reason we check for this is because some tracing implementations
      // cannot guarantee that a ']' gets written to the trace file. So, we are
      // forgiving and if this is obviously the case, we fix it up before
      // throwing the string at JSON.parse.
      if (eventData[0] === '[') {
        eventData = eventData.replace(/\s*,\s*$/, '');
        if (eventData[eventData.length - 1] !== ']')
          eventData = eventData + ']';
      }

      this.events_ = JSON.parse(eventData);
      this.eventsWereFromString_ = true;
    } else {
      this.events_ = eventData;
    }

    this.traceAnnotations_ = this.events_.traceAnnotations;

    // Some trace_event implementations put the actual trace events
    // inside a container. E.g { ... , traceEvents: [ ] }
    // If we see that, just pull out the trace events.
    if (this.events_.traceEvents) {
      var container = this.events_;
      this.events_ = this.events_.traceEvents;

      // Some trace_event implementations put ftrace_importer traces as a
      // huge string inside container.systemTraceEvents. If we see that, pull it
      // out. It will be picked up by extractSubtraces later on.
      this.systemTraceEvents_ = container.systemTraceEvents;

      // Some trace_event implementations put battor power traces as a
      // huge string inside container.battorLogAsString. If we see that, pull
      // it out. It will be picked up by extractSubtraces later on.
      this.battorData_ = container.battorLogAsString;

      // Sampling data.
      this.sampleEvents_ = container.samples;
      this.stackFrameEvents_ = container.stackFrames;

      // Some implementations specify displayTimeUnit
      if (container.displayTimeUnit) {
        var unitName = container.displayTimeUnit;
        var unit = tr.b.u.TimeDisplayModes[unitName];
        if (unit === undefined) {
          throw new Error('Unit ' + unitName + ' is not supported.');
        }
        this.model_.intrinsicTimeUnit = unit;
      }

      var knownFieldNames = {
        battorLogAsString: true,
        samples: true,
        stackFrames: true,
        systemTraceEvents: true,
        traceAnnotations: true,
        traceEvents: true
      };
      // Any other fields in the container should be treated as metadata.
      for (var fieldName in container) {
        if (fieldName in knownFieldNames)
          continue;
        this.model_.metadata.push({name: fieldName,
          value: container[fieldName]});
      }
    }
  }

  /**
   * @return {boolean} Whether obj is a TraceEvent array.
   */
  TraceEventImporter.canImport = function(eventData) {
    // May be encoded JSON. But we dont want to parse it fully yet.
    // Use a simple heuristic:
    //   - eventData that starts with [ are probably trace_event
    //   - eventData that starts with { are probably trace_event
    // May be encoded JSON. Treat files that start with { as importable by us.
    if (typeof(eventData) === 'string' || eventData instanceof String) {
      eventData = eventData.trim();
      return eventData[0] == '{' || eventData[0] == '[';
    }

    // Might just be an array of events
    if (eventData instanceof Array && eventData.length && eventData[0].ph)
      return true;

    // Might be an object with a traceEvents field in it.
    if (eventData.traceEvents) {
      if (eventData.traceEvents instanceof Array) {
        if (eventData.traceEvents.length && eventData.traceEvents[0].ph)
          return true;
        if (eventData.samples.length && eventData.stackFrames !== undefined)
          return true;
      }
    }

    return false;
  };

  TraceEventImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    extractSubtraces: function() {
      var systemEventsTmp = this.systemTraceEvents_;
      var battorDataTmp = this.battorData_;
      this.systemTraceEvents_ = undefined;
      this.battorData_ = undefined;
      var subTraces = systemEventsTmp ? [systemEventsTmp] : [];
      if (battorDataTmp)
        subTraces.push(battorDataTmp);
       return subTraces;
    },

    /**
     * Deep copying is only needed if the trace was given to us as events.
     */
    deepCopyIfNeeded_: function(obj) {
      if (obj === undefined)
        obj = {};
      if (this.eventsWereFromString_)
        return obj;
      return deepCopy(obj);
    },

    /**
     * Always perform deep copying.
     */
    deepCopyAlways_: function(obj) {
      if (obj === undefined)
        obj = {};
      return deepCopy(obj);
    },

    /**
     * Helper to process an async event.
     */
    processAsyncEvent: function(event) {
      var thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      this.allAsyncEvents_.push({
        sequenceNumber: this.allAsyncEvents_.length,
        event: event,
        thread: thread
      });
    },

    /**
     * Helper to process a flow event.
     */
    processFlowEvent: function(event, opt_slice) {
      var thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      this.allFlowEvents_.push({
        refGuid: tr.b.GUID.getLastGuid(),
        sequenceNumber: this.allFlowEvents_.length,
        event: event,
        slice: opt_slice,  // slice for events that have flow info
        thread: thread
      });
    },

    /**
     * Helper that creates and adds samples to a Counter object based on
     * 'C' phase events.
     */
    processCounterEvent: function(event) {
      var ctr_name;
      if (event.id !== undefined)
        ctr_name = event.name + '[' + event.id + ']';
      else
        ctr_name = event.name;

      var ctr = this.model_.getOrCreateProcess(event.pid)
          .getOrCreateCounter(event.cat, ctr_name);
      var reservedColorId = event.cname ? getEventColor(event) : undefined;

      // Initialize the counter's series fields if needed.
      if (ctr.numSeries === 0) {
        for (var seriesName in event.args) {
          var colorId = reservedColorId ||
              getEventColor(event, ctr.name + '.' + seriesName);
          ctr.addSeries(new tr.model.CounterSeries(seriesName, colorId));
        }

        if (ctr.numSeries === 0) {
          this.model_.importWarning({
            type: 'counter_parse_error',
            message: 'Expected counter ' + event.name +
                ' to have at least one argument to use as a value.'
          });

          // Drop the counter.
          delete ctr.parent.counters[ctr.name];
          return;
        }
      }

      var ts = timestampFromUs(event.ts);
      ctr.series.forEach(function(series) {
        var val = event.args[series.name] ? event.args[series.name] : 0;
        series.addCounterSample(ts, val);
      });
    },

    processObjectEvent: function(event) {
      var thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      this.allObjectEvents_.push({
        sequenceNumber: this.allObjectEvents_.length,
        event: event,
        thread: thread});
    },

    processDurationEvent: function(event) {
      var thread = this.model_.getOrCreateProcess(event.pid)
        .getOrCreateThread(event.tid);
      var ts = timestampFromUs(event.ts);
      if (!thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'duration_parse_error',
          message: 'Timestamps are moving backward.'
        });
        return;
      }

      if (event.ph == 'B') {
        var slice = thread.sliceGroup.beginSlice(
            event.cat, event.name, timestampFromUs(event.ts),
            this.deepCopyIfNeeded_(event.args),
            timestampFromUs(event.tts), event.argsStripped,
            getEventColor(event));
        slice.startStackFrame = this.getStackFrameForEvent_(event);
      } else if (event.ph == 'I' || event.ph == 'i') {
        if (event.s !== undefined && event.s !== 't')
          throw new Error('This should never happen');

        thread.sliceGroup.beginSlice(event.cat, event.name,
                                     timestampFromUs(event.ts),
                                     this.deepCopyIfNeeded_(event.args),
                                     timestampFromUs(event.tts),
                                     event.argsStripped,
                                     getEventColor(event));
        var slice = thread.sliceGroup.endSlice(timestampFromUs(event.ts),
                                   timestampFromUs(event.tts));
        slice.startStackFrame = this.getStackFrameForEvent_(event);
        slice.endStackFrame = undefined;
      } else {
        if (!thread.sliceGroup.openSliceCount) {
          this.model_.importWarning({
            type: 'duration_parse_error',
            message: 'E phase event without a matching B phase event.'
          });
          return;
        }

        var slice = thread.sliceGroup.endSlice(timestampFromUs(event.ts),
                                               timestampFromUs(event.tts),
                                               getEventColor(event));
        if (event.name && slice.title != event.name) {
          this.model_.importWarning({
            type: 'title_match_error',
            message: 'Titles do not match. Title is ' +
                slice.title + ' in openSlice, and is ' +
                event.name + ' in endSlice'
          });
        }
        slice.endStackFrame = this.getStackFrameForEvent_(event);

        this.mergeArgsInto_(slice.args, event.args, slice.title);
      }
    },

    mergeArgsInto_: function(dstArgs, srcArgs, eventName) {
      for (var arg in srcArgs) {
        if (dstArgs[arg] !== undefined) {
          this.model_.importWarning({
            type: 'arg_merge_error',
            message: 'Different phases of ' + eventName +
                ' provided values for argument ' + arg + '.' +
                ' The last provided value will be used.'
          });
        }
        dstArgs[arg] = this.deepCopyIfNeeded_(srcArgs[arg]);
      }
    },

    processCompleteEvent: function(event) {
      // TODO(fmeawad): Preventing the overhead slices from making it into
      // the model until bug
      // https://github.com/catapult-project/catapult/issues/1469 is addressed.
      if (event.cat.indexOf('trace_event_overhead') > -1)
        return undefined;

      var thread = this.model_.getOrCreateProcess(event.pid)
          .getOrCreateThread(event.tid);

      if (event.flow_out) {
        if (event.flow_in)
          event.flowPhase = STEP;
        else
          event.flowPhase = PRODUCER;
      } else if (event.flow_in) {
        event.flowPhase = CONSUMER;
      }

      var slice = thread.sliceGroup.pushCompleteSlice(event.cat, event.name,
          timestampFromUs(event.ts),
          maybeTimestampFromUs(event.dur),
          maybeTimestampFromUs(event.tts),
          maybeTimestampFromUs(event.tdur),
          this.deepCopyIfNeeded_(event.args),
          event.argsStripped,
          getEventColor(event),
          event.bind_id);
      slice.startStackFrame = this.getStackFrameForEvent_(event);
      slice.endStackFrame = this.getStackFrameForEvent_(event, true);

      return slice;
    },

    processMetadataEvent: function(event) {
      // The metadata events aren't useful without args.
      if (event.argsStripped)
        return;

      if (event.name == 'process_name') {
        var process = this.model_.getOrCreateProcess(event.pid);
        process.name = event.args.name;
      } else if (event.name == 'process_labels') {
        var process = this.model_.getOrCreateProcess(event.pid);
        var labels = event.args.labels.split(',');
        for (var i = 0; i < labels.length; i++)
          process.addLabelIfNeeded(labels[i]);
      } else if (event.name == 'process_sort_index') {
        var process = this.model_.getOrCreateProcess(event.pid);
        process.sortIndex = event.args.sort_index;
      } else if (event.name == 'thread_name') {
        var thread = this.model_.getOrCreateProcess(event.pid).
            getOrCreateThread(event.tid);
        thread.name = event.args.name;
      } else if (event.name == 'thread_sort_index') {
        var thread = this.model_.getOrCreateProcess(event.pid).
            getOrCreateThread(event.tid);
        thread.sortIndex = event.args.sort_index;
      } else if (event.name == 'num_cpus') {
        var n = event.args.number;
        // Not all render processes agree on the cpu count in trace_event. Some
        // processes will report 1, while others will report the actual cpu
        // count. To deal with this, take the max of what is reported.
        if (this.softwareMeasuredCpuCount_ !== undefined)
          n = Math.max(n, this.softwareMeasuredCpuCount_);
        this.softwareMeasuredCpuCount_ = n;
      } else {
        this.model_.importWarning({
          type: 'metadata_parse_error',
          message: 'Unrecognized metadata name: ' + event.name
        });
      }
    },

    processJitCodeEvent: function(event) {
      if (this.v8ProcessCodeMaps_[event.pid] === undefined)
        this.v8ProcessCodeMaps_[event.pid] = new tr.e.importer.v8.CodeMap();
      var map = this.v8ProcessCodeMaps_[event.pid];

      var data = event.args.data;
      var startAddr = parseInt(data.code_start, 16);
      if (event.name === 'JitCodeMoved') {
        try {
          map.moveCode(startAddr, parseInt(data.new_code_start, 16));
        } catch (err) {
          // Ignore moved error. Means we didn't find the original block.
          // We won't know the name if we try to insert the code here.
        }
      } else {
        var entry = new tr.e.importer.TraceCodeEntry(data.code_len, data.name);
        // Hack to get around name de-duplication done by CodeMap::findEntry.
        entry.nameUpdated_ = true;
        map.addCode(startAddr, entry);
      }
    },

    processInstantEvent: function(event) {
      // V8 JIT events are logged as phase 'I' so we need to separate them out
      // and handle specially.
      //
      // TODO(dsinclair): There are _a lot_ of JitCode events so I'm skipping
      // the display for now. Can revisit later if we want to show them.
      if (event.name === 'JitCodeAdded' || event.name === 'JitCodeMoved') {
        this.processJitCodeEvent(event);
        return;
      }

      // Thread-level instant events are treated as zero-duration slices.
      if (event.s == 't' || event.s === undefined) {
        this.processDurationEvent(event);
        return;
      }

      var constructor;
      switch (event.s) {
        case 'g':
          constructor = tr.model.GlobalInstantEvent;
          break;
        case 'p':
          constructor = tr.model.ProcessInstantEvent;
          break;
        default:
          this.model_.importWarning({
            type: 'instant_parse_error',
            message: 'I phase event with unknown "s" field value.'
          });
          return;
      }

      var instantEvent = new constructor(event.cat, event.name,
          getEventColor(event), timestampFromUs(event.ts),
          this.deepCopyIfNeeded_(event.args));

      switch (instantEvent.type) {
        case tr.model.InstantEventType.GLOBAL:
          this.model_.pushInstantEvent(instantEvent);
          break;

        case tr.model.InstantEventType.PROCESS:
          var process = this.model_.getOrCreateProcess(event.pid);
          process.pushInstantEvent(instantEvent);
          break;

        default:
          throw new Error('Unknown instant event type: ' + event.s);
      }
    },

    processV8Sample: function(event) {
      var data = event.args.data;

      // As-per DevTools, the backend sometimes creates bogus samples. Skip it.
      if (data.vm_state === 'js' && !data.stack.length)
        return;

      var rootStackFrame = this.v8ProcessRootStackFrame_[event.pid];
      if (!rootStackFrame) {
        rootStackFrame = new tr.model.StackFrame(
            undefined /* parent */, 'v8-root-stack-frame' /* id */,
            'v8' /* category */, 'v8-root-stack-frame' /* title */,
            0 /* colorId */);
        this.v8ProcessRootStackFrame_[event.pid] = rootStackFrame;
      }

      function findChildWithEntryID(stackFrame, entryID) {
        return tr.b.findFirstInArray(stackFrame.children, function(child) {
          return child.entryID === entryID;
        });
      }

      var model = this.model_;
      function addStackFrame(lastStackFrame, entry) {
        var childFrame = findChildWithEntryID(lastStackFrame, entry.id);
        if (childFrame)
          return childFrame;

        var frame = new tr.model.StackFrame(
            lastStackFrame, tr.b.GUID.allocate(),
            'v8', entry.name,
            tr.ui.b.getColorIdForGeneralPurposeString(entry.name),
            entry.sourceInfo);

        frame.entryID = entry.id;
        model.addStackFrame(frame);
        return frame;
      }

      var lastStackFrame = rootStackFrame;

      // There are several types of v8 sample events, gc, native, compiler, etc.
      // Some of these types have stacks and some don't, we handle those two
      // cases differently. For types that don't have any stack frames attached
      // we synthesize one based on the type of thing that's happening so when
      // we view all the samples we'll see something like 'external' or 'gc'
      // as a fraction of the time spent.
      if (data.stack.length > 0 && this.v8ProcessCodeMaps_[event.pid]) {
        var map = this.v8ProcessCodeMaps_[event.pid];

        // Stacks have the leaf node first, flip them around so the root
        // comes first.
        data.stack.reverse();

        for (var i = 0; i < data.stack.length; i++) {
          var addr = parseInt(data.stack[i], 16);
          var entry = map.findEntry(addr);

          if (entry === null) {
            entry = {
              id: 'unknown',
              name: 'unknown',
              sourceInfo: undefined
            };
          }

          lastStackFrame = addStackFrame(lastStackFrame, entry);
        }
      } else {
        var entry = {
          id: data.vm_state,
          name: data.vm_state,
          sourceInfo: undefined
        };
        lastStackFrame = addStackFrame(lastStackFrame, entry);
      }

      var thread = this.model_.getOrCreateProcess(event.pid)
        .getOrCreateThread(event.tid);

      var sample = new tr.model.Sample(
          undefined /* cpu */, thread, 'V8 Sample',
          timestampFromUs(event.ts), lastStackFrame, 1 /* weight */,
          this.deepCopyIfNeeded_(event.args));
      this.model_.samples.push(sample);
    },

    processTraceSampleEvent: function(event) {
      if (event.name === 'V8Sample') {
        this.processV8Sample(event);
        return;
      }

      var stackFrame = this.getStackFrameForEvent_(event);
      if (stackFrame === undefined) {
        stackFrame = this.traceEventSampleStackFramesByName_[
            event.name];
      }
      if (stackFrame === undefined) {
        var id = 'te-' + tr.b.GUID.allocate();
        stackFrame = new tr.model.StackFrame(
            undefined, id,
            event.cat, event.name,
            tr.ui.b.getColorIdForGeneralPurposeString(event.name));
        this.model_.addStackFrame(stackFrame);
        this.traceEventSampleStackFramesByName_[event.name] = stackFrame;
      }

      var thread = this.model_.getOrCreateProcess(event.pid)
        .getOrCreateThread(event.tid);

      var sample = new tr.model.Sample(
          undefined, thread, 'Trace Event Sample',
          timestampFromUs(event.ts), stackFrame, 1,
          this.deepCopyIfNeeded_(event.args));
      this.model_.samples.push(sample);
    },

    getOrCreateMemoryDumpEvents_: function(dumpId) {
      if (this.allMemoryDumpEvents_[dumpId] === undefined) {
        this.allMemoryDumpEvents_[dumpId] = {
          global: undefined,
          process: []
        };
      }
      return this.allMemoryDumpEvents_[dumpId];
    },

    processMemoryDumpEvent: function(event) {
      if (event.id === undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: event.ph + ' phase event without a dump ID.'
        });
        return;
      }
      var events = this.getOrCreateMemoryDumpEvents_(event.id);

      if (event.ph === 'v') {
        // Add a process memory dump.
        events.process.push(event);
      } else if (event.ph === 'V') {
        // Add a global memory dump (unless already present).
        if (events.global !== undefined) {
          this.model_.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Multiple V phase events with the same dump ID.'
          });
          return;
        }
        events.global = event;
      } else {
        throw new Error('Invalid memory dump event phase "' + event.ph + '".');
      }
    },

    /**
     * Walks through the events_ list and outputs the structures discovered to
     * model_.
     */
    importEvents: function() {
      var csr = new tr.ClockSyncRecord('ftrace_importer', 0, {});
      this.model_.clockSyncRecords.push(csr);
      if (this.stackFrameEvents_)
        this.importStackFrames_();

      if (this.traceAnnotations_)
        this.importAnnotations_();

      var events = this.events_;
      for (var eI = 0; eI < events.length; eI++) {
        var event = events[eI];
        if (event.args === '__stripped__') {
          event.argsStripped = true;
          event.args = undefined;
        }

        if (event.ph === 'B' || event.ph === 'E') {
          this.processDurationEvent(event);

        } else if (event.ph === 'X') {
          var slice = this.processCompleteEvent(event);
          // TODO(yuhaoz): If Chrome supports creating other events with flow,
          // we will need to call processFlowEvent for them also.
          // https://github.com/catapult-project/catapult/issues/1259
          if (slice !== undefined && event.bind_id !== undefined)
            this.processFlowEvent(event, slice);

        } else if (event.ph === 'b' || event.ph === 'e' || event.ph === 'n' ||
                   event.ph === 'S' || event.ph === 'F' || event.ph === 'T' ||
                   event.ph === 'p') {
          this.processAsyncEvent(event);

        // Note, I is historic. The instant event marker got changed, but we
        // want to support loading old trace files so we have both I and i.
        } else if (event.ph == 'I' || event.ph == 'i') {
          this.processInstantEvent(event);

        } else if (event.ph == 'P') {
          this.processTraceSampleEvent(event);

        } else if (event.ph == 'C') {
          this.processCounterEvent(event);

        } else if (event.ph == 'M') {
          this.processMetadataEvent(event);

        } else if (event.ph === 'N' || event.ph === 'D' || event.ph === 'O') {
          this.processObjectEvent(event);

        } else if (event.ph === 's' || event.ph === 't' || event.ph === 'f') {
          this.processFlowEvent(event);

        } else if (event.ph === 'v' || event.ph === 'V') {
          this.processMemoryDumpEvent(event);

        } else {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Unrecognized event phase: ' +
                event.ph + ' (' + event.name + ')'
          });
        }
      }

      // Remove all the root stack frame children as they should
      // already be added.
      tr.b.iterItems(this.v8ProcessRootStackFrame_, function(name, frame) {
        frame.removeAllChildren();
      });
    },

    importStackFrames_: function() {
      var m = this.model_;
      var events = this.stackFrameEvents_;

      for (var id in events) {
        var event = events[id];
        var textForColor = event.category ? event.category : event.name;
        var frame = new tr.model.StackFrame(
            undefined, 'g' + id,
            event.category, event.name,
            tr.ui.b.getColorIdForGeneralPurposeString(textForColor));
        m.addStackFrame(frame);
      }
      for (var id in events) {
        var event = events[id];
        if (event.parent === undefined)
          continue;

        var frame = m.stackFrames['g' + id];
        if (frame === undefined)
          throw new Error('omg');
        var parentFrame;
        if (event.parent === undefined) {
          parentFrame = undefined;
        } else {
          parentFrame = m.stackFrames['g' + event.parent];
          if (parentFrame === undefined)
            throw new Error('omg');
        }
        frame.parentFrame = parentFrame;
      }
    },

    importAnnotations_: function() {
      for (var id in this.traceAnnotations_) {
        var annotation = tr.model.Annotation.fromDictIfPossible(
           this.traceAnnotations_[id]);
        if (!annotation) {
          this.model_.importWarning({
            type: 'annotation_warning',
            message: 'Unrecognized traceAnnotation typeName \"' +
                this.traceAnnotations_[id].typeName + '\"'
          });
          continue;
        }
        this.model_.addAnnotation(annotation);
      }
    },

    /**
     * Called by the Model after all other importers have imported their
     * events.
     */
    finalizeImport: function() {
      if (this.softwareMeasuredCpuCount_ !== undefined) {
        this.model_.kernel.softwareMeasuredCpuCount =
            this.softwareMeasuredCpuCount_;
      }
      this.createAsyncSlices_();
      this.createFlowSlices_();
      this.createExplicitObjects_();
      this.createImplicitObjects_();
      this.createMemoryDumps_();
    },

    /* Events can have one or more stack frames associated with them, but
     * that frame might be encoded either as a stack trace of program counters,
     * or as a direct stack frame reference. This handles either case and
     * if found, returns the stackframe.
     */
    getStackFrameForEvent_: function(event, opt_lookForEndEvent) {
      var sf;
      var stack;
      if (opt_lookForEndEvent) {
        sf = event.esf;
        stack = event.estack;
      } else {
        sf = event.sf;
        stack = event.stack;
      }
      if (stack !== undefined && sf !== undefined) {
        this.model_.importWarning({
          type: 'stack_frame_and_stack_error',
          message: 'Event at ' + event.ts +
              ' cannot have both a stack and a stackframe.'
        });
        return undefined;
      }

      if (stack !== undefined)
        return this.model_.resolveStackToStackFrame_(event.pid, stack);
      if (sf === undefined)
        return undefined;

      var stackFrame = this.model_.stackFrames['g' + sf];
      if (stackFrame === undefined) {
        this.model_.importWarning({
          type: 'sample_import_error',
          message: 'No frame for ' + sf
        });
        return;
      }
      return stackFrame;
    },

    resolveStackToStackFrame_: function(pid, stack) {
      // TODO(alph,fmeawad): Add codemap resolution code here.
      return undefined;
    },

    importSampleData: function() {
      if (!this.sampleEvents_)
        return;
      var m = this.model_;

      // If this is the only importer, then fake-create the threads.
      var events = this.sampleEvents_;
      if (this.events_.length === 0) {
        for (var i = 0; i < events.length; i++) {
          var event = events[i];
          m.getOrCreateProcess(event.tid).getOrCreateThread(event.tid);
        }
      }

      var threadsByTid = {};
      m.getAllThreads().forEach(function(t) {
        threadsByTid[t.tid] = t;
      });

      for (var i = 0; i < events.length; i++) {
        var event = events[i];
        var thread = threadsByTid[event.tid];
        if (thread === undefined) {
          m.importWarning({
            type: 'sample_import_error',
            message: 'Thread ' + events.tid + 'not found'
          });
          continue;
        }

        var cpu;
        if (event.cpu !== undefined)
          cpu = m.kernel.getOrCreateCpu(event.cpu);

        var stackFrame = this.getStackFrameForEvent_(event);

        var sample = new tr.model.Sample(
            cpu, thread,
            event.name,
            timestampFromUs(event.ts),
            stackFrame,
            event.weight);
        m.samples.push(sample);
      }
    },

    /**
     * Called by the model to join references between objects, after final model
     * bounds have been computed.
     */
    joinRefs: function() {
      this.joinObjectRefs_();
    },

    createAsyncSlices_: function() {
      if (this.allAsyncEvents_.length === 0)
        return;

      this.allAsyncEvents_.sort(function(x, y) {
        var d = x.event.ts - y.event.ts;
        if (d !== 0)
          return d;
        return x.sequenceNumber - y.sequenceNumber;
      });

      var legacyEvents = [];
      // Group nestable async events by ID. Events with the same ID should
      // belong to the same parent async event.
      var nestableAsyncEventsByKey = {};
      for (var i = 0; i < this.allAsyncEvents_.length; i++) {
        var asyncEventState = this.allAsyncEvents_[i];
        var event = asyncEventState.event;
        if (event.ph === 'S' || event.ph === 'F' || event.ph === 'T' ||
            event.ph === 'p') {
          legacyEvents.push(asyncEventState);
          continue;
        }
        if (event.cat === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Nestable async events (ph: b, e, or n) require a ' +
                'cat parameter.'
          });
          continue;
        }

        if (event.name === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Nestable async events (ph: b, e, or n) require a ' +
                'name parameter.'
          });
          continue;
        }

        if (event.id === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Nestable async events (ph: b, e, or n) require an ' +
                'id parameter.'
          });
          continue;
        }
        var key = event.cat + ':' + event.id;
        if (nestableAsyncEventsByKey[key] === undefined)
           nestableAsyncEventsByKey[key] = [];
        nestableAsyncEventsByKey[key].push(asyncEventState);
      }
      // Handle legacy async events.
      this.createLegacyAsyncSlices_(legacyEvents);

      // Parse nestable async events into AsyncSlices.
      for (var key in nestableAsyncEventsByKey) {
        var eventStateEntries = nestableAsyncEventsByKey[key];
        // Stack of enclosing BEGIN events.
        var parentStack = [];
        for (var i = 0; i < eventStateEntries.length; ++i) {
          var eventStateEntry = eventStateEntries[i];
          // If this is the end of an event, match it to the start.
          if (eventStateEntry.event.ph === 'e') {
            // Walk up the parent stack to find the corresponding BEGIN for
            // this END.
            var parentIndex = -1;
            for (var k = parentStack.length - 1; k >= 0; --k) {
              if (parentStack[k].event.name === eventStateEntry.event.name) {
                parentIndex = k;
                break;
              }
            }
            if (parentIndex === -1) {
              // Unmatched end.
              eventStateEntry.finished = false;
            } else {
              parentStack[parentIndex].end = eventStateEntry;
              // Pop off all enclosing unmatched BEGINs util parentIndex.
              while (parentIndex < parentStack.length) {
                parentStack.pop();
              }
            }
          }
          // Inherit the current parent.
          if (parentStack.length > 0)
            eventStateEntry.parentEntry = parentStack[parentStack.length - 1];
          if (eventStateEntry.event.ph === 'b')
            parentStack.push(eventStateEntry);
        }
        var topLevelSlices = [];
        for (var i = 0; i < eventStateEntries.length; ++i) {
          var eventStateEntry = eventStateEntries[i];
          // Skip matched END, as its slice will be created when we
          // encounter its corresponding BEGIN.
          if (eventStateEntry.event.ph === 'e' &&
              eventStateEntry.finished === undefined) {
            continue;
          }
          var startState = undefined;
          var endState = undefined;
          var sliceArgs = eventStateEntry.event.args || {};
          var sliceError = undefined;
          if (eventStateEntry.event.ph === 'n') {
            startState = eventStateEntry;
            endState = eventStateEntry;
          } else if (eventStateEntry.event.ph === 'b') {
            if (eventStateEntry.end === undefined) {
              // Unmatched BEGIN. End it when last event with this ID ends.
              eventStateEntry.end =
                  eventStateEntries[eventStateEntries.length - 1];
              sliceError =
                  'Slice has no matching END. End time has been adjusted.';
              this.model_.importWarning({
                type: 'async_slice_parse_error',
                message: 'Nestable async BEGIN event at ' +
                    eventStateEntry.event.ts + ' with name=' +
                    eventStateEntry.event.name +
                    ' and id=' + eventStateEntry.event.id + ' was unmatched.'
              });
            } else {
              // Include args for both END and BEGIN for a matched pair.
              function concatenateArguments(args1, args2) {
                if (args1.params === undefined || args2.params === undefined)
                  return tr.b.concatenateObjects(args1, args2);
                // Make an argument object to hold the combined params.
                var args3 = {};
                args3.params = tr.b.concatenateObjects(args1.params,
                                                       args2.params);
                return tr.b.concatenateObjects(args1, args2, args3);
              }
              var endArgs = eventStateEntry.end.event.args || {};
              sliceArgs = concatenateArguments(sliceArgs, endArgs);
            }
            startState = eventStateEntry;
            endState = eventStateEntry.end;
          } else {
            // Unmatched END. Start it at the first event with this ID starts.
            sliceError =
                'Slice has no matching BEGIN. Start time has been adjusted.';
            this.model_.importWarning({
              type: 'async_slice_parse_error',
              message: 'Nestable async END event at ' +
                  eventStateEntry.event.ts + ' with name=' +
                  eventStateEntry.event.name +
                  ' and id=' + eventStateEntry.event.id + ' was unmatched.'
            });
            startState = eventStateEntries[0];
            endState = eventStateEntry;
          }

          var isTopLevel = (eventStateEntry.parentEntry === undefined);
          var asyncSliceConstructor =
             tr.model.AsyncSlice.getConstructor(
                eventStateEntry.event.cat,
                eventStateEntry.event.name);

          var thread_start = undefined;
          var thread_duration = undefined;
          if (startState.event.tts && startState.event.use_async_tts) {
            thread_start = timestampFromUs(startState.event.tts);
            if (endState.event.tts) {
              var thread_end = timestampFromUs(endState.event.tts);
              thread_duration = thread_end - thread_start;
            }
          }

          var slice = new asyncSliceConstructor(
              eventStateEntry.event.cat,
              eventStateEntry.event.name,
              getEventColor(endState.event),
              timestampFromUs(startState.event.ts),
              sliceArgs,
              timestampFromUs(endState.event.ts - startState.event.ts),
              isTopLevel,
              thread_start,
              thread_duration,
              startState.event.argsStripped);

          slice.startThread = startState.thread;
          slice.endThread = endState.thread;

          slice.startStackFrame = this.getStackFrameForEvent_(startState.event);
          slice.endStackFrame = this.getStackFrameForEvent_(endState.event);

          slice.id = key;
          if (sliceError !== undefined)
            slice.error = sliceError;
          eventStateEntry.slice = slice;
          // Add the slice to the topLevelSlices array if there is no parent.
          // Otherwise, add the slice to the subSlices of its parent.
          if (isTopLevel) {
            topLevelSlices.push(slice);
          } else if (eventStateEntry.parentEntry.slice !== undefined) {
            eventStateEntry.parentEntry.slice.subSlices.push(slice);
          }
        }
        for (var si = 0; si < topLevelSlices.length; si++) {
          topLevelSlices[si].startThread.asyncSliceGroup.push(
              topLevelSlices[si]);
        }
      }
    },

    createLegacyAsyncSlices_: function(legacyEvents) {
      if (legacyEvents.length === 0)
        return;

      legacyEvents.sort(function(x, y) {
        var d = x.event.ts - y.event.ts;
        if (d != 0)
          return d;
        return x.sequenceNumber - y.sequenceNumber;
      });

      var asyncEventStatesByNameThenID = {};

      for (var i = 0; i < legacyEvents.length; i++) {
        var asyncEventState = legacyEvents[i];

        var event = asyncEventState.event;
        var name = event.name;
        if (name === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Async events (ph: S, T, p, or F) require a name ' +
                ' parameter.'
          });
          continue;
        }

        var id = event.id;
        if (id === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Async events (ph: S, T, p, or F) require an id parameter.'
          });
          continue;
        }

        // TODO(simonjam): Add a synchronous tick on the appropriate thread.

        if (event.ph === 'S') {
          if (asyncEventStatesByNameThenID[name] === undefined)
            asyncEventStatesByNameThenID[name] = {};
          if (asyncEventStatesByNameThenID[name][id]) {
            this.model_.importWarning({
              type: 'async_slice_parse_error',
              message: 'At ' + event.ts + ', a slice of the same id ' + id +
                  ' was alrady open.'
            });
            continue;
          }
          asyncEventStatesByNameThenID[name][id] = [];
          asyncEventStatesByNameThenID[name][id].push(asyncEventState);
        } else {
          if (asyncEventStatesByNameThenID[name] === undefined) {
            this.model_.importWarning({
              type: 'async_slice_parse_error',
              message: 'At ' + event.ts + ', no slice named ' + name +
                  ' was open.'
            });
            continue;
          }
          if (asyncEventStatesByNameThenID[name][id] === undefined) {
            this.model_.importWarning({
              type: 'async_slice_parse_error',
              message: 'At ' + event.ts + ', no slice named ' + name +
                  ' with id=' + id + ' was open.'
            });
            continue;
          }
          var events = asyncEventStatesByNameThenID[name][id];
          events.push(asyncEventState);

          if (event.ph === 'F') {
            // Create a slice from start to end.
            var asyncSliceConstructor =
               tr.model.AsyncSlice.getConstructor(
                  events[0].event.cat,
                  name);
            var slice = new asyncSliceConstructor(
                events[0].event.cat,
                name,
                getEventColor(events[0].event),
                timestampFromUs(events[0].event.ts),
                tr.b.concatenateObjects(events[0].event.args,
                                      events[events.length - 1].event.args),
                timestampFromUs(event.ts - events[0].event.ts),
                true, undefined, undefined, events[0].event.argsStripped);
            slice.startThread = events[0].thread;
            slice.endThread = asyncEventState.thread;
            slice.id = id;

            var stepType = events[1].event.ph;
            var isValid = true;

            // Create subSlices for each step. Skip the start and finish events,
            // which are always first and last respectively.
            for (var j = 1; j < events.length - 1; ++j) {
              if (events[j].event.ph === 'T' || events[j].event.ph === 'p') {
                isValid = this.assertStepTypeMatches_(stepType, events[j]);
                if (!isValid)
                  break;
              }

              if (events[j].event.ph === 'S') {
                this.model_.importWarning({
                  type: 'async_slice_parse_error',
                  message: 'At ' + event.event.ts + ', a slice named ' +
                      event.event.name + ' with id=' + event.event.id +
                      ' had a step before the start event.'
                });
                continue;
              }

              if (events[j].event.ph === 'F') {
                this.model_.importWarning({
                  type: 'async_slice_parse_error',
                  message: 'At ' + event.event.ts + ', a slice named ' +
                      event.event.name + ' with id=' + event.event.id +
                      ' had a step after the finish event.'
                });
                continue;
              }

              var startIndex = j + (stepType === 'T' ? 0 : -1);
              var endIndex = startIndex + 1;

              var subName = events[j].event.name;
              if (!events[j].event.argsStripped &&
                  (events[j].event.ph === 'T' || events[j].event.ph === 'p'))
                subName = subName + ':' + events[j].event.args.step;

              var asyncSliceConstructor =
                 tr.model.AsyncSlice.getConstructor(
                    events[0].event.cat,
                    subName);
              var subSlice = new asyncSliceConstructor(
                  events[0].event.cat,
                  subName,
                  getEventColor(event, subName + j),
                  timestampFromUs(events[startIndex].event.ts),
                  this.deepCopyIfNeeded_(events[j].event.args),
                  timestampFromUs(
                    events[endIndex].event.ts - events[startIndex].event.ts),
                      undefined, undefined,
                      events[startIndex].event.argsStripped);
              subSlice.startThread = events[startIndex].thread;
              subSlice.endThread = events[endIndex].thread;
              subSlice.id = id;

              slice.subSlices.push(subSlice);
            }

            if (isValid) {
              // Add |slice| to the start-thread's asyncSlices.
              slice.startThread.asyncSliceGroup.push(slice);
            }

            delete asyncEventStatesByNameThenID[name][id];
          }
        }
      }
    },

    assertStepTypeMatches_: function(stepType, event) {
      if (stepType != event.event.ph) {
        this.model_.importWarning({
          type: 'async_slice_parse_error',
          message: 'At ' + event.event.ts + ', a slice named ' +
              event.event.name + ' with id=' + event.event.id +
              ' had both begin and end steps, which is not allowed.'
        });
        return false;
      }
      return true;
    },

    createFlowSlices_: function() {
      if (this.allFlowEvents_.length === 0)
        return;

      var that = this;

      function validateFlowEvent() {
        if (event.name === undefined) {
          that.model_.importWarning({
            type: 'flow_slice_parse_error',
            message: 'Flow events (ph: s, t or f) require a name parameter.'
          });
          return false;
        }

        // Support Flow API v1.
        if (event.ph === 's' || event.ph === 'f' || event.ph === 't') {
          if (event.id === undefined) {
            that.model_.importWarning({
              type: 'flow_slice_parse_error',
              message: 'Flow events (ph: s, t or f) require an id parameter.'
            });
            return false;
          }
          return true;
        }

        // Support Flow API v2.
        if (event.bind_id) {
          if (event.flow_in === undefined && event.flow_out === undefined) {
            that.model_.importWarning({
              type: 'flow_slice_parse_error',
              message: 'Flow producer or consumer require flow_in or flow_out.'
            });
            return false;
          }
          return true;
        }

        return false;
      }

      function createFlowEvent(thread, event, opt_slice) {
        var startSlice, flowId, flowStartTs;

        if (event.bind_id) {
          // Support Flow API v2.
          startSlice = opt_slice;
          flowId = event.bind_id;
          flowStartTs = timestampFromUs(event.ts + event.dur);
        } else {
          // Support Flow API v1.
          var ts = timestampFromUs(event.ts);
          startSlice = thread.sliceGroup.findSliceAtTs(ts);
          if (startSlice === undefined)
            return undefined;
          flowId = event.id;
          flowStartTs = ts;
        }

        var flowEvent = new tr.model.FlowEvent(
            event.cat,
            flowId,
            event.name,
            getEventColor(event),
            flowStartTs,
            that.deepCopyAlways_(event.args));
        flowEvent.startSlice = startSlice;
        flowEvent.startStackFrame = that.getStackFrameForEvent_(event);
        flowEvent.endStackFrame = undefined;
        startSlice.outFlowEvents.push(flowEvent);
        return flowEvent;
      }

      function finishFlowEventWith(flowEvent, thread, event,
                                   refGuid, bindToParent, opt_slice) {
        var endSlice;

        if (event.bind_id) {
          // Support Flow API v2.
          endSlice = opt_slice;
        } else {
          // Support Flow API v1.
          var ts = timestampFromUs(event.ts);
          if (bindToParent) {
            endSlice = thread.sliceGroup.findSliceAtTs(ts);
          } else {
            endSlice = thread.sliceGroup.findNextSliceAfter(ts, refGuid);
          }
          if (endSlice === undefined)
            return false;
        }

        endSlice.inFlowEvents.push(flowEvent);
        flowEvent.endSlice = endSlice;
        flowEvent.duration = timestampFromUs(event.ts) - flowEvent.start;
        flowEvent.endStackFrame = that.getStackFrameForEvent_(event);
        that.mergeArgsInto_(flowEvent.args, event.args, flowEvent.title);
        return true;
      }

      function processFlowConsumer(flowIdToEvent, sliceGuidToEvent, event,
          slice) {
        var flowEvent = flowIdToEvent[event.bind_id];
        if (flowEvent === undefined) {
          that.model_.importWarning({
              type: 'flow_slice_ordering_error',
              message: 'Flow consumer ' + event.bind_id + ' does not have ' +
                  'a flow producer'});
          return false;
        } else if (flowEvent.endSlice) {
          // One flow producer can have more than one flow consumers.
          // In this case, create a new flow event using the flow producer.
          var flowProducer = flowEvent.startSlice;
          flowEvent = createFlowEvent(undefined,
              sliceGuidToEvent[flowProducer.guid], flowProducer);
        }

        var ok = finishFlowEventWith(flowEvent, undefined, event,
                                     refGuid, undefined, slice);
        if (ok) {
          that.model_.flowEvents.push(flowEvent);
        } else {
          that.model_.importWarning({
              type: 'flow_slice_end_error',
              message: 'Flow consumer ' + event.bind_id + ' does not end ' +
                  'at an actual slice, so cannot be created.'});
          return false;
        }

        return true;
      }

      function processFlowProducer(flowIdToEvent, flowStatus, event, slice) {
        if (flowIdToEvent[event.bind_id] &&
            flowStatus[event.bind_id]) {
          // Can't open the same flow again while it's still open.
          // This is essentially the multi-producer case which we don't support
          that.model_.importWarning({
              type: 'flow_slice_start_error',
              message: 'Flow producer ' + event.bind_id + ' already seen'});
          return false;
        }

        var flowEvent = createFlowEvent(undefined, event, slice);
        if (!flowEvent) {
          that.model_.importWarning({
              type: 'flow_slice_start_error',
              message: 'Flow producer ' + event.bind_id + ' does not start' +
                  'a flow'});
          return false;
        }
        flowIdToEvent[event.bind_id] = flowEvent;

        return;
      }

      // Actual import.
      this.allFlowEvents_.sort(function(x, y) {
        var d = x.event.ts - y.event.ts;
        if (d != 0)
          return d;
        return x.sequenceNumber - y.sequenceNumber;
      });

      var flowIdToEvent = {};
      var sliceGuidToEvent = {};
      var flowStatus = {}; // true: open; false: closed.
      for (var i = 0; i < this.allFlowEvents_.length; ++i) {
        var data = this.allFlowEvents_[i];
        var refGuid = data.refGuid;
        var event = data.event;
        var thread = data.thread;
        if (!validateFlowEvent(event))
          continue;

        // Support for Flow API v2.
        if (event.bind_id) {
          var slice = data.slice;
          sliceGuidToEvent[slice.guid] = event;

          if (event.flowPhase === PRODUCER) {
            if (!processFlowProducer(flowIdToEvent, flowStatus, event, slice))
              continue;
            flowStatus[event.bind_id] = true; // open the flow.
          }
          else {
            if (!processFlowConsumer(flowIdToEvent, sliceGuidToEvent,
                event, slice))
              continue;
            flowStatus[event.bind_id] = false; // close the flow.

            if (event.flowPhase === STEP) {
              if (!processFlowProducer(flowIdToEvent, flowStatus,
                  event, slice))
                continue;
              flowStatus[event.bind_id] = true; // open the flow again.
            }
          }
          continue;
        }

        // Support for Flow API v1.
        var flowEvent;
        if (event.ph === 's') {
          if (flowIdToEvent[event.id]) {
            this.model_.importWarning({
              type: 'flow_slice_start_error',
              message: 'event id ' + event.id + ' already seen when ' +
                  'encountering start of flow event.'});
            continue;
          }
          flowEvent = createFlowEvent(thread, event);
          if (!flowEvent) {
            this.model_.importWarning({
              type: 'flow_slice_start_error',
              message: 'event id ' + event.id + ' does not start ' +
                  'at an actual slice, so cannot be created.'});
            continue;
          }
          flowIdToEvent[event.id] = flowEvent;

        } else if (event.ph === 't' || event.ph === 'f') {
          flowEvent = flowIdToEvent[event.id];
          if (flowEvent === undefined) {
            this.model_.importWarning({
              type: 'flow_slice_ordering_error',
              message: 'Found flow phase ' + event.ph + ' for id: ' + event.id +
                  ' but no flow start found.'
            });
            continue;
          }

          var bindToParent = event.ph === 't';

          if (event.ph === 'f') {
            if (event.bp === undefined) {
              // TODO(yuhaoz): In flow V2, there is no notion of binding point.
              // Removal of binding point is tracked in
              // https://github.com/google/trace-viewer/issues/991.
              if (event.cat.indexOf('input') > -1)
                bindToParent = true;
              else if (event.cat.indexOf('ipc.flow') > -1)
                bindToParent = true;
            } else {
              if (event.bp !== 'e') {
                this.model_.importWarning({
                 type: 'flow_slice_bind_point_error',
                 message: 'Flow event with invalid binding point (event.bp).'
                });
                continue;
              }
              bindToParent = true;
            }
          }

          var ok = finishFlowEventWith(flowEvent, thread, event,
                                       refGuid, bindToParent);
          if (ok) {
            that.model_.flowEvents.push(flowEvent);
          } else {
            this.model_.importWarning({
              type: 'flow_slice_end_error',
              message: 'event id ' + event.id + ' does not end ' +
                  'at an actual slice, so cannot be created.'});
          }
          flowIdToEvent[event.id] = undefined;

          // If this is a step, then create another flow event.
          if (ok && event.ph === 't') {
            flowEvent = createFlowEvent(thread, event);
            flowIdToEvent[event.id] = flowEvent;
          }
        }
      }
    },

    /**
     * This function creates objects described via the N, D, and O phase
     * events.
     */
    createExplicitObjects_: function() {
      if (this.allObjectEvents_.length == 0)
        return;

      function processEvent(objectEventState) {
        var event = objectEventState.event;
        var thread = objectEventState.thread;
        if (event.name === undefined) {
          this.model_.importWarning({
            type: 'object_parse_error',
            message: 'While processing ' + JSON.stringify(event) + ': ' +
                'Object events require an name parameter.'
          });
        }

        if (event.id === undefined) {
          this.model_.importWarning({
            type: 'object_parse_error',
            message: 'While processing ' + JSON.stringify(event) + ': ' +
                'Object events require an id parameter.'
          });
        }
        var process = thread.parent;
        var ts = timestampFromUs(event.ts);
        var instance;
        if (event.ph == 'N') {
          try {
            instance = process.objects.idWasCreated(
                event.id, event.cat, event.name, ts);
          } catch (e) {
            this.model_.importWarning({
              type: 'object_parse_error',
              message: 'While processing create of ' +
                  event.id + ' at ts=' + ts + ': ' + e
            });
            return;
          }
        } else if (event.ph == 'O') {
          if (event.args.snapshot === undefined) {
            this.model_.importWarning({
              type: 'object_parse_error',
              message: 'While processing ' + event.id + ' at ts=' + ts + ': ' +
                  'Snapshots must have args: {snapshot: ...}'
            });
            return;
          }
          var snapshot;
          try {
            var args = this.deepCopyIfNeeded_(event.args.snapshot);
            var cat;
            if (args.cat) {
              cat = args.cat;
              delete args.cat;
            } else {
              cat = event.cat;
            }

            var baseTypename;
            if (args.base_type) {
              baseTypename = args.base_type;
              delete args.base_type;
            } else {
              baseTypename = undefined;
            }
            snapshot = process.objects.addSnapshot(
                event.id, cat, event.name, ts,
                args, baseTypename);
            snapshot.snapshottedOnThread = thread;
          } catch (e) {
            this.model_.importWarning({
              type: 'object_parse_error',
              message: 'While processing snapshot of ' +
                  event.id + ' at ts=' + ts + ': ' + e
            });
            return;
          }
          instance = snapshot.objectInstance;
        } else if (event.ph == 'D') {
          try {
            process.objects.idWasDeleted(event.id, event.cat, event.name, ts);
            var instanceMap = process.objects.getOrCreateInstanceMap_(event.id);
            instance = instanceMap.lastInstance;
          } catch (e) {
            this.model_.importWarning({
              type: 'object_parse_error',
              message: 'While processing delete of ' +
                  event.id + ' at ts=' + ts + ': ' + e
            });
            return;
          }
        }

        if (instance)
          instance.colorId = getEventColor(event, instance.typeName);
      }

      this.allObjectEvents_.sort(function(x, y) {
        var d = x.event.ts - y.event.ts;
        if (d != 0)
          return d;
        return x.sequenceNumber - y.sequenceNumber;
      });

      var allObjectEvents = this.allObjectEvents_;
      for (var i = 0; i < allObjectEvents.length; i++) {
        var objectEventState = allObjectEvents[i];
        try {
          processEvent.call(this, objectEventState);
        } catch (e) {
          this.model_.importWarning({
            type: 'object_parse_error',
            message: e.message
          });
        }
      }
    },

    createImplicitObjects_: function() {
      tr.b.iterItems(this.model_.processes, function(pid, process) {
        this.createImplicitObjectsForProcess_(process);
      }, this);
    },

    // Here, we collect all the snapshots that internally contain a
    // Javascript-level object inside their args list that has an "id" field,
    // and turn that into a snapshot of the instance referred to by id.
    createImplicitObjectsForProcess_: function(process) {

      function processField(referencingObject,
                            referencingObjectFieldName,
                            referencingObjectFieldValue,
                            containingSnapshot) {
        if (!referencingObjectFieldValue)
          return;

        if (referencingObjectFieldValue instanceof
            tr.model.ObjectSnapshot)
          return null;
        if (referencingObjectFieldValue.id === undefined)
          return;

        var implicitSnapshot = referencingObjectFieldValue;

        var rawId = implicitSnapshot.id;
        var m = /(.+)\/(.+)/.exec(rawId);
        if (!m)
          throw new Error('Implicit snapshots must have names.');
        delete implicitSnapshot.id;
        var name = m[1];
        var id = m[2];
        var res;

        var cat;
        if (implicitSnapshot.cat !== undefined)
          cat = implicitSnapshot.cat;
        else
          cat = containingSnapshot.objectInstance.category;

        var baseTypename;
        if (implicitSnapshot.base_type)
          baseTypename = implicitSnapshot.base_type;
        else
          baseTypename = undefined;

        try {
          res = process.objects.addSnapshot(
              id, cat,
              name, containingSnapshot.ts,
              implicitSnapshot, baseTypename);
        } catch (e) {
          this.model_.importWarning({
            type: 'object_snapshot_parse_error',
            message: 'While processing implicit snapshot of ' +
                rawId + ' at ts=' + containingSnapshot.ts + ': ' + e
          });
          return;
        }
        res.objectInstance.hasImplicitSnapshots = true;
        res.containingSnapshot = containingSnapshot;
        res.snapshottedOnThread = containingSnapshot.snapshottedOnThread;
        referencingObject[referencingObjectFieldName] = res;
        if (!(res instanceof tr.model.ObjectSnapshot))
          throw new Error('Created object must be instanceof snapshot');
        return res.args;
      }

      /**
       * Iterates over the fields in the object, calling func for every
       * field/value found.
       *
       * @return {object} If the function does not want the field's value to be
       * iterated, return null. If iteration of the field value is desired, then
       * return either undefined (if the field value did not change) or the new
       * field value if it was changed.
       */
      function iterObject(object, func, containingSnapshot, thisArg) {
        if (!(object instanceof Object))
          return;

        if (object instanceof Array) {
          for (var i = 0; i < object.length; i++) {
            var res = func.call(thisArg, object, i, object[i],
                                containingSnapshot);
            if (res === null)
              continue;
            if (res)
              iterObject(res, func, containingSnapshot, thisArg);
            else
              iterObject(object[i], func, containingSnapshot, thisArg);
          }
          return;
        }

        for (var key in object) {
          var res = func.call(thisArg, object, key, object[key],
                              containingSnapshot);
          if (res === null)
            continue;
          if (res)
            iterObject(res, func, containingSnapshot, thisArg);
          else
            iterObject(object[key], func, containingSnapshot, thisArg);
        }
      }

      // TODO(nduca): We may need to iterate the instances in sorted order by
      // creationTs.
      process.objects.iterObjectInstances(function(instance) {
        instance.snapshots.forEach(function(snapshot) {
          if (snapshot.args.id !== undefined)
            throw new Error('args cannot have an id field inside it');
          iterObject(snapshot.args, processField, snapshot, this);
        }, this);
      }, this);
    },

    createMemoryDumps_: function() {
      tr.b.iterItems(this.allMemoryDumpEvents_, function(id, events) {
        // Calculate the range of the global memory dump.
        var range = new tr.b.Range();
        if (events.global !== undefined)
          range.addValue(timestampFromUs(events.global.ts));
        for (var i = 0; i < events.process.length; i++)
          range.addValue(timestampFromUs(events.process[i].ts));

        // Create the global memory dump.
        var globalMemoryDump = new tr.model.GlobalMemoryDump(
            this.model_, range.min);
        globalMemoryDump.duration = range.range;
        this.model_.globalMemoryDumps.push(globalMemoryDump);

        // Create individual process memory dumps.
        if (events.process.length === 0) {
          this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'No process memory dumps associated with global memory' +
                  ' dump ' + id + '.'
          });
        }

        var allMemoryAllocatorDumpsByGuid = {};
        var globalMemoryAllocatorDumpsByFullName = {};

        var LEVELS_OF_DETAIL = [undefined, 'light', 'detailed'];
        var globalLevelOfDetailIndex = undefined;

        events.process.forEach(function(processEvent) {
          var pid = processEvent.pid;
          if (pid in globalMemoryDump.processMemoryDumps) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'Multiple process memory dumps with pid=' + pid +
                  ' for dump id ' + id + '.'
            });
            return;
          }

          var dumps = processEvent.args.dumps;
          if (dumps === undefined) {
            this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'dumps not found in process memory dump for ' +
                    'pid=' + pid + ' and dump id=' + id + '.'
            });
            return;
          }

          var process = this.model_.getOrCreateProcess(pid);
          var processMemoryDump = new tr.model.ProcessMemoryDump(
              globalMemoryDump, process,
              timestampFromUs(processEvent.ts));

          // Determine the level of detail of the dump.
          var processLevelOfDetail = dumps.level_of_detail;
          var processLevelOfDetailIndex = LEVELS_OF_DETAIL.indexOf(
              processLevelOfDetail);
          if (processLevelOfDetailIndex < 0) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'unknown level of detail \'' + processLevelOfDetail +
                  '\' of process memory dump for pid=' + pid +
                  ' and dump id=' + id + '.'
            });
          } else {
            processMemoryDump.levelOfDetail = processLevelOfDetail;
            if (globalLevelOfDetailIndex === undefined) {
              globalLevelOfDetailIndex = processLevelOfDetailIndex;
            } else if (globalLevelOfDetailIndex !== processLevelOfDetailIndex) {
              // If the process memory dumps have different levels of detail,
              // show a warning and use the highest level.
              this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'diffent levels of detail of process memory dumps ' +
                    'for dump id=' + id + '.'
              });
              globalLevelOfDetailIndex = Math.max(
                  globalLevelOfDetailIndex, processLevelOfDetailIndex);
            }
          }

          // Parse the totals.
          var rawTotals = dumps.process_totals;
          if (rawTotals !== undefined) {
            processMemoryDump.totals = {};

            // Total resident bytes (mandatory).
            if (rawTotals.resident_set_bytes !== undefined) {
              processMemoryDump.totals.residentBytes = parseInt(
                  rawTotals.resident_set_bytes, 16);
            }

            // Peak resident bytes (optional).
            if (rawTotals.peak_resident_set_bytes !== undefined) {
              if (rawTotals.is_peak_rss_resetable === undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Optional field peak_resident_set_bytes found' +
                        ' but is_peak_rss_resetable not found in' +
                        ' process memory dump for pid=' + pid +
                        ' and dump id=' + id + '.'
                });
              }
              processMemoryDump.totals.peakResidentBytes = parseInt(
                  rawTotals.peak_resident_set_bytes, 16);
            }
            if (rawTotals.is_peak_rss_resetable !== undefined) {
              if (rawTotals.peak_resident_set_bytes === undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Optional field is_peak_rss_resetable found' +
                        ' but peak_resident_set_bytes not found in' +
                        ' process memory dump for pid=' + pid +
                        ' and dump id=' + id + '.'
                });
              }
              processMemoryDump.totals.arePeakResidentBytesResettable =
                  !!rawTotals.is_peak_rss_resetable;
            }
          }
          if (processMemoryDump.totals === undefined ||
              processMemoryDump.totals.residentBytes === undefined) {
            this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'Mandatory field resident_set_bytes not found in' +
                    ' process memory dump for pid=' + pid +
                    ' and dump id=' + id + '.'
            });
          }

          // Populate the vmRegions, if present.
          if (dumps.process_mmaps && dumps.process_mmaps.vm_regions) {
            function parseByteStat(rawValue) {
              if (rawValue === undefined)
                return undefined;
              return parseInt(rawValue, 16);
            }

            processMemoryDump.vmRegions = dumps.process_mmaps.vm_regions.map(
              function(rawRegion) {
                // See //base/trace_event/process_memory_maps.cc in Chromium.
                var byteStats = new tr.model.VMRegionByteStats(
                  parseByteStat(rawRegion.bs.pc),
                  parseByteStat(rawRegion.bs.pd),
                  parseByteStat(rawRegion.bs.sc),
                  parseByteStat(rawRegion.bs.sd),
                  parseByteStat(rawRegion.bs.pss),
                  parseByteStat(rawRegion.bs.sw)
                );
                return new tr.model.VMRegion(
                    parseInt(rawRegion.sa, 16),  // startAddress
                    parseInt(rawRegion.sz, 16),  // sizeInBytes
                    rawRegion.pf,  // protectionFlags
                    rawRegion.mf,  // mappedFile
                    byteStats
                );
              }
            );
          }

          // Gather the process and global memory allocator dumps, if present.
          var processMemoryAllocatorDumpsByFullName = {};
          if (dumps.allocators !== undefined) {
            // Construct the MemoryAllocatorDump objects without parent links
            // and add them to the processMemoryAllocatorDumpsByName and
            // globalMemoryAllocatorDumpsByName indices appropriately.
            tr.b.iterItems(dumps.allocators,
                function(fullName, rawAllocatorDump) {
              // Every memory allocator dump should have a GUID. If not, then
              // it cannot be associated with any edges.
              var guid = rawAllocatorDump.guid;
              if (guid === undefined) {
                this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Memory allocator dump ' + fullName +
                      ' from pid=' + pid + ' does not have a GUID.'
                });
              }

              // Determine if this is a global memory allocator dump (check if
              // it's prefixed with 'global/').
              var GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX = 'global/';
              var containerMemoryDump;
              var dstIndex;
              if (fullName.startsWith(GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX)) {
                // Global memory allocator dump.
                fullName = fullName.substring(
                    GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX.length);
                containerMemoryDump = globalMemoryDump;
                dstIndex = globalMemoryAllocatorDumpsByFullName;
              } else {
                // Process memory allocator dump.
                containerMemoryDump = processMemoryDump;
                dstIndex = processMemoryAllocatorDumpsByFullName;
              }

              // Construct or retrieve a memory allocator dump with the provided
              // GUID.
              var allocatorDump = allMemoryAllocatorDumpsByGuid[guid];
              if (allocatorDump === undefined) {
                if (fullName in dstIndex) {
                  this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Multiple GUIDs provided for' +
                        ' memory allocator dump ' + fullName + ': ' +
                        dstIndex[fullName].guid + ', ' + guid + ' (ignored).'
                  });
                  return;
                }
                allocatorDump = new tr.model.MemoryAllocatorDump(
                    containerMemoryDump, fullName, guid);
                dstIndex[fullName] = allocatorDump;
                if (guid !== undefined)
                  allMemoryAllocatorDumpsByGuid[guid] = allocatorDump;
              } else {
                // A memory allocator dump with this GUID has already been
                // dumped (so we will only add new attributes). Check that it
                // belonged to the same process or was also global.
                if (allocatorDump.containerMemoryDump !== containerMemoryDump) {
                  this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Memory allocator dump ' + fullName +
                      ' (GUID=' + guid + ') dumped in different contexts.'
                  });
                  return;
                }
                // Check that the names of the memory allocator dumps match.
                if (allocatorDump.fullName !== fullName) {
                  this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Memory allocator dump with GUID=' + guid +
                      ' has multiple names: ' + allocatorDump.fullName +
                      ', ' + fullName + ' (ignored).'
                  });
                  return;
                }
              }

              // Add all new attributes to the memory allocator dump.
              var attributes = rawAllocatorDump.attrs;
              if (attributes === undefined) {
                this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Memory allocator dump ' + fullName +
                      ' from pid=' + pid + ' (GUID=' + guid + ') does not' +
                      ' have attributes.'
                });
                attributes = {};
              }

              tr.b.iterItems(attributes, function(attrName, attrArgs) {
                if (attrName in allocatorDump.attributes) {
                  // Skip existing attributes of the memory allocator dump.
                  this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Multiple values provided for attribute ' +
                      attrName + ' of memory allocator dump ' + fullName +
                      ' (GUID=' + guid + ').'
                  });
                  return;
                }
                var attrValue =
                    tr.model.Attribute.fromDictIfPossible(attrArgs);
                allocatorDump.addAttribute(attrName, attrValue);
              }, this);
            }, this);
          }

          // Find the root allocator dumps and establish the parent links of
          // the process memory dump.
          processMemoryDump.memoryAllocatorDumps =
              this.inferMemoryAllocatorDumpTree_(
                  processMemoryAllocatorDumpsByFullName);

          process.memoryDumps.push(processMemoryDump);
          globalMemoryDump.processMemoryDumps[pid] = processMemoryDump;
        }, this);

        globalMemoryDump.levelOfDetail =
            LEVELS_OF_DETAIL[globalLevelOfDetailIndex];

        // Find the root allocator dumps and establish the parent links of
        // the global memory dump.
        globalMemoryDump.memoryAllocatorDumps =
            this.inferMemoryAllocatorDumpTree_(
                globalMemoryAllocatorDumpsByFullName);

        // Set up edges between memory allocator dumps.
        events.process.forEach(function(processEvent) {
          var dumps = processEvent.args.dumps;
          if (dumps === undefined)
            return;

          var edges = dumps.allocators_graph;
          if (edges === undefined)
            return;

          edges.forEach(function(rawEdge) {
            var sourceGuid = rawEdge.source;
            var sourceDump = allMemoryAllocatorDumpsByGuid[sourceGuid];
            if (sourceDump === undefined) {
              this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'Edge is missing source memory allocator dump (GUID=' +
                    sourceGuid + ')'
              });
              return;
            }

            var targetGuid = rawEdge.target;
            var targetDump = allMemoryAllocatorDumpsByGuid[targetGuid];
            if (targetDump === undefined) {
              this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'Edge is missing target memory allocator dump (GUID=' +
                    targetGuid + ')'
              });
              return;
            }

            var importance = rawEdge.importance;
            var edge = new tr.model.MemoryAllocatorDumpLink(
                sourceDump, targetDump, importance);

            switch (rawEdge.type) {
              case 'ownership':
                if (sourceDump.owns !== undefined) {
                  this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Memory allocator dump ' + sourceDump.fullName +
                        ' (GUID=' + sourceGuid + ') already owns a memory' +
                        ' allocator dump (' +
                        sourceDump.owns.target.fullName + ').'
                  });
                  return;
                }
                sourceDump.owns = edge;
                targetDump.ownedBy.push(edge);
                break;

              case 'retention':
                sourceDump.retains.push(edge);
                targetDump.retainedBy.push(edge);
                break;

              default:
                this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Invalid edge type: ' + rawEdge.type +
                      ' (source=' + sourceGuid + ', target=' + targetGuid +
                      ', importance=' + importance + ').'
                });
            }
          }, this);
        }, this);
      }, this);
    },

    inferMemoryAllocatorDumpTree_: function(memoryAllocatorDumpsByFullName) {
      var rootAllocatorDumps = [];

      var fullNames = Object.keys(memoryAllocatorDumpsByFullName);
      fullNames.sort();
      fullNames.forEach(function(fullName) {
        var allocatorDump = memoryAllocatorDumpsByFullName[fullName];

        // This is a loop because we might need to build implicit
        // ancestors in case they were not present in the trace.
        while (true) {
          var lastSlashIndex = fullName.lastIndexOf('/');
          if (lastSlashIndex === -1) {
            // If the dump is a root, add it to the top-level
            // rootAllocatorDumps list.
            rootAllocatorDumps.push(allocatorDump);
            break;
          }

          // If the dump is not a root, find its parent.
          var parentFullName = fullName.substring(0, lastSlashIndex);
          var parentAllocatorDump =
              memoryAllocatorDumpsByFullName[parentFullName];

          // If the parent dump does not exist yet, we build an implicit
          // one and continue up the ancestor chain.
          var parentAlreadyExisted = true;
          if (parentAllocatorDump === undefined) {
            parentAlreadyExisted = false;
            parentAllocatorDump = new tr.model.MemoryAllocatorDump(
                allocatorDump.containerMemoryDump, parentFullName);
            memoryAllocatorDumpsByFullName[parentFullName] =
                parentAllocatorDump;
          }

          // Setup the parent <-> children relationships
          allocatorDump.parent = parentAllocatorDump;
          parentAllocatorDump.children.push(allocatorDump);

          // If the parent already existed, then its ancestors were/will be
          // constructed in another iteration of the forEach loop.
          if (parentAlreadyExisted)
            break;

          fullName = parentFullName;
          allocatorDump = parentAllocatorDump;
        }
      }, this);

      return rootAllocatorDumps;
    },

    joinObjectRefs_: function() {
      tr.b.iterItems(this.model_.processes, function(pid, process) {
        this.joinObjectRefsForProcess_(process);
      }, this);
    },

    joinObjectRefsForProcess_: function(process) {
      // Iterate the world, looking for id_refs
      var patchupsToApply = [];
      tr.b.iterItems(process.threads, function(tid, thread) {
        thread.asyncSliceGroup.slices.forEach(function(item) {
          this.searchItemForIDRefs_(
              patchupsToApply, process.objects, 'start', item);
        }, this);
        thread.sliceGroup.slices.forEach(function(item) {
          this.searchItemForIDRefs_(
              patchupsToApply, process.objects, 'start', item);
        }, this);
      }, this);
      process.objects.iterObjectInstances(function(instance) {
        instance.snapshots.forEach(function(item) {
          this.searchItemForIDRefs_(
              patchupsToApply, process.objects, 'ts', item);
        }, this);
      }, this);

      // Change all the fields pointing at id_refs to their real values.
      patchupsToApply.forEach(function(patchup) {
        patchup.object[patchup.field] = patchup.value;
      });
    },

    searchItemForIDRefs_: function(patchupsToApply, objectCollection,
                                   itemTimestampField, item) {
      if (!item.args)
        throw new Error('item is missing its args');

      function handleField(object, fieldName, fieldValue) {
        if (!fieldValue || (!fieldValue.id_ref && !fieldValue.idRef))
          return;

        var id = fieldValue.id_ref || fieldValue.idRef;
        var ts = item[itemTimestampField];
        var snapshot = objectCollection.getSnapshotAt(id, ts);
        if (!snapshot)
          return;

        // We have to delay the actual change to the new value until after all
        // refs have been located. Otherwise, we could end up recursing in
        // ways we definitely didn't intend.
        patchupsToApply.push({object: object,
          field: fieldName,
          value: snapshot});
      }
      function iterObjectFieldsRecursively(object) {
        if (!(object instanceof Object))
          return;

        if ((object instanceof tr.model.ObjectSnapshot) ||
            (object instanceof Float32Array) ||
            (object instanceof tr.b.Quad))
          return;

        if (object instanceof Array) {
          for (var i = 0; i < object.length; i++) {
            handleField(object, i, object[i]);
            iterObjectFieldsRecursively(object[i]);
          }
          return;
        }

        for (var key in object) {
          var value = object[key];
          handleField(object, key, value);
          iterObjectFieldsRecursively(value);
        }
      }

      iterObjectFieldsRecursively(item.args);
    }
  };

  tr.importer.Importer.register(TraceEventImporter);

  return {
    TraceEventImporter: TraceEventImporter
  };
});


'use strict';

/**
 * @fileoverview ZipImporter inflates zip compressed data and passes it along
 * to an actual importer.
 */
tr.exportTo('tr.e.importer', function() {
  function ZipImporter(model, eventData) {
    if (eventData instanceof ArrayBuffer)
      eventData = new Uint8Array(eventData);
    this.model_ = model;
    this.eventData_ = eventData;
  }

  /**
   * @param {eventData} string Possibly zip compressed data.
   * @return {boolean} Whether eventData looks like zip compressed data.
   */
  ZipImporter.canImport = function(eventData) {
    var header;
    if (eventData instanceof ArrayBuffer)
      header = new Uint8Array(eventData.slice(0, 2));
    else if (typeof(eventData) === 'string' || eventData instanceof String)
      header = [eventData.charCodeAt(0), eventData.charCodeAt(1)];
    else
      return false;
    return header[0] === 'P'.charCodeAt(0) && header[1] === 'K'.charCodeAt(0);
  };

  ZipImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    isTraceDataContainer: function() {
      return true;
    },

    extractSubtraces: function() {
      var zip = new JSZip(this.eventData_);
      var subtraces = [];
      for (var idx in zip.files)
        subtraces.push(zip.files[idx].asBinary());
      return subtraces;
    }
  };

  tr.importer.Importer.register(ZipImporter);

  return {
    ZipImporter: ZipImporter
  };
});


'use strict';

/**
 * @fileoverview Log Reader is used to process log file produced by V8.
 */
tr.exportTo('tr.e.importer.v8', function() {
  /**
   * Creates a CSV lines parser.
   */
  function CsvParser() { };

  /**
   * A regex for matching a CSV field.
   * @private
   */
  CsvParser.CSV_FIELD_RE_ = /^"((?:[^"]|"")*)"|([^,]*)/;

  /**
   * A regex for matching a double quote.
   * @private
   */
  CsvParser.DOUBLE_QUOTE_RE_ = /""/g;

  /**
   * Parses a line of CSV-encoded values. Returns an array of fields.
   *
   * @param {string} line Input line.
   */
  CsvParser.prototype.parseLine = function(line) {
    var fieldRe = CsvParser.CSV_FIELD_RE_;
    var doubleQuoteRe = CsvParser.DOUBLE_QUOTE_RE_;
    var pos = 0;
    var endPos = line.length;
    var fields = [];
    if (endPos > 0) {
      do {
        var fieldMatch = fieldRe.exec(line.substr(pos));
        if (typeof fieldMatch[1] === 'string') {
          var field = fieldMatch[1];
          pos += field.length + 3;  // Skip comma and quotes.
          fields.push(field.replace(doubleQuoteRe, '"'));
        } else {
          // The second field pattern will match anything, thus
          // in the worst case the match will be an empty string.
          var field = fieldMatch[2];
          pos += field.length + 1;  // Skip comma.
          fields.push(field);
        }
      } while (pos <= endPos);
    }
    return fields;
  };

  /**
   * Base class for processing log files.
   *
   * @param {Array.<Object>} dispatchTable A table used for parsing and
   * processing log records.
   *
   * @constructor
   */
  function LogReader(dispatchTable) {
    /**
     * @type {Array.<Object>}
     */
    this.dispatchTable_ = dispatchTable;

    /**
     * Current line.
     * @type {number}
     */
    this.lineNum_ = 0;

    /**
     * CSV lines parser.
     * @type {CsvParser}
     */
    this.csvParser_ = new CsvParser();
  };

  /**
   * Used for printing error messages.
   *
   * @param {string} str Error message.
   */
  LogReader.prototype.printError = function(str) {
    // Do nothing.
  };

  /**
   * Processes a portion of V8 profiler event log.
   *
   * @param {string} chunk A portion of log.
   */
  LogReader.prototype.processLogChunk = function(chunk) {
    this.processLog_(chunk.split('\n'));
  };

  /**
   * Processes a line of V8 profiler event log.
   *
   * @param {string} line A line of log.
   */
  LogReader.prototype.processLogLine = function(line) {
    this.processLog_([line]);
  };

  /**
   * Processes stack record.
   *
   * @param {number} pc Program counter.
   * @param {number} func JS Function.
   * @param {Array.<string>} stack String representation of a stack.
   * @return {Array.<number>} Processed stack.
   */
  LogReader.prototype.processStack = function(pc, func, stack) {
    var fullStack = func ? [pc, func] : [pc];
    var prevFrame = pc;
    for (var i = 0, n = stack.length; i < n; ++i) {
      var frame = stack[i];
      var firstChar = frame.charAt(0);
      if (firstChar == '+' || firstChar == '-') {
        // An offset from the previous frame.
        prevFrame += parseInt(frame, 16);
        fullStack.push(prevFrame);
      // Filter out possible 'overflow' string.
      } else if (firstChar != 'o') {
        fullStack.push(parseInt(frame, 16));
      }
    }
    return fullStack;
  };

  /**
   * Returns whether a particular dispatch must be skipped.
   *
   * @param {!Object} dispatch Dispatch record.
   * @return {boolean} True if dispatch must be skipped.
   */
  LogReader.prototype.skipDispatch = function(dispatch) {
    return false;
  };

  /**
   * Does a dispatch of a log record.
   *
   * @param {Array.<string>} fields Log record.
   * @private
   */
  LogReader.prototype.dispatchLogRow_ = function(fields) {
    // Obtain the dispatch.
    var command = fields[0];
    if (!(command in this.dispatchTable_)) return;

    var dispatch = this.dispatchTable_[command];

    if (dispatch === null || this.skipDispatch(dispatch)) {
      return;
    }

    // Parse fields.
    var parsedFields = [];
    for (var i = 0; i < dispatch.parsers.length; ++i) {
      var parser = dispatch.parsers[i];
      if (parser === null) {
        parsedFields.push(fields[1 + i]);
      } else if (typeof parser == 'function') {
        parsedFields.push(parser(fields[1 + i]));
      } else {
        // var-args
        parsedFields.push(fields.slice(1 + i));
        break;
      }
    }

    // Run the processor.
    dispatch.processor.apply(this, parsedFields);
  };

  /**
   * Processes log lines.
   *
   * @param {Array.<string>} lines Log lines.
   * @private
   */
  LogReader.prototype.processLog_ = function(lines) {
    for (var i = 0, n = lines.length; i < n; ++i, ++this.lineNum_) {
      var line = lines[i];
      if (!line) {
        continue;
      }
      try {
        var fields = this.csvParser_.parseLine(line);
        this.dispatchLogRow_(fields);
      } catch (e) {
        this.printError('line ' + (this.lineNum_ + 1) + ': ' +
                        (e.message || e));
      }
    }
  };
  return {
    LogReader: LogReader
  };
});



'use strict';

/**
 * @fileoverview V8LogImporter imports v8.log files into the provided model.
 */
tr.exportTo('tr.e.importer.v8', function() {
  function V8LogImporter(model, eventData) {
    this.importPriority = 3;
    this.model_ = model;

    this.logData_ = eventData;

    this.code_map_ = new tr.e.importer.v8.CodeMap();
    this.v8_timer_thread_ = undefined;
    this.v8_thread_ = undefined;

    this.root_stack_frame_ = new tr.model.StackFrame(
        undefined, 'v8-root-stack-frame',
        'v8-root-stack-frame', 'v8-root-stack-frame', 0);

    // We reconstruct the stack timeline from ticks.
    this.v8_stack_timeline_ = new Array();
  }

  var kV8BinarySuffixes = ['/d8', '/libv8.so'];


  var TimerEventDefaultArgs = {
    'V8.Execute': { pause: false, no_execution: false},
    'V8.External': { pause: false, no_execution: true},
    'V8.CompileFullCode': { pause: true, no_execution: true},
    'V8.RecompileSynchronous': { pause: true, no_execution: true},
    'V8.RecompileParallel': { pause: false, no_execution: false},
    'V8.CompileEval': { pause: true, no_execution: true},
    'V8.Parse': { pause: true, no_execution: true},
    'V8.PreParse': { pause: true, no_execution: true},
    'V8.ParseLazy': { pause: true, no_execution: true},
    'V8.GCScavenger': { pause: true, no_execution: true},
    'V8.GCCompactor': { pause: true, no_execution: true},
    'V8.GCContext': { pause: true, no_execution: true}
  };

  /**
   * @return {boolean} Whether obj is a V8 log string.
   */
  V8LogImporter.canImport = function(eventData) {
    if (typeof(eventData) !== 'string' && !(eventData instanceof String))
      return false;

    return eventData.substring(0, 11) == 'v8-version,' ||
           eventData.substring(0, 12) == 'timer-event,' ||
           eventData.substring(0, 5) == 'tick,' ||
           eventData.substring(0, 15) == 'shared-library,' ||
           eventData.substring(0, 9) == 'profiler,' ||
           eventData.substring(0, 14) == 'code-creation,';
  };

  V8LogImporter.prototype = {

    __proto__: tr.importer.Importer.prototype,

    processTimerEvent_: function(name, start, length) {
      var args = TimerEventDefaultArgs[name];
      if (args === undefined) return;
      start /= 1000;  // Convert to milliseconds.
      length /= 1000;
      var colorId = tr.ui.b.getColorIdForGeneralPurposeString(name);
      var slice = new tr.model.Slice('v8', name, colorId, start,
          args, length);
      this.v8_timer_thread_.sliceGroup.pushSlice(slice);
    },

    processTimerEventStart_: function(name, start) {
      var args = TimerEventDefaultArgs[name];
      if (args === undefined) return;
      start /= 1000;  // Convert to milliseconds.
      this.v8_timer_thread_.sliceGroup.beginSlice('v8', name, start, args);
    },

    processTimerEventEnd_: function(name, end) {
      end /= 1000;  // Convert to milliseconds.
      this.v8_timer_thread_.sliceGroup.endSlice(end);
    },

    processCodeCreateEvent_: function(type, kind, address, size, name) {
      var code_entry = new tr.e.importer.v8.CodeMap.CodeEntry(size, name);
      code_entry.kind = kind;
      this.code_map_.addCode(address, code_entry);
    },

    processCodeMoveEvent_: function(from, to) {
      this.code_map_.moveCode(from, to);
    },

    processCodeDeleteEvent_: function(address) {
      this.code_map_.deleteCode(address);
    },

    processSharedLibrary_: function(name, start, end) {
      var code_entry = new tr.e.importer.v8.CodeMap.CodeEntry(
          end - start, name);
      code_entry.kind = -3;  // External code kind.
      for (var i = 0; i < kV8BinarySuffixes.length; i++) {
        var suffix = kV8BinarySuffixes[i];
        if (name.indexOf(suffix, name.length - suffix.length) >= 0) {
          code_entry.kind = -1;  // V8 runtime code kind.
          break;
        }
      }
      this.code_map_.addLibrary(start, code_entry);
    },

    findCodeKind_: function(kind) {
      for (name in CodeKinds) {
        if (CodeKinds[name].kinds.indexOf(kind) >= 0) {
          return CodeKinds[name];
        }
      }
    },

    processTickEvent_: function(pc, start, unused_x, unused_y, vmstate, stack) {
      start /= 1000;

      function findChildWithEntryID(stackFrame, entryID) {
        for (var i = 0; i < stackFrame.children.length; i++) {
          if (stackFrame.children[i].entryID == entryID)
            return stackFrame.children[i];
        }
        return undefined;
      }

      var lastStackFrame;
      if (stack && stack.length) {

        lastStackFrame = this.root_stack_frame_;
        // v8 log stacks are inverted, leaf first and the root at the end.
        stack = stack.reverse();
        for (var i = 0; i < stack.length; i++) {
          if (!stack[i])
            break;
          var entry = this.code_map_.findEntry(stack[i]);

          var entryID = entry ? entry.id : 'Unknown';
          var childFrame = findChildWithEntryID(lastStackFrame, entryID);
          if (childFrame === undefined) {
            var entryName = entry ? entry.name : 'Unknown';
            lastStackFrame = new tr.model.StackFrame(
                lastStackFrame, 'v8sf-' + tr.b.GUID.allocate(),
                'v8', entryName,
                tr.ui.b.getColorIdForGeneralPurposeString(entryName));
            lastStackFrame.entryID = entryID;
            this.model_.addStackFrame(lastStackFrame);
          } else {
            lastStackFrame = childFrame;
          }
        }
      } else {
        var pcEntry = this.code_map_.findEntry(pc);
        var pcEntryID = 'v8pc-' + (pcEntry ? pcEntry.id : 'Unknown');
        if (this.model_.stackFrames[pcEntryID] === undefined) {
          var pcEntryName = pcEntry ? pcEntry.name : 'Unknown';
          lastStackFrame = new tr.model.StackFrame(
              undefined, pcEntryID,
              'v8', pcEntryName,
              tr.ui.b.getColorIdForGeneralPurposeString(pcEntryName));
          this.model_.addStackFrame(lastStackFrame);
        }
        lastStackFrame = this.model_.stackFrames[pcEntryID];
      }

      var sample = new tr.model.Sample(
          undefined, this.v8_thread_, 'V8 PC',
          start, lastStackFrame, 1);
      this.model_.samples.push(sample);
    },

    processDistortion_: function(distortion_in_picoseconds) {
      distortion_per_entry = distortion_in_picoseconds / 1000000;
    },

    processPlotRange_: function(start, end) {
      xrange_start_override = start;
      xrange_end_override = end;
    },

    processV8Version_: function(major, minor, build, patch, candidate) {
      // do nothing.
    },

    /**
     * Walks through the events_ list and outputs the structures discovered to
     * model_.
     */
    importEvents: function() {
      var logreader = new tr.e.importer.v8.LogReader(
          { 'timer-event' : {
            parsers: [null, parseInt, parseInt],
            processor: this.processTimerEvent_.bind(this)
          },
          'shared-library': {
            parsers: [null, parseInt, parseInt],
            processor: this.processSharedLibrary_.bind(this)
          },
          'timer-event-start' : {
            parsers: [null, parseInt],
            processor: this.processTimerEventStart_.bind(this)
          },
          'timer-event-end' : {
            parsers: [null, parseInt],
            processor: this.processTimerEventEnd_.bind(this)
          },
          'code-creation': {
            parsers: [null, parseInt, parseInt, parseInt, null],
            processor: this.processCodeCreateEvent_.bind(this)
          },
          'code-move': {
            parsers: [parseInt, parseInt],
            processor: this.processCodeMoveEvent_.bind(this)
          },
          'code-delete': {
            parsers: [parseInt],
            processor: this.processCodeDeleteEvent_.bind(this)
          },
          'tick': {
            parsers: [parseInt, parseInt, null, null, parseInt, 'var-args'],
            processor: this.processTickEvent_.bind(this)
          },
          'distortion': {
            parsers: [parseInt],
            processor: this.processDistortion_.bind(this)
          },
          'plot-range': {
            parsers: [parseInt, parseInt],
            processor: this.processPlotRange_.bind(this)
          },
          'v8-version': {
            parsers: [parseInt, parseInt, parseInt, parseInt, parseInt],
            processor: this.processV8Version_.bind(this)
          }
          });

      this.v8_timer_thread_ =
          this.model_.getOrCreateProcess(-32).getOrCreateThread(1);
      this.v8_timer_thread_.name = 'V8 Timers';
      this.v8_thread_ =
          this.model_.getOrCreateProcess(-32).getOrCreateThread(2);
      this.v8_thread_.name = 'V8';

      var lines = this.logData_.split('\n');
      for (var i = 0; i < lines.length; i++) {
        logreader.processLogLine(lines[i]);
      }

      // The processing of samples adds all the root stack frame to
      // this.root_stack_frame_. But, we don't want that stack frame in the real
      // model. So get rid of it.
      this.root_stack_frame_.removeAllChildren();

      function addSlices(slices, thread) {
        for (var i = 0; i < slices.length; i++) {
          var duration = slices[i].end - slices[i].start;
          var slice = new tr.model.Slice('v8', slices[i].name,
              tr.ui.b.getColorIdForGeneralPurposeString(slices[i].name),
              slices[i].start, {}, duration);
          thread.sliceGroup.pushSlice(slice);
          addSlices(slices[i].children, thread);
        }
      }
      addSlices(this.v8_stack_timeline_, this.v8_thread_);
    }
  };

  tr.importer.Importer.register(V8LogImporter);

  return {
    V8LogImporter: V8LogImporter
  };
});


'use strict';

/**
 * @fileoverview Base class for Windows ETW event parsers.
 *
 * The ETW trace event importer depends on subclasses of
 * Parser to parse event data.  Each subclass corresponds
 * to a group of trace events; e.g. Thread and Process implements
 * decoding of scheduling events.  Parser subclasses must
 * call Parser.register to arrange to be instantiated
 * and their constructor must register their event handlers with the
 * importer.  For example,
 *
 * var Parser = tr.e.importer.etw.Parser;
 *
 * function ThreadParser(importer) {
 *   Parser.call(this, importer);
 *
 *   importer.registerEventHandler(guid, kThreadStartOpcode,
 *       ThreadParser.prototype.decodeStart.bind(this));
 *   importer.registerEventHandler(guid, kThreadEndOpcode,
 *       ThreadParser.prototype.decodeEnd.bind(this));
 * }
 *
 * Parser.register(ThreadParser);
 *
 * When a registered event is found, the associated event handler is invoked:
 *
 *   decodeStart: function(header, decoder) {
 *     [...]
 *     return true;
 *   },
 *
 * If the routine returns false the caller will generate an import error
 * saying there was a problem parsing it.  Handlers can also emit import
 * messages using this.importer.model.importWarning.  If this is done in lieu of
 * the generic import error it may be desirable for the handler to return
 * true.
 *
 */
tr.exportTo('tr.e.importer.etw', function() {
  /**
   * Parses Windows ETW events.
   * @constructor
   */
  function Parser(importer) {
    this.importer = importer;
    this.model = importer.model;
  }

  Parser.prototype = {
    __proto__: Object.prototype
  };

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.mandatoryBaseClass = Parser;
  tr.b.decorateExtensionRegistry(Parser, options);


  return {
    Parser: Parser
  };
});


'use strict';

/**
 * @fileoverview Parses EventTrace events in the Windows event trace format.
 */

tr.exportTo('tr.e.importer.etw', function() {
  var Parser = tr.e.importer.etw.Parser;

  // Constants for EventTrace events.
  var guid = '68FDD900-4A3E-11D1-84F4-0000F80464E3';
  var kEventTraceHeaderOpcode = 0;

  /**
   * Parses Windows EventTrace trace events.
   * @constructor
   */
  function EventTraceParser(importer) {
    Parser.call(this, importer);

    // Register handlers.
    importer.registerEventHandler(guid, kEventTraceHeaderOpcode,
        EventTraceParser.prototype.decodeHeader.bind(this));
  }

  EventTraceParser.prototype = {
    __proto__: Parser.prototype,

    decodeFields: function(header, decoder) {
      if (header.version != 2)
        throw new Error('Incompatible EventTrace event version.');

      var bufferSize = decoder.decodeUInt32();
      var version = decoder.decodeUInt32();
      var providerVersion = decoder.decodeUInt32();
      var numberOfProcessors = decoder.decodeUInt32();
      var endTime = decoder.decodeUInt64ToString();
      var timerResolution = decoder.decodeUInt32();
      var maxFileSize = decoder.decodeUInt32();
      var logFileMode = decoder.decodeUInt32();
      var buffersWritten = decoder.decodeUInt32();
      var startBuffers = decoder.decodeUInt32();
      var pointerSize = decoder.decodeUInt32();
      var eventsLost = decoder.decodeUInt32();
      var cpuSpeed = decoder.decodeUInt32();
      var loggerName = decoder.decodeUInteger(header.is64);
      var logFileName = decoder.decodeUInteger(header.is64);
      var timeZoneInformation = decoder.decodeTimeZoneInformation();
      var padding = decoder.decodeUInt32();
      var bootTime = decoder.decodeUInt64ToString();
      var perfFreq = decoder.decodeUInt64ToString();
      var startTime = decoder.decodeUInt64ToString();
      var reservedFlags = decoder.decodeUInt32();
      var buffersLost = decoder.decodeUInt32();
      var sessionNameString = decoder.decodeW16String();
      var logFileNameString = decoder.decodeW16String();

      return {
        bufferSize: bufferSize,
        version: version,
        providerVersion: providerVersion,
        numberOfProcessors: numberOfProcessors,
        endTime: endTime,
        timerResolution: timerResolution,
        maxFileSize: maxFileSize,
        logFileMode: logFileMode,
        buffersWritten: buffersWritten,
        startBuffers: startBuffers,
        pointerSize: pointerSize,
        eventsLost: eventsLost,
        cpuSpeed: cpuSpeed,
        loggerName: loggerName,
        logFileName: logFileName,
        timeZoneInformation: timeZoneInformation,
        bootTime: bootTime,
        perfFreq: perfFreq,
        startTime: startTime,
        reservedFlags: reservedFlags,
        buffersLost: buffersLost,
        sessionNameString: sessionNameString,
        logFileNameString: logFileNameString
      };
    },

    decodeHeader: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      // TODO(etienneb): Update the Model with |fields|.
      return true;
    }

  };

  Parser.register(EventTraceParser);

  return {
    EventTraceParser: EventTraceParser
  };
});


'use strict';

/**
 * @fileoverview Parses processes events in the Windows event trace format.
 *
 * The Windows process events are:
 *
 * - DCStart: Describes a process that was already running when the trace
 *    started. ETW automatically generates these events for all running
 *    processes at the beginning of the trace.
 * - Start: Describes a process launched during the tracing session.
 * - End: Describes a process that ended during the tracing session.
 * - DCEnd: Describes a process that was still running when the trace ended.
 *
 * See http://msdn.microsoft.com/library/windows/desktop/aa364092.aspx
 */
tr.exportTo('tr.e.importer.etw', function() {
  var Parser = tr.e.importer.etw.Parser;

  // Constants for Process events.
  var guid = '3D6FA8D0-FE05-11D0-9DDA-00C04FD7BA7C';
  var kProcessStartOpcode = 1;
  var kProcessEndOpcode = 2;
  var kProcessDCStartOpcode = 3;
  var kProcessDCEndOpcode = 4;
  var kProcessDefunctOpcode = 39;

  /**
   * Parses Windows process trace events.
   * @constructor
   */
  function ProcessParser(importer) {
    Parser.call(this, importer);

    // Register handlers.
    importer.registerEventHandler(guid, kProcessStartOpcode,
        ProcessParser.prototype.decodeStart.bind(this));
    importer.registerEventHandler(guid, kProcessEndOpcode,
        ProcessParser.prototype.decodeEnd.bind(this));
    importer.registerEventHandler(guid, kProcessDCStartOpcode,
        ProcessParser.prototype.decodeDCStart.bind(this));
    importer.registerEventHandler(guid, kProcessDCEndOpcode,
        ProcessParser.prototype.decodeDCEnd.bind(this));
    importer.registerEventHandler(guid, kProcessDefunctOpcode,
        ProcessParser.prototype.decodeDefunct.bind(this));
  }

  ProcessParser.prototype = {
    __proto__: Parser.prototype,

    decodeFields: function(header, decoder) {
      if (header.version > 5)
        throw new Error('Incompatible Process event version.');

      var pageDirectoryBase;
      if (header.version == 1)
        pageDirectoryBase = decoder.decodeUInteger(header.is64);

      var uniqueProcessKey;
      if (header.version >= 2)
        uniqueProcessKey = decoder.decodeUInteger(header.is64);

      var processId = decoder.decodeUInt32();
      var parentId = decoder.decodeUInt32();

      var sessionId;
      var exitStatus;
      if (header.version >= 1) {
        sessionId = decoder.decodeUInt32();
        exitStatus = decoder.decodeInt32();
      }

      var directoryTableBase;
      if (header.version >= 3)
        directoryTableBase = decoder.decodeUInteger(header.is64);

      var flags;
      if (header.version >= 4)
        flags = decoder.decodeUInt32();

      var userSID = decoder.decodeSID(header.is64);

      var imageFileName;
      if (header.version >= 1)
        imageFileName = decoder.decodeString();

      var commandLine;
      if (header.version >= 2)
        commandLine = decoder.decodeW16String();

      var packageFullName;
      var applicationId;
      if (header.version >= 4) {
        packageFullName = decoder.decodeW16String();
        applicationId = decoder.decodeW16String();
      }

      var exitTime;
      if (header.version == 5 && header.opcode == kProcessDefunctOpcode)
        exitTime = decoder.decodeUInt64ToString();

      return {
        pageDirectoryBase: pageDirectoryBase,
        uniqueProcessKey: uniqueProcessKey,
        processId: processId,
        parentId: parentId,
        sessionId: sessionId,
        exitStatus: exitStatus,
        directoryTableBase: directoryTableBase,
        flags: flags,
        userSID: userSID,
        imageFileName: imageFileName,
        commandLine: commandLine,
        packageFullName: packageFullName,
        applicationId: applicationId,
        exitTime: exitTime
      };
    },

    decodeStart: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      var process = this.model.getOrCreateProcess(fields.processId);
      if (process.hasOwnProperty('has_ended')) {
        // On Windows, a process ID used by a process could be reused as soon as
        // the process ends (there is no pid cycling like on Linux). However, in
        // a short trace, this is unlikely to happen.
        throw new Error('Process clash detected.');
      }
      process.name = fields.imageFileName;
      return true;
    },

    decodeEnd: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      var process = this.model.getOrCreateProcess(fields.processId);
      process.has_ended = true;
      return true;
    },

    decodeDCStart: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      var process = this.model.getOrCreateProcess(fields.processId);
      if (process.hasOwnProperty('has_ended'))
        throw new Error('Process clash detected.');
      process.name = fields.imageFileName;
      return true;
    },

    decodeDCEnd: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      var process = this.model.getOrCreateProcess(fields.processId);
      process.has_ended = true;
      return true;
    },

    decodeDefunct: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      // TODO(etienneb): Update the Model with |fields|.
      return true;
    }

  };

  Parser.register(ProcessParser);

  return {
    ProcessParser: ProcessParser
  };
});


'use strict';

/**
 * @fileoverview Parses threads events in the Windows event trace format.
 *
 * The Windows thread events are:
 *
 * - DCStart: Describes a thread that was already running when the trace
 *    started. ETW automatically generates these events for all running
 *    threads at the beginning of the trace.
 * - Start: Describes a thread that started during the tracing session.
 * - End: Describes a thread that ended during the tracing session.
 * - DCEnd: Describes a thread that was still alive when the trace ended.
 *
 * See http://msdn.microsoft.com/library/windows/desktop/aa364132.aspx
 */
tr.exportTo('tr.e.importer.etw', function() {
  var Parser = tr.e.importer.etw.Parser;

  // Constants for Thread events.
  var guid = '3D6FA8D1-FE05-11D0-9DDA-00C04FD7BA7C';
  var kThreadStartOpcode = 1;
  var kThreadEndOpcode = 2;
  var kThreadDCStartOpcode = 3;
  var kThreadDCEndOpcode = 4;
  var kThreadCSwitchOpcode = 36;

  /**
   * Parses Windows threads trace events.
   * @constructor
   */
  function ThreadParser(importer) {
    Parser.call(this, importer);

    // Register handlers.
    importer.registerEventHandler(guid, kThreadStartOpcode,
        ThreadParser.prototype.decodeStart.bind(this));
    importer.registerEventHandler(guid, kThreadEndOpcode,
        ThreadParser.prototype.decodeEnd.bind(this));
    importer.registerEventHandler(guid, kThreadDCStartOpcode,
        ThreadParser.prototype.decodeDCStart.bind(this));
    importer.registerEventHandler(guid, kThreadDCEndOpcode,
        ThreadParser.prototype.decodeDCEnd.bind(this));
    importer.registerEventHandler(guid, kThreadCSwitchOpcode,
        ThreadParser.prototype.decodeCSwitch.bind(this));
  }

  ThreadParser.prototype = {
    __proto__: Parser.prototype,

    decodeFields: function(header, decoder) {
      if (header.version > 3)
        throw new Error('Incompatible Thread event version.');

      // Common fields to all Thread events.
      var processId = decoder.decodeUInt32();
      var threadId = decoder.decodeUInt32();

      // Extended fields.
      var stackBase;
      var stackLimit;
      var userStackBase;
      var userStackLimit;
      var affinity;
      var startAddr;
      var win32StartAddr;
      var tebBase;
      var subProcessTag;
      var basePriority;
      var pagePriority;
      var ioPriority;
      var threadFlags;
      var waitMode;

      if (header.version == 1) {
        // On version 1, only start events have extended information.
        if (header.opcode == kThreadStartOpcode ||
            header.opcode == kThreadDCStartOpcode) {
          stackBase = decoder.decodeUInteger(header.is64);
          stackLimit = decoder.decodeUInteger(header.is64);
          userStackBase = decoder.decodeUInteger(header.is64);
          userStackLimit = decoder.decodeUInteger(header.is64);
          startAddr = decoder.decodeUInteger(header.is64);
          win32StartAddr = decoder.decodeUInteger(header.is64);
          waitMode = decoder.decodeInt8();
          decoder.skip(3);
        }
      } else {
        stackBase = decoder.decodeUInteger(header.is64);
        stackLimit = decoder.decodeUInteger(header.is64);
        userStackBase = decoder.decodeUInteger(header.is64);
        userStackLimit = decoder.decodeUInteger(header.is64);

        // Version 2 produces a field named 'startAddr'.
        if (header.version == 2)
          startAddr = decoder.decodeUInteger(header.is64);
        else
          affinity = decoder.decodeUInteger(header.is64);

        win32StartAddr = decoder.decodeUInteger(header.is64);
        tebBase = decoder.decodeUInteger(header.is64);
        subProcessTag = decoder.decodeUInt32();

        if (header.version == 3) {
          basePriority = decoder.decodeUInt8();
          pagePriority = decoder.decodeUInt8();
          ioPriority = decoder.decodeUInt8();
          threadFlags = decoder.decodeUInt8();
        }
      }

      return {
        processId: processId,
        threadId: threadId,
        stackBase: stackBase,
        stackLimit: stackLimit,
        userStackBase: userStackBase,
        userStackLimit: userStackLimit,
        affinity: affinity,
        startAddr: startAddr,
        win32StartAddr: win32StartAddr,
        tebBase: tebBase,
        subProcessTag: subProcessTag,
        waitMode: waitMode,
        basePriority: basePriority,
        pagePriority: pagePriority,
        ioPriority: ioPriority,
        threadFlags: threadFlags
      };
    },

    decodeCSwitchFields: function(header, decoder) {
      if (header.version != 2)
        throw new Error('Incompatible Thread event version.');

      // Decode CSwitch payload.
      var newThreadId = decoder.decodeUInt32();
      var oldThreadId = decoder.decodeUInt32();
      var newThreadPriority = decoder.decodeInt8();
      var oldThreadPriority = decoder.decodeInt8();
      var previousCState = decoder.decodeUInt8();
      var spareByte = decoder.decodeInt8();
      var oldThreadWaitReason = decoder.decodeInt8();
      var oldThreadWaitMode = decoder.decodeInt8();
      var oldThreadState = decoder.decodeInt8();
      var oldThreadWaitIdealProcessor = decoder.decodeInt8();
      var newThreadWaitTime = decoder.decodeUInt32();
      var reserved = decoder.decodeUInt32();

      return {
        newThreadId: newThreadId,
        oldThreadId: oldThreadId,
        newThreadPriority: newThreadPriority,
        oldThreadPriority: oldThreadPriority,
        previousCState: previousCState,
        spareByte: spareByte,
        oldThreadWaitReason: oldThreadWaitReason,
        oldThreadWaitMode: oldThreadWaitMode,
        oldThreadState: oldThreadState,
        oldThreadWaitIdealProcessor: oldThreadWaitIdealProcessor,
        newThreadWaitTime: newThreadWaitTime,
        reserved: reserved
      };
    },

    decodeStart: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      this.importer.createThreadIfNeeded(fields.processId, fields.threadId);
      return true;
    },

    decodeEnd: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      this.importer.removeThreadIfPresent(fields.threadId);
      return true;
    },

    decodeDCStart: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      this.importer.createThreadIfNeeded(fields.processId, fields.threadId);
      return true;
    },

    decodeDCEnd: function(header, decoder) {
      var fields = this.decodeFields(header, decoder);
      this.importer.removeThreadIfPresent(fields.threadId);
      return true;
    },

    decodeCSwitch: function(header, decoder) {
      var fields = this.decodeCSwitchFields(header, decoder);
      var cpu = this.importer.getOrCreateCpu(header.cpu);
      var new_thread =
          this.importer.getThreadFromWindowsTid(fields.newThreadId);

      // Generate the new thread name. If some events were lost, it's possible
      // that information about the new thread or process is not available.
      var new_thread_name;
      if (new_thread && new_thread.userFriendlyName) {
        new_thread_name = new_thread.userFriendlyName;
      } else {
        var new_process_id = this.importer.getPidFromWindowsTid(
            fields.newThreadId);
        var new_process = this.model.getProcess(new_process_id);
        var new_process_name;
        if (new_process)
          new_process_name = new_process.name;
        else
          new_process_name = 'Unknown process';

        new_thread_name =
            new_process_name + ' (tid ' + fields.newThreadId + ')';
      }

      cpu.switchActiveThread(
          header.timestamp,
          {},
          fields.newThreadId,
          new_thread_name,
          fields);
      return true;
    }

  };

  Parser.register(ThreadParser);

  return {
    ThreadParser: ThreadParser
  };
});


'use strict';

tr.exportTo('tr.b', function() {

  function Base64() {
  }

  function b64ToUint6(nChr) {
    if (nChr > 64 && nChr < 91)
      return nChr - 65;
    if (nChr > 96 && nChr < 123)
      return nChr - 71;
    if (nChr > 47 && nChr < 58)
      return nChr + 4;
    if (nChr === 43)
      return 62;
    if (nChr === 47)
      return 63;
    return 0;
  }

  Base64.getDecodedBufferLength = function(input) {
    return input.length * 3 + 1 >> 2;
  }

  Base64.EncodeArrayBufferToString = function(input) {
    // http://stackoverflow.com/questions/9267899/
    var binary = '';
    var bytes = new Uint8Array(input);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++)
      binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  Base64.DecodeToTypedArray = function(input, output) {

    var nInLen = input.length;
    var nOutLen = nInLen * 3 + 1 >> 2;
    var nMod3 = 0;
    var nMod4 = 0;
    var nUint24 = 0;
    var nOutIdx = 0;

    if (nOutLen > output.byteLength)
      throw new Error('Output buffer too small to decode.');

    for (var nInIdx = 0; nInIdx < nInLen; nInIdx++) {
      nMod4 = nInIdx & 3;
      nUint24 |= b64ToUint6(input.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
      if (nMod4 === 3 || nInLen - nInIdx === 1) {
        for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
          output.setUint8(nOutIdx, nUint24 >>> (16 >>> nMod3 & 24) & 255);
        }
        nUint24 = 0;
      }
    }
    return nOutIdx - 1;
  }

  return {
    Base64: Base64
  };

});


/**
 * @fileoverview Imports JSON file with the raw payloads from a Windows event
 * trace into the Model. This format is outputted by Chrome running
 * on a Windows system.
 *
 * This importer assumes the events arrived as a JSON file and the payloads are
 * undecoded sequence of bytes in hex format string. The unit tests provide
 * examples of the trace format.
 *
 * The format of the system trace is
 *     {
 *       name: 'ETW',
 *       content: [ <events> ]
 *     }
  *
 * where the <events> are dictionary values with fields.
 *
 *     {
 *       guid: "1234-...",    // The unique GUID for the event.
 *       op: 12,              // The opcode of the event.
 *       ver: 1,              // The encoding version of the event.
 *       cpu: 0,              // The cpu id on which the event was captured.
 *       ts: 1092,            // The thread id on which the event was captured.
 *       payload: "aaaa"      // A base64 encoded string of the raw payload.
 *     }
 *
 * The payload is an undecoded version of the raw event sent by ETW.
 * This importer uses specific parsers to decode recognized events.
 * A parser need to register the recognized event by calling
 * registerEventHandler(guid, opcode, handler). The parser is responsible to
 * decode the payload and update the Model.
 *
 * The payload formats are described there:
 *   http://msdn.microsoft.com/en-us/library/windows/desktop/aa364085(v=vs.85).aspx
 *
 */
'use strict';

tr.exportTo('tr.e.importer.etw', function() {
  // GUID and opcode of a Thread DCStart event, as defined at the link above.
  var kThreadGuid = '3D6FA8D1-FE05-11D0-9DDA-00C04FD7BA7C';
  var kThreadDCStartOpcode = 3;

  /**
   * Represents the raw bytes payload decoder.
   * @constructor
   */
  function Decoder() {
    this.payload_ = new DataView(new ArrayBuffer(256));
  };

  Decoder.prototype = {
    __proto__: Object.prototype,

    reset: function(base64_payload) {
      var decoded_size = tr.b.Base64.getDecodedBufferLength(base64_payload);
      if (decoded_size > this.payload_.byteLength)
        this.payload_ = new DataView(new ArrayBuffer(decoded_size));

      tr.b.Base64.DecodeToTypedArray(base64_payload, this.payload_);
      this.position_ = 0;
    },

    skip: function(length) {
      this.position_ += length;
    },

    decodeUInt8: function() {
      var result = this.payload_.getUint8(this.position_, true);
      this.position_ += 1;
      return result;
    },

    decodeUInt16: function() {
      var result = this.payload_.getUint16(this.position_, true);
      this.position_ += 2;
      return result;
    },

    decodeUInt32: function() {
      var result = this.payload_.getUint32(this.position_, true);
      this.position_ += 4;
      return result;
    },

    decodeUInt64ToString: function() {
      // Javascript isn't able to manage 64-bit numeric values.
      var low = this.decodeUInt32();
      var high = this.decodeUInt32();
      var low_str = ('0000000' + low.toString(16)).substr(-8);
      var high_str = ('0000000' + high.toString(16)).substr(-8);
      var result = high_str + low_str;
      return result;
    },

    decodeInt8: function() {
      var result = this.payload_.getInt8(this.position_, true);
      this.position_ += 1;
      return result;
    },

    decodeInt16: function() {
      var result = this.payload_.getInt16(this.position_, true);
      this.position_ += 2;
      return result;
    },

    decodeInt32: function() {
      var result = this.payload_.getInt32(this.position_, true);
      this.position_ += 4;
      return result;
    },

    decodeInt64ToString: function() {
      // Javascript isn't able to manage 64-bit numeric values.
      // Fallback to unsigned 64-bit hexa value.
      return this.decodeUInt64ToString();
    },

    decodeUInteger: function(is64) {
      if (is64)
        return this.decodeUInt64ToString();
      return this.decodeUInt32();
    },

    decodeString: function() {
      var str = '';
      while (true) {
        var c = this.decodeUInt8();
        if (!c)
          return str;
        str = str + String.fromCharCode(c);
      }
    },

    decodeW16String: function() {
      var str = '';
      while (true) {
        var c = this.decodeUInt16();
        if (!c)
          return str;
        str = str + String.fromCharCode(c);
      }
    },

    decodeFixedW16String: function(length) {
      var old_position = this.position_;
      var str = '';
      for (var i = 0; i < length; i++) {
        var c = this.decodeUInt16();
        if (!c)
          break;
        str = str + String.fromCharCode(c);
      }

      // Move the position after the fixed buffer (i.e. wchar[length]).
      this.position_ = old_position + 2 * length;
      return str;
    },

    decodeBytes: function(length) {
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        var c = this.decodeUInt8();
        bytes.push(c);
      }
      return bytes;
    },

    decodeSID: function(is64) {
      // Decode the TOKEN_USER structure.
      var pSid = this.decodeUInteger(is64);
      var attributes = this.decodeUInt32();

      // Skip padding.
      if (is64)
        this.decodeUInt32();

      // Decode the SID structure.
      var revision = this.decodeUInt8();
      var subAuthorityCount = this.decodeUInt8();
      this.decodeUInt16();
      this.decodeUInt32();

      if (revision != 1)
        throw 'Invalid SID revision: could not decode the SID structure.';

      var sid = this.decodeBytes(4 * subAuthorityCount);

      return {
        pSid: pSid,
        attributes: attributes,
        sid: sid
      };
    },

    decodeSystemTime: function() {
      // Decode the SystemTime structure.
      var wYear = this.decodeInt16();
      var wMonth = this.decodeInt16();
      var wDayOfWeek = this.decodeInt16();
      var wDay = this.decodeInt16();
      var wHour = this.decodeInt16();
      var wMinute = this.decodeInt16();
      var wSecond = this.decodeInt16();
      var wMilliseconds = this.decodeInt16();
      return {
        wYear: wYear,
        wMonth: wMonth,
        wDayOfWeek: wDayOfWeek,
        wDay: wDay,
        wHour: wHour,
        wMinute: wMinute,
        wSecond: wSecond,
        wMilliseconds: wMilliseconds
      };
    },

    decodeTimeZoneInformation: function() {
      // Decode the TimeZoneInformation structure.
      var bias = this.decodeUInt32();
      var standardName = this.decodeFixedW16String(32);
      var standardDate = this.decodeSystemTime();
      var standardBias = this.decodeUInt32();
      var daylightName = this.decodeFixedW16String(32);
      var daylightDate = this.decodeSystemTime();
      var daylightBias = this.decodeUInt32();
      return {
        bias: bias,
        standardName: standardName,
        standardDate: standardDate,
        standardBias: standardBias,
        daylightName: daylightName,
        daylightDate: daylightDate,
        daylightBias: daylightBias
      };
    }

  };

  /**
   * Imports Windows ETW kernel events into a specified model.
   * @constructor
   */
  function EtwImporter(model, events) {
    this.importPriority = 3;
    this.model_ = model;
    this.events_ = events;
    this.handlers_ = {};
    this.decoder_ = new Decoder();
    this.walltime_ = undefined;
    this.ticks_ = undefined;
    this.is64bit_ = undefined;

    // A map of tids to their process pid. On Windows, the tid is global to
    // the system and doesn't need to belong to a process. As many events
    // only provide tid, this map allows to retrieve the parent process.
    this.tidsToPid_ = {};

    // Instantiate the parsers; this will register handlers for known events.
    var allTypeInfos = tr.e.importer.etw.Parser.getAllRegisteredTypeInfos();
    this.parsers_ = allTypeInfos.map(
        function(typeInfo) {
          return new typeInfo.constructor(this);
        }, this);
  }

  /**
   * Guesses whether the provided events is from a Windows ETW trace.
   * The object must has a property named 'name' with the value 'ETW' and
   * a property 'content' with all the undecoded events.
   *
   * @return {boolean} True when events is a Windows ETW array.
   */
  EtwImporter.canImport = function(events) {
    if (!events.hasOwnProperty('name') ||
        !events.hasOwnProperty('content') ||
        events.name !== 'ETW') {
      return false;
    }

    return true;
  };

  EtwImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get model() {
      return this.model_;
    },

    createThreadIfNeeded: function(pid, tid) {
      this.tidsToPid_[tid] = pid;
    },

    removeThreadIfPresent: function(tid) {
      this.tidsToPid_[tid] = undefined;
    },

    getPidFromWindowsTid: function(tid) {
      if (tid == 0)
        return 0;
      var pid = this.tidsToPid_[tid];
      if (pid == undefined) {
        // Kernel threads are not defined.
        return 0;
      }
      return pid;
    },

    getThreadFromWindowsTid: function(tid) {
      var pid = this.getPidFromWindowsTid(tid);
      var process = this.model_.getProcess(pid);
      if (!process)
        return undefined;
      return process.getThread(tid);
    },

    /*
     * Retrieve the Cpu for a given cpuNumber.
     * @return {Cpu} A Cpu corresponding to the given cpuNumber.
     */
    getOrCreateCpu: function(cpuNumber) {
      var cpu = this.model_.kernel.getOrCreateCpu(cpuNumber);
      return cpu;
    },

    /**
     * Imports the data in this.events_ into this.model_.
     */
    importEvents: function(isSecondaryImport) {
      this.events_.content.forEach(this.parseInfo.bind(this));

      if (this.walltime_ == undefined || this.ticks_ == undefined)
        throw Error('Cannot find clock sync information in the system trace.');

      if (this.is64bit_ == undefined)
        throw Error('Cannot determine pointer size of the system trace.');

      this.events_.content.forEach(this.parseEvent.bind(this));
    },

    importTimestamp: function(timestamp) {
      var ts = parseInt(timestamp, 16);
      return (ts - this.walltime_ + this.ticks_) / 1000.;
    },

    parseInfo: function(event) {
      // Retrieve clock sync information.
      if (event.hasOwnProperty('guid') &&
          event.hasOwnProperty('walltime') &&
          event.hasOwnProperty('tick') &&
          event.guid === 'ClockSync') {
        this.walltime_ = parseInt(event.walltime, 16);
        this.ticks_ = parseInt(event.tick, 16);
      }

      // Retrieve pointer size information from a Thread.DCStart event.
      if (this.is64bit_ == undefined &&
          event.hasOwnProperty('guid') &&
          event.hasOwnProperty('op') &&
          event.hasOwnProperty('ver') &&
          event.hasOwnProperty('payload') &&
          event.guid === kThreadGuid &&
          event.op == kThreadDCStartOpcode) {
        var decoded_size = tr.b.Base64.getDecodedBufferLength(event.payload);

        if (event.ver == 1) {
          if (decoded_size >= 52)
            this.is64bit_ = true;
          else
            this.is64bit_ = false;
        } else if (event.ver == 2) {
          if (decoded_size >= 64)
            this.is64bit_ = true;
          else
            this.is64bit_ = false;
        } else if (event.ver == 3) {
          if (decoded_size >= 60)
            this.is64bit_ = true;
          else
            this.is64bit_ = false;
        }
      }

      return true;
    },

    parseEvent: function(event) {
      if (!event.hasOwnProperty('guid') ||
          !event.hasOwnProperty('op') ||
          !event.hasOwnProperty('ver') ||
          !event.hasOwnProperty('cpu') ||
          !event.hasOwnProperty('ts') ||
          !event.hasOwnProperty('payload')) {
        return false;
      }

      var timestamp = this.importTimestamp(event.ts);

      // Create the event header.
      var header = {
        guid: event.guid,
        opcode: event.op,
        version: event.ver,
        cpu: event.cpu,
        timestamp: timestamp,
        is64: this.is64bit_
      };

      // Set the payload to decode.
      var decoder = this.decoder_;
      decoder.reset(event.payload);

      // Retrieve the handler to decode the payload.
      var handler = this.getEventHandler(header.guid, header.opcode);
      if (!handler)
        return false;

      if (!handler(header, decoder)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Malformed ' + header.guid + ' event (' + text + ')'
        });
        return false;
      }

      return true;
    },

    /**
     * Registers a windows ETW event handler used by parseEvent().
     */
    registerEventHandler: function(guid, opcode, handler) {
      if (this.handlers_[guid] == undefined)
        this.handlers_[guid] = [];
      this.handlers_[guid][opcode] = handler;
    },

    /**
     * Retrieves a registered event handler.
     */
    getEventHandler: function(guid, opcode) {
      if (this.handlers_[guid] == undefined)
        return undefined;
      return this.handlers_[guid][opcode];
    }

  };

  // Register the EtwImporter to the Importer.
  tr.importer.Importer.register(EtwImporter);

  return {
    EtwImporter: EtwImporter
  };
});


'use strict';

tr.exportTo('tr.e.importer', function() {

  function Trace2HTMLImporter(model, events) {
    this.importPriority = 0;
  }

  Trace2HTMLImporter.subtraces_ = [];

  function _extractEventsFromHTML(text) {
    // Clear the array before pushing data to it.
    Trace2HTMLImporter.subtraces_ = [];

    var r = new tr.importer.SimpleLineReader(text);

    // Try to find viewer-data...
    while (true) {
      if (!r.advanceToLineMatching(
          new RegExp('^<\s*script id="viewer-data" ' +
                     'type="(application\/json|text\/plain)">$')))
        break;

      r.beginSavingLines();
      if (!r.advanceToLineMatching(/^<\/\s*script>$/))
        return failure;

      var raw_events = r.endSavingLinesAndGetResult();

      // Drop off first and last event as it contains the end script tag.
      raw_events = raw_events.slice(1, raw_events.length - 1);
      var data64 = raw_events.join('\n');
      var buffer = new ArrayBuffer(
          tr.b.Base64.getDecodedBufferLength(data64));
      var len = tr.b.Base64.DecodeToTypedArray(data64, new DataView(buffer));
      Trace2HTMLImporter.subtraces_.push(buffer.slice(0, len));
    }
  }

  function _canImportFromHTML(text) {
    if (/^<!DOCTYPE HTML>/.test(text) === false)
      return false;

    // Try to find viewer-data...
    _extractEventsFromHTML(text);
    if (Trace2HTMLImporter.subtraces_.length === 0)
      return false;
    return true;
  }

  Trace2HTMLImporter.canImport = function(events) {
    return _canImportFromHTML(events);
  };

  Trace2HTMLImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    isTraceDataContainer: function() {
      return true;
    },

    extractSubtraces: function() {
      return Trace2HTMLImporter.subtraces_;
    },

    importEvents: function() {
    }
  };


  tr.importer.Importer.register(Trace2HTMLImporter);


  return {
    Trace2HTMLImporter: Trace2HTMLImporter
  };
});


'use strict';

tr.exportTo('tr.e.net', function() {
  var AsyncSlice = tr.model.AsyncSlice;

  function NetAsyncSlice() {
    AsyncSlice.apply(this, arguments);
    // A boolean variable indicates whether we have computed the title.
    this.isTitleComputed_ = false;
  }

  NetAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    get viewSubGroupTitle() {
      return 'NetLog';
    },

    get title() {
      if (this.isTitleComputed_ || !this.isTopLevel) {
        return this.title_;
      }

      // A recursive helper function that gets the url param of a slice or its
      // nested subslices if there is one.
      var getUrl = function(slice) {
        if (slice.args !== undefined && slice.args.params !== undefined &&
            slice.args.params.url !== undefined) {
          return slice.args.params.url;
        }
        if (slice.subSlices === undefined || slice.subSlices.length === 0)
          return undefined;
        for (var i = 0; i < slice.subSlices.length; i++) {
          var result = getUrl(slice.subSlices[i]);
          if (result !== undefined)
            return result;
        }
        return undefined;
      };

      var url = getUrl(this);
      if (url !== undefined && url.length > 0) {
        // Set the title so we do not have to recompute when it is redrawn.
        this.title_ = url;
      } else if (this.args !== undefined &&
                 this.args.source_type !== undefined) {
        // We do not have a URL, use the source type as the title.
        this.title_ = this.args.source_type;
      }
      this.isTitleComputed_ = true;
      return this.title_;
    },

    set title(title) {
      this.title_ = title;
    }
  };

  AsyncSlice.register(
    NetAsyncSlice,
    {
      categoryParts: ['netlog', 'disabled-by-default-netlog']
    });

  return {
    NetAsyncSlice: NetAsyncSlice
  };
});


'use strict';

/**
 * @fileoverview Provides the LayoutObject class.
 */
tr.exportTo('tr.e.chrome', function() {
  var KNOWN_PROPERTIES = {
    children: 1,
    name: 1,
    address: 1
  };

  /**
   * @constructor
   */
  function LayoutObject(snapshot, args) {
    this.snapshot_ = snapshot;
    this.id_ = args.address;
    this.name_ = args.name;
    this.childLayoutObjects_ = [];
    this.otherProperties_ = {};

    if (args.children) {
      args.children.forEach(function(child) {
        this.childLayoutObjects_.push(new LayoutObject(snapshot, child));
      }.bind(this));
    }

    for (var property in args) {
      if (!KNOWN_PROPERTIES[property])
        this.otherProperties_[property] = args[property];
    }
  }

  LayoutObject.prototype = {
    get snapshot() {
      return this.snapshot_;
    },

    get id() {
      return this.id_;
    },

    get name() {
      return this.name_;
    },

    get hasChildLayoutObjects() {
      return this.childLayoutObjects_.length > 0;
    },

    get childLayoutObjects() {
      return this.childLayoutObjects_;
    },

    traverseTree: function(cb, opt_this) {
      cb.call(opt_this, this);
      if (!this.hasChildLayoutObjects)
        return;
      this.childLayoutObjects.forEach(function(child) {
        child.traverseTree(cb, opt_this);
      });
    },

    get otherPropertyNames() {
      var names = [];
      for (var name in this.otherProperties_) {
        names.push(name);
      }
      return names;
    },

    getProperty: function(name) {
      return this.otherProperties_[name];
    },

    get previousSnapshotLayoutObject() {
      if (!this.snapshot.previousSnapshot)
        return undefined;
      return this.snapshot.previousSnapshot.getLayoutObjectById(this.id);
    },

    get nextSnapshotLayoutObject() {
      if (!this.snapshot.nextSnapshot)
        return undefined;
      return this.snapshot.nextSnapshot.getLayoutObjectById(this.id);
    }
  };

  return {
    LayoutObject: LayoutObject
  };
});


'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
tr.exportTo('tr.e.audits', function() {
  var MAIN_FRAMETIME_TYPE = 'main_frametime_type';
  var IMPL_FRAMETIME_TYPE = 'impl_frametime_type';

  var MAIN_RENDERING_STATS =
      'BenchmarkInstrumentation::MainThreadRenderingStats';
  var IMPL_RENDERING_STATS =
      'BenchmarkInstrumentation::ImplThreadRenderingStats';


  function getSlicesIntersectingRange(rangeOfInterest, slices) {
    var slicesInFilterRange = [];
    for (var i = 0; i < slices.length; i++) {
      var slice = slices[i];
      if (rangeOfInterest.intersectsExplicitRange(slice.start, slice.end))
        slicesInFilterRange.push(slice);
    }
    return slicesInFilterRange;
  }


  function ChromeProcessHelper(modelHelper, process) {
    this.modelHelper = modelHelper;
    this.process = process;
  }

  ChromeProcessHelper.prototype = {
    get pid() {
      return this.process.pid;
    },

    getFrameEventsInRange: function(frametimeType, range) {
      var titleToGet;
      if (frametimeType == MAIN_FRAMETIME_TYPE)
        titleToGet = MAIN_RENDERING_STATS;
      else
        titleToGet = IMPL_RENDERING_STATS;

      var frameEvents = [];
      this.process.iterateAllEvents(function(event) {
        if (event.title !== titleToGet)
          return;
        if (range.intersectsExplicitRange(event.start, event.end))
          frameEvents.push(event);
      });

      frameEvents.sort(function(a, b) {return a.start - b.start});
      return frameEvents;
    }
  };

  function getFrametimeDataFromEvents(frameEvents) {
    var frametimeData = [];
    for (var i = 1; i < frameEvents.length; i++) {
      var diff = frameEvents[i].start - frameEvents[i - 1].start;
      frametimeData.push({
        'x': frameEvents[i].start,
        'frametime': diff
      });
    }
    return frametimeData;
  }

  return {
    ChromeProcessHelper: ChromeProcessHelper,

    MAIN_FRAMETIME_TYPE: MAIN_FRAMETIME_TYPE,
    IMPL_FRAMETIME_TYPE: IMPL_FRAMETIME_TYPE,
    MAIN_RENDERING_STATS: MAIN_RENDERING_STATS,
    IMPL_RENDERING_STATS: IMPL_RENDERING_STATS,

    getSlicesIntersectingRange: getSlicesIntersectingRange,
    getFrametimeDataFromEvents: getFrametimeDataFromEvents
  };
});


'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
tr.exportTo('tr.e.audits', function() {
  function ChromeBrowserHelper(modelHelper, process) {
    tr.e.audits.ChromeProcessHelper.call(this, modelHelper, process);
    this.mainThread_ = process.findAtMostOneThreadNamed('CrBrowserMain');
  }

  ChromeBrowserHelper.isBrowserProcess = function(process) {
    return !!process.findAtMostOneThreadNamed('CrBrowserMain');
  };

  ChromeBrowserHelper.prototype = {
    __proto__: tr.e.audits.ChromeProcessHelper.prototype,

    get rendererHelpers() {
      return this.modelHelper.rendererHelpers;
    },

    getLoadingEventsInRange: function(rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function(slice) {
        return slice.title.indexOf('WebContentsImpl Loading') === 0 &&
            rangeOfInterest.intersectsExplicitRange(slice.start, slice.end);
      });
    },

    getCommitProvisionalLoadEventsInRange: function(rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function(slice) {
        return slice.title === 'RenderFrameImpl::didCommitProvisionalLoad' &&
            rangeOfInterest.intersectsExplicitRange(slice.start, slice.end);
      });
    },

    get hasLatencyEvents() {
      var hasLatency = false;
      this.modelHelper.model.getAllThreads().some(function(thread) {
        thread.iterateAllEvents(function(event) {
          if (!event.isTopLevel)
            return;
          if (!(event instanceof tr.e.cc.InputLatencyAsyncSlice))
            return;
          hasLatency = true;
        });
        return hasLatency;
      });
      return hasLatency;
    },

    getLatencyEventsInRange: function(rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function(slice) {
        return (slice.title.indexOf('InputLatency') === 0) &&
            rangeOfInterest.intersectsExplicitRange(slice.start, slice.end);
      });
    },

    getAllAsyncSlicesMatching: function(pred, opt_this) {
      var events = [];
      this.iterAllThreads(function(thread) {
        thread.iterateAllEvents(function(slice) {
          if (pred.call(opt_this, slice))
            events.push(slice);
        });
      });
      return events;
    },

    getAllNetworkEventsInRange: function(rangeOfInterest) {
      var networkEvents = [];
      this.modelHelper.model.getAllThreads().forEach(function(thread) {
        thread.asyncSliceGroup.slices.forEach(function(slice) {
          var match = false;
          if (slice.category == 'net' ||  // old-style URLRequest/Resource
              slice.category == 'disabled-by-default-netlog' ||
              slice.category == 'netlog') {
            match = true;
          }

          if (!match)
            return;

          if (rangeOfInterest.intersectsExplicitRange(slice.start, slice.end))
            networkEvents.push(slice);
        });
      });
      return networkEvents;
    },

    iterAllThreads: function(func, opt_this) {
      tr.b.iterItems(this.process.threads, function(tid, thread) {
        func.call(opt_this, thread);
      });

      tr.b.iterItems(this.rendererHelpers, function(pid, rendererHelper) {
        var rendererProcess = rendererHelper.process;
        tr.b.iterItems(rendererProcess.threads, function(tid, thread) {
          func.call(opt_this, thread);
        });
      }, this);
    }
  };

  return {
    ChromeBrowserHelper: ChromeBrowserHelper
  };
});


'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
tr.exportTo('tr.e.audits', function() {
  function ChromeRendererHelper(modelHelper, process) {
    tr.e.audits.ChromeProcessHelper.call(this, modelHelper, process);
    this.mainThread_ = process.findAtMostOneThreadNamed('CrRendererMain');
    this.compositorThread_ = process.findAtMostOneThreadNamed('Compositor');
    this.rasterWorkerThreads_ = process.findAllThreadsMatching(function(t) {
      if (t.name === undefined)
        return false;
      if (t.name.indexOf('CompositorTileWorker') === 0)
        return true;
      if (t.name.indexOf('CompositorRasterWorker') === 0)
        return true;
      return false;
    });
  };

  ChromeRendererHelper.isRenderProcess = function(process) {
    if (!process.findAtMostOneThreadNamed('CrRendererMain'))
      return false;
    if (!process.findAtMostOneThreadNamed('Compositor'))
      return false;
    return true;
  };

  ChromeRendererHelper.prototype = {
    __proto__: tr.e.audits.ChromeProcessHelper.prototype,

    get mainThread() {
      return this.mainThread_;
    },

    get compositorThread() {
      return this.compositorThread_;
    },

    get rasterWorkerThreads() {
      return this.rasterWorkerThreads_;
    }
  };

  return {
    ChromeRendererHelper: ChromeRendererHelper
  };
});


'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
tr.exportTo('tr.e.audits', function() {
  function findChromeBrowserProcess(model) {
    var browserProcesses = [];
    model.getAllProcesses().forEach(function(process) {
      if (!tr.e.audits.ChromeBrowserHelper.isBrowserProcess(process))
        return;
      browserProcesses.push(process);
    }, this);
    if (browserProcesses.length === 0)
      return undefined;
    if (browserProcesses.length > 1)
      return undefined;
    return browserProcesses[0];
  }

  function findChromeRenderProcesses(model) {
    var rendererProcesses = [];
    model.getAllProcesses().forEach(function(process) {
      if (!tr.e.audits.ChromeRendererHelper.isRenderProcess(process))
        return;
      rendererProcesses.push(process);
    });
    return rendererProcesses;
  }

  /**
   * @constructor
   */
  function ChromeModelHelper(model) {
    this.model_ = model;

    // Find browserHelper.
    this.browserProcess_ = findChromeBrowserProcess(model);
    if (this.browserProcess_) {
      this.browserHelper_ = new tr.e.audits.ChromeBrowserHelper(
          this, this.browserProcess_);
    } else {
      this.browserHelper_ = undefined;
    }

    // Find rendererHelpers.
    var rendererProcesses_ = findChromeRenderProcesses(model);

    this.rendererHelpers_ = {};
    rendererProcesses_.forEach(function(renderProcess) {
      var rendererHelper = new tr.e.audits.ChromeRendererHelper(
        this, renderProcess);
      this.rendererHelpers_[rendererHelper.pid] = rendererHelper;
    }, this);
  }

  ChromeModelHelper.supportsModel = function(model) {
    if (findChromeBrowserProcess(model) !== undefined)
      return true;
    if (findChromeRenderProcesses(model).length)
      return true;
    return false;
  }

  ChromeModelHelper.prototype = {
    get pid() {
      throw new Error('woah');
    },

    get process() {
      throw new Error('woah');
    },

    get model() {
      return this.model_;
    },

    get browserProcess() {
      return this.browserProcess_;
    },

    get browserHelper() {
      return this.browserHelper_;
    },

    get rendererHelpers() {
      return this.rendererHelpers_;
    }
  };

  return {
    ChromeModelHelper: ChromeModelHelper
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  var AsyncSlice = tr.model.AsyncSlice;
  var EventSet = tr.model.EventSet;

  var UI_COMP_NAME = 'INPUT_EVENT_LATENCY_UI_COMPONENT';
  var ORIGINAL_COMP_NAME = 'INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT';
  var BEGIN_COMP_NAME = 'INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT';
  var END_COMP_NAME = 'INPUT_EVENT_LATENCY_TERMINATED_FRAME_SWAP_COMPONENT';

  var MAIN_RENDERER_THREAD_NAME = 'CrRendererMain';
  var COMPOSITOR_THREAD_NAME = 'Compositor';

  var POSTTASK_FLOW_EVENT = 'disabled-by-default-toplevel.flow';
  var IPC_FLOW_EVENT = 'disabled-by-default-ipc.flow';

  var INPUT_EVENT_TYPE_NAMES = {
    CHAR: 'Char',
    CLICK: 'GestureClick',
    CONTEXT_MENU: 'ContextMenu',
    FLING_CANCEL: 'GestureFlingCancel',
    FLING_START: 'GestureFlingStart',
    KEY_DOWN: 'KeyDown',
    KEY_DOWN_RAW: 'RawKeyDown',
    KEY_UP: 'KeyUp',
    LATENCY_SCROLL_UPDATE: 'ScrollUpdate',
    MOUSE_DOWN: 'MouseDown',
    MOUSE_ENTER: 'MouseEnter',
    MOUSE_LEAVE: 'MouseLeave',
    MOUSE_MOVE: 'MouseMove',
    MOUSE_UP: 'MouseUp',
    MOUSE_WHEEL: 'MouseWheel',
    PINCH_BEGIN: 'GesturePinchBegin',
    PINCH_END: 'GesturePinchEnd',
    PINCH_UPDATE: 'GesturePinchUpdate',
    SCROLL_BEGIN: 'GestureScrollBegin',
    SCROLL_END: 'GestureScrollEnd',
    SCROLL_UPDATE: 'GestureScrollUpdate',
    SCROLL_UPDATE_RENDERER: 'ScrollUpdate',
    SHOW_PRESS: 'GestureShowPress',
    TAP: 'GestureTap',
    TAP_CANCEL: 'GestureTapCancel',
    TAP_DOWN: 'GestureTapDown',
    TOUCH_CANCEL: 'TouchCancel',
    TOUCH_END: 'TouchEnd',
    TOUCH_MOVE: 'TouchMove',
    TOUCH_START: 'TouchStart',
    UNKNOWN: 'UNKNOWN'
  };

  function InputLatencyAsyncSlice() {
    AsyncSlice.apply(this, arguments);
    this.associatedEvents_ = new EventSet();
    this.typeName_ = undefined;
    if (!this.isLegacyEvent)
      this.determineModernTypeName_();
  }

  InputLatencyAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    // Legacy InputLatencyAsyncSlices involve a top-level slice titled
    // "InputLatency" containing a subSlice whose title starts with
    // "InputLatency:". Modern InputLatencyAsyncSlices involve a single
    // top-level slice whose title starts with "InputLatency::".
    // Legacy subSlices are not available at construction time, so
    // determineLegacyTypeName_() must be called at get time.
    // So this returns false for the legacy subSlice events titled like
    // "InputLatency:Foo" even though they are technically legacy events.
    get isLegacyEvent() {
      return this.title === 'InputLatency';
    },

    get typeName() {
      if (!this.typeName_)
        this.determineLegacyTypeName_();
      return this.typeName_;
    },

    checkTypeName_: function() {
      if (!this.typeName_)
        throw 'Unable to determine typeName';
      var found = false;
      for (var type_name in INPUT_EVENT_TYPE_NAMES) {
        if (this.typeName === INPUT_EVENT_TYPE_NAMES[type_name]) {
          found = true;
          break;
        }
      }
      if (!found)
        this.typeName_ = INPUT_EVENT_TYPE_NAMES.UNKNOWN;
    },

    determineModernTypeName_: function() {
      // This method works both on modern events titled like
      // "InputLatency::Foo" and also on the legacy subSlices titled like
      // "InputLatency:Foo". Modern events' titles contain 2 colons, whereas the
      // legacy subSlices events contain 1 colon.

      var lastColonIndex = this.title.lastIndexOf(':');
      if (lastColonIndex < 0)
        return;

      var characterAfterLastColonIndex = lastColonIndex + 1;
      this.typeName_ = this.title.slice(characterAfterLastColonIndex);

      // Check that the determined typeName is known.
      this.checkTypeName_();
    },

    determineLegacyTypeName_: function() {
      // Iterate over all descendent subSlices.
      this.iterateAllDescendents(function(subSlice) {

        // If |subSlice| is not an InputLatencyAsyncSlice, then ignore it.
        var subSliceIsAInputLatencyAsyncSlice = (
            subSlice instanceof InputLatencyAsyncSlice);
        if (!subSliceIsAInputLatencyAsyncSlice)
          return;

        // If |subSlice| does not have a typeName, then ignore it.
        if (!subSlice.typeName)
          return;

        // If |this| already has a typeName and |subSlice| has a different
        // typeName, then explode!
        if (this.typeName_ && subSlice.typeName_) {
          var subSliceHasDifferentTypeName = (
              this.typeName_ !== subSlice.typeName_);
          if (subSliceHasDifferentTypeName) {
            throw 'InputLatencyAsyncSlice.determineLegacyTypeName_() ' +
              ' found multiple typeNames';
          }
        }

        // The typeName of |this| top-level event is whatever the typeName of
        // |subSlice| is. Set |this.typeName_| to the subSlice's typeName.
        this.typeName_ = subSlice.typeName_;
      }, this);

      // If typeName could not be determined, then explode!
      if (!this.typeName_)
        throw 'InputLatencyAsyncSlice.determineLegacyTypeName_() failed';

      // Check that the determined typeName is known.
      this.checkTypeName_();
    },

    getRendererHelper: function(sourceSlices) {
      var traceModel = this.startThread.parent.model;
      if (!tr.e.audits.ChromeModelHelper.supportsModel(traceModel))
        return undefined;

      var mainThread = undefined;
      var compositorThread = undefined;

      for (var i in sourceSlices) {
        if (sourceSlices[i].parentContainer.name ===
            MAIN_RENDERER_THREAD_NAME)
          mainThread = sourceSlices[i].parentContainer;
        else if (sourceSlices[i].parentContainer.name ===
            COMPOSITOR_THREAD_NAME)
          compositorThread = sourceSlices[i].parentContainer;

        if (mainThread && compositorThread)
          break;
      }

      var modelHelper = new tr.e.audits.ChromeModelHelper(traceModel);
      var rendererHelpers = modelHelper.rendererHelpers;

      var pids = Object.keys(rendererHelpers);
      for (var i = 0; i < pids.length; i++) {
        var pid = pids[i];
        var rendererHelper = rendererHelpers[pid];
        if (rendererHelper.mainThread === mainThread ||
            rendererHelper.compositorThread === compositorThread)
          return rendererHelper;
      }

      return undefined;
    },

    addEntireSliceHierarchy: function(slice) {
      this.associatedEvents_.push(slice);
      slice.iterateAllSubsequentSlices(function(subsequentSlice) {
        this.associatedEvents_.push(subsequentSlice);
      }, this);
    },

    addDirectlyAssociatedEvents: function(flowEvents) {
      var slices = [];

      flowEvents.forEach(function(flowEvent) {
        this.associatedEvents_.push(flowEvent);
        var newSource = flowEvent.startSlice.mostTopLevelSlice;
        if (slices.indexOf(newSource) === -1)
          slices.push(newSource);
      }, this);

      var lastFlowEvent = flowEvents[flowEvents.length - 1];
      var lastSource = lastFlowEvent.endSlice.mostTopLevelSlice;
      if (slices.indexOf(lastSource) === -1)
        slices.push(lastSource);

      return slices;
    },

    // Find the Latency::ScrollUpdate slice that corresponds to the
    // InputLatency::GestureScrollUpdate slice.
    // The C++ CL that makes this connection is at:
    // https://codereview.chromium.org/1178963003
    addScrollUpdateEvents: function(rendererHelper) {
      if (!rendererHelper || !rendererHelper.compositorThread)
        return;

      var compositorThread = rendererHelper.compositorThread;
      var gestureScrollUpdateStart = this.start;
      var gestureScrollUpdateEnd = this.end;

      var allCompositorAsyncSlices =
        compositorThread.asyncSliceGroup.slices;

      for (var i in allCompositorAsyncSlices) {
        var slice = allCompositorAsyncSlices[i];

        if (slice.title !== 'Latency::ScrollUpdate')
          continue;

        var parentId = slice.args.data.
            INPUT_EVENT_LATENCY_FORWARD_SCROLL_UPDATE_TO_MAIN_COMPONENT.
            sequence_number;

        if (parentId === undefined) {
          // Old trace, we can only rely on the timestamp to find the slice
          if (slice.start < gestureScrollUpdateStart ||
              slice.start >= gestureScrollUpdateEnd)
            continue;
        } else {
          // New trace, we can definitively find the latency slice by comparing
          // its sequence number with gesture id
          if (parseInt(parentId) !== parseInt(this.id))
            continue;
        }

        slice.associatedEvents.forEach(function(event) {
          this.associatedEvents_.push(event);
        }, this);
        break;
      }
    },

    // Return true if the slice hierarchy is tracked by LatencyInfo of other
    // input latency events. If the slice hierarchy is tracked by both, this
    // function still returns true.
    belongToOtherInputs: function(slice, flowEvents) {
      var fromOtherInputs = false;

      slice.iterateEntireHierarchy(function(subsequentSlice) {
        if (fromOtherInputs)
          return;

        subsequentSlice.inFlowEvents.forEach(function(inflow) {
          if (fromOtherInputs)
            return;

          if (inflow.category.indexOf('input') > -1) {
            if (flowEvents.indexOf(inflow) === -1)
              fromOtherInputs = true;
          }
        }, this);
      }, this);

      return fromOtherInputs;
    },

    // Return true if |event| triggers slices of other inputs.
    triggerOtherInputs: function(event, flowEvents) {
      if (event.outFlowEvents === undefined ||
          event.outFlowEvents.length === 0)
        return false;

      // Once we fix the bug of flow event binding, there should exist one and
      // only one outgoing flow (PostTask) from ScheduleBeginImplFrameDeadline
      // and PostComposite.
      var flow = event.outFlowEvents[0];

      if (flow.category !== POSTTASK_FLOW_EVENT ||
          !flow.endSlice)
        return false;

      var endSlice = flow.endSlice;
      if (this.belongToOtherInputs(endSlice.mostTopLevelSlice, flowEvents))
        return true;

      return false;
    },

    // Follow outgoing flow of subsequentSlices in the current hierarchy.
    // We also handle cases where different inputs interfere with each other.
    followSubsequentSlices: function(event, queue, visited, flowEvents) {
      var stopFollowing = false;
      var inputAck = false;

      event.iterateAllSubsequentSlices(function(slice) {
        if (stopFollowing)
          return;

        // Do not follow TaskQueueManager::RunTask because it causes
        // many false events to be included.
        if (slice.title === 'TaskQueueManager::RunTask')
          return;

        // Do not follow ScheduledActionSendBeginMainFrame because the real
        // main thread BeginMainFrame is already traced by LatencyInfo flow.
        if (slice.title === 'ThreadProxy::ScheduledActionSendBeginMainFrame')
          return;

        // Do not follow ScheduleBeginImplFrameDeadline that triggers an
        // OnBeginImplFrameDeadline that is tracked by another LatencyInfo.
        if (slice.title === 'Scheduler::ScheduleBeginImplFrameDeadline') {
          if (this.triggerOtherInputs(slice, flowEvents))
            return;
        }

        // Do not follow PostComposite that triggers CompositeImmediately
        // that is tracked by another LatencyInfo.
        if (slice.title === 'CompositorImpl::PostComposite') {
          if (this.triggerOtherInputs(slice, flowEvents))
            return;
        }

        // Stop following the rest of the current slice hierarchy if
        // FilterAndSendWebInputEvent occurs after ProcessInputEventAck.
        if (slice.title === 'InputRouterImpl::ProcessInputEventAck')
          inputAck = true;
        if (inputAck &&
            slice.title === 'InputRouterImpl::FilterAndSendWebInputEvent')
          stopFollowing = true;

        this.followCurrentSlice(slice, queue, visited);
      }, this);
    },

    // Follow outgoing flow events of the current slice.
    followCurrentSlice: function(event, queue, visited) {
      event.outFlowEvents.forEach(function(outflow) {
        if ((outflow.category === POSTTASK_FLOW_EVENT ||
            outflow.category === IPC_FLOW_EVENT) &&
            outflow.endSlice) {
          this.associatedEvents_.push(outflow);

          var nextEvent = outflow.endSlice.mostTopLevelSlice;
          if (!visited.contains(nextEvent)) {
            visited.push(nextEvent);
            queue.push(nextEvent);
          }
        }
      }, this);
    },

    backtraceFromDraw: function(beginImplFrame, visited) {
      var pendingEventQueue = [];
      pendingEventQueue.push(beginImplFrame.mostTopLevelSlice);

      while (pendingEventQueue.length !== 0) {
        var event = pendingEventQueue.pop();

        this.addEntireSliceHierarchy(event);

        // TODO(yuhao): For now, we backtrace all the way to the source input.
        // But is this really needed? I will have an entry in the design
        // doc to discuss this.
        event.inFlowEvents.forEach(function(inflow) {
          if (inflow.category === POSTTASK_FLOW_EVENT && inflow.startSlice) {
            var nextEvent = inflow.startSlice.mostTopLevelSlice;
            if (!visited.contains(nextEvent)) {
              visited.push(nextEvent);
              pendingEventQueue.push(nextEvent);
            }
          }
        }, this);
      }
    },

    sortRasterizerSlices: function(rasterWorkerThreads,
        sortedRasterizerSlices) {
      rasterWorkerThreads.forEach(function(rasterizer) {
        Array.prototype.push.apply(sortedRasterizerSlices,
            rasterizer.sliceGroup.slices);
      }, this);

      sortedRasterizerSlices.sort(function(a, b) {
        if (a.start !== b.start)
          return a.start - b.start;
        return a.guid - b.guid;
      });
    },

    // Find rasterization slices that have the source_prepare_tiles_id
    // same as the prepare_tiles_id of TileManager::PrepareTiles
    // The C++ CL that makes this connection is at:
    // https://codereview.chromium.org/1208683002/
    addRasterizationEvents: function(prepareTiles, rendererHelper,
        visited, flowEvents, sortedRasterizerSlices) {
      if (!prepareTiles.args.prepare_tiles_id)
        return;

      if (!rendererHelper || !rendererHelper.rasterWorkerThreads)
        return;

      var rasterWorkerThreads = rendererHelper.rasterWorkerThreads;
      var prepare_tile_id = prepareTiles.args.prepare_tiles_id;
      var pendingEventQueue = [];

      // Collect all the rasterizer tasks. Return the cached copy if possible.
      if (sortedRasterizerSlices.length === 0)
        this.sortRasterizerSlices(rasterWorkerThreads, sortedRasterizerSlices);

      // TODO(yuhao): Once TaskSetFinishedTaskImpl also get the prepare_tile_id
      // we can simply track by checking id rather than counting.
      var numFinishedTasks = 0;
      var RASTER_TASK_TITLE = 'RasterizerTaskImpl::RunOnWorkerThread';
      var IMAGEDECODE_TASK_TITLE = 'ImageDecodeTaskImpl::RunOnWorkerThread';
      var FINISHED_TASK_TITLE = 'TaskSetFinishedTaskImpl::RunOnWorkerThread';

      for (var i = 0; i < sortedRasterizerSlices.length; i++) {
        var task = sortedRasterizerSlices[i];

        if (task.title === RASTER_TASK_TITLE ||
            task.title === IMAGEDECODE_TASK_TITLE) {
          if (task.args.source_prepare_tiles_id === prepare_tile_id)
            this.addEntireSliceHierarchy(task.mostTopLevelSlice);
        } else if (task.title === FINISHED_TASK_TITLE) {
          if (task.start > prepareTiles.start) {
            pendingEventQueue.push(task.mostTopLevelSlice);
            if (++numFinishedTasks === 3)
              break;
          }
        }
      }

      // Trace PostTask from rasterizer tasks.
      while (pendingEventQueue.length != 0) {
        var event = pendingEventQueue.pop();

        this.addEntireSliceHierarchy(event);
        this.followSubsequentSlices(event, pendingEventQueue, visited,
            flowEvents);
      }
    },

    addOtherCausallyRelatedEvents: function(rendererHelper, sourceSlices,
        flowEvents, sortedRasterizerSlices) {
      var pendingEventQueue = [];
      // Keep track of visited nodes when traversing a DAG
      var visitedEvents = new EventSet();
      var beginImplFrame = undefined;
      var prepareTiles = undefined;
      var sortedRasterizerSlices = [];

      sourceSlices.forEach(function(sourceSlice) {
        if (!visitedEvents.contains(sourceSlice)) {
          visitedEvents.push(sourceSlice);
          pendingEventQueue.push(sourceSlice);
        }
      }, this);

      while (pendingEventQueue.length != 0) {
        var event = pendingEventQueue.pop();

        // Push the current event chunk into associatedEvents.
        this.addEntireSliceHierarchy(event);

        this.followCurrentSlice(event, pendingEventQueue, visitedEvents);

        this.followSubsequentSlices(event, pendingEventQueue, visitedEvents,
            flowEvents);

        // The rasterization work (CompositorTileWorker thread) and the
        // Compositor tile manager are connect by the prepare_tiles_id
        // instead of flow events.
        var COMPOSITOR_PREPARE_TILES = 'TileManager::PrepareTiles';
        prepareTiles = event.findDescendentSlice(COMPOSITOR_PREPARE_TILES);
        if (prepareTiles)
           this.addRasterizationEvents(prepareTiles, rendererHelper,
               visitedEvents, flowEvents, sortedRasterizerSlices);

        // OnBeginImplFrameDeadline could be triggered by other inputs.
        // For now, we backtrace from it.
        // TODO(yuhao): There are more such slices that we need to backtrace
        var COMPOSITOR_ON_BIFD = 'Scheduler::OnBeginImplFrameDeadline';
        beginImplFrame = event.findDescendentSlice(COMPOSITOR_ON_BIFD);
        if (beginImplFrame)
          this.backtraceFromDraw(beginImplFrame, visitedEvents);
      }

      // A separate pass on GestureScrollUpdate.
      // Scroll update doesn't go through the main thread, but the compositor
      // may go back to the main thread if there is an onscroll event handler.
      // This is captured by a different flow event, which does not have the
      // same ID as the Input Latency Event, but it is technically causally
      // related to the GestureScrollUpdate input. Add them manually for now.
      var INPUT_GSU = 'InputLatency::GestureScrollUpdate';
      if (this.title === INPUT_GSU)
        this.addScrollUpdateEvents(rendererHelper);
    },

    get associatedEvents() {
      if (this.associatedEvents_.length !== 0)
        return this.associatedEvents_;

      var modelIndices = this.startThread.parent.model.modelIndices;
      var flowEvents = modelIndices.getFlowEventsWithId(this.id);

      if (flowEvents.length === 0)
        return this.associatedEvents_;

      // Step 1: Get events that are directly connected by the LatencyInfo
      // flow events. This gives us a small set of events that are guaranteed
      // to be associated with the input, but are almost certain incomplete.
      // We call this set "source" event set.
      // This step returns the "source" event set (sourceSlices), which is then
      // used in the second step.
      var sourceSlices = this.addDirectlyAssociatedEvents(flowEvents);

      // Step 2: Start from the previously constructed "source" event set, we
      // follow the toplevel (i.e., PostTask) and IPC flow events. Any slices
      // that are reachable from the "source" event set via PostTasks or IPCs
      // are conservatively considered associated with the input event.
      // We then deal with specific cases where flow events either over include
      // or miss capturing slices.
      var rendererHelper = this.getRendererHelper(sourceSlices);
      this.addOtherCausallyRelatedEvents(rendererHelper, sourceSlices,
          flowEvents);

      return this.associatedEvents_;
    },

    get inputLatency() {
      if (!('data' in this.args))
        return undefined;

      var data = this.args.data;
      if (!(END_COMP_NAME in data))
        return undefined;

      var latency = 0;
      var endTime = data[END_COMP_NAME].time;
      if (ORIGINAL_COMP_NAME in data) {
        latency = endTime - data[ORIGINAL_COMP_NAME].time;
      } else if (UI_COMP_NAME in data) {
        latency = endTime - data[UI_COMP_NAME].time;
      } else if (BEGIN_COMP_NAME in data) {
        latency = endTime - data[BEGIN_COMP_NAME].time;
      } else {
        throw new Error('No valid begin latency component');
      }
      return latency;
    }
  };

  var eventTypeNames = [
    'Char',
    'ContextMenu',
    'GestureClick',
    'GestureFlingCancel',
    'GestureFlingStart',
    'GestureScrollBegin',
    'GestureScrollEnd',
    'GestureScrollUpdate',
    'GestureShowPress',
    'GestureTap',
    'GestureTapCancel',
    'GestureTapDown',
    'GesturePinchBegin',
    'GesturePinchEnd',
    'GesturePinchUpdate',
    'KeyDown',
    'KeyUp',
    'MouseDown',
    'MouseEnter',
    'MouseLeave',
    'MouseMove',
    'MouseUp',
    'MouseWheel',
    'RawKeyDown',
    'ScrollUpdate',
    'TouchCancel',
    'TouchEnd',
    'TouchMove',
    'TouchStart'
  ];
  var allTypeNames = ['InputLatency'];
  eventTypeNames.forEach(function(eventTypeName) {
    // Old style.
    allTypeNames.push('InputLatency:' + eventTypeName);

    // New style.
    allTypeNames.push('InputLatency::' + eventTypeName);
  });

  AsyncSlice.register(
    InputLatencyAsyncSlice,
    {
      typeNames: allTypeNames,
      categoryParts: ['latencyInfo']
    });

  return {
    InputLatencyAsyncSlice: InputLatencyAsyncSlice,
    INPUT_EVENT_TYPE_NAMES: INPUT_EVENT_TYPE_NAMES
  };
});


'use strict';

/**
 * @fileoverview Base class for trace data Auditors.
 */
tr.exportTo('tr.e.rail', function() {
  // When computing an IR's RAIL score, the IR's pain and efficiency are
  // averaged together such that the lower score has a higher weight.
  // Without knowing which sub-score is lower, happiness (1 - pain) is
  // theoretically twice as important as efficiency. If the entire web were to
  // eventually achieve relatively low pain scores such that pain was less of a
  // concern than efficiency, then this number could be lowered. If further
  // thought suggests that pain is even more than twice as important as
  // efficiency, then this number could be raised.
  // Must be greater than 0.
  var HAPPINESS_IMPORTANCE = 2;

  // This is another parameter that affects the shape of computeRawPain().
  var DEFAULT_PAIN_BASE = Math.exp(1);

  // We need an up-front list of all IR types in order to keep various groupings
  // stable, in presence of only a portion of interactions in a given trace.
  var ALL_RAIL_TYPE_NAMES = [
    'rail_response',
    'rail_animate',
    'rail_idle',
    'rail_load'
  ];

  var DOES_RAIL_TYPE_NAME_EXIST = {};
  ALL_RAIL_TYPE_NAMES.forEach(function(railTypeName) {
    DOES_RAIL_TYPE_NAME_EXIST[railTypeName] = true;
  });


  function RAILInteractionRecord(title, railTypeName, start, duration) {
    if (!DOES_RAIL_TYPE_NAME_EXIST[railTypeName])
      throw new Error(railTypeName + ' is not listed in ALL_RAIL_TYPE_NAMES');

    var colorId = tr.ui.b.getColorIdForReservedName(railTypeName);
    this.railTypeName_ = railTypeName;
    this.name = '';
    tr.model.InteractionRecord.call(this,
                                    title, colorId, start, duration);
  }

  RAILInteractionRecord.prototype = {
    __proto__: tr.model.InteractionRecord.prototype,

    updateArgs: function() {
      var args = {};

      var layoutSlices = this.associatedEvents.filter(function(event) {
        return event.title === 'FrameView::layout';
      });
      var timeInLayout = tr.b.Statistics.sum(layoutSlices, function(event) {
        return event.duration;
      });

      args['layoutInfo'] = {
        'timeInLayout': timeInLayout
      };

      this.args = args;
    },

    get railTypeName() {
      return this.railTypeName_;
    },

    /**
     * Returns the overall rail score, from 0 to 1.
     *
     * RAILScore for an interaction merges the user's pain with the
     * efficiency, in order to create a perception-oriented measure
     * of how users percieve speed during this interaction.
     *
     *  0 means a bad user experience.
     *  1 means a perfect user experience.
     */
    get railScore() {
      var happiness = 1 - this.normalizedUserPain;
      var efficiency = this.normalizedEfficiency;
      return weightedAverage2(happiness, efficiency, HAPPINESS_IMPORTANCE);
    },

    /**
     * Measures the pain the user experienced, from 0 to 1.
     *
     * A user performs an interaction with an expectation in mind.
     * When we exceed their expectations, we get zero pain.
     * When we meet their expectations, we get zero pain.
     * As we exceed their expectations, pain goes up. Maximum pain
     * is 1.0, aka "Switch to FireFox".
     */
    get normalizedUserPain() {
      throw new Error('Not implemented');
    },

    /**
     * Returns the sum of the number of CPU ms spent by this IR.
     */
    get rawCpuMs() {
      var cpuMs = 0;
      this.associatedEvents.forEach(function(event) {
        if (event.cpuSelfTime)
          cpuMs += event.cpuSelfTime;
      });
      return cpuMs;
    },

    /**
     * Returns a number between 0 and 1 representing how efficiently this IR
     * used CPU resources. 0 is maximally in-efficient, 1 is maximally
     * efficient.
     */
    get normalizedCpuEfficiency() {
      var minCpuMs = this.duration * this.minCpuFraction;
      var maxCpuMs = this.duration * this.maxCpuFraction;
      var normalizedCpu = tr.b.normalize(this.rawCpuMs, minCpuMs, maxCpuMs);
      return 1 - tr.b.clamp(normalizedCpu, 0, 1);
    },

    /**
     * The minimum fraction of a CPU that can be spent on this IR before the
     * efficiency score will be impacted.
     * If less CPU ms than this is spent on this IR, then
     * normalizedCpuEfficiency will be 1.
     */
    get minCpuFraction() {
      return 0.5;
    },

    /**
     * The maximum fraction of a CPU that can be spent on this IR.
     * If more CPU ms than this is spent on this IR, then
     * normalizedCpuEfficiency will be 0.
     */
    get maxCpuFraction() {
      return 1.5;
    },

    /**
     * Measures the efficiency of the interaction from 0 to 1.
     *
     * Efficiency is a notion of how well we used the machine's limited
     * resources in service of this interaction. If we used it perfectly,
     * we would get a 1.0. If we used everything that there was to use ---
     * power, memory, cpu, then we'd get a zero.
     */
    get normalizedEfficiency() {
      return this.normalizedCpuEfficiency;
    }
  };

  // The following functions are useful for sub-classes to override
  // normalizedUserPain.

  // Any computable value related to an IR can be used to define the pain of
  // that IR: its duration, its FPS, etc.
  function computeNormalizedPain(value, opts) {
    opts.min = Math.max(opts.min, 0);
    opts.max = Math.max(opts.max, 0);
    opts.base = Math.max(opts.base || DEFAULT_PAIN_BASE, 0);

    if (opts.min >= opts.max)
      throw 'computeNormalizedPain invalid range';

    var rawPain = computeRawPain(value, opts);
    var minPain = computeRawPain(opts.min, opts);
    var maxPain = computeRawPain(opts.max, opts);

    var normalizedPain = tr.b.normalize(
        rawPain, minPain, maxPain);

    // It's possible for normalizedPain to be negative if value < opts.min,
    // or greater than 1 if value > opts.max, so clamp it.
    return tr.b.clamp(normalizedPain, 0, 1);
  }

  // Returns a raw pain score based on |value| and options |opts|.
  // |value| can be any number.
  function computeRawPain(value, opts) {
    // Pre-normalize value so that large numbers won't be passed to
    // Math.pow() and cause it to run out of IEEE754 exponent bits and
    // return Infinity.
    value = tr.b.normalize(value, opts.min, opts.max);

    // Don't raise a negative number to a fractional power. That produces
    // NaN.
    value = Math.max(value, 0);

    // Raising value to a non-unity power affords a tunable parameter to change
    // the shape of this function.
    var tunedValue = Math.pow(value, opts.power);

    return Math.pow(opts.base, tunedValue);

    // If you modify this function to be non-monotonic anywhere, then you
    // should consider how that affects the clamp() at the end of
    // computeNormalizedPain.
  }

  // Returns a weighted average of numbers between 0 and 1.
  // The lower input has a higher weight.
  // If the first input should have a higher weight a priori its relationship to
  // the other input, then set opt_apriori > 1.
  // This function is graphed at http://goo.gl/XMWUKA
  function weightedAverage2(x, y, opt_apriori) {
    var numerator = 0;
    var denominator = 0;

    var xWeight = (opt_apriori || 1) * Math.exp(1 - x);
    numerator += xWeight * x;
    denominator += xWeight;

    var yWeight = Math.exp(1 - y);
    numerator += yWeight * y;
    denominator += yWeight;

    return numerator / denominator;
  }

  return {
    RAILInteractionRecord: RAILInteractionRecord,
    computeNormalizedPain: computeNormalizedPain,
    weightedAverage2: weightedAverage2,
    ALL_RAIL_TYPE_NAMES: ALL_RAIL_TYPE_NAMES
  };
});


'use strict';

/**
 * @fileoverview Base class for trace data Auditors.
 */
tr.exportTo('tr.e.rail', function() {
  function IdleInteractionRecord(start, duration) {
    tr.e.rail.RAILInteractionRecord.call(
        this, 'Idle', 'rail_idle',
        start, duration);
  }

  IdleInteractionRecord.prototype = {
    __proto__: tr.e.rail.RAILInteractionRecord.prototype,

    get normalizedUserPain() {
      return 0;
    },

    // Unlike during active IRs, while the user is idle, the CPU should not be
    // utilized much.

    get minCpuFraction() {
      return 0.1;
    },

    get maxCpuFraction() {
      return 1;
    }
  };

  return {
    IdleInteractionRecord: IdleInteractionRecord
  };
});


'use strict';

/**
 * @fileoverview The Load phase of RAIL.
 */
tr.exportTo('tr.e.rail', function() {
  function LoadInteractionRecord(start, duration) {
    tr.e.rail.RAILInteractionRecord.call(
        this, 'Load', 'rail_load',
        start, duration);
  }

  LoadInteractionRecord.prototype = {
    __proto__: tr.e.rail.RAILInteractionRecord.prototype,

    get normalizedUserPain() {
      return 0;
    }
  };

  return {
    LoadInteractionRecord: LoadInteractionRecord
  };
});


'use strict';

/**
 * @fileoverview The Animation phase of RAIL.
 */
tr.exportTo('tr.e.rail', function() {
  // If FPS is greater than this, then the FPS-pain is minimized.
  var PAIN_BEGINS_AT_FPS = 60;

  // If FPS is less than this, then the FPS-pain is maximized.
  var PAIN_PEAKS_AT_FPS = 10;

  // PAIN_POWER is a tunable parameter that affects the shape of
  // computeRawPain() in rail_interaction_record.html.  It must be greater than
  // 0.
  var PAIN_POWER = 1.5;

  // A frame is long if it starts more than this much time after the previous
  // frame.
  var LONG_FRAME_MS = 50;

  // If the number of long frames is less than this, then long-frame-pain is
  // minimized.
  var MIN_LONG_FRAMES = 0;

  // If the number of long frames is greater than this times the total number of
  // frames in the animation, then long-frame-pain is maximized.
  // TODO(benjhayden): Modify LONG_FRAME_PAIN_PEAK_FRACTION once we've observed
  //   the actual distribution of frames per animation and long-frames per
  //   animation in a given corpus of traces.
  var LONG_FRAME_PAIN_PEAK_FRACTION = 0.1;

  // This is the lowest reasonable value for the number of long frames that
  // would maximize long-frame-pain.
  var MIN_MAX_LONG_FRAMES = 2;

  // Discrepancy is minimized at 0 when every frame is exactly the same length,
  // but realistically, a tiny amount of jank will look just as good.
  var PAIN_BEGINS_AT_JANK = 0.05;

  // Discrepancy is maximized at 1 when there are thousands of ridiculously fast
  // frames and 1 ridiculously long frame. But realistically, discrepancy might
  // never be larger than 0.3, so discrepancy up to take advantage of the full
  // range of pain.
  var PAIN_PEAKS_AT_JANK = 0.3;

  function AnimationInteractionRecord(start, duration) {
    tr.e.rail.RAILInteractionRecord.call(
        this, 'Animation', 'rail_animate',
        start, duration);
    this.frameEvents_ = undefined;
  }

  AnimationInteractionRecord.prototype = {
    __proto__: tr.e.rail.RAILInteractionRecord.prototype,

    get frameEvents() {
      if (this.frameEvents_)
        return this.frameEvents_;

      this.frameEvents_ = new tr.model.EventSet();

      this.associatedEvents.forEach(function(event) {
        if (event.title === tr.e.audits.IMPL_RENDERING_STATS)
          this.frameEvents_.push(event);
      }, this);

      return this.frameEvents_;
    },

    get normalizedUserPain() {
      return tr.e.rail.weightedAverage2(
          this.normalizedJankPain, this.normalizedFPSPain);
    },

    get normalizedFPSPain() {
      var durationSeconds = this.duration / 1000;
      var avgFps = this.frameEvents.length / durationSeconds;
      var avgSpf = 1 / avgFps;
      return tr.e.rail.computeNormalizedPain(avgSpf, {
        min: 1 / PAIN_BEGINS_AT_FPS,
        max: 1 / PAIN_PEAKS_AT_FPS,
        power: PAIN_POWER
      });
    },

    get normalizedJankPain() {
      var frameTimestamps = this.frameEvents.toArray().map(function(event) {
        return event.start;
      });
      var absolute = false;
      var discrepancy = tr.b.Statistics.timestampsDiscrepancy(
          frameTimestamps, absolute);
      return tr.e.rail.computeNormalizedPain(discrepancy, {
        min: PAIN_BEGINS_AT_JANK,
        max: PAIN_PEAKS_AT_JANK,
        power: PAIN_POWER
      });
    }
  };

  return {
    AnimationInteractionRecord: AnimationInteractionRecord
  };
});


'use strict';

/**
 * @fileoverview The Response phase of RAIL.
 */
tr.exportTo('tr.e.rail', function() {
  // User pain is hypothesized to rise exponentially as duration rises between
  // 150ms and 1000ms.

  // If the duration of the Response is less than this, then pain is minimized.
  var PAIN_STARTS_AT_MS = 150;

  // If the duration of the Response is greater than this, then the pain is
  // maximized.
  var PAIN_PEAKS_AT_MS = 1000;

  // PAIN_POWER is a tunable parameter that affects the shape of
  // computeRawPain() in rail_interaction_record.html.  It must be greater than
  // 0.
  var PAIN_POWER = 1.5;

  function ResponseInteractionRecord(start, duration) {
    tr.e.rail.RAILInteractionRecord.call(
        this, 'Response', 'rail_response',
        start, duration);
  }

  ResponseInteractionRecord.prototype = {
    __proto__: tr.e.rail.RAILInteractionRecord.prototype,

    get normalizedUserPain() {
      // User pain is derived from the time between when the user thinks they
      // begin an interation (expectedStart) and the time when the screen first
      // changes to reflect the interaction (actualEnd).  There may be a delay
      // between expectedStart and when chrome first starts processing the
      // interaction (actualStart) if the main thread is busy.  The user doesn't
      // know when actualStart is, they only know when expectedStart is. User
      // pain, by definition, considers only what the user experiences, so
      // "duration" is defined as actualEnd - expectedStart.

      // This function is graphed at
      // https://www.desmos.com/calculator/fqhkz1ohia
      return tr.e.rail.computeNormalizedPain(this.duration, {
        min: PAIN_STARTS_AT_MS,
        max: PAIN_PEAKS_AT_MS,
        power: PAIN_POWER
      });
    }
  };

  return {
    ResponseInteractionRecord: ResponseInteractionRecord
  };
});


'use strict';

/**
 * @fileoverview An intermediate data format between InputLatencyAsyncSlices
 * and RAILIRs.
 */
tr.exportTo('tr.e.rail', function() {
  // This is an intermediate data format between InputLatencyAsyncSlices and
  // Response and Animation IRs.
  function ProtoIR(irType, name) {
    this.irType = irType;
    this.names = new Set(name ? [name] : undefined);
    this.start = Infinity;
    this.end = -Infinity;
    this.associatedEvents = new tr.model.EventSet();
  }

  ProtoIR.RESPONSE_TYPE = 'r';
  ProtoIR.ANIMATION_TYPE = 'a';

  // Explicitly ignore some input events to allow
  // RAILIRFinder.checkAllInputEventsHandled() to determine which events were
  // unintentionally ignored due to a bug.
  ProtoIR.IGNORED_TYPE = 'ignored';

  ProtoIR.prototype = {
    get isValid() {
      return this.end > this.start;
    },

    // Return true if any associatedEvent's typeName is in typeNames.
    containsTypeNames: function(typeNames) {
      for (var i = 0; i < this.associatedEvents.length; ++i) {
        if (typeNames.indexOf(this.associatedEvents[i].typeName) >= 0)
          return true;
      }
      return false;
    },

    containsSliceTitle: function(title) {
      for (var i = 0; i < this.associatedEvents.length; ++i) {
        if (title === this.associatedEvents[i].title)
          return true;
      }
      return false;
    },

    getIRConstructor: function() {
      switch (this.irType) {
        case ProtoIR.RESPONSE_TYPE:
          return tr.e.rail.ResponseInteractionRecord;
        case ProtoIR.ANIMATION_TYPE:
          return tr.e.rail.AnimationInteractionRecord;
      }
      return undefined;
    },

    createInteractionRecord: function() {
      if (!this.isValid) {
        console.error('Invalid ProtoIR: ' + this.debug() +
                      ' File a bug with this trace!');
        return undefined;
      }

      var constructor = this.getIRConstructor();
      if (constructor === undefined)
        return undefined;

      var ir = new constructor(this.start, this.end - this.start);
      var names = [];
      this.names.forEach(function(name) { names.push(name); });
      ir.name = names.sort().join(',');

      ir.sourceEvents.addEventSet(this.associatedEvents);

      function pushAssociatedEvents(event) {
        ir.associatedEvents.push(event);

        // |event| is either an InputLatencyAsyncSlice (which collects all of
        // its associated events transitively) or a CSS Animation (which doesn't
        // have any associated events). So this does not need to recurse.
        if (event.associatedEvents)
          ir.associatedEvents.addEventSet(event.associatedEvents);
      }

      this.associatedEvents.forEach(function(event) {
        pushAssociatedEvents(event);

        // Old-style InputLatencyAsyncSlices have subSlices.
        if (event.subSlices)
          event.subSlices.forEach(pushAssociatedEvents);
      });

      return ir;
    },

    // Merge the other ProtoIR into this one.
    // The irTypes need not match: ignored ProtoIRs might be merged into
    // overlapping ProtoIRs, and Touch-only Animations are merged into Tap
    // Responses.
    merge: function(other) {
      other.names.forEach(function(name) { this.names.add(name); }.bind(this));

      // Don't use pushEvent(), which would lose special start, end.
      this.associatedEvents.addEventSet(other.associatedEvents);
      this.start = Math.min(this.start, other.start);
      this.end = Math.max(this.end, other.end);
    },

    // Include |event| in this ProtoIR, expanding start/end to include it.
    pushEvent: function(event) {
      // Usually, this method will be called while iterating over a list of
      // events sorted by start time, so this method won't usually change
      // this.start. However, this will sometimes be called for ProtoIRs created
      // by previous handlers, in which case event.start could possibly be
      // before this.start.
      this.start = Math.min(this.start, event.start);
      this.end = Math.max(this.end, event.end);
      this.associatedEvents.push(event);
    },

    // Returns true if timestamp is contained in this ProtoIR.
    containsTimestampInclusive: function(timestamp) {
      return (this.start <= timestamp) && (timestamp <= this.end);
    },

    // Return true if the other event intersects this ProtoIR.
    intersects: function(other) {
      // http://stackoverflow.com/questions/325933
      return (other.start < this.end) && (other.end > this.start);
    },

    isNear: function(event, threshold) {
      return (this.end + threshold) > event.start;
    },

    // Return a string describing this ProtoIR for debugging.
    debug: function() {
      var debugString = this.irType + '(';
      debugString += parseInt(this.start) + ' ';
      debugString += parseInt(this.end);
      this.associatedEvents.forEach(function(event) {
        debugString += ' ' + event.typeName;
      });
      return debugString + ')';
    }
  };

  return {
    ProtoIR: ProtoIR
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function getAssociatedEvents(irs) {
    var allAssociatedEvents = new tr.model.EventSet();
    irs.forEach(function(ir) {
      ir.associatedEvents.forEach(function(event) {
        // FlowEvents don't have parentContainers or cpuDurations, and it's
        // annoying to highlight them.
        if (event instanceof tr.model.FlowEvent)
          return;
        allAssociatedEvents.push(event);
      });
    });
    return allAssociatedEvents;
  }

  function getUnassociatedEvents(model, associatedEvents) {
    var unassociatedEvents = new tr.model.EventSet();
    model.getAllProcesses().forEach(function(process) {
      for (var tid in process.threads) {
        var thread = process.threads[tid];
        thread.sliceGroup.iterateAllEvents(function(event) {
          // The set of unassociated events contains only events that are not in
          // the set of associated events.
          // Only add event to the set of unassociated events if it is not in
          // the set of associated events.
          if (!associatedEvents.contains(event))
            unassociatedEvents.push(event);
        });
      }
    });
    return unassociatedEvents;
  }

  function getTotalCpuDuration(events) {
    var cpuMs = 0;
    events.forEach(function(event) {
      // Add up events' cpu self time if they have any.
      if (event.cpuSelfTime)
        cpuMs += event.cpuSelfTime;
    });
    return cpuMs;
  }

  function getIRCoverageFromModel(model) {
    var associatedEvents = getAssociatedEvents(model.interactionRecords);

    if (!associatedEvents.length)
      return undefined;

    var unassociatedEvents = getUnassociatedEvents(
        model, associatedEvents);

    var associatedCpuMs = getTotalCpuDuration(associatedEvents);
    var unassociatedCpuMs = getTotalCpuDuration(unassociatedEvents);

    var totalEventCount = associatedEvents.length + unassociatedEvents.length;
    var totalCpuMs = associatedCpuMs + unassociatedCpuMs;

    return {
      associatedEventsCount: associatedEvents.length,
      unassociatedEventsCount: unassociatedEvents.length,
      associatedEventsCpuTimeMs: associatedCpuMs,
      unassociatedEventsCpuTimeMs: unassociatedCpuMs,
      coveredEventsCountRatio: associatedEvents.length / totalEventCount,
      coveredEventsCpuTimeRatio: associatedCpuMs / totalCpuMs
    };
  }

  return {
    getIRCoverageFromModel: getIRCoverageFromModel,
    getAssociatedEvents: getAssociatedEvents,
    getUnassociatedEvents: getUnassociatedEvents
  };
});


'use strict';

/**
 * @fileoverview Base class for trace data Auditors.
 */
tr.exportTo('tr.e.rail', function() {
  var INPUT_TYPE = tr.e.cc.INPUT_EVENT_TYPE_NAMES;
  var ProtoIR = tr.e.rail.ProtoIR;

  function compareEvents(x, y) {
    if (x.start !== y.start)
      return x.start - y.start;
    if (x.end !== y.end)
      return x.end - y.end;
    if (x.guid && y.guid)
      return x.guid - y.guid;
    return 0;
  }

  function causedFrame(event) {
    for (var i = 0; i < event.associatedEvents.length; ++i) {
      if (event.associatedEvents[i].title === tr.e.audits.IMPL_RENDERING_STATS)
        return true;
    }
    return false;
  }

  // If there's less than this much time between the end of one event and the
  // start of the next, then they might be merged.
  // There was not enough thought given to this value, so if you have any slight
  // reason to change it, then please do so. It might also be good to split this
  // into multiple values.
  var INPUT_MERGE_THRESHOLD_MS = 200;
  var ANIMATION_MERGE_THRESHOLD_MS = 1;

  // If two MouseWheel events begin this close together, then they're an
  // Animation, not two responses.
  var MOUSE_WHEEL_THRESHOLD_MS = 40;

  // If two MouseMoves are more than this far apart, then they're two Responses,
  // not Animation.
  var MOUSE_MOVE_THRESHOLD_MS = 40;

  var INSIGNIFICANT_MS = 1;

  var KEYBOARD_TYPE_NAMES = [
    INPUT_TYPE.CHAR,
    INPUT_TYPE.KEY_DOWN_RAW,
    INPUT_TYPE.KEY_DOWN,
    INPUT_TYPE.KEY_UP
  ];
  var MOUSE_RESPONSE_TYPE_NAMES = [
    INPUT_TYPE.CLICK,
    INPUT_TYPE.CONTEXT_MENU
  ];
  var MOUSE_WHEEL_TYPE_NAMES = [
    INPUT_TYPE.MOUSE_WHEEL
  ];
  var MOUSE_DRAG_TYPE_NAMES = [
    INPUT_TYPE.MOUSE_DOWN,
    INPUT_TYPE.MOUSE_MOVE,
    INPUT_TYPE.MOUSE_UP
  ];
  var TAP_TYPE_NAMES = [
    INPUT_TYPE.TAP,
    INPUT_TYPE.TAP_CANCEL,
    INPUT_TYPE.TAP_DOWN
  ];
  var PINCH_TYPE_NAMES = [
    INPUT_TYPE.PINCH_BEGIN,
    INPUT_TYPE.PINCH_END,
    INPUT_TYPE.PINCH_UPDATE
  ];
  var FLING_TYPE_NAMES = [
    INPUT_TYPE.FLING_CANCEL,
    INPUT_TYPE.FLING_START
  ];
  var TOUCH_TYPE_NAMES = [
    INPUT_TYPE.TOUCH_END,
    INPUT_TYPE.TOUCH_MOVE,
    INPUT_TYPE.TOUCH_START
  ];
  var SCROLL_TYPE_NAMES = [
    INPUT_TYPE.SCROLL_BEGIN,
    INPUT_TYPE.SCROLL_END,
    INPUT_TYPE.SCROLL_UPDATE
  ];
  var ALL_HANDLED_TYPE_NAMES = [].concat(
    KEYBOARD_TYPE_NAMES,
    MOUSE_RESPONSE_TYPE_NAMES,
    MOUSE_WHEEL_TYPE_NAMES,
    MOUSE_DRAG_TYPE_NAMES,
    PINCH_TYPE_NAMES,
    TAP_TYPE_NAMES,
    FLING_TYPE_NAMES,
    TOUCH_TYPE_NAMES,
    SCROLL_TYPE_NAMES
  );

  var RENDERER_FLING_TITLE = 'InputHandlerProxy::HandleGestureFling::started';
  var CSS_ANIMATION_TITLE = 'Animation';

  // Strings used to name IRs.
  var LOAD_STARTUP_IR_NAME = 'Startup';
  var LOAD_SUCCEEDED_IR_NAME = 'Succeeded';
  var LOAD_FAILED_IR_NAME = 'Failed';
  var KEYBOARD_IR_NAME = 'Keyboard';
  var MOUSE_IR_NAME = 'Mouse';
  var MOUSEWHEEL_IR_NAME = 'MouseWheel';
  var TAP_IR_NAME = 'Tap';
  var PINCH_IR_NAME = 'Pinch';
  var FLING_IR_NAME = 'Fling';
  var TOUCH_IR_NAME = 'Touch';
  var SCROLL_IR_NAME = 'Scroll';
  var CSS_IR_NAME = 'CSS';

  function RAILIRFinder(model, modelHelper) {
    this.model = model;
    this.modelHelper = modelHelper;
  };

  RAILIRFinder.supportsModelHelper = function(modelHelper) {
    return modelHelper.browserHelper !== undefined;
  };

  RAILIRFinder.prototype = {
    findAllInteractionRecords: function() {
      var rirs = [];
      rirs.push.apply(rirs, this.findLoadInteractionRecords());
      rirs.push.apply(rirs, this.findInputInteractionRecords());
      // findIdleInteractionRecords must be called last!
      rirs.push.apply(rirs, this.findIdleInteractionRecords(rirs));
      this.collectUnassociatedEvents_(rirs);
      return rirs;
    },

    setIRNames_: function(name, irs) {
      irs.forEach(function(ir) {
        ir.name = name;
      });
    },

    // Find all unassociated top-level ThreadSlices. If they start during an
    // Idle or Load IR, then add their entire hierarchy to that IR.
    collectUnassociatedEvents_: function(rirs) {
      var vacuumIRs = [];
      rirs.forEach(function(ir) {
        if (ir instanceof tr.e.rail.LoadInteractionRecord ||
            ir instanceof tr.e.rail.IdleInteractionRecord)
          vacuumIRs.push(ir);
      });
      if (vacuumIRs.length === 0)
        return;

      var allAssociatedEvents = tr.model.getAssociatedEvents(rirs);
      var unassociatedEvents = tr.model.getUnassociatedEvents(
          this.model, allAssociatedEvents);

      unassociatedEvents.forEach(function(event) {
        if (!(event instanceof tr.model.ThreadSlice))
          return;

        if (!event.isTopLevel)
          return;

        for (var iri = 0; iri < vacuumIRs.length; ++iri) {
          var ir = vacuumIRs[iri];

          if ((event.start >= ir.start) &&
              (event.start < ir.end)) {
            ir.associatedEvents.addEventSet(event.entireHierarchy);
            return;
          }
        }
      });
    },

    // Fill in the empty space between IRs with IdleIRs.
    findIdleInteractionRecords: function(otherIRs) {
      if (this.model.bounds.isEmpty)
        return;
      var emptyRanges = tr.b.findEmptyRangesBetweenRanges(
          tr.b.convertEventsToRanges(otherIRs),
          this.model.bounds);
      var irs = [];
      emptyRanges.forEach(function(range) {
        // Ignore insignificantly tiny idle ranges.
        if (range.max < (range.min + INSIGNIFICANT_MS))
          return;
        irs.push(new tr.e.rail.IdleInteractionRecord(
            range.min, range.max - range.min));
      });
      return irs;
    },

    getAllFrameEvents: function() {
      var frameEvents = [];
      frameEvents.push.apply(frameEvents,
          this.modelHelper.browserHelper.getFrameEventsInRange(
              tr.e.audits.IMPL_FRAMETIME_TYPE, this.model.bounds));

      tr.b.iterItems(this.modelHelper.rendererHelpers, function(pid, renderer) {
        frameEvents.push.apply(frameEvents, renderer.getFrameEventsInRange(
            tr.e.audits.IMPL_FRAMETIME_TYPE, this.model.bounds));
      }, this);
      return frameEvents.sort(compareEvents);
    },

    getStartLoadEvents: function() {
      function isStartLoadSlice(slice) {
        return slice.title === 'RenderFrameImpl::didStartProvisionalLoad';
      }
      return this.modelHelper.browserHelper.getAllAsyncSlicesMatching(
          isStartLoadSlice).sort(compareEvents);
    },

    getFailLoadEvents: function() {
      function isFailLoadSlice(slice) {
        return slice.title === 'RenderFrameImpl::didFailProvisionalLoad';
      }
      return this.modelHelper.browserHelper.getAllAsyncSlicesMatching(
          isFailLoadSlice).sort(compareEvents);
    },

    // Main runner events are emitted very early on in the lifetime of browser
    // and renderer processes. It's emitted in the Initialize method of
    // ContentMainRunner as soon as TRACE_EVENT is available.
    getMainRunnerEvents: function() {
      function isMainRunnerSlice(slice) {
        return slice.title === 'ContentMainRunnerImpl::Initialize';
      }
      return this.modelHelper.browserHelper.getAllAsyncSlicesMatching(
          isMainRunnerSlice).sort(compareEvents);
    },

    // Match every event in |openingEvents| to the first following event from
    // |closingEvents| and return an array containing a load interaction record
    // for each pair.
    findLoadInteractionRecords_: function(openingEvents, closingEvents) {
      var lirs = [];
      openingEvents.forEach(function(openingEvent) {
        closingEvents.forEach(function(closingEvent) {
          // Ignore opening event that already have a closing event.
          if (openingEvent.closingEvent)
            return;

          // Ignore closing events that already belong to an opening event.
          if (closingEvent.openingEvent)
            return;

          // Ignore closing events before |openingEvent|.
          if (closingEvent.start <= openingEvent.start)
            return;

          // Ignore events from different threads.
          if (openingEvent.parentContainer.parent.pid !==
               closingEvent.parentContainer.parent.pid)
            return;

          // This is the first closing event for this opening event, record it.
          openingEvent.closingEvent = closingEvent;
          closingEvent.openingEvent = openingEvent;
          var lir = new tr.e.rail.LoadInteractionRecord(
              openingEvent.start, closingEvent.end - openingEvent.start);
          lir.associatedEvents.push(openingEvent);
          lir.associatedEvents.push(closingEvent);
          lirs.push(lir);
        });
      });
      return lirs;
    },

    // Match up RenderFrameImpl events with frame render events.
    findLoadInteractionRecords: function() {
      var mainRunnerEvents = this.getMainRunnerEvents();
      var commitLoadEvents =
          this.modelHelper.browserHelper.getCommitProvisionalLoadEventsInRange(
              this.model.bounds);
      var frameEvents = this.getAllFrameEvents();
      var startLoadEvents = this.getStartLoadEvents();
      var failLoadEvents = this.getFailLoadEvents();
      var lirs = [];

      // Attach frame events to every main runner events.
      var startupLIRs = this.findLoadInteractionRecords_(mainRunnerEvents,
          frameEvents);
      this.setIRNames_(LOAD_STARTUP_IR_NAME, startupLIRs);
      lirs.push.apply(lirs, startupLIRs);

      // Attach frame events to every commit load events.
      var succesfulLIRs = this.findLoadInteractionRecords_(commitLoadEvents,
          frameEvents);
      this.setIRNames_(LOAD_SUCCEEDED_IR_NAME, succesfulLIRs);
      lirs.push.apply(lirs, succesfulLIRs);

      // Attach fail load events to every start load events.
      var failedLIRs = this.findLoadInteractionRecords_(startLoadEvents,
          failLoadEvents);
      this.setIRNames_(LOAD_FAILED_IR_NAME, failedLIRs);
      lirs.push.apply(lirs, failedLIRs);

      return lirs;
    },

    // Find ProtoIRs, post-process them, convert them to real IRs.
    findInputInteractionRecords: function() {
      var protoIRs = this.findProtoIRs();
      protoIRs = this.postProcessProtoIRs(protoIRs);
      this.checkAllInputEventsHandled(protoIRs);

      var irs = [];
      protoIRs.forEach(function(protoIR) {
        var ir = protoIR.createInteractionRecord();
        if (ir)
          irs.push(ir);
      });
      return irs;
    },

    findProtoIRs: function() {
      var protoIRs = [];
      // This order is not important. Handlers are independent.
      protoIRs.push.apply(protoIRs, this.handleKeyboardEvents());
      protoIRs.push.apply(protoIRs, this.handleMouseResponseEvents());
      protoIRs.push.apply(protoIRs, this.handleMouseWheelEvents());
      protoIRs.push.apply(protoIRs, this.handleMouseDragEvents());
      protoIRs.push.apply(protoIRs, this.handleTapResponseEvents());
      protoIRs.push.apply(protoIRs, this.handlePinchEvents());
      protoIRs.push.apply(protoIRs, this.handleFlingEvents());
      protoIRs.push.apply(protoIRs, this.handleTouchEvents());
      protoIRs.push.apply(protoIRs, this.handleScrollEvents());
      protoIRs.push.apply(protoIRs, this.handleCSSAnimations());
      protoIRs.sort(compareEvents);
      return protoIRs;
    },

    getSortedInputEvents: function(typeNames) {
      function isMatchingSlice(slice) {
        if (!slice.isTopLevel)
          return false;

        if (!(slice instanceof tr.e.cc.InputLatencyAsyncSlice))
          return false;

        return typeNames.indexOf(slice.typeName) >= 0;
      }

      return this.modelHelper.browserHelper.getAllAsyncSlicesMatching(
          isMatchingSlice).sort(compareEvents);
    },

    // Every keyboard event is a Response.
    handleKeyboardEvents: function() {
      var protoIRs = [];
      this.getSortedInputEvents(KEYBOARD_TYPE_NAMES).forEach(function(event) {
        var pir = new ProtoIR(ProtoIR.RESPONSE_TYPE, KEYBOARD_IR_NAME);
        pir.pushEvent(event);
        protoIRs.push(pir);
      });
      return protoIRs;
    },

    // Some mouse events can be translated directly into Responses.
    handleMouseResponseEvents: function() {
      var protoIRs = [];
      var mouseEvents = this.getSortedInputEvents(MOUSE_RESPONSE_TYPE_NAMES);
      mouseEvents.forEach(function(event) {
        var pir = new ProtoIR(ProtoIR.RESPONSE_TYPE, MOUSE_IR_NAME);
        pir.pushEvent(event);
        protoIRs.push(pir);
      });
      return protoIRs;
    },

    // MouseWheel events are caused either by a physical wheel on a physical
    // mouse, or by a touch-drag gesture on a track-pad. The physical wheel
    // causes MouseWheel events that are much more spaced out, and have no
    // chance of hitting 60fps, so they are each turned into separate Response
    // IRs. The track-pad causes MouseWheel events that are much closer
    // together, and are expected to be 60fps, so the first event in a sequence
    // is turned into a Response, and the rest are merged into an Animation.
    // NB this threshold uses the two events' start times, unlike
    // ProtoIR.isNear, which compares the end time of the previous event with
    // the start time of the next.
    handleMouseWheelEvents: function() {
      var protoIRs = [];
      var currentPIR = undefined;
      var prevEvent_ = undefined;
      var wheelEvents = this.getSortedInputEvents(MOUSE_WHEEL_TYPE_NAMES);
      wheelEvents.forEach(function(event) {
        // Switch prevEvent in one place so that we can early-return later.
        var prevEvent = prevEvent_;
        prevEvent_ = event;

        if (currentPIR &&
            (prevEvent.start + MOUSE_WHEEL_THRESHOLD_MS) >= event.start) {
          if (currentPIR.irType === ProtoIR.ANIMATION_TYPE) {
            currentPIR.pushEvent(event);
          } else {
            currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE,
                MOUSEWHEEL_IR_NAME);
            currentPIR.pushEvent(event);
            protoIRs.push(currentPIR);
          }
          return;
        }
        currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, MOUSEWHEEL_IR_NAME);
        currentPIR.pushEvent(event);
        protoIRs.push(currentPIR);
      });
      return protoIRs;
    },

    // Down events followed closely by Up events are click Responses, but the
    // Response doesn't start until the Up event.
    //
    //     RRR
    // DDD UUU
    //
    // If there are any Move events in between a Down and an Up, then the Down
    // and the first Move are a Response, then the rest of the Moves are an
    // Animation:
    //
    // RRRRRRRAAAAAAAAAAAAAAAAAAAA
    // DDD MMM MMM MMM MMM MMM UUU
    //
    handleMouseDragEvents: function() {
      var protoIRs = [];
      var currentPIR = undefined;
      var mouseDownEvent = undefined;
      this.getSortedInputEvents(MOUSE_DRAG_TYPE_NAMES).forEach(function(event) {
        switch (event.typeName) {
          case INPUT_TYPE.MOUSE_DOWN:
            if (causedFrame(event)) {
              var pir = new ProtoIR(ProtoIR.RESPONSE_TYPE, MOUSE_IR_NAME);
              pir.pushEvent(event);
              protoIRs.push(pir);
            } else {
              // Responses typically don't start until the mouse up event.
              // Add this MouseDown to the Response that starts at the MouseUp.
              mouseDownEvent = event;
            }
            break;
            // There may be more than 100ms between the start of the mouse down
            // and the start of the mouse up. Chrome and the web don't start to
            // respond until the mouse up. ResponseIRs start scoring "pain" at
            // 100ms duration. If more than that 100ms duration is burned
            // through while waiting for the user to release the
            // mouse button, then ResponseIR will unfairly start scoring pain
            // before Chrome even has a mouse up to respond to.
            // It is technically possible for a site to afford one response on
            // mouse down and another on mouse up, but that is an edge case. The
            // vast majority of mouse downs are not responses.

          case INPUT_TYPE.MOUSE_MOVE:
            if (!causedFrame(event)) {
              // Ignore MouseMoves that do not affect the screen. They are not
              // part of an interaction record by definition.
              var pir = new ProtoIR(ProtoIR.IGNORED_TYPE);
              pir.pushEvent(event);
              protoIRs.push(pir);
            } else if (!currentPIR ||
                       !currentPIR.isNear(event, MOUSE_MOVE_THRESHOLD_MS)) {
              // The first MouseMove after a MouseDown or after a while is a
              // Response.
              currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, MOUSE_IR_NAME);
              currentPIR.pushEvent(event);
              if (mouseDownEvent) {
                currentPIR.associatedEvents.push(mouseDownEvent);
                mouseDownEvent = undefined;
              }
              protoIRs.push(currentPIR);
            } else {
              // Merge this event into an Animation.
              if (currentPIR.irType === ProtoIR.ANIMATION_TYPE) {
                currentPIR.pushEvent(event);
              } else {
                currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE, MOUSE_IR_NAME);
                currentPIR.pushEvent(event);
                protoIRs.push(currentPIR);
              }
            }
            break;

          case INPUT_TYPE.MOUSE_UP:
            if (!mouseDownEvent) {
              var pir = new ProtoIR(causedFrame(event) ? ProtoIR.RESPONSE_TYPE :
                  ProtoIR.IGNORED_TYPE, MOUSE_IR_NAME);
              pir.pushEvent(event);
              protoIRs.push(pir);
              break;
            }

            if (currentPIR) {
              currentPIR.pushEvent(event);
            } else {
              currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, MOUSE_IR_NAME);
              if (mouseDownEvent)
                currentPIR.associatedEvents.push(mouseDownEvent);
              currentPIR.pushEvent(event);
              protoIRs.push(currentPIR);
            }
            mouseDownEvent = undefined;
            currentPIR = undefined;
            break;
        }
      });
      if (mouseDownEvent) {
        currentPIR = new ProtoIR(ProtoIR.IGNORED_TYPE);
        currentPIR.pushEvent(mouseDownEvent);
        protoIRs.push(currentPIR);
      }
      return protoIRs;
    },

    // Solitary Tap events are simple Responses:
    //
    // RRR
    // TTT
    //
    // TapDowns are part of Responses.
    //
    // RRRRRRR
    // DDD TTT
    //
    // TapCancels are part of Responses, which seems strange. They always go
    // with scrolls, so they'll probably be merged with scroll Responses.
    // TapCancels can take a significant amount of time and account for a
    // significant amount of work, which should be grouped with the scroll IRs
    // if possible.
    //
    // RRRRRRR
    // DDD CCC
    //
    handleTapResponseEvents: function() {
      var protoIRs = [];
      var currentPIR = undefined;
      this.getSortedInputEvents(TAP_TYPE_NAMES).forEach(function(event) {
        switch (event.typeName) {
          case INPUT_TYPE.TAP_DOWN:
            currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, TAP_IR_NAME);
            currentPIR.pushEvent(event);
            protoIRs.push(currentPIR);
            break;

          case INPUT_TYPE.TAP:
            if (currentPIR) {
              currentPIR.pushEvent(event);
            } else {
              // Sometimes we get Tap events with no TapDown, sometimes we get
              // TapDown events. Handle both.
              currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, TAP_IR_NAME);
              currentPIR.pushEvent(event);
              protoIRs.push(currentPIR);
            }
            currentPIR = undefined;
            break;

          case INPUT_TYPE.TAP_CANCEL:
            if (!currentPIR) {
              var pir = new ProtoIR(ProtoIR.IGNORED_TYPE);
              pir.pushEvent(event);
              protoIRs.push(pir);
              break;
            }

            if (currentPIR.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
              currentPIR.pushEvent(event);
            } else {
              currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, TAP_IR_NAME);
              currentPIR.pushEvent(event);
              protoIRs.push(currentPIR);
            }
            currentPIR = undefined;
            break;
        }
      });
      return protoIRs;
    },

    // The PinchBegin and the first PinchUpdate comprise a Response, then the
    // rest of the PinchUpdates comprise an Animation.
    //
    // RRRRRRRAAAAAAAAAAAAAAAAAAAA
    // BBB UUU UUU UUU UUU UUU EEE
    //
    handlePinchEvents: function() {
      var protoIRs = [];
      var currentPIR = undefined;
      var sawFirstUpdate = false;
      var modelBounds = this.model.bounds;
      this.getSortedInputEvents(PINCH_TYPE_NAMES).forEach(function(event) {
        switch (event.typeName) {
          case INPUT_TYPE.PINCH_BEGIN:
            if (currentPIR &&
                currentPIR.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
              currentPIR.pushEvent(event);
              break;
            }
            currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, PINCH_IR_NAME);
            currentPIR.pushEvent(event);
            protoIRs.push(currentPIR);
            sawFirstUpdate = false;
            break;

          case INPUT_TYPE.PINCH_UPDATE:
            // Like ScrollUpdates, the Begin and the first Update constitute a
            // Response, then the rest of the Updates constitute an Animation
            // that begins when the Response ends. If the user pauses in the
            // middle of an extended pinch gesture, then multiple Animations
            // will be created.
            if (!currentPIR ||
                ((currentPIR.irType === ProtoIR.RESPONSE_TYPE) &&
                 sawFirstUpdate) ||
                !currentPIR.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
              currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE, PINCH_IR_NAME);
              currentPIR.pushEvent(event);
              protoIRs.push(currentPIR);
            } else {
              currentPIR.pushEvent(event);
              sawFirstUpdate = true;
            }
            break;

          case INPUT_TYPE.PINCH_END:
            if (currentPIR) {
              currentPIR.pushEvent(event);
            } else {
              var pir = new ProtoIR(ProtoIR.IGNORED_TYPE);
              pir.pushEvent(event);
              protoIRs.push(pir);
            }
            currentPIR = undefined;
            break;
        }
      });
      return protoIRs;
    },

    // Flings are defined by 3 types of events: FlingStart, FlingCancel, and the
    // renderer fling event. Flings do not begin with a Response. Flings end
    // either at the beginning of a FlingCancel, or at the end of the renderer
    // fling event.
    //
    // AAAAAAAAAAAAAAAAAAAAAAAAAA
    // SSS
    //     RRRRRRRRRRRRRRRRRRRRRR
    //
    //
    // AAAAAAAAAAA
    // SSS        CCC
    //
    handleFlingEvents: function() {
      var protoIRs = [];
      var currentPIR = undefined;
      var flingEvents = this.getSortedInputEvents(FLING_TYPE_NAMES);

      function isRendererFling(event) {
        return event.title === RENDERER_FLING_TITLE;
      }
      var browserHelper = this.modelHelper.browserHelper;
      flingEvents.push.apply(flingEvents,
          browserHelper.getAllAsyncSlicesMatching(isRendererFling));

      flingEvents.forEach(function(event) {
        if (event.title === RENDERER_FLING_TITLE) {
          if (currentPIR) {
            currentPIR.pushEvent(event);
          } else {
            currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE, FLING_IR_NAME);
            currentPIR.pushEvent(event);
            protoIRs.push(currentPIR);
          }
          return;
        }

        switch (event.typeName) {
          case INPUT_TYPE.FLING_START:
            if (currentPIR) {
              console.error('Another FlingStart? File a bug with this trace!');
              currentPIR.pushEvent(event);
            } else {
              currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE, FLING_IR_NAME);
              currentPIR.pushEvent(event);
              // Set end to an invalid value so that it can be noticed and fixed
              // later.
              currentPIR.end = 0;
              protoIRs.push(currentPIR);
            }
            break;

          case INPUT_TYPE.FLING_CANCEL:
            if (currentPIR) {
              currentPIR.pushEvent(event);
              // FlingCancel events start when TouchStart events start, which is
              // typically when a Response starts. FlingCancel events end when
              // chrome acknowledges them, not when they update the screen. So
              // there might be one more frame during the FlingCancel, after
              // this Animation ends. That won't affect the scoring algorithms,
              // and it will make the IRs look more correct if they don't
              // overlap unnecessarily.
              currentPIR.end = event.start;
              currentPIR = undefined;
            } else {
              var pir = new ProtoIR(ProtoIR.IGNORED_TYPE);
              pir.pushEvent(event);
              protoIRs.push(pir);
            }
            break;
        }
      });
      // If there was neither a FLING_CANCEL nor a renderer fling after the
      // FLING_START, then assume that it ends at the end of the model, so set
      // the end of currentPIR to the end of the model.
      if (currentPIR && !currentPIR.end)
        currentPIR.end = this.model.bounds.max;
      return protoIRs;
    },

    // The TouchStart and the first TouchMove comprise a Response, then the
    // rest of the TouchMoves comprise an Animation.
    //
    // RRRRRRRAAAAAAAAAAAAAAAAAAAA
    // SSS MMM MMM MMM MMM MMM EEE
    //
    // If there are no TouchMove events in between a TouchStart and a TouchEnd,
    // then it's just a Response.
    //
    // RRRRRRR
    // SSS EEE
    //
    handleTouchEvents: function() {
      var protoIRs = [];
      var currentPIR = undefined;
      var sawFirstMove = false;
      this.getSortedInputEvents(TOUCH_TYPE_NAMES).forEach(function(event) {
        switch (event.typeName) {
          case INPUT_TYPE.TOUCH_START:
            if (currentPIR) {
              // NB: currentPIR will probably be merged with something from
              // handlePinchEvents(). Multiple TouchStart events without an
              // intervening TouchEnd logically implies that multiple fingers
              // are on the screen, so this is probably a pinch gesture.
              currentPIR.pushEvent(event);
            } else {
              currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, TOUCH_IR_NAME);
              currentPIR.pushEvent(event);
              protoIRs.push(currentPIR);
              sawFirstMove = false;
            }
            break;

          case INPUT_TYPE.TOUCH_MOVE:
            if (!currentPIR) {
              currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE, TOUCH_IR_NAME);
              currentPIR.pushEvent(event);
              protoIRs.push(currentPIR);
              break;
            }

            // Like Scrolls and Pinches, the Response is defined to be the
            // TouchStart plus the first TouchMove, then the rest of the
            // TouchMoves constitute an Animation.
            if ((sawFirstMove &&
                (currentPIR.irType === ProtoIR.RESPONSE_TYPE)) ||
                !currentPIR.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
              // If there's already a touchmove in the currentPIR or it's not
              // near event, then finish it and start a new animation.
              var prevEnd = currentPIR.end;
              currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE, TOUCH_IR_NAME);
              currentPIR.pushEvent(event);
              // It's possible for there to be a gap between TouchMoves, but
              // that doesn't mean that there should be an Idle IR there.
              currentPIR.start = prevEnd;
              protoIRs.push(currentPIR);
            } else {
              currentPIR.pushEvent(event);
              sawFirstMove = true;
            }
            break;

          case INPUT_TYPE.TOUCH_END:
            if (!currentPIR) {
              var pir = new ProtoIR(ProtoIR.IGNORED_TYPE);
              pir.pushEvent(event);
              protoIRs.push(pir);
              break;
            }
            if (currentPIR.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
              currentPIR.pushEvent(event);
            } else {
              var pir = new ProtoIR(ProtoIR.IGNORED_TYPE);
              pir.pushEvent(event);
              protoIRs.push(pir);
            }
            currentPIR = undefined;
            break;
        }
      });
      return protoIRs;
    },

    // The first ScrollBegin and the first ScrollUpdate comprise a Response,
    // then the rest comprise an Animation.
    //
    // RRRRRRRAAAAAAAAAAAAAAAAAAAA
    // BBB UUU UUU UUU UUU UUU EEE
    //
    handleScrollEvents: function() {
      var protoIRs = [];
      var currentPIR = undefined;
      var sawFirstUpdate = false;
      this.getSortedInputEvents(SCROLL_TYPE_NAMES).forEach(function(event) {
        switch (event.typeName) {
          case INPUT_TYPE.SCROLL_BEGIN:
            // Always begin a new PIR even if there already is one, unlike
            // PinchBegin.
            currentPIR = new ProtoIR(ProtoIR.RESPONSE_TYPE, SCROLL_IR_NAME);
            currentPIR.pushEvent(event);
            protoIRs.push(currentPIR);
            sawFirstUpdate = false;
            break;

          case INPUT_TYPE.SCROLL_UPDATE:
            if (currentPIR) {
              if (currentPIR.isNear(event, INPUT_MERGE_THRESHOLD_MS) &&
                  ((currentPIR.irType === ProtoIR.ANIMATION_TYPE) ||
                  !sawFirstUpdate)) {
                currentPIR.pushEvent(event);
                sawFirstUpdate = true;
              } else {
                currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE,
                    SCROLL_IR_NAME);
                currentPIR.pushEvent(event);
                protoIRs.push(currentPIR);
              }
            } else {
              // ScrollUpdate without ScrollBegin.
              currentPIR = new ProtoIR(ProtoIR.ANIMATION_TYPE, SCROLL_IR_NAME);
              currentPIR.pushEvent(event);
              protoIRs.push(currentPIR);
            }
            break;

          case INPUT_TYPE.SCROLL_END:
            if (!currentPIR) {
              console.error('ScrollEnd without ScrollUpdate? ' +
                            'File a bug with this trace!');
              var pir = new ProtoIR(ProtoIR.IGNORED_TYPE);
              pir.pushEvent(event);
              protoIRs.push(pir);
              break;
            }
            currentPIR.pushEvent(event);
            break;
        }
      });
      return protoIRs;
    },

    // CSS Animations are merged into Animations when they intersect.
    handleCSSAnimations: function() {
      var animationEvents = this.modelHelper.browserHelper.
          getAllAsyncSlicesMatching(function(event) {
            return event.title === CSS_ANIMATION_TITLE;
      });

      var animationRanges = [];
      animationEvents.forEach(function(event) {
        animationRanges.push({
          min: event.start,
          max: event.end,
          event: event
        });
      });

      function merge(ranges) {
        var protoIR = new ProtoIR(ProtoIR.ANIMATION_TYPE, CSS_IR_NAME);
        ranges.forEach(function(range) {
          protoIR.pushEvent(range.event);
        });
        return protoIR;
      }

      return tr.b.mergeRanges(animationRanges,
                              ANIMATION_MERGE_THRESHOLD_MS,
                              merge);
    },

    postProcessProtoIRs: function(protoIRs) {
      // protoIRs is input only. Returns a modified set of ProtoIRs.
      // The order is important.
      protoIRs = this.mergeIntersectingResponses(protoIRs);
      protoIRs = this.mergeIntersectingAnimations(protoIRs);
      protoIRs = this.fixResponseAnimationStarts(protoIRs);
      protoIRs = this.fixTapResponseTouchAnimations(protoIRs);
      return protoIRs;
    },

    // TouchStarts happen at the same time as ScrollBegins.
    // It's easier to let multiple handlers create multiple overlapping
    // Responses and then merge them, rather than make the handlers aware of the
    // other handlers' PIRs.
    //
    // For example:
    // RR
    //  RRR  -> RRRRR
    //    RR
    //
    // protoIRs is input only.
    // Returns a modified set of ProtoIRs.
    mergeIntersectingResponses: function(protoIRs) {
      var newPIRs = [];
      while (protoIRs.length) {
        var pir = protoIRs.shift();
        newPIRs.push(pir);

        // Only consider Responses for now.
        if (pir.irType !== ProtoIR.RESPONSE_TYPE)
          continue;

        for (var i = 0; i < protoIRs.length; ++i) {
          var otherPIR = protoIRs[i];

          if (otherPIR.irType !== pir.irType)
            continue;

          if (!otherPIR.intersects(pir))
            continue;

          // Don't merge together Responses of the same type.
          // If handleTouchEvents wanted two of its Responses to be merged, then
          // it would have made them that way to begin with.
          var typeNames = pir.associatedEvents.map(function(event) {
            return event.typeName;
          });
          if (otherPIR.containsTypeNames(typeNames))
            continue;

          pir.merge(otherPIR);
          protoIRs.splice(i, 1);
          // Don't skip the next otherPIR!
          --i;
        }
      }
      return newPIRs;
    },

    // An animation is simply an expectation of 60fps between start and end.
    // If two animations overlap, then merge them.
    //
    // For example:
    // AA
    //  AAA  -> AAAAA
    //    AA
    //
    // protoIRs is input only.
    // Returns a modified set of ProtoIRs.
    mergeIntersectingAnimations: function(protoIRs) {
      var newPIRs = [];
      while (protoIRs.length) {
        var pir = protoIRs.shift();
        newPIRs.push(pir);

        // Only consider Animations for now.
        if (pir.irType !== ProtoIR.ANIMATION_TYPE)
          continue;

        var isCSS = pir.containsSliceTitle(CSS_ANIMATION_TITLE);
        var isFling = pir.containsTypeNames([INPUT_TYPE.FLING_START]);

        for (var i = 0; i < protoIRs.length; ++i) {
          var otherPIR = protoIRs[i];

          if (otherPIR.irType !== pir.irType)
            continue;

          // Don't merge CSS Animations with any other types.
          if (isCSS != otherPIR.containsSliceTitle(CSS_ANIMATION_TITLE))
            continue;

          if (!otherPIR.intersects(pir))
            continue;

          // Don't merge Fling Animations with any other types.
          if (isFling != otherPIR.containsTypeNames([INPUT_TYPE.FLING_START]))
            continue;

          pir.merge(otherPIR);
          protoIRs.splice(i, 1);
          // Don't skip the next otherPIR!
          --i;
        }
      }
      return newPIRs;
    },

    // The ends of responses frequently overlap the starts of animations.
    // Fix the animations to reflect the fact that the user can only start to
    // expect 60fps after the response.
    //
    // For example:
    // RRR   -> RRRAA
    //  AAAA
    //
    // protoIRs is input only.
    // Returns a modified set of ProtoIRs.
    fixResponseAnimationStarts: function(protoIRs) {
      protoIRs.forEach(function(apir) {
        // Only consider animations for now.
        if (apir.irType !== ProtoIR.ANIMATION_TYPE)
          return;

        protoIRs.forEach(function(rpir) {
          // Only consider responses for now.
          if (rpir.irType !== ProtoIR.RESPONSE_TYPE)
            return;

          // Only consider responses that end during the animation.
          if (!apir.containsTimestampInclusive(rpir.end))
            return;

          // Ignore Responses that are entirely contained by the animation.
          if (apir.containsTimestampInclusive(rpir.start))
            return;

          // Move the animation start to the response end.
          apir.start = rpir.end;
        });
      });
      return protoIRs;
    },

    // Merge Tap Responses that overlap Touch-only Animations.
    // https://github.com/catapult-project/catapult/issues/1431
    fixTapResponseTouchAnimations: function(protoIRs) {
      function isTapResponse(pir) {
        return (pir.irType === ProtoIR.RESPONSE_TYPE) &&
               pir.containsTypeNames([INPUT_TYPE.TAP]);
      }
      function isTouchAnimation(pir) {
        return (pir.irType === ProtoIR.ANIMATION_TYPE) &&
               pir.containsTypeNames([INPUT_TYPE.TOUCH_MOVE]) &&
               !pir.containsTypeNames([
                   INPUT_TYPE.SCROLL_UPDATE, INPUT_TYPE.PINCH_UPDATE]);
      }
      var newPIRs = [];
      while (protoIRs.length) {
        var pir = protoIRs.shift();
        newPIRs.push(pir);

        // protoIRs are sorted by start time, and we don't know whether the Tap
        // Response or the Touch Animation will be first
        var pirIsTapResponse = isTapResponse(pir);
        var pirIsTouchAnimation = isTouchAnimation(pir);
        if (!pirIsTapResponse && !pirIsTouchAnimation)
          continue;

        for (var i = 0; i < protoIRs.length; ++i) {
          var otherPIR = protoIRs[i];

          if (!otherPIR.intersects(pir))
            continue;

          if (pirIsTapResponse && !isTouchAnimation(otherPIR))
            continue;

          if (pirIsTouchAnimation && !isTapResponse(otherPIR))
            continue;

          // pir might be the Touch Animation, but the merged ProtoIR should be
          // a Response.
          pir.irType = ProtoIR.RESPONSE_TYPE;

          pir.merge(otherPIR);
          protoIRs.splice(i, 1);
          // Don't skip the next otherPIR!
          --i;
        }
      }
      return newPIRs;
    },

    // Check that none of the handlers accidentally ignored an input event.
    checkAllInputEventsHandled: function(protoIRs) {
      var handledEvents = [];
      protoIRs.forEach(function(protoIR) {
        protoIR.associatedEvents.forEach(function(event) {
          if (handledEvents.indexOf(event) >= 0) {
            console.error('double-handled event', event.typeName,
                parseInt(event.start), parseInt(event.end), protoIR);
            return;
          }
          handledEvents.push(event);
        });
      });

      this.getSortedInputEvents(ALL_HANDLED_TYPE_NAMES).forEach(
          function(event) {
        if (handledEvents.indexOf(event) < 0) {
          console.error('UNHANDLED INPUT EVENT!',
              event.typeName, parseInt(event.start), parseInt(event.end));
        }
      });
    }
  };

  function createCustomizeModelLinesFromModel(model) {
    var modelLines = [];
    modelLines.push('      audits.addEvent(model.browserMain,');
    modelLines.push('          {title: \'model start\', start: 0, end: 1});');

    var typeNames = {};
    for (var typeName in tr.e.cc.INPUT_EVENT_TYPE_NAMES) {
      typeNames[tr.e.cc.INPUT_EVENT_TYPE_NAMES[typeName]] = typeName;
    }

    var modelEvents = new tr.model.EventSet();
    model.interactionRecords.forEach(function(ir, index) {
      modelEvents.addEventSet(ir.sourceEvents);
    });
    modelEvents = modelEvents.toArray();
    modelEvents.sort(compareEvents);

    modelEvents.forEach(function(event) {
      var startAndEnd = 'start: ' + parseInt(event.start) + ', ' +
                        'end: ' + parseInt(event.end) + '});';
      if (event instanceof tr.e.cc.InputLatencyAsyncSlice) {
        modelLines.push('      audits.addInputEvent(model, INPUT_TYPE.' +
                        typeNames[event.typeName] + ',');
      } else if (event.title === 'RenderFrameImpl::didCommitProvisionalLoad') {
        modelLines.push('      audits.addCommitLoadEvent(model,');
      } else if (event.title ===
                 'InputHandlerProxy::HandleGestureFling::started') {
        modelLines.push('      audits.addFlingAnimationEvent(model,');
      } else if (event.title === tr.e.audits.IMPL_RENDERING_STATS) {
        modelLines.push('      audits.addFrameEvent(model,');
      } else if (event.title === CSS_ANIMATION_TITLE) {
        modelLines.push('      audits.addEvent(model.rendererMain, {');
        modelLines.push('        title: \'Animation\', ' + startAndEnd);
        return;
      } else {
        throw ('You must extend createCustomizeModelLinesFromModel()' +
               'to support this event:\n' + event.title + '\n');
      }
      modelLines.push('          {' + startAndEnd);
    });

    modelLines.push('      audits.addEvent(model.browserMain,');
    modelLines.push('          {' +
                    'title: \'model end\', ' +
                    'start: ' + (parseInt(model.bounds.max) - 1) + ', ' +
                    'end: ' + parseInt(model.bounds.max) + '});');
    return modelLines;
  }

  function createExpectedIRLinesFromModel(model) {
    var expectedLines = [];
    var irCount = model.interactionRecords.length;
    model.interactionRecords.forEach(function(ir, index) {
      var irString = '      {';
      irString += 'title: \'' + ir.title + '\', ';
      irString += 'start: ' + parseInt(ir.start) + ', ';
      irString += 'end: ' + parseInt(ir.end) + ', ';
      irString += 'eventCount: ' + ir.sourceEvents.length;
      irString += '}';
      if (index < (irCount - 1))
        irString += ',';
      expectedLines.push(irString);
    });
    return expectedLines;
  }

  function createIRFinderTestCaseStringFromModel(model) {
    var filename = window.location.hash.substr(1);
    var testName = filename.substr(filename.lastIndexOf('/') + 1);
    testName = testName.substr(0, testName.indexOf('.'));

    // createCustomizeModelLinesFromModel() throws an error if there's an
    // unsupported event.
    try {
      var testLines = [];
      testLines.push('  /*');
      testLines.push('    This test was generated from');
      testLines.push('    ' + filename + '');
      testLines.push('   */');
      testLines.push('  test(\'' + testName + '\', function() {');
      testLines.push('    var verifier = new IRVerifier();');
      testLines.push('    verifier.customizeModelCallback = function(model) {');
      testLines.push.apply(testLines,
          createCustomizeModelLinesFromModel(model));
      testLines.push('    };');
      testLines.push('    verifier.expectedIRs = [');
      testLines.push.apply(testLines, createExpectedIRLinesFromModel(model));
      testLines.push('    ];');
      testLines.push('    verifier.verify();');
      testLines.push('  });');
      return testLines.join('\n');
    } catch (error) {
      return error;
    }
  }

  return {
    RAILIRFinder: RAILIRFinder,
    createIRFinderTestCaseStringFromModel: createIRFinderTestCaseStringFromModel
  };
});


'use strict';

/**
 * @fileoverview Base class for trace data Auditors.
 */
tr.exportTo('tr.e.audits', function() {
  var Auditor = tr.c.Auditor;

  /**
   * Auditor for Chrome-specific traces.
   * @constructor
   */
  function ChromeAuditor(model) {
    Auditor.call(this, model);

    if (tr.e.audits.ChromeModelHelper.supportsModel(this.model)) {
      var modelHelper = new tr.e.audits.ChromeModelHelper(this.model);

      // Must be a browserHelper in order to do audits.
      if (modelHelper.browserHelper === undefined)
        this.modelHelper = undefined;
      else
        this.modelHelper = modelHelper;
    } else {
      this.modelHelper = undefined;
    }
  };

  ChromeAuditor.prototype = {
    __proto__: Auditor.prototype,

    runAnnotate: function() {
      if (!this.modelHelper)
        return;

      this.model.getAllProcesses().forEach(function(process) {
        if (process.labels !== undefined &&
            process.labels.length == 1 &&
            process.labels[0] == 'chrome://tracing')
          process.important = false;
      });
    },

    runAudit: function() {
      if (!this.modelHelper)
        return;

      if (!tr.e.rail.RAILIRFinder.supportsModelHelper(this.modelHelper))
        return;

      var rirf = new tr.e.rail.RAILIRFinder(this.model, this.modelHelper);
      var rirs = undefined;
      try {
        rirs = rirf.findAllInteractionRecords();
        // There are not currently any known cases when this could throw.
      } catch (error) {
        this.model.importWarning(error);
        return;
      }

      rirs.forEach(function(ir) {
        this.model.addInteractionRecord(ir);

        var alerts = this.createAlertsForIR_(ir);
        alerts.forEach(function(alert) {
          this.model.alerts.push(alert);
        }, this);
      }, this);
    },

    createAlertsForIR_: function(ir) {
      var allAlerts = [];
      ir.associatedEvents.forEach(function(event) {
        if (!(event instanceof tr.model.Slice))
          return;
        var slice = event;

        if (slice.category != 'toplevel')
          return;
        if (slice.duration > 75.0) {
          var alertInfo = new tr.model.EventInfo(
              'Task too long',
              'Tasks taking >= 75ms are bad, and should be broken up to ' +
              'ensure the main thread is responsive');
          var center = slice.start + 0.5 * slice.duration;
          var alert = new tr.model.Alert(
              alertInfo, center, [slice]);
          allAlerts.push(alert);
        }
      });
      return allAlerts;
    }
  };

  Auditor.register(ChromeAuditor);

  return {
    ChromeAuditor: ChromeAuditor
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  /**
   * @constructor
   */
  function PictureAsImageData(picture, errorOrImageData) {
    this.picture_ = picture;
    if (errorOrImageData instanceof ImageData) {
      this.error_ = undefined;
      this.imageData_ = errorOrImageData;
    } else {
      this.error_ = errorOrImageData;
      this.imageData_ = undefined;
    }
  };

  /**
   * Creates a new pending PictureAsImageData (no image data and no error).
   *
   * @return {PictureAsImageData} a new pending PictureAsImageData.
   */
  PictureAsImageData.Pending = function(picture) {
    return new PictureAsImageData(picture, undefined);
  };

  PictureAsImageData.prototype = {
    get picture() {
      return this.picture_;
    },

    get error() {
      return this.error_;
    },

    get imageData() {
      return this.imageData_;
    },

    isPending: function() {
      return this.error_ === undefined && this.imageData_ === undefined;
    },

    asCanvas: function() {
      if (!this.imageData_)
        return;

      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');

      canvas.width = this.imageData_.width;
      canvas.height = this.imageData_.height;
      ctx.putImageData(this.imageData_, 0, 0);
      return canvas;
    }
  };

  return {
    PictureAsImageData: PictureAsImageData
  };
});



'use strict';

tr.exportTo('tr.e.cc', function() {
  var convertedNameCache = {};
  function convertNameToJSConvention(name) {
    if (name in convertedNameCache)
      return convertedNameCache[name];

    if (name[0] == '_' ||
        name[name.length - 1] == '_') {
      convertedNameCache[name] = name;
      return name;
    }

    var words = name.split('_');
    if (words.length == 1) {
      convertedNameCache[name] = words[0];
      return words[0];
    }

    for (var i = 1; i < words.length; i++)
      words[i] = words[i][0].toUpperCase() + words[i].substring(1);

    convertedNameCache[name] = words.join('');
    return convertedNameCache[name];
  }

  function convertObjectFieldNamesToJSConventions(object) {
    tr.b.iterObjectFieldsRecursively(
        object,
        function(object, fieldName, fieldValue) {
          delete object[fieldName];
          object[newFieldName] = fieldValue;
          return newFieldName;
        });
  }

  function convertQuadSuffixedTypesToQuads(object) {
    tr.b.iterObjectFieldsRecursively(
        object,
        function(object, fieldName, fieldValue) {
        });
  }

  function convertObject(object) {
    convertObjectFieldNamesToJSConventions(object);
    convertQuadSuffixedTypesToQuads(object);
  }

  function moveRequiredFieldsFromArgsToToplevel(object, fields) {
    for (var i = 0; i < fields.length; i++) {
      var key = fields[i];
      if (object.args[key] === undefined)
        throw Error('Expected field ' + key + ' not found in args');
      if (object[key] !== undefined)
        throw Error('Field ' + key + ' already in object');
      object[key] = object.args[key];
      delete object.args[key];
    }
  }

  function moveOptionalFieldsFromArgsToToplevel(object, fields) {
    for (var i = 0; i < fields.length; i++) {
      var key = fields[i];
      if (object.args[key] === undefined)
        continue;
      if (object[key] !== undefined)
        throw Error('Field ' + key + ' already in object');
      object[key] = object.args[key];
      delete object.args[key];
    }
  }

  function preInitializeObject(object) {
    preInitializeObjectInner(object.args, false);
  }

  function preInitializeObjectInner(object, hasRecursed) {
    if (!(object instanceof Object))
      return;

    if (object instanceof Array) {
      for (var i = 0; i < object.length; i++)
        preInitializeObjectInner(object[i], true);
      return;
    }

    if (hasRecursed &&
        (object instanceof tr.model.ObjectSnapshot ||
         object instanceof tr.model.ObjectInstance))
      return;

    for (var key in object) {
      var newKey = convertNameToJSConvention(key);
      if (newKey != key) {
        var value = object[key];
        delete object[key];
        object[newKey] = value;
        key = newKey;
      }

      // Convert objects with keys ending with Quad to tr.b.Quad type.
      if (/Quad$/.test(key) && !(object[key] instanceof tr.b.Quad)) {
        var q;
        try {
          q = tr.b.Quad.from8Array(object[key]);
        } catch (e) {
          console.log(e);
        }
        object[key] = q;
        continue;
      }

      // Convert objects with keys ending with Rect to tr.b.Rect type.
      if (/Rect$/.test(key) && !(object[key] instanceof tr.b.Rect)) {
        var r;
        try {
          r = tr.b.Rect.fromArray(object[key]);
        } catch (e) {
          console.log(e);
        }
        object[key] = r;
      }

      preInitializeObjectInner(object[key], true);
    }
  }

  function bytesToRoundedMegabytes(bytes) {
    return Math.round(bytes / 100000.0) / 10.0;
  }

  return {
    preInitializeObject: preInitializeObject,
    convertNameToJSConvention: convertNameToJSConvention,
    moveRequiredFieldsFromArgsToToplevel: moveRequiredFieldsFromArgsToToplevel,
    moveOptionalFieldsFromArgsToToplevel: moveOptionalFieldsFromArgsToToplevel,
    bytesToRoundedMegabytes: bytesToRoundedMegabytes
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  // Number of pictures created. Used as an uniqueId because we are immutable.
  var PictureCount = 0;
  var OPS_TIMING_ITERATIONS = 3;

  function Picture(skp64, layerRect) {
    this.skp64_ = skp64;
    this.layerRect_ = layerRect;

    this.guid_ = tr.b.GUID.allocate();
  }

  Picture.prototype = {
    get canSave() {
      return true;
    },

    get layerRect() {
      return this.layerRect_;
    },

    get guid() {
      return this.guid_;
    },

    getBase64SkpData: function() {
      return this.skp64_;
    },

    getOps: function() {
      if (!PictureSnapshot.CanGetOps()) {
        console.error(PictureSnapshot.HowToEnablePictureDebugging());
        return undefined;
      }

      var ops = window.chrome.skiaBenchmarking.getOps({
        skp64: this.skp64_,
        params: {
          layer_rect: this.layerRect_.toArray()
        }
      });

      if (!ops)
        console.error('Failed to get picture ops.');

      return ops;
    },

    getOpTimings: function() {
      if (!PictureSnapshot.CanGetOpTimings()) {
        console.error(PictureSnapshot.HowToEnablePictureDebugging());
        return undefined;
      }

      var opTimings = window.chrome.skiaBenchmarking.getOpTimings({
        skp64: this.skp64_,
        params: {
          layer_rect: this.layerRect_.toArray()
        }
      });

      if (!opTimings)
        console.error('Failed to get picture op timings.');

      return opTimings;
    },

    /**
     * Tag each op with the time it takes to rasterize.
     *
     * FIXME: We should use real statistics to get better numbers here, see
     *        https://code.google.com/p/trace-viewer/issues/detail?id=357
     *
     * @param {Array} ops Array of Skia operations.
     * @return {Array} Skia ops where op.cmd_time contains the associated time
     *         for a given op.
     */
    tagOpsWithTimings: function(ops) {
      var opTimings = new Array();
      for (var iteration = 0; iteration < OPS_TIMING_ITERATIONS; iteration++) {
        opTimings[iteration] = this.getOpTimings();
        if (!opTimings[iteration] || !opTimings[iteration].cmd_times)
          return ops;
        if (opTimings[iteration].cmd_times.length != ops.length)
          return ops;
      }

      for (var opIndex = 0; opIndex < ops.length; opIndex++) {
        var min = Number.MAX_VALUE;
        for (var i = 0; i < OPS_TIMING_ITERATIONS; i++)
          min = Math.min(min, opTimings[i].cmd_times[opIndex]);
        ops[opIndex].cmd_time = min;
      }

      return ops;
    },

    /**
     * Rasterize the picture.
     *
     * @param {{opt_stopIndex: number, params}} The SkPicture operation to
     *     rasterize up to. If not defined, the entire SkPicture is rasterized.
     * @param {{opt_showOverdraw: bool, params}} Defines whether pixel overdraw
           should be visualized in the image.
     * @param {function(tr.e.cc.PictureAsImageData)} The callback function that
     *     is called after rasterization is complete or fails.
     */
    rasterize: function(params, rasterCompleteCallback) {
      if (!PictureSnapshot.CanRasterize() || !PictureSnapshot.CanGetOps()) {
        rasterCompleteCallback(new tr.e.cc.PictureAsImageData(
            this, tr.e.cc.PictureSnapshot.HowToEnablePictureDebugging()));
        return;
      }

      var raster = window.chrome.skiaBenchmarking.rasterize(
          {
            skp64: this.skp64_,
            params: {
              layer_rect: this.layerRect_.toArray()
            }
          },
          {
            stop: params.stopIndex === undefined ? -1 : params.stopIndex,
            overdraw: !!params.showOverdraw,
            params: { }
          });

      if (raster) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = raster.width;
        canvas.height = raster.height;
        var imageData = ctx.createImageData(raster.width, raster.height);
        imageData.data.set(new Uint8ClampedArray(raster.data));
        rasterCompleteCallback(new tr.e.cc.PictureAsImageData(this, imageData));
      } else {
        var error = 'Failed to rasterize picture. ' +
                'Your recording may be from an old Chrome version. ' +
                'The SkPicture format is not backward compatible.';
        rasterCompleteCallback(new tr.e.cc.PictureAsImageData(this, error));
      }
    }
  };

  function LayeredPicture(pictures) {
    this.guid_ = tr.b.GUID.allocate();
    this.pictures_ = pictures;
    this.layerRect_ = undefined;
  }

  LayeredPicture.prototype = {
    __proto__: Picture.prototype,

    get canSave() {
      return false;
    },

    get typeName() {
      return 'cc::LayeredPicture';
    },

    get layerRect() {
      if (this.layerRect_ !== undefined)
        return this.layerRect_;

      this.layerRect_ = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };

      for (var i = 0; i < this.pictures_.length; ++i) {
        var rect = this.pictures_[i].layerRect;
        this.layerRect_.x = Math.min(this.layerRect_.x, rect.x);
        this.layerRect_.y = Math.min(this.layerRect_.y, rect.y);
        this.layerRect_.width =
            Math.max(this.layerRect_.width, rect.x + rect.width);
        this.layerRect_.height =
            Math.max(this.layerRect_.height, rect.y + rect.height);
      }
      return this.layerRect_;
    },

    get guid() {
      return this.guid_;
    },

    getBase64SkpData: function() {
      throw new Error('Not available with a LayeredPicture.');
    },

    getOps: function() {
      var ops = [];
      for (var i = 0; i < this.pictures_.length; ++i)
        ops = ops.concat(this.pictures_[i].getOps());
      return ops;
    },

    getOpTimings: function() {
      var opTimings = this.pictures_[0].getOpTimings();
      for (var i = 1; i < this.pictures_.length; ++i) {
        var timings = this.pictures_[i].getOpTimings();
        opTimings.cmd_times = opTimings.cmd_times.concat(timings.cmd_times);
        opTimings.total_time += timings.total_time;
      }
      return opTimings;
    },

    tagOpsWithTimings: function(ops) {
      var opTimings = new Array();
      for (var iteration = 0; iteration < OPS_TIMING_ITERATIONS; iteration++) {
        opTimings[iteration] = this.getOpTimings();
        if (!opTimings[iteration] || !opTimings[iteration].cmd_times)
          return ops;
      }

      for (var opIndex = 0; opIndex < ops.length; opIndex++) {
        var min = Number.MAX_VALUE;
        for (var i = 0; i < OPS_TIMING_ITERATIONS; i++)
          min = Math.min(min, opTimings[i].cmd_times[opIndex]);
        ops[opIndex].cmd_time = min;
      }
      return ops;
    },

    rasterize: function(params, rasterCompleteCallback) {
      this.picturesAsImageData_ = [];
      var rasterCallback = function(pictureAsImageData) {
        this.picturesAsImageData_.push(pictureAsImageData);
        if (this.picturesAsImageData_.length !== this.pictures_.length)
          return;

        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = this.layerRect.width;
        canvas.height = this.layerRect.height;

        // TODO(dsinclair): Verify these finish in the order started.
        //   Do the rasterize calls run sync or asyn? As the imageData
        //   going to be in the same order as the pictures_ list?
        for (var i = 0; i < this.picturesAsImageData_.length; ++i) {
          ctx.putImageData(this.picturesAsImageData_[i].imageData,
                           this.pictures_[i].layerRect.x,
                           this.pictures_[i].layerRect.y);
        }
        this.picturesAsImageData_ = [];

        rasterCompleteCallback(new tr.e.cc.PictureAsImageData(this,
            ctx.getImageData(this.layerRect.x, this.layerRect.y,
                             this.layerRect.width, this.layerRect.height)));
      }.bind(this);

      for (var i = 0; i < this.pictures_.length; ++i)
        this.pictures_[i].rasterize(params, rasterCallback);
    }
  };


  /**
   * @constructor
   */
  function PictureSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  PictureSnapshot.HasSkiaBenchmarking = function() {
    return tr.isExported('chrome.skiaBenchmarking');
  }

  PictureSnapshot.CanRasterize = function() {
    if (!PictureSnapshot.HasSkiaBenchmarking())
      return false;
    if (!window.chrome.skiaBenchmarking.rasterize)
      return false;
    return true;
  }

  PictureSnapshot.CanGetOps = function() {
    if (!PictureSnapshot.HasSkiaBenchmarking())
      return false;
    if (!window.chrome.skiaBenchmarking.getOps)
      return false;
    return true;
  }

  PictureSnapshot.CanGetOpTimings = function() {
    if (!PictureSnapshot.HasSkiaBenchmarking())
      return false;
    if (!window.chrome.skiaBenchmarking.getOpTimings)
      return false;
    return true;
  }

  PictureSnapshot.CanGetInfo = function() {
    if (!PictureSnapshot.HasSkiaBenchmarking())
      return false;
    if (!window.chrome.skiaBenchmarking.getInfo)
      return false;
    return true;
  }

  PictureSnapshot.HowToEnablePictureDebugging = function() {
    if (tr.isHeadless)
      return 'Pictures only work in chrome';

    var usualReason = [
      'For pictures to show up, you need to have Chrome running with ',
      '--enable-skia-benchmarking. Please restart chrome with this flag ',
      'and try again.'
    ].join('');

    if (!tr.isExported('global.chrome.skiaBenchmarking'))
      return usualReason;
    if (!global.chrome.skiaBenchmarking.rasterize)
      return 'Your chrome is old';
    if (!global.chrome.skiaBenchmarking.getOps)
      return 'Your chrome is old: skiaBenchmarking.getOps not found';
    if (!global.chrome.skiaBenchmarking.getOpTimings)
      return 'Your chrome is old: skiaBenchmarking.getOpTimings not found';
    if (!global.chrome.skiaBenchmarking.getInfo)
      return 'Your chrome is old: skiaBenchmarking.getInfo not found';
    return 'Rasterizing is on';
  }

  PictureSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize: function() {
      tr.e.cc.preInitializeObject(this);
      this.rasterResult_ = undefined;
    },

    initialize: function() {
      // If we have an alias args, that means this picture was represented
      // by an alias, and the real args is in alias.args.
      if (this.args.alias)
        this.args = this.args.alias.args;

      if (!this.args.params.layerRect)
        throw new Error('Missing layer rect');

      this.layerRect_ = this.args.params.layerRect;
      this.picture_ = new Picture(this.args.skp64, this.args.params.layerRect);
    },

    set picture(picture) {
      this.picture_ = picture;
    },

    get canSave() {
      return this.picture_.canSave;
    },

    get layerRect() {
      return this.layerRect_ ? this.layerRect_ : this.picture_.layerRect;
    },

    get guid() {
      return this.picture_.guid;
    },

    getBase64SkpData: function() {
      return this.picture_.getBase64SkpData();
    },

    getOps: function() {
      return this.picture_.getOps();
    },

    getOpTimings: function() {
      return this.picture_.getOpTimings();
    },

    tagOpsWithTimings: function(ops) {
      return this.picture_.tagOpsWithTimings(ops);
    },

    rasterize: function(params, rasterCompleteCallback) {
      this.picture_.rasterize(params, rasterCompleteCallback);
    }
  };

  ObjectSnapshot.register(
      PictureSnapshot,
      {typeNames: ['cc::Picture']});

  return {
    PictureSnapshot: PictureSnapshot,
    Picture: Picture,
    LayeredPicture: LayeredPicture
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  function DisplayItemList(skp64, layerRect) {
    tr.e.cc.Picture.apply(this, arguments);
  }

  DisplayItemList.prototype = {
    __proto__: tr.e.cc.Picture.prototype
  };

  /**
   * @constructor
   */
  function DisplayItemListSnapshot() {
    tr.e.cc.PictureSnapshot.apply(this, arguments);
  }

  DisplayItemListSnapshot.prototype = {
    __proto__: tr.e.cc.PictureSnapshot.prototype,

    initialize: function() {
      tr.e.cc.PictureSnapshot.prototype.initialize.call(this);
      this.displayItems_ = this.args.params.items;
    },

    get items() {
      return this.displayItems_;
    }
  };

  ObjectSnapshot.register(
      DisplayItemListSnapshot,
      {typeNames: ['cc::DisplayItemList']});

  return {
    DisplayItemListSnapshot: DisplayItemListSnapshot,
    DisplayItemList: DisplayItemList
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  var constants = {};
  constants.ACTIVE_TREE = 0;
  constants.PENDING_TREE = 1;

  constants.HIGH_PRIORITY_BIN = 0;
  constants.LOW_PRIORITY_BIN = 1;

  constants.SEND_BEGIN_FRAME_EVENT =
    'ThreadProxy::ScheduledActionSendBeginMainFrame';
  constants.BEGIN_MAIN_FRAME_EVENT = 'ThreadProxy::BeginMainFrame';

  return {
    constants: constants
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  /**
   * @constructor
   */
  function Region() {
    this.rects = [];
  }

  Region.fromArray = function(array) {
    if (array.length % 4 != 0)
      throw new Error('Array must consist be a multiple of 4 in length');

    var r = new Region();
    for (var i = 0; i < array.length; i += 4) {
      r.rects.push(tr.b.Rect.fromXYWH(array[i], array[i + 1],
                                      array[i + 2], array[i + 3]));
    }
    return r;
  }

  /**
   * @return {Region} If array is undefined, returns an empty region. Otherwise
   * returns Region.fromArray(array).
   */
  Region.fromArrayOrUndefined = function(array) {
    if (array === undefined)
      return new Region();
    return Region.fromArray(array);
  };

  Region.prototype = {
    __proto__: Region.prototype,

    rectIntersects: function(r) {
      for (var i = 0; i < this.rects.length; i++) {
        if (this.rects[i].intersects(r))
          return true;
      }
      return false;
    },

    addRect: function(r) {
      this.rects.push(r);
    }
  };

  return {
    Region: Region
  };
});



'use strict';

tr.exportTo('tr.e.cc', function() {
  /**
   * This class represents a tile (from impl side) and its final rect on the
   * layer. Note that the rect is determined by what is needed to cover all
   * of the layer without overlap.
   * @constructor
   */
  function TileCoverageRect(rect, tile) {
    this.geometryRect = rect;
    this.tile = tile;
  }

  return {
    TileCoverageRect: TileCoverageRect
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  var constants = tr.e.cc.constants;
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function LayerImplSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  LayerImplSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize: function() {
      tr.e.cc.preInitializeObject(this);

      this.layerTreeImpl_ = undefined;
      this.parentLayer = undefined;
    },

    initialize: function() {
      // Defaults.
      this.invalidation = new tr.e.cc.Region();
      this.annotatedInvalidation = new tr.e.cc.Region();
      this.unrecordedRegion = new tr.e.cc.Region();
      this.pictures = [];

      // Import & validate this.args
      tr.e.cc.moveRequiredFieldsFromArgsToToplevel(
          this, ['layerId', 'children',
                 'layerQuad']);
      tr.e.cc.moveOptionalFieldsFromArgsToToplevel(
          this, ['maskLayer', 'replicaLayer',
                 'idealContentsScale', 'geometryContentsScale',
                 'layoutRects', 'usingGpuRasterization']);

      // Leave gpu memory usage in both places.
      this.gpuMemoryUsageInBytes = this.args.gpuMemoryUsage;

      // Leave bounds in both places.
      this.bounds = tr.b.Rect.fromXYWH(
          0, 0,
          this.args.bounds.width, this.args.bounds.height);

      if (this.args.animationBounds) {
        // AnimationBounds[2] and [5] are the Z-component of the box.
        this.animationBoundsRect = tr.b.Rect.fromXYWH(
            this.args.animationBounds[0], this.args.animationBounds[1],
            this.args.animationBounds[3], this.args.animationBounds[4]);
      }

      for (var i = 0; i < this.children.length; i++)
        this.children[i].parentLayer = this;
      if (this.maskLayer)
        this.maskLayer.parentLayer = this;
      if (this.replicaLayer)
        this.replicaLayer.parentLayer = this;
      if (!this.geometryContentsScale)
        this.geometryContentsScale = 1.0;
      if (!this.idealContentsScale)
        this.idealContentsScale = 1.0;

      this.touchEventHandlerRegion = tr.e.cc.Region.fromArrayOrUndefined(
          this.args.touchEventHandlerRegion);
      this.wheelEventHandlerRegion = tr.e.cc.Region.fromArrayOrUndefined(
          this.args.wheelEventHandlerRegion);
      this.nonFastScrollableRegion = tr.e.cc.Region.fromArrayOrUndefined(
          this.args.nonFastScrollableRegion);
    },

    get layerTreeImpl() {
      if (this.layerTreeImpl_)
        return this.layerTreeImpl_;
      if (this.parentLayer)
        return this.parentLayer.layerTreeImpl;
      return undefined;
    },
    set layerTreeImpl(layerTreeImpl) {
      this.layerTreeImpl_ = layerTreeImpl;
    },

    get activeLayer() {
      if (this.layerTreeImpl.whichTree == constants.ACTIVE_TREE)
        return this;
      var activeTree = this.layerTreeImpl.layerTreeHostImpl.activeTree;
      return activeTree.findLayerWithId(this.layerId);
    },

    get pendingLayer() {
      if (this.layerTreeImpl.whichTree == constants.PENDING_TREE)
        return this;
      var pendingTree = this.layerTreeImpl.layerTreeHostImpl.pendingTree;
      return pendingTree.findLayerWithId(this.layerId);
    }
  };

  /**
   * @constructor
   */
  function PictureLayerImplSnapshot() {
    LayerImplSnapshot.apply(this, arguments);
  }

  PictureLayerImplSnapshot.prototype = {
    __proto__: LayerImplSnapshot.prototype,

    initialize: function() {
      LayerImplSnapshot.prototype.initialize.call(this);

      if (this.args.invalidation) {
        this.invalidation = tr.e.cc.Region.fromArray(this.args.invalidation);
        delete this.args.invalidation;
      }
      if (this.args.annotatedInvalidationRects) {
        this.annotatedInvalidation = new tr.e.cc.Region();
        for (var i = 0; i < this.args.annotatedInvalidationRects.length; ++i) {
          var annotatedRect = this.args.annotatedInvalidationRects[i];
          var rect = annotatedRect.geometryRect;
          rect.reason = annotatedRect.reason;
          this.annotatedInvalidation.addRect(rect);
        }
        delete this.args.annotatedInvalidationRects;
      }
      if (this.args.unrecordedRegion) {
        this.unrecordedRegion = tr.e.cc.Region.fromArray(
            this.args.unrecordedRegion);
        delete this.args.unrecordedRegion;
      }
      if (this.args.pictures) {
        this.pictures = this.args.pictures;

        // The picture list comes in with an unknown ordering. We resort based
        // on timestamp order so we will draw the base picture first and the
        // various fixes on top of that.
        this.pictures.sort(function(a, b) { return a.ts - b.ts; });
      }

      this.tileCoverageRects = [];
      if (this.args.coverageTiles) {
        for (var i = 0; i < this.args.coverageTiles.length; ++i) {
          var rect = this.args.coverageTiles[i].geometryRect.scale(
              this.idealContentsScale);
          var tile = this.args.coverageTiles[i].tile;
          this.tileCoverageRects.push(new tr.e.cc.TileCoverageRect(rect, tile));
        }
        delete this.args.coverageTiles;
      }
    }
  };

  ObjectSnapshot.register(
      PictureLayerImplSnapshot,
      {
        typeName: 'cc::PictureLayerImpl'
      });

  ObjectSnapshot.register(
      LayerImplSnapshot,
      {
        typeNames: [
          'cc::LayerImpl',
          'cc::DelegatedRendererLayerImpl',
          'cc::HeadsUpDisplayLayerImpl',
          'cc::IOSurfaceLayerImpl',
          'cc::NinePatchLayerImpl',
          'cc::PictureImageLayerImpl',
          'cc::ScrollbarLayerImpl',
          'cc::SolidColorLayerImpl',
          'cc::SurfaceLayerImpl',
          'cc::TextureLayerImpl',
          'cc::TiledLayerImpl',
          'cc::VideoLayerImpl',
          'cc::PaintedScrollbarLayerImpl',
          'ClankPatchLayer',
          'TabBorderLayer',
          'CounterLayer'
        ]
      });

  return {
    LayerImplSnapshot: LayerImplSnapshot,
    PictureLayerImplSnapshot: PictureLayerImplSnapshot
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {

  var constants = tr.e.cc.constants;
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function LayerTreeImplSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  LayerTreeImplSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize: function() {
      tr.e.cc.preInitializeObject(this);
      this.layerTreeHostImpl = undefined;
      this.whichTree = undefined;
      this.sourceFrameNumber = undefined;
    },

    initialize: function() {
      tr.e.cc.moveRequiredFieldsFromArgsToToplevel(
          this, ['rootLayer',
            'renderSurfaceLayerList']);
      if (this.args.sourceFrameNumber)
        this.sourceFrameNumber = this.args.sourceFrameNumber;
      this.rootLayer.layerTreeImpl = this;

      if (this.args.swapPromiseTraceIds &&
          this.args.swapPromiseTraceIds.length) {
        this.tracedInputLatencies = [];

        var ownProcess = this.objectInstance.parent;
        var model = ownProcess.model;
        if (tr.e.audits.ChromeModelHelper.supportsModel(model))
          this._initializeTracedInputLatencies(model);
      }
    },

    _initializeTracedInputLatencies: function(model) {
      var modelHelper = new tr.e.audits.ChromeModelHelper(model);
      if (!modelHelper.browserHelper)
        return;

      var latencyEvents = modelHelper.browserHelper.getLatencyEventsInRange(
          model.bounds);

      // Convert all ids to InputLatency Async objects.
      latencyEvents.forEach(function(event) {
        for (var i = 0; i < this.args.swapPromiseTraceIds.length; i++) {
          if (!event.args.data || !event.args.data.trace_id)
            continue;
          if (parseInt(event.args.data.trace_id) ===
              this.args.swapPromiseTraceIds[i])
            this.tracedInputLatencies.push(event);
        }
      }, this);
    },

    get hasSourceFrameBeenDrawnBefore() {
      if (this.whichTree == tr.e.cc.constants.PENDING_TREE)
        return false;

      // Old chrome's don't produce sourceFrameNumber.
      if (this.sourceFrameNumber === undefined)
        return;

      var thisLTHI = this.layerTreeHostImpl;
      var thisLTHIIndex = thisLTHI.objectInstance.snapshots.indexOf(
        thisLTHI);
      var prevLTHIIndex = thisLTHIIndex - 1;
      if (prevLTHIIndex < 0 ||
          prevLTHIIndex >= thisLTHI.objectInstance.snapshots.length)
        return false;
      var prevLTHI = thisLTHI.objectInstance.snapshots[prevLTHIIndex];
      if (!prevLTHI.activeTree)
        return false;

      // Old chrome's don't produce sourceFrameNumber.
      if (prevLTHI.activeTree.sourceFrameNumber === undefined)
        return;
      return prevLTHI.activeTree.sourceFrameNumber == this.sourceFrameNumber;
    },

    get otherTree() {
      var other = this.whichTree == constants.ACTIVE_TREE ?
          constants.PENDING_TREE : constants.ACTIVE_TREE;
      return this.layerTreeHostImpl.getTree(other);
    },

    get gpuMemoryUsageInBytes() {
      var totalBytes = 0;
      this.iterLayers(function(layer) {
        if (layer.gpuMemoryUsageInBytes !== undefined)
          totalBytes += layer.gpuMemoryUsageInBytes;
      });
      return totalBytes;
    },

    iterLayers: function(func, thisArg) {
      var visitedLayers = {};
      function visitLayer(layer, depth, isMask, isReplica) {
        if (visitedLayers[layer.layerId])
          return;
        visitedLayers[layer.layerId] = true;
        func.call(thisArg, layer, depth, isMask, isReplica);
        if (layer.children) {
          for (var i = 0; i < layer.children.length; i++)
            visitLayer(layer.children[i], depth + 1);
        }
        if (layer.maskLayer)
          visitLayer(layer.maskLayer, depth + 1, true, false);
        if (layer.replicaLayer)
          visitLayer(layer.replicaLayer, depth + 1, false, true);
      }
      visitLayer(this.rootLayer, 0, false, false);
    },
    findLayerWithId: function(id) {
      var foundLayer = undefined;
      function visitLayer(layer) {
        if (layer.layerId == id)
          foundLayer = layer;
      }
      this.iterLayers(visitLayer);
      return foundLayer;
    }
  };

  ObjectSnapshot.register(
      LayerTreeImplSnapshot,
      {typeName: 'cc::LayerTreeImpl'});

  return {
    LayerTreeImplSnapshot: LayerTreeImplSnapshot
  };
});


'use strict';

/**
 * @fileoverview 2D bounding box computations.
 */
tr.exportTo('tr.b', function() {

  /**
   * Tracks a 2D bounding box.
   * @constructor
   */
  function BBox2() {
    this.isEmpty_ = true;
    this.min_ = undefined;
    this.max_ = undefined;
  };

  BBox2.prototype = {
    __proto__: Object.prototype,

    reset: function() {
      this.isEmpty_ = true;
      this.min_ = undefined;
      this.max_ = undefined;
    },

    get isEmpty() {
      return this.isEmpty_;
    },

    addBBox2: function(bbox2) {
      if (bbox2.isEmpty)
        return;
      this.addVec2(bbox2.min_);
      this.addVec2(bbox2.max_);
    },

    clone: function() {
      var bbox = new BBox2();
      bbox.addBBox2(this);
      return bbox;
    },

    /**
     * Adds x, y to the range.
     */
    addXY: function(x, y) {
      if (this.isEmpty_) {
        this.max_ = vec2.create();
        this.min_ = vec2.create();
        vec2.set(this.max_, x, y);
        vec2.set(this.min_, x, y);
        this.isEmpty_ = false;
        return;
      }
      this.max_[0] = Math.max(this.max_[0], x);
      this.max_[1] = Math.max(this.max_[1], y);
      this.min_[0] = Math.min(this.min_[0], x);
      this.min_[1] = Math.min(this.min_[1], y);
    },

    /**
     * Adds value_x, value_y in the form [value_x,value_y] to the range.
     */
    addVec2: function(value) {
      if (this.isEmpty_) {
        this.max_ = vec2.create();
        this.min_ = vec2.create();
        vec2.set(this.max_, value[0], value[1]);
        vec2.set(this.min_, value[0], value[1]);
        this.isEmpty_ = false;
        return;
      }
      this.max_[0] = Math.max(this.max_[0], value[0]);
      this.max_[1] = Math.max(this.max_[1], value[1]);
      this.min_[0] = Math.min(this.min_[0], value[0]);
      this.min_[1] = Math.min(this.min_[1], value[1]);
    },

    addQuad: function(quad) {
      this.addVec2(quad.p1);
      this.addVec2(quad.p2);
      this.addVec2(quad.p3);
      this.addVec2(quad.p4);
    },

    get minVec2() {
      if (this.isEmpty_)
        return undefined;
      return this.min_;
    },

    get maxVec2() {
      if (this.isEmpty_)
        return undefined;
      return this.max_;
    },

    get sizeAsVec2() {
      if (this.isEmpty_)
        throw new Error('Empty BBox2 has no size');
      var size = vec2.create();
      vec2.subtract(size, this.max_, this.min_);
      return size;
    },

    get size() {
      if (this.isEmpty_)
        throw new Error('Empty BBox2 has no size');
      return {width: this.max_[0] - this.min_[0],
        height: this.max_[1] - this.min_[1]};
    },

    get width() {
      if (this.isEmpty_)
        throw new Error('Empty BBox2 has no width');
      return this.max_[0] - this.min_[0];
    },

    get height() {
      if (this.isEmpty_)
        throw new Error('Empty BBox2 has no width');
      return this.max_[1] - this.min_[1];
    },

    toString: function() {
      if (this.isEmpty_)
        return 'empty';
      return 'min=(' + this.min_[0] + ',' + this.min_[1] + ') ' +
          'max=(' + this.max_[0] + ',' + this.max_[1] + ')';
    },

    asRect: function() {
      return tr.b.Rect.fromXYWH(
          this.min_[0],
          this.min_[1],
          this.max_[0] - this.min_[0],
          this.max_[1] - this.min_[1]);
    }
  };

  return {
    BBox2: BBox2
  };

});


'use strict';

/**
 * @fileoverview Provides the LayerTreeHostImpl model-level objects.
 */
tr.exportTo('tr.e.cc', function() {
  var constants = tr.e.cc.constants;

  var ObjectSnapshot = tr.model.ObjectSnapshot;
  var ObjectInstance = tr.model.ObjectInstance;

  /**
   * @constructor
   */
  function LayerTreeHostImplSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  LayerTreeHostImplSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize: function() {
      tr.e.cc.preInitializeObject(this);
    },

    initialize: function() {
      tr.e.cc.moveRequiredFieldsFromArgsToToplevel(
          this, ['deviceViewportSize',
            'activeTree']);
      tr.e.cc.moveOptionalFieldsFromArgsToToplevel(
          this, ['pendingTree']);

      // Move active_tiles into this.tiles. If that doesn't exist then, then as
      // a backward compatability move tiles into this.tiles.
      if (this.args.activeTiles !== undefined) {
        this.activeTiles = this.args.activeTiles;
        delete this.args.activeTiles;
      } else if (this.args.tiles !== undefined) {
        this.activeTiles = this.args.tiles;
        delete this.args.tiles;
      }

      if (!this.activeTiles)
        this.activeTiles = [];

      this.activeTree.layerTreeHostImpl = this;
      this.activeTree.whichTree = constants.ACTIVE_TREE;
      if (this.pendingTree) {
        this.pendingTree.layerTreeHostImpl = this;
        this.pendingTree.whichTree = constants.PENDING_TREE;
      }
    },

    /**
     * Get all of tile scales and their associated names.
     */
    getContentsScaleNames: function() {
      var scales = {};
      for (var i = 0; i < this.activeTiles.length; ++i) {
        var tile = this.activeTiles[i];
        // Return scale -> scale name mappings.
        // Example:
        //  0.25 -> LOW_RESOLUTION
        //  1.0 -> HIGH_RESOLUTION
        //  0.75 -> NON_IDEAL_RESOLUTION
        scales[tile.contentsScale] = tile.resolution;
      }
      return scales;
    },

    getTree: function(whichTree) {
      if (whichTree == constants.ACTIVE_TREE)
        return this.activeTree;
      if (whichTree == constants.PENDING_TREE)
        return this.pendingTree;
      throw new Exception('Unknown tree type + ' + whichTree);
    },

    get tilesHaveGpuMemoryUsageInfo() {
      if (this.tilesHaveGpuMemoryUsageInfo_ !== undefined)
        return this.tilesHaveGpuMemoryUsageInfo_;

      for (var i = 0; i < this.activeTiles.length; i++) {
        if (this.activeTiles[i].gpuMemoryUsageInBytes === undefined)
          continue;
        this.tilesHaveGpuMemoryUsageInfo_ = true;
        return true;
      }
      this.tilesHaveGpuMemoryUsageInfo_ = false;
      return false;
    },

    get gpuMemoryUsageInBytes() {
      if (!this.tilesHaveGpuMemoryUsageInfo)
        return;

      var usage = 0;
      for (var i = 0; i < this.activeTiles.length; i++) {
        var u = this.activeTiles[i].gpuMemoryUsageInBytes;
        if (u !== undefined)
          usage += u;
      }
      return usage;
    },

    get userFriendlyName() {
      var frameNumber;
      if (!this.activeTree) {
        frameNumber = this.objectInstance.snapshots.indexOf(this);
      } else {
        if (this.activeTree.sourceFrameNumber === undefined)
          frameNumber = this.objectInstance.snapshots.indexOf(this);
        else
          frameNumber = this.activeTree.sourceFrameNumber;
      }
      return 'cc::LayerTreeHostImpl frame ' + frameNumber;
    }
  };

  ObjectSnapshot.register(
      LayerTreeHostImplSnapshot,
      {typeName: 'cc::LayerTreeHostImpl'});

  /**
   * @constructor
   */
  function LayerTreeHostImplInstance() {
    ObjectInstance.apply(this, arguments);

    this.allLayersBBox_ = undefined;
  }

  LayerTreeHostImplInstance.prototype = {
    __proto__: ObjectInstance.prototype,

    get allContentsScales() {
      if (this.allContentsScales_)
        return this.allContentsScales_;

      var scales = {};
      for (var tileID in this.allTileHistories_) {
        var tileHistory = this.allTileHistories_[tileID];
        scales[tileHistory.contentsScale] = true;
      }
      this.allContentsScales_ = tr.b.dictionaryKeys(scales);
      return this.allContentsScales_;
    },

    get allLayersBBox() {
      if (this.allLayersBBox_)
        return this.allLayersBBox_;
      var bbox = new tr.b.BBox2();
      function handleTree(tree) {
        tree.renderSurfaceLayerList.forEach(function(layer) {
          bbox.addQuad(layer.layerQuad);
        });
      }
      this.snapshots.forEach(function(lthi) {
        handleTree(lthi.activeTree);
        if (lthi.pendingTree)
          handleTree(lthi.pendingTree);
      });
      this.allLayersBBox_ = bbox;
      return this.allLayersBBox_;
    }
  };

  ObjectInstance.register(
      LayerTreeHostImplInstance,
      {typeName: 'cc::LayerTreeHostImpl'});

  return {
    LayerTreeHostImplSnapshot: LayerTreeHostImplSnapshot,
    LayerTreeHostImplInstance: LayerTreeHostImplInstance

  };
});


'use strict';

/**
 * @fileoverview Mapping of different tile configuration
 * to border colors and widths.
 */
tr.exportTo('tr.e.cc', function() {
  var tileTypes = {
    highRes: 'highRes',
    lowRes: 'lowRes',
    extraHighRes: 'extraHighRes',
    extraLowRes: 'extraLowRes',
    missing: 'missing',
    culled: 'culled',
    solidColor: 'solidColor',
    picture: 'picture',
    directPicture: 'directPicture',
    unknown: 'unknown'
  };

  var tileBorder = {
    highRes: {
      color: 'rgba(80, 200, 200, 0.7)',
      width: 1
    },
    lowRes: {
      color: 'rgba(212, 83, 192, 0.7)',
      width: 2
    },
    extraHighRes: {
      color: 'rgba(239, 231, 20, 0.7)',
      width: 2
    },
    extraLowRes: {
      color: 'rgba(93, 186, 18, 0.7)',
      width: 2
    },
    missing: {
      color: 'rgba(255, 0, 0, 0.7)',
      width: 1
    },
    culled: {
      color: 'rgba(160, 100, 0, 0.8)',
      width: 1
    },
    solidColor: {
      color: 'rgba(128, 128, 128, 0.7)',
      width: 1
    },
    picture: {
      color: 'rgba(64, 64, 64, 0.7)',
      width: 1
    },
    directPicture: {
      color: 'rgba(127, 255, 0, 1.0)',
      width: 1
    },
    unknown: {
      color: 'rgba(0, 0, 0, 1.0)',
      width: 2
    }
  };

  return {
    tileTypes: tileTypes,
    tileBorder: tileBorder
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function TileSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  TileSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize: function() {
      tr.e.cc.preInitializeObject(this);
    },

    initialize: function() {
      tr.e.cc.moveOptionalFieldsFromArgsToToplevel(
          this, ['layerId', 'contentsScale', 'contentRect']);
      if (this.args.managedState) {
        this.resolution = this.args.managedState.resolution;
        this.isSolidColor = this.args.managedState.isSolidColor;
        this.isUsingGpuMemory = this.args.managedState.isUsingGpuMemory;
        this.hasResource = this.args.managedState.hasResource;
        this.scheduledPriority = this.args.scheduledPriority;
        this.gpuMemoryUsageInBytes = this.args.gpuMemoryUsage;
      } else {
        this.resolution = this.args.resolution;
        this.isSolidColor = this.args.drawInfo.isSolidColor;
        this.isUsingGpuMemory = this.args.isUsingGpuMemory;
        this.hasResource = this.args.hasResource;
        this.scheduledPriority = this.args.scheduledPriority;
        this.gpuMemoryUsageInBytes = this.args.gpuMemoryUsage;
      }

      // This check is for backward compatability. It can probably
      // be removed once we're confident that most traces contain
      // content_rect.
      if (this.contentRect)
        this.layerRect = this.contentRect.scale(1.0 / this.contentsScale);

      if (this.isSolidColor)
        this.type_ = tr.e.cc.tileTypes.solidColor;
      else if (!this.hasResource)
        this.type_ = tr.e.cc.tileTypes.missing;
      else if (this.resolution === 'HIGH_RESOLUTION')
        this.type_ = tr.e.cc.tileTypes.highRes;
      else if (this.resolution === 'LOW_RESOLUTION')
        this.type_ = tr.e.cc.tileTypes.lowRes;
      else
        this.type_ = tr.e.cc.tileTypes.unknown;
    },

    getTypeForLayer: function(layer) {
      var type = this.type_;
      if (type == tr.e.cc.tileTypes.unknown) {
        if (this.contentsScale < layer.idealContentsScale)
          type = tr.e.cc.tileTypes.extraLowRes;
        else if (this.contentsScale > layer.idealContentsScale)
          type = tr.e.cc.tileTypes.extraHighRes;
      }
      return type;
    }
  };

  ObjectSnapshot.register(TileSnapshot, {typeName: 'cc::Tile'});

  return {
    TileSnapshot: TileSnapshot
  };
});


  'use strict';

  Polymer('tr-ui-b-info-bar', {
    ready: function() {
      this.messageEl_ = this.$.message;
      this.buttonsEl_ = this.$.buttons;

      this.message = '';
      this.visible = false;
    },

    get message() {
      return this.messageEl_.textContent;
    },

    set message(message) {
      this.messageEl_.textContent = message;
    },

    get visible() {
      return !this.classList.contains('info-bar-hidden');
    },

    set visible(visible) {
      if (visible)
        this.classList.remove('info-bar-hidden');
      else
        this.classList.add('info-bar-hidden');
    },

    removeAllButtons: function() {
      this.buttonsEl_.textContent = '';
    },

    addButton: function(text, clickCallback) {
      var button = document.createElement('button');
      button.textContent = text;
      button.addEventListener('click', clickCallback);
      this.buttonsEl_.appendChild(button);
      return button;
    }
  });
  

'use strict';

/**
 * @fileoverview Simple list view.
 */
tr.exportTo('tr.ui.b', function() {
  /**
   * @constructor
   */
  var ListView = tr.ui.b.define(
      'x-list-view', tr.ui.b.ContainerThatDecoratesItsChildren);

  ListView.prototype = {
    __proto__: tr.ui.b.ContainerThatDecoratesItsChildren.prototype,

    decorate: function() {
      tr.ui.b.ContainerThatDecoratesItsChildren.prototype.decorate.call(this);

      this.classList.add('x-list-view');
      this.onItemClicked_ = this.onItemClicked_.bind(this);
      this.onKeyDown_ = this.onKeyDown_.bind(this);
      this.tabIndex = 0;
      this.addEventListener('keydown', this.onKeyDown_);

      this.selectionChanged_ = false;
    },

    decorateChild_: function(item) {
      item.classList.add('list-item');
      item.addEventListener('click', this.onItemClicked_, true);

      var listView = this;
      Object.defineProperty(
          item,
          'selected', {
            configurable: true,
            set: function(value) {
              var oldSelection = listView.selectedElement;
              if (oldSelection && oldSelection != this && value)
                listView.selectedElement.removeAttribute('selected');
              if (value)
                this.setAttribute('selected', 'selected');
              else
                this.removeAttribute('selected');
              var newSelection = listView.selectedElement;
              if (newSelection != oldSelection)
                tr.b.dispatchSimpleEvent(listView, 'selection-changed', false);
            },
            get: function() {
              return this.hasAttribute('selected');
            }
          });
    },

    undecorateChild_: function(item) {
      this.selectionChanged_ |= item.selected;

      item.classList.remove('list-item');
      item.removeEventListener('click', this.onItemClicked_);
      delete item.selected;
    },

    beginDecorating_: function() {
      this.selectionChanged_ = false;
    },

    doneDecoratingForNow_: function() {
      if (this.selectionChanged_)
        tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
    },

    get selectedElement() {
      var el = this.querySelector('.list-item[selected]');
      if (!el)
        return undefined;
      return el;
    },

    set selectedElement(el) {
      if (!el) {
        if (this.selectedElement)
          this.selectedElement.selected = false;
        return;
      }

      if (el.parentElement != this)
        throw new Error(
            'Can only select elements that are children of this list view');
      el.selected = true;
    },

    getElementByIndex: function(index) {
      return this.querySelector('.list-item:nth-child(' + index + ')');
    },

    clear: function() {
      var changed = this.selectedElement !== undefined;
      tr.ui.b.ContainerThatDecoratesItsChildren.prototype.clear.call(this);
      if (changed)
        tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
    },

    onItemClicked_: function(e) {
      var currentSelectedElement = this.selectedElement;
      if (currentSelectedElement)
        currentSelectedElement.removeAttribute('selected');
      var element = e.target;
      while (element.parentElement != this)
        element = element.parentElement;
      if (element !== currentSelectedElement)
        element.setAttribute('selected', 'selected');
      tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
    },

    onKeyDown_: function(e) {
      if (this.selectedElement === undefined)
        return;

      if (e.keyCode == 38) { // Up arrow.
        var prev = this.selectedElement.previousSibling;
        if (prev) {
          prev.selected = true;
          tr.ui.b.scrollIntoViewIfNeeded(prev);
          e.preventDefault();
          return true;
        }
      } else if (e.keyCode == 40) { // Down arrow.
        var next = this.selectedElement.nextSibling;
        if (next) {
          next.selected = true;
          tr.ui.b.scrollIntoViewIfNeeded(next);
          e.preventDefault();
          return true;
        }
      }
    },

    addItem: function(textContent) {
      var item = document.createElement('div');
      item.textContent = textContent;
      this.appendChild(item);
      return item;
    }

  };

  return {
    ListView: ListView
  };

});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  function Selection() {
    this.selectionToSetIfClicked = undefined;
  };
  Selection.prototype = {
    /**
     * When two things are picked in the UI, one must occasionally tie-break
     * between them to decide what was really clicked. Things with higher
     * specicifity will win.
     */
    get specicifity() {
      throw new Error('Not implemented');
    },

    /**
     * If a selection is related to a specific layer, then this returns the
     * layerId of that layer. If the selection is not related to a layer, for
     * example if the device viewport is selected, then this returns undefined.
     */
    get associatedLayerId() {
      throw new Error('Not implemented');
    },

    /**
     * If a selection is related to a specific render pass, then this returns
     * the layerId of that layer. If the selection is not related to a layer,
     * for example if the device viewport is selected, then this returns
     * undefined.
     */
    get associatedRenderPassId() {
      throw new Error('Not implemented');
    },


    get highlightsByLayerId() {
      return {};
    },

    /**
     * Called when the selection is made active in the layer view. Must return
     * an HTMLElement that explains this selection in detail.
     */
    createAnalysis: function() {
      throw new Error('Not implemented');
    },

    /**
     * Should try to create the equivalent selection in the provided LTHI,
     * or undefined if it can't be done.
     */
    findEquivalent: function(lthi) {
      throw new Error('Not implemented');
    }
  };

  /**
   * @constructor
   */
  function RenderPassSelection(renderPass, renderPassId) {
    if (!renderPass || (renderPassId === undefined))
      throw new Error('Render pass (with id) is required');
    this.renderPass_ = renderPass;
    this.renderPassId_ = renderPassId;
  }

  RenderPassSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 1;
    },

    get associatedLayerId() {
      return undefined;
    },

    get associatedRenderPassId() {
      return this.renderPassId_;
    },

    get renderPass() {
      return this.renderPass_;
    },

    createAnalysis: function() {
      var dataView = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      dataView.label = 'RenderPass ' + this.renderPassId_;
      dataView.object = this.renderPass_.args;
      return dataView;
    },

    get title() {
      return this.renderPass_.objectInstance.typeName;
    }
  };

  /**
   * @constructor
   */
  function LayerSelection(layer) {
    if (!layer)
      throw new Error('Layer is required');
    this.layer_ = layer;
  }

  LayerSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 1;
    },

    get associatedLayerId() {
      return this.layer_.layerId;
    },

    get associatedRenderPassId() {
      return undefined;
    },

    get layer() {
      return this.layer_;
    },

    createAnalysis: function() {
      var dataView = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      dataView.label = 'Layer ' + this.layer_.layerId;
      if (this.layer_.usingGpuRasterization)
        dataView.label += ' (GPU-rasterized)';
      dataView.object = this.layer_.args;
      return dataView;
    },

    get title() {
      return this.layer_.objectInstance.typeName;
    },

    findEquivalent: function(lthi) {
      var layer = lthi.activeTree.findLayerWithId(this.layer_.layerId) ||
          lthi.pendingTree.findLayerWithId(this.layer_.layerId);
      if (!layer)
        return undefined;
      return new LayerSelection(layer);
    }
  };

  /**
   * @constructor
   */
  function TileSelection(tile, opt_data) {
    this.tile_ = tile;
    this.data_ = opt_data || {};
  }

  TileSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 2;
    },

    get associatedLayerId() {
      return this.tile_.layerId;
    },

    get highlightsByLayerId() {
      var highlights = {};
      highlights[this.tile_.layerId] = [
        {
          colorKey: this.tile_.objectInstance.typeName,
          rect: this.tile_.layerRect
        }
      ];
      return highlights;
    },

    createAnalysis: function() {
      var analysis = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      analysis.label = 'Tile ' + this.tile_.objectInstance.id + ' on layer ' +
          this.tile_.layerId;
      if (this.data_) {
        analysis.object = {
          moreInfo: this.data_,
          tileArgs: this.tile_.args
        };
      } else {
        analysis.object = this.tile_.args;
      }
      return analysis;
    },

    findEquivalent: function(lthi) {
      var tileInstance = this.tile_.tileInstance;
      if (lthi.ts < tileInstance.creationTs ||
          lthi.ts >= tileInstance.deletionTs)
        return undefined;
      var tileSnapshot = tileInstance.getSnapshotAt(lthi.ts);
      if (!tileSnapshot)
        return undefined;
      return new TileSelection(tileSnapshot);
    }
  };

  /**
   * @constructor
   */
  function LayerRectSelection(layer, rectType, rect, opt_data) {
    this.layer_ = layer;
    this.rectType_ = rectType;
    this.rect_ = rect;
    this.data_ = opt_data !== undefined ? opt_data : rect;
  }

  LayerRectSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 2;
    },

    get associatedLayerId() {
      return this.layer_.layerId;
    },


    get highlightsByLayerId() {
      var highlights = {};
      highlights[this.layer_.layerId] = [
        {
          colorKey: this.rectType_,
          rect: this.rect_
        }
      ];
      return highlights;
    },

    createAnalysis: function() {
      var analysis = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      analysis.label = this.rectType_ + ' on layer ' + this.layer_.layerId;
      analysis.object = this.data_;
      return analysis;
    },

    findEquivalent: function(lthi) {
      return undefined;
    }
  };

  /**
   * @constructor
   */
  function AnimationRectSelection(layer, rect) {
    this.layer_ = layer;
    this.rect_ = rect;
  }

  AnimationRectSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 0;
    },

    get associatedLayerId() {
      return this.layer_.layerId;
    },

    createAnalysis: function() {
      var analysis = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      analysis.label = 'Animation Bounds of layer ' + this.layer_.layerId;
      analysis.object = this.rect_;
      return analysis;
    }
  };

  return {
    Selection: Selection,
    RenderPassSelection: RenderPassSelection,
    LayerSelection: LayerSelection,
    TileSelection: TileSelection,
    LayerRectSelection: LayerRectSelection,
    AnimationRectSelection: AnimationRectSelection
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  var OPS_TIMING_ITERATIONS = 3; // Iterations to average op timing info over.
  var ANNOTATION = 'Comment';
  var BEGIN_ANNOTATION = 'BeginCommentGroup';
  var END_ANNOTATION = 'EndCommentGroup';
  var ANNOTATION_ID = 'ID: ';
  var ANNOTATION_CLASS = 'CLASS: ';
  var ANNOTATION_TAG = 'TAG: ';

  var constants = tr.e.cc.constants;

  /**
   * @constructor
   */
  var PictureOpsListView =
      tr.ui.b.define('tr-ui-e-chrome-cc-picture-ops-list-view');

  PictureOpsListView.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.opsList_ = new tr.ui.b.ListView();
      this.appendChild(this.opsList_);

      this.selectedOp_ = undefined;
      this.selectedOpIndex_ = undefined;
      this.opsList_.addEventListener(
          'selection-changed', this.onSelectionChanged_.bind(this));

      this.picture_ = undefined;
    },

    get picture() {
      return this.picture_;
    },

    set picture(picture) {
      this.picture_ = picture;
      this.updateContents_();
    },

    updateContents_: function() {
      this.opsList_.clear();

      if (!this.picture_)
        return;

      var ops = this.picture_.getOps();
      if (!ops)
        return;

      ops = this.picture_.tagOpsWithTimings(ops);

      ops = this.opsTaggedWithAnnotations_(ops);

      for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        var item = document.createElement('div');
        item.opIndex = op.opIndex;
        item.textContent = i + ') ' + op.cmd_string;

        // Display the element info associated with the op, if available.
        if (op.elementInfo.tag || op.elementInfo.id || op.elementInfo.class) {
          var elementInfo = document.createElement('span');
          elementInfo.classList.add('elementInfo');
          var tag = op.elementInfo.tag ? op.elementInfo.tag : 'unknown';
          var id = op.elementInfo.id ? 'id=' + op.elementInfo.id : undefined;
          var className = op.elementInfo.class ? 'class=' +
              op.elementInfo.class : undefined;
          elementInfo.textContent =
              '<' + tag + (id ? ' ' : '') +
              (id ? id : '') + (className ? ' ' : '') +
              (className ? className : '') + '>';
          item.appendChild(elementInfo);
        }

        // Display the Skia params.
        // FIXME: now that we have structured data, we should format it.
        // (https://github.com/google/trace-viewer/issues/782)
        if (op.info.length > 0) {
          var infoItem = document.createElement('div');
          infoItem.textContent = JSON.stringify(op.info);
          item.appendChild(infoItem);
        }

        // Display the op timing, if available.
        if (op.cmd_time && op.cmd_time >= 0.0001) {
          var time = document.createElement('span');
          time.classList.add('time');
          var rounded = op.cmd_time.toFixed(4);
          time.textContent = '(' + rounded + 'ms)';
          item.appendChild(time);
        }

        this.opsList_.appendChild(item);
      }
    },

    onSelectionChanged_: function(e) {
      var beforeSelectedOp = true;

      // Deselect on re-selection.
      if (this.opsList_.selectedElement === this.selectedOp_) {
        this.opsList_.selectedElement = undefined;
        beforeSelectedOp = false;
        this.selectedOpIndex_ = undefined;
      }

      this.selectedOp_ = this.opsList_.selectedElement;

      // Set selection on all previous ops.
      var ops = this.opsList_.children;
      for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        if (op === this.selectedOp_) {
          beforeSelectedOp = false;
          this.selectedOpIndex_ = op.opIndex;
        } else if (beforeSelectedOp) {
          op.setAttribute('beforeSelection', 'beforeSelection');
        } else {
          op.removeAttribute('beforeSelection');
        }
      }

      tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
    },

    get numOps() {
      return this.opsList_.children.length;
    },

    get selectedOpIndex() {
      return this.selectedOpIndex_;
    },

    set selectedOpIndex(s) {
      this.selectedOpIndex_ = s;

      if (s === undefined) {
        this.opsList_.selectedElement = this.selectedOp_;
        this.onSelectionChanged_();
      } else {
        if (s < 0) throw new Error('Invalid index');
        if (s >= this.numOps) throw new Error('Invalid index');
        this.opsList_.selectedElement = this.opsList_.getElementByIndex(s + 1);
        tr.ui.b.scrollIntoViewIfNeeded(this.opsList_.selectedElement);
      }
    },

    /**
     * Return Skia operations tagged by annotation.
     *
     * The ops returned from Picture.getOps() contain both Skia ops and
     * annotations threaded together. This function removes all annotations
     * from the list and tags each op with the associated annotations.
     * Additionally, the last {tag, id, class} is stored as elementInfo on
     * each op.
     *
     * @param {Array} ops Array of Skia operations and annotations.
     * @return {Array} Skia ops where op.annotations contains the associated
     *         annotations for a given op.
     */
    opsTaggedWithAnnotations_: function(ops) {
      // This algorithm works by walking all the ops and pushing any
      // annotations onto a stack. When a non-annotation op is found, the
      // annotations stack is traversed and stored with the op.
      var annotationGroups = new Array();
      var opsWithoutAnnotations = new Array();
      for (var opIndex = 0; opIndex < ops.length; opIndex++) {
        var op = ops[opIndex];
        op.opIndex = opIndex;
        switch (op.cmd_string) {
          case BEGIN_ANNOTATION:
            annotationGroups.push(new Array());
            break;
          case END_ANNOTATION:
            annotationGroups.pop();
            break;
          case ANNOTATION:
            annotationGroups[annotationGroups.length - 1].push(op);
            break;
          default:
            var annotations = new Array();
            var elementInfo = {};
            annotationGroups.forEach(function(annotationGroup) {
              elementInfo = {};
              annotationGroup.forEach(function(annotation) {
                annotation.info.forEach(function(info) {
                  if (info.indexOf(ANNOTATION_TAG) != -1)
                    elementInfo.tag = info.substring(
                        info.indexOf(ANNOTATION_TAG) +
                        ANNOTATION_TAG.length).toLowerCase();
                  else if (info.indexOf(ANNOTATION_ID) != -1)
                    elementInfo.id = info.substring(
                        info.indexOf(ANNOTATION_ID) +
                        ANNOTATION_ID.length);
                  else if (info.indexOf(ANNOTATION_CLASS) != -1)
                    elementInfo.class = info.substring(
                        info.indexOf(ANNOTATION_CLASS) +
                        ANNOTATION_CLASS.length);

                  annotations.push(info);
                });
              });
            });
            op.annotations = annotations;
            op.elementInfo = elementInfo;
            opsWithoutAnnotations.push(op);
        }
      }

      return opsWithoutAnnotations;
    }
  };

  return {
    PictureOpsListView: PictureOpsListView
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  var THIS_DOC = document.currentScript.ownerDocument;

  /**
   * DisplayItemDebugger is a view of a DisplayItemListSnapshot for inspecting
   * a display item list and the pictures within it.
   *
   * @constructor
   */
  var DisplayItemDebugger = tr.ui.b.define(
      'tr-ui-e-chrome-cc-display-item-debugger');

  DisplayItemDebugger.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      var node = tr.ui.b.instantiateTemplate(
          '#tr-ui-e-chrome-cc-display-item-debugger-template', THIS_DOC);

      this.appendChild(node);

      this.pictureAsImageData_ = undefined;
      this.zoomScaleValue_ = 1;

      this.sizeInfo_ = this.querySelector('.size');
      this.rasterArea_ = this.querySelector('raster-area');
      this.rasterCanvas_ = this.rasterArea_.querySelector('canvas');
      this.rasterCtx_ = this.rasterCanvas_.getContext('2d');

      this.trackMouse_();

      this.displayItemInfo_ = this.querySelector('display-item-info');
      this.displayItemInfo_.addEventListener(
          'click', this.onDisplayItemInfoClick_.bind(this), false);

      this.displayItemListView_ = new tr.ui.b.ListView();
      this.displayItemListView_.addEventListener('selection-changed',
          this.onDisplayItemListSelection_.bind(this));
      this.displayItemInfo_.appendChild(this.displayItemListView_);

      this.displayListFilename_ = this.querySelector('.dlfilename');
      this.displayListExportButton_ = this.querySelector('.dlexport');
      this.displayListExportButton_.addEventListener(
          'click', this.onExportDisplayListClicked_.bind(this));

      this.skpFilename_ = this.querySelector('.skpfilename');
      this.skpExportButton_ = this.querySelector('.skpexport');
      this.skpExportButton_.addEventListener(
          'click', this.onExportSkPictureClicked_.bind(this));

      var leftPanel = this.querySelector('left-panel');

      var middleDragHandle = new tr.ui.b.DragHandle();
      middleDragHandle.horizontal = false;
      middleDragHandle.target = leftPanel;

      var rightPanel = this.querySelector('right-panel');

      this.infoBar_ = document.createElement('tr-ui-b-info-bar');
      this.rasterArea_.insertBefore(this.infoBar_, this.rasterCanvas_);

      this.insertBefore(middleDragHandle, rightPanel);

      this.picture_ = undefined;

      this.pictureOpsListView_ = new tr.ui.e.chrome.cc.PictureOpsListView();
      rightPanel.insertBefore(this.pictureOpsListView_, this.rasterArea_);

      this.pictureOpsListDragHandle_ = new tr.ui.b.DragHandle();
      this.pictureOpsListDragHandle_.horizontal = false;
      this.pictureOpsListDragHandle_.target = this.pictureOpsListView_;
      rightPanel.insertBefore(this.pictureOpsListDragHandle_, this.rasterArea_);
    },

    get picture() {
      return this.picture_;
    },

    set displayItemList(displayItemList) {
      this.displayItemList_ = displayItemList;
      this.picture = this.displayItemList_;

      this.displayItemListView_.clear();
      this.displayItemList_.items.forEach(function(item) {
        var newListItem = document.createElement('div');
        newListItem.innerText = item;
        // FIXME: We should improve our output to better format this.
        var text = item.skp64 ? item.name : item;
        this.displayItemListView_.addItem(text);
      }.bind(this));
    },

    set picture(picture) {
      this.picture_ = picture;

      // Hide the ops list if we are showing the "main" display item list.
      var showOpsList = picture && picture !== this.displayItemList_;
      this.updateDrawOpsList_(showOpsList);

      if (picture) {
        var size = this.getRasterCanvasSize_();
        this.rasterCanvas_.width = size.width;
        this.rasterCanvas_.height = size.height;
      }

      var bounds = this.rasterArea_.getBoundingClientRect();
      var selectorBounds = this.mouseModeSelector_.getBoundingClientRect();
      this.mouseModeSelector_.pos = {
        x: (bounds.right - selectorBounds.width - 10),
        y: bounds.top
      };

      this.rasterize_();

      this.scheduleUpdateContents_();
    },

    getRasterCanvasSize_: function() {
      var style = window.getComputedStyle(this.rasterArea_);
      var width = parseInt(style.width);
      var height = parseInt(style.height);
      if (this.picture_) {
        width = Math.max(width, this.picture_.layerRect.width);
        height = Math.max(height, this.picture_.layerRect.height);
      }

      return {
        width: width,
        height: height
      };
    },

    scheduleUpdateContents_: function() {
      if (this.updateContentsPending_)
        return;
      this.updateContentsPending_ = true;
      tr.b.requestAnimationFrameInThisFrameIfPossible(
          this.updateContents_.bind(this)
      );
    },

    updateContents_: function() {
      this.updateContentsPending_ = false;

      if (this.picture_) {
        this.sizeInfo_.textContent = '(' +
            this.picture_.layerRect.width + ' x ' +
            this.picture_.layerRect.height + ')';
      }

      // Return if picture hasn't finished rasterizing.
      if (!this.pictureAsImageData_)
        return;

      this.infoBar_.visible = false;
      this.infoBar_.removeAllButtons();
      if (this.pictureAsImageData_.error) {
        this.infoBar_.message = 'Cannot rasterize...';
        this.infoBar_.addButton('More info...', function(e) {
          var overlay = new tr.ui.b.Overlay();
          overlay.textContent = this.pictureAsImageData_.error;
          overlay.visible = true;
          e.stopPropagation();
          return false;
        }.bind(this));
        this.infoBar_.visible = true;
      }

      this.drawPicture_();
    },

    drawPicture_: function() {
      var size = this.getRasterCanvasSize_();
      if (size.width !== this.rasterCanvas_.width)
        this.rasterCanvas_.width = size.width;
      if (size.height !== this.rasterCanvas_.height)
        this.rasterCanvas_.height = size.height;

      this.rasterCtx_.clearRect(0, 0, size.width, size.height);

      if (!this.picture_ || !this.pictureAsImageData_.imageData)
        return;

      var imgCanvas = this.pictureAsImageData_.asCanvas();
      var w = imgCanvas.width;
      var h = imgCanvas.height;
      this.rasterCtx_.drawImage(imgCanvas, 0, 0, w, h,
                                0, 0, w * this.zoomScaleValue_,
                                h * this.zoomScaleValue_);
    },

    rasterize_: function() {
      if (this.picture_) {
        this.picture_.rasterize(
            {
              showOverdraw: false
            },
            this.onRasterComplete_.bind(this));
      }
    },

    onRasterComplete_: function(pictureAsImageData) {
      this.pictureAsImageData_ = pictureAsImageData;
      this.scheduleUpdateContents_();
    },

    onDisplayItemListSelection_: function(e) {
      var selected = this.displayItemListView_.selectedElement;

      if (!selected) {
        this.picture = this.displayItemList_;
        return;
      }

      var index = Array.prototype.indexOf.call(
          this.displayItemListView_.children, selected);
      var displayItem = this.displayItemList_.items[index];
      if (displayItem && displayItem.skp64)
        this.picture = new tr.e.cc.Picture(
            displayItem.skp64, this.displayItemList_.layerRect);
      else
        this.picture = undefined;
    },

    onDisplayItemInfoClick_: function(e) {
      if (e && e.target == this.displayItemInfo_) {
        this.displayItemListView_.selectedElement = undefined;
      }
    },

    updateDrawOpsList_: function(showOpsList) {
      if (showOpsList) {
        this.pictureOpsListView_.picture = this.picture_;
        if (this.pictureOpsListView_.numOps > 0) {
          this.pictureOpsListView_.classList.add('hasPictureOps');
          this.pictureOpsListDragHandle_.classList.add('hasPictureOps');
        }
      } else {
        this.pictureOpsListView_.classList.remove('hasPictureOps');
        this.pictureOpsListDragHandle_.classList.remove('hasPictureOps');
      }
    },

    trackMouse_: function() {
      this.mouseModeSelector_ = document.createElement(
          'tr-ui-b-mouse-mode-selector');
      this.mouseModeSelector_.targetElement = this.rasterArea_;
      this.rasterArea_.appendChild(this.mouseModeSelector_);

      this.mouseModeSelector_.supportedModeMask =
          tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.mode = tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.defaultMode = tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.settingsKey = 'pictureDebugger.mouseModeSelector';

      this.mouseModeSelector_.addEventListener('beginzoom',
          this.onBeginZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('updatezoom',
          this.onUpdateZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('endzoom',
          this.onEndZoom_.bind(this));
    },

    onBeginZoom_: function(e) {
      this.isZooming_ = true;

      this.lastMouseViewPos_ = this.extractRelativeMousePosition_(e);

      e.preventDefault();
    },

    onUpdateZoom_: function(e) {
      if (!this.isZooming_)
        return;

      var currentMouseViewPos = this.extractRelativeMousePosition_(e);

      // Take the distance the mouse has moved and we want to zoom at about
      // 1/1000th of that speed. 0.01 feels jumpy. This could possibly be tuned
      // more if people feel it's too slow.
      this.zoomScaleValue_ +=
          ((this.lastMouseViewPos_.y - currentMouseViewPos.y) * 0.001);
      this.zoomScaleValue_ = Math.max(this.zoomScaleValue_, 0.1);

      this.drawPicture_();

      this.lastMouseViewPos_ = currentMouseViewPos;
    },

    onEndZoom_: function(e) {
      this.lastMouseViewPos_ = undefined;
      this.isZooming_ = false;
      e.preventDefault();
    },

    extractRelativeMousePosition_: function(e) {
      return {
        x: e.clientX - this.rasterArea_.offsetLeft,
        y: e.clientY - this.rasterArea_.offsetTop
      };
    },

    saveFile_: function(filename, rawData) {
      if (!rawData)
        return;

      // Convert this String into an Uint8Array
      var length = rawData.length;
      var arrayBuffer = new ArrayBuffer(length);
      var uint8Array = new Uint8Array(arrayBuffer);
      for (var c = 0; c < length; c++)
        uint8Array[c] = rawData.charCodeAt(c);

      // Create a blob URL from the binary array.
      var blob = new Blob([uint8Array], {type: 'application/octet-binary'});
      var blobUrl = window.URL.createObjectURL(blob);

      // Create a link and click on it.
      var link = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
      link.href = blobUrl;
      link.download = filename;
      var event = document.createEvent('MouseEvents');
      event.initMouseEvent(
          'click', true, false, window, 0, 0, 0, 0, 0,
          false, false, false, false, 0, null);
      link.dispatchEvent(event);
    },

    onExportDisplayListClicked_: function() {
      var rawData = JSON.stringify(this.displayItemList_.items);
      this.saveFile_(this.displayListFilename_.value, rawData);
    },

    onExportSkPictureClicked_: function() {
      var rawData = atob(this.picture_.getBase64SkpData());
      this.saveFile_(this.skpFilename_.value, rawData);
    }
  };

  return {
    DisplayItemDebugger: DisplayItemDebugger
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /*
   * Displays a display item snapshot in a human readable form.
   * @constructor
   */
  var DisplayItemSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-display-item-list-view',
      tr.ui.analysis.ObjectSnapshotView);

  DisplayItemSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate: function() {
      this.classList.add('tr-ui-e-chrome-cc-display-item-list-view');
      this.displayItemDebugger_ = new tr.ui.e.chrome.cc.DisplayItemDebugger();
      this.appendChild(this.displayItemDebugger_);
    },

    updateContents: function() {
      if (this.objectSnapshot_ && this.displayItemDebugger_)
        this.displayItemDebugger_.displayItemList = this.objectSnapshot_;
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      DisplayItemSnapshotView,
      {
        typeNames: ['cc::DisplayItemList'],
        showInstances: false
      });

  return {
    DisplayItemSnapshotView: DisplayItemSnapshotView
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  var constants = tr.e.cc.constants;
  var bytesToRoundedMegabytes = tr.e.cc.bytesToRoundedMegabytes;
  var RENDER_PASS_QUADS =
      Math.max(constants.ACTIVE_TREE, constants.PENDING_TREE) + 1;

  /**
   * @constructor
   */
  var LayerPicker = tr.ui.b.define('tr-ui-e-chrome-cc-layer-picker');

  LayerPicker.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.lthi_ = undefined;
      this.controls_ = document.createElement('top-controls');
      this.renderPassQuads_ = false;


      this.itemList_ = new tr.ui.b.ListView();
      this.appendChild(this.controls_);

      this.appendChild(this.itemList_);

      this.itemList_.addEventListener(
          'selection-changed', this.onItemSelectionChanged_.bind(this));

      this.controls_.appendChild(tr.ui.b.createSelector(
          this, 'whichTree',
          'layerPicker.whichTree', constants.ACTIVE_TREE,
          [{label: 'Active tree', value: constants.ACTIVE_TREE},
           {label: 'Pending tree', value: constants.PENDING_TREE},
           {label: 'Render pass quads', value: RENDER_PASS_QUADS}]));

      this.showPureTransformLayers_ = false;
      var showPureTransformLayers = tr.ui.b.createCheckBox(
          this, 'showPureTransformLayers',
          'layerPicker.showPureTransformLayers', false,
          'Transform layers');
      showPureTransformLayers.classList.add('show-transform-layers');
      showPureTransformLayers.title =
          'When checked, pure transform layers are shown';
      this.controls_.appendChild(showPureTransformLayers);
    },

    get lthiSnapshot() {
      return this.lthiSnapshot_;
    },

    set lthiSnapshot(lthiSnapshot) {
      this.lthiSnapshot_ = lthiSnapshot;
      this.updateContents_();
    },

    get whichTree() {
      return this.renderPassQuads_ ? constants.ACTIVE_TREE : this.whichTree_;
    },

    set whichTree(whichTree) {
      this.whichTree_ = whichTree;
      this.renderPassQuads_ = (whichTree == RENDER_PASS_QUADS);
      this.updateContents_();
      tr.b.dispatchSimpleEvent(this, 'selection-change', false);
    },

    get layerTreeImpl() {
      if (this.lthiSnapshot === undefined)
        return undefined;
      return this.lthiSnapshot.getTree(this.whichTree);
    },

    get isRenderPassQuads() {
      return this.renderPassQuads_;
    },

    get showPureTransformLayers() {
      return this.showPureTransformLayers_;
    },

    set showPureTransformLayers(show) {
      if (this.showPureTransformLayers_ === show)
        return;
      this.showPureTransformLayers_ = show;
      this.updateContents_();
    },

    getRenderPassInfos_: function() {
      if (!this.lthiSnapshot_)
        return [];

      var renderPassInfo = [];
      if (!this.lthiSnapshot_.args.frame ||
          !this.lthiSnapshot_.args.frame.renderPasses)
        return renderPassInfo;

      var renderPasses = this.lthiSnapshot_.args.frame.renderPasses;
      for (var i = 0; i < renderPasses.length; ++i) {
        var info = {renderPass: renderPasses[i],
                     depth: 0,
                     id: i,
                     name: 'cc::RenderPass'};
        renderPassInfo.push(info);
      }
      return renderPassInfo;
    },

    getLayerInfos_: function() {
      if (!this.lthiSnapshot_)
        return [];

      var tree = this.lthiSnapshot_.getTree(this.whichTree_);
      if (!tree)
        return [];

      var layerInfos = [];

      var showPureTransformLayers = this.showPureTransformLayers_;

      function isPureTransformLayer(layer) {
        if (layer.args.compositingReasons &&
            layer.args.compositingReasons.length != 1 &&
            layer.args.compositingReasons[0] != 'No reasons given')
          return false;

        if (layer.args.drawsContent)
          return false;

        return true;
      }
      var visitedLayers = {};
      function visitLayer(layer, depth, isMask, isReplica) {
        if (visitedLayers[layer.layerId])
          return;
        visitedLayers[layer.layerId] = true;
        var info = {layer: layer,
          depth: depth};

        if (layer.args.drawsContent)
          info.name = layer.objectInstance.name;
        else
          info.name = 'cc::LayerImpl';

        if (layer.usingGpuRasterization)
          info.name += ' (G)';

        info.isMaskLayer = isMask;
        info.replicaLayer = isReplica;

        if (showPureTransformLayers || !isPureTransformLayer(layer))
          layerInfos.push(info);

      };
      tree.iterLayers(visitLayer);
      return layerInfos;
    },

    updateContents_: function() {
      if (this.renderPassQuads_)
        this.updateRenderPassContents_();
      else
        this.updateLayerContents_();
    },

    updateRenderPassContents_: function() {
      this.itemList_.clear();

      var selectedRenderPassId;
      if (this.selection_ && this.selection_.associatedRenderPassId)
        selectedRenderPassId = this.selection_.associatedRenderPassId;

      var renderPassInfos = this.getRenderPassInfos_();
      renderPassInfos.forEach(function(renderPassInfo) {
        var renderPass = renderPassInfo.renderPass;
        var id = renderPassInfo.id;

        var item = this.createElementWithDepth_(renderPassInfo.depth);
        var labelEl = item.appendChild(tr.ui.b.createSpan());

        labelEl.textContent = renderPassInfo.name + ' ' + id;
        item.renderPass = renderPass;
        item.renderPassId = id;
        this.itemList_.appendChild(item);

        if (id == selectedRenderPassId) {
          renderPass.selectionState =
              tr.model.SelectionState.SELECTED;
        }
      }, this);
    },

    updateLayerContents_: function() {
      this.changingItemSelection_ = true;
      try {
        this.itemList_.clear();

        var selectedLayerId;
        if (this.selection_ && this.selection_.associatedLayerId)
          selectedLayerId = this.selection_.associatedLayerId;

        var layerInfos = this.getLayerInfos_();
        layerInfos.forEach(function(layerInfo) {
          var layer = layerInfo.layer;
          var id = layer.layerId;

          var item = this.createElementWithDepth_(layerInfo.depth);
          var labelEl = item.appendChild(tr.ui.b.createSpan());

          labelEl.textContent = layerInfo.name + ' ' + id;

          var notesEl = item.appendChild(tr.ui.b.createSpan());
          if (layerInfo.isMaskLayer)
            notesEl.textContent += '(mask)';
          if (layerInfo.isReplicaLayer)
            notesEl.textContent += '(replica)';

          if (layer.gpuMemoryUsageInBytes !== undefined) {
            var rounded = bytesToRoundedMegabytes(layer.gpuMemoryUsageInBytes);
            if (rounded !== 0)
              notesEl.textContent += ' (' + rounded + ' MB)';
          }

          item.layer = layer;
          this.itemList_.appendChild(item);

          if (layer.layerId == selectedLayerId) {
            layer.selectionState = tr.model.SelectionState.SELECTED;
            item.selected = true;
          }
        }, this);
      } finally {
        this.changingItemSelection_ = false;
      }
    },

    createElementWithDepth_: function(depth) {
      var item = document.createElement('div');

      var indentEl = item.appendChild(tr.ui.b.createSpan());
      indentEl.style.whiteSpace = 'pre';
      for (var i = 0; i < depth; i++)
        indentEl.textContent = indentEl.textContent + ' ';
      return item;
    },

    onItemSelectionChanged_: function(e) {
      if (this.changingItemSelection_)
        return;
      if (this.renderPassQuads_)
        this.onRenderPassSelected_(e);
      else
        this.onLayerSelected_(e);
      tr.b.dispatchSimpleEvent(this, 'selection-change', false);
    },

    onRenderPassSelected_: function(e) {
      var selectedRenderPass;
      var selectedRenderPassId;
      if (this.itemList_.selectedElement) {
        selectedRenderPass = this.itemList_.selectedElement.renderPass;
        selectedRenderPassId =
            this.itemList_.selectedElement.renderPassId;
      }

      if (selectedRenderPass) {
        this.selection_ = new tr.ui.e.chrome.cc.RenderPassSelection(
            selectedRenderPass, selectedRenderPassId);
      } else {
        this.selection_ = undefined;
      }
    },

    onLayerSelected_: function(e) {
      var selectedLayer;
      if (this.itemList_.selectedElement)
        selectedLayer = this.itemList_.selectedElement.layer;

      if (selectedLayer)
        this.selection_ = new tr.ui.e.chrome.cc.LayerSelection(selectedLayer);
      else
        this.selection_ = undefined;
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (this.selection_ == selection)
        return;
      this.selection_ = selection;
      this.updateContents_();
    }
  };

  return {
    LayerPicker: LayerPicker
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  function Color(opt_r, opt_g, opt_b, opt_a) {
    this.r = Math.floor(opt_r) || 0;
    this.g = Math.floor(opt_g) || 0;
    this.b = Math.floor(opt_b) || 0;
    this.a = opt_a;
  }

  Color.fromString = function(str) {
    var tmp;
    var values;
    if (str.substr(0, 4) == 'rgb(') {
      tmp = str.substr(4, str.length - 5);
      values = tmp.split(',').map(function(v) {
        return v.replace(/^\s+/, '', 'g');
      });
      if (values.length != 3)
        throw new Error('Malformatted rgb-expression');
      return new Color(
          parseInt(values[0]),
          parseInt(values[1]),
          parseInt(values[2]));
    } else if (str.substr(0, 5) == 'rgba(') {
      tmp = str.substr(5, str.length - 6);
      values = tmp.split(',').map(function(v) {
        return v.replace(/^\s+/, '', 'g');
      });
      if (values.length != 4)
        throw new Error('Malformatted rgb-expression');
      return new Color(
          parseInt(values[0]),
          parseInt(values[1]),
          parseInt(values[2]),
          parseFloat(values[3]));
    } else if (str[0] == '#' && str.length == 7) {
      return new Color(
          parseInt(str.substr(1, 2), 16),
          parseInt(str.substr(3, 2), 16),
          parseInt(str.substr(5, 2), 16));
    } else {
      throw new Error('Unrecognized string format.');
    }
  };

  Color.lerp = function(a, b, percent) {
    if (a.a !== undefined && b.a !== undefined)
      return Color.lerpRGBA(a, b, percent);
    return Color.lerpRGB(a, b, percent);
  }

  Color.lerpRGB = function(a, b, percent) {
    return new Color(
        ((b.r - a.r) * percent) + a.r,
        ((b.g - a.g) * percent) + a.g,
        ((b.b - a.b) * percent) + a.b);
  }

  Color.lerpRGBA = function(a, b, percent) {
    return new Color(
        ((b.r - a.r) * percent) + a.r,
        ((b.g - a.g) * percent) + a.g,
        ((b.b - a.b) * percent) + a.b,
        ((b.a - a.a) * percent) + a.a);
  }

  Color.prototype = {
    clone: function() {
      var c = new Color();
      c.r = this.r;
      c.g = this.g;
      c.b = this.b;
      c.a = this.a;
      return c;
    },

    blendOver: function(bgColor) {
      var oneMinusThisAlpha = 1 - this.a;
      var outA = this.a + bgColor.a * oneMinusThisAlpha;
      var bgBlend = (bgColor.a * oneMinusThisAlpha) / bgColor.a;
      return new Color(
          this.r * this.a + bgColor.r * bgBlend,
          this.g * this.a + bgColor.g * bgBlend,
          this.b * this.a + bgColor.b * bgBlend,
          outA);
    },

    brighten: function(opt_k) {
      var k;
      k = opt_k || 0.45;

      return new Color(
          Math.min(255, this.r + Math.floor(this.r * k)),
          Math.min(255, this.g + Math.floor(this.g * k)),
          Math.min(255, this.b + Math.floor(this.b * k)));
    },

    darken: function(opt_k) {
      var k;
      k = opt_k || 0.45;

      return new Color(
          Math.min(255, this.r - Math.floor(this.r * k)),
          Math.min(255, this.g - Math.floor(this.g * k)),
          Math.min(255, this.b - Math.floor(this.b * k)));
    },

    withAlpha: function(a) {
      return new Color(this.r, this.g, this.b, a);
    },

    toString: function() {
      if (this.a !== undefined) {
        return 'rgba(' +
            this.r + ',' + this.g + ',' +
            this.b + ',' + this.a + ')';
      }
      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
    }
  };

  return {
    Color: Color
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function RenderPassSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  RenderPassSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize: function() {
      tr.e.cc.preInitializeObject(this);
    },

    initialize: function() {
      tr.e.cc.moveRequiredFieldsFromArgsToToplevel(
          this, ['quadList']);
    }
  };

  ObjectSnapshot.register(RenderPassSnapshot, {typeName: 'cc::RenderPass'});

  return {
    RenderPassSnapshot: RenderPassSnapshot
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {

  var constants = {
    DEFAULT_SCALE: 0.5,
    DEFAULT_EYE_DISTANCE: 10000,
    MINIMUM_DISTANCE: 1000,
    MAXIMUM_DISTANCE: 100000,
    FOV: 15,
    RESCALE_TIMEOUT_MS: 200,
    MAXIMUM_TILT: 80,
    SETTINGS_NAMESPACE: 'tr.ui_camera'
  };


  var Camera = tr.ui.b.define('camera');

  Camera.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function(eventSource) {
      this.eventSource_ = eventSource;

      this.eventSource_.addEventListener('beginpan',
          this.onPanBegin_.bind(this));
      this.eventSource_.addEventListener('updatepan',
          this.onPanUpdate_.bind(this));
      this.eventSource_.addEventListener('endpan',
          this.onPanEnd_.bind(this));

      this.eventSource_.addEventListener('beginzoom',
          this.onZoomBegin_.bind(this));
      this.eventSource_.addEventListener('updatezoom',
          this.onZoomUpdate_.bind(this));
      this.eventSource_.addEventListener('endzoom',
          this.onZoomEnd_.bind(this));

      this.eventSource_.addEventListener('beginrotate',
          this.onRotateBegin_.bind(this));
      this.eventSource_.addEventListener('updaterotate',
          this.onRotateUpdate_.bind(this));
      this.eventSource_.addEventListener('endrotate',
          this.onRotateEnd_.bind(this));

      this.eye_ = [0, 0, constants.DEFAULT_EYE_DISTANCE];
      this.gazeTarget_ = [0, 0, 0];
      this.rotation_ = [0, 0];

      this.pixelRatio_ = window.devicePixelRatio || 1;
    },


    get modelViewMatrix() {
      var mvMatrix = mat4.create();

      mat4.lookAt(mvMatrix, this.eye_, this.gazeTarget_, [0, 1, 0]);
      return mvMatrix;
    },

    get projectionMatrix() {
      var rect =
          tr.ui.b.windowRectForElement(this.canvas_).
              scaleSize(this.pixelRatio_);

      var aspectRatio = rect.width / rect.height;
      var matrix = mat4.create();
      mat4.perspective(
          matrix, tr.b.deg2rad(constants.FOV), aspectRatio, 1, 100000);

      return matrix;
    },

    set canvas(c) {
      this.canvas_ = c;
    },

    set deviceRect(rect) {
      this.deviceRect_ = rect;
    },

    get stackingDistanceDampening() {
      var gazeVector = [
        this.gazeTarget_[0] - this.eye_[0],
        this.gazeTarget_[1] - this.eye_[1],
        this.gazeTarget_[2] - this.eye_[2]];
      vec3.normalize(gazeVector, gazeVector);
      return 1 + gazeVector[2];
    },

    loadCameraFromSettings: function(settings) {
      this.eye_ = settings.get(
          'eye', this.eye_, constants.SETTINGS_NAMESPACE);
      this.gazeTarget_ = settings.get(
          'gaze_target', this.gazeTarget_, constants.SETTINGS_NAMESPACE);
      this.rotation_ = settings.get(
          'rotation', this.rotation_, constants.SETTINGS_NAMESPACE);

      this.dispatchRenderEvent_();
    },

    saveCameraToSettings: function(settings) {
      settings.set(
          'eye', this.eye_, constants.SETTINGS_NAMESPACE);
      settings.set(
          'gaze_target', this.gazeTarget_, constants.SETTINGS_NAMESPACE);
      settings.set(
          'rotation', this.rotation_, constants.SETTINGS_NAMESPACE);
    },

    resetCamera: function() {
      this.eye_ = [0, 0, constants.DEFAULT_EYE_DISTANCE];
      this.gazeTarget_ = [0, 0, 0];
      this.rotation_ = [0, 0];

      var settings = tr.b.SessionSettings();
      var keys = settings.keys(constants.SETTINGS_NAMESPACE);
      if (keys.length !== 0) {
        this.loadCameraFromSettings(settings);
        return;
      }

      if (this.deviceRect_) {
        var rect = tr.ui.b.windowRectForElement(this.canvas_).
            scaleSize(this.pixelRatio_);

        this.eye_[0] = this.deviceRect_.width / 2;
        this.eye_[1] = this.deviceRect_.height / 2;

        this.gazeTarget_[0] = this.deviceRect_.width / 2;
        this.gazeTarget_[1] = this.deviceRect_.height / 2;
      }

      this.saveCameraToSettings(settings);
      this.dispatchRenderEvent_();
    },

    updatePanByDelta: function(delta) {
      var rect =
          tr.ui.b.windowRectForElement(this.canvas_).
              scaleSize(this.pixelRatio_);

      // Get the eye vector, since we'll be adjusting gazeTarget.
      var eyeVector = [
        this.eye_[0] - this.gazeTarget_[0],
        this.eye_[1] - this.gazeTarget_[1],
        this.eye_[2] - this.gazeTarget_[2]];
      var length = vec3.length(eyeVector);
      vec3.normalize(eyeVector, eyeVector);

      var halfFov = constants.FOV / 2;
      var multiplier =
          2.0 * length * Math.tan(tr.b.deg2rad(halfFov)) / rect.height;

      // Get the up and right vectors.
      var up = [0, 1, 0];
      var rotMatrix = mat4.create();
      mat4.rotate(
          rotMatrix, rotMatrix, tr.b.deg2rad(this.rotation_[1]), [0, 1, 0]);
      mat4.rotate(
          rotMatrix, rotMatrix, tr.b.deg2rad(this.rotation_[0]), [1, 0, 0]);
      vec3.transformMat4(up, up, rotMatrix);

      var right = [0, 0, 0];
      vec3.cross(right, eyeVector, up);
      vec3.normalize(right, right);

      // Update the gaze target.
      for (var i = 0; i < 3; ++i) {
        this.gazeTarget_[i] +=
            delta[0] * multiplier * right[i] - delta[1] * multiplier * up[i];

        this.eye_[i] = this.gazeTarget_[i] + length * eyeVector[i];
      }

      // If we have some z offset, we need to reposition gazeTarget
      // to be on the plane z = 0 with normal [0, 0, 1].
      if (Math.abs(this.gazeTarget_[2]) > 1e-6) {
        var gazeVector = [-eyeVector[0], -eyeVector[1], -eyeVector[2]];
        var newLength = tr.b.clamp(
            -this.eye_[2] / gazeVector[2],
            constants.MINIMUM_DISTANCE,
            constants.MAXIMUM_DISTANCE);

        for (var i = 0; i < 3; ++i)
          this.gazeTarget_[i] = this.eye_[i] + newLength * gazeVector[i];
      }

      this.saveCameraToSettings(tr.b.SessionSettings());
      this.dispatchRenderEvent_();
    },

    updateZoomByDelta: function(delta) {
      var deltaY = delta[1];
      deltaY = tr.b.clamp(deltaY, -50, 50);
      var scale = 1.0 - deltaY / 100.0;

      var eyeVector = [0, 0, 0];
      vec3.subtract(eyeVector, this.eye_, this.gazeTarget_);

      var length = vec3.length(eyeVector);

      // Clamp the length to allowed values by changing the scale.
      if (length * scale < constants.MINIMUM_DISTANCE)
        scale = constants.MINIMUM_DISTANCE / length;
      else if (length * scale > constants.MAXIMUM_DISTANCE)
        scale = constants.MAXIMUM_DISTANCE / length;

      vec3.scale(eyeVector, eyeVector, scale);
      vec3.add(this.eye_, this.gazeTarget_, eyeVector);

      this.saveCameraToSettings(tr.b.SessionSettings());
      this.dispatchRenderEvent_();
    },

    updateRotateByDelta: function(delta) {
      delta[0] *= 0.5;
      delta[1] *= 0.5;

      if (Math.abs(this.rotation_[0] + delta[1]) > constants.MAXIMUM_TILT)
        return;
      if (Math.abs(this.rotation_[1] - delta[0]) > constants.MAXIMUM_TILT)
        return;

      var eyeVector = [0, 0, 0, 0];
      vec3.subtract(eyeVector, this.eye_, this.gazeTarget_);

      // Undo the current rotation.
      var rotMatrix = mat4.create();
      mat4.rotate(
          rotMatrix, rotMatrix, -tr.b.deg2rad(this.rotation_[0]), [1, 0, 0]);
      mat4.rotate(
          rotMatrix, rotMatrix, -tr.b.deg2rad(this.rotation_[1]), [0, 1, 0]);
      vec4.transformMat4(eyeVector, eyeVector, rotMatrix);

      // Update rotation values.
      this.rotation_[0] += delta[1];
      this.rotation_[1] -= delta[0];

      // Redo the new rotation.
      mat4.identity(rotMatrix);
      mat4.rotate(
          rotMatrix, rotMatrix, tr.b.deg2rad(this.rotation_[1]), [0, 1, 0]);
      mat4.rotate(
          rotMatrix, rotMatrix, tr.b.deg2rad(this.rotation_[0]), [1, 0, 0]);
      vec4.transformMat4(eyeVector, eyeVector, rotMatrix);

      vec3.add(this.eye_, this.gazeTarget_, eyeVector);

      this.saveCameraToSettings(tr.b.SessionSettings());
      this.dispatchRenderEvent_();
    },


    // Event callbacks.
    onPanBegin_: function(e) {
      this.panning_ = true;
      this.lastMousePosition_ = this.getMousePosition_(e);
    },

    onPanUpdate_: function(e) {
      if (!this.panning_)
        return;

      var delta = this.getMouseDelta_(e, this.lastMousePosition_);
      this.lastMousePosition_ = this.getMousePosition_(e);
      this.updatePanByDelta(delta);
    },

    onPanEnd_: function(e) {
      this.panning_ = false;
    },

    onZoomBegin_: function(e) {
      this.zooming_ = true;

      var p = this.getMousePosition_(e);

      this.lastMousePosition_ = p;
      this.zoomPoint_ = p;
    },

    onZoomUpdate_: function(e) {
      if (!this.zooming_)
        return;

      var delta = this.getMouseDelta_(e, this.lastMousePosition_);
      this.lastMousePosition_ = this.getMousePosition_(e);
      this.updateZoomByDelta(delta);
    },

    onZoomEnd_: function(e) {
      this.zooming_ = false;
      this.zoomPoint_ = undefined;
    },

    onRotateBegin_: function(e) {
      this.rotating_ = true;
      this.lastMousePosition_ = this.getMousePosition_(e);
    },

    onRotateUpdate_: function(e) {
      if (!this.rotating_)
        return;

      var delta = this.getMouseDelta_(e, this.lastMousePosition_);
      this.lastMousePosition_ = this.getMousePosition_(e);
      this.updateRotateByDelta(delta);
    },

    onRotateEnd_: function(e) {
      this.rotating_ = false;
    },


    // Misc helper functions.
    getMousePosition_: function(e) {
      var rect = tr.ui.b.windowRectForElement(this.canvas_);
      return [(e.clientX - rect.x) * this.pixelRatio_,
              (e.clientY - rect.y) * this.pixelRatio_];
    },

    getMouseDelta_: function(e, p) {
      var newP = this.getMousePosition_(e);
      return [newP[0] - p[0], newP[1] - p[1]];
    },

    dispatchRenderEvent_: function() {
      tr.b.dispatchSimpleEvent(this, 'renderrequired', false, false);
    }
  };

  return {
    Camera: Camera
  };
});


'use strict';

/**
 * @fileoverview QuadStackView controls the content and viewing angle a
 * QuadStack.
 */
tr.exportTo('tr.ui.b', function() {
  var THIS_DOC = document.currentScript.ownerDocument;

  var constants = {};
  constants.IMAGE_LOAD_RETRY_TIME_MS = 500;
  constants.SUBDIVISION_MINIMUM = 1;
  constants.SUBDIVISION_RECURSION_DEPTH = 3;
  constants.SUBDIVISION_DEPTH_THRESHOLD = 100;
  constants.FAR_PLANE_DISTANCE = 10000;

  // Care of bckenney@ via
  // http://extremelysatisfactorytotalitarianism.com/blog/?p=2120
  function drawTexturedTriangle(ctx, img, p0, p1, p2, t0, t1, t2) {
    var tmp_p0 = [p0[0], p0[1]];
    var tmp_p1 = [p1[0], p1[1]];
    var tmp_p2 = [p2[0], p2[1]];
    var tmp_t0 = [t0[0], t0[1]];
    var tmp_t1 = [t1[0], t1[1]];
    var tmp_t2 = [t2[0], t2[1]];

    ctx.beginPath();
    ctx.moveTo(tmp_p0[0], tmp_p0[1]);
    ctx.lineTo(tmp_p1[0], tmp_p1[1]);
    ctx.lineTo(tmp_p2[0], tmp_p2[1]);
    ctx.closePath();

    tmp_p1[0] -= tmp_p0[0];
    tmp_p1[1] -= tmp_p0[1];
    tmp_p2[0] -= tmp_p0[0];
    tmp_p2[1] -= tmp_p0[1];

    tmp_t1[0] -= tmp_t0[0];
    tmp_t1[1] -= tmp_t0[1];
    tmp_t2[0] -= tmp_t0[0];
    tmp_t2[1] -= tmp_t0[1];

    var det = 1 / (tmp_t1[0] * tmp_t2[1] - tmp_t2[0] * tmp_t1[1]),

        // linear transformation
        a = (tmp_t2[1] * tmp_p1[0] - tmp_t1[1] * tmp_p2[0]) * det,
        b = (tmp_t2[1] * tmp_p1[1] - tmp_t1[1] * tmp_p2[1]) * det,
        c = (tmp_t1[0] * tmp_p2[0] - tmp_t2[0] * tmp_p1[0]) * det,
        d = (tmp_t1[0] * tmp_p2[1] - tmp_t2[0] * tmp_p1[1]) * det,

        // translation
        e = tmp_p0[0] - a * tmp_t0[0] - c * tmp_t0[1],
        f = tmp_p0[1] - b * tmp_t0[0] - d * tmp_t0[1];

    ctx.save();
    ctx.transform(a, b, c, d, e, f);
    ctx.clip();
    ctx.drawImage(img, 0, 0);
    ctx.restore();
  }

  function drawTriangleSub(
      ctx, img, p0, p1, p2, t0, t1, t2, opt_recursion_depth) {
    var depth = opt_recursion_depth || 0;

    // We may subdivide if we are not at the limit of recursion.
    var subdivisionIndex = 0;
    if (depth < constants.SUBDIVISION_MINIMUM) {
      subdivisionIndex = 7;
    } else if (depth < constants.SUBDIVISION_RECURSION_DEPTH) {
      if (Math.abs(p0[2] - p1[2]) > constants.SUBDIVISION_DEPTH_THRESHOLD)
        subdivisionIndex += 1;
      if (Math.abs(p0[2] - p2[2]) > constants.SUBDIVISION_DEPTH_THRESHOLD)
        subdivisionIndex += 2;
      if (Math.abs(p1[2] - p2[2]) > constants.SUBDIVISION_DEPTH_THRESHOLD)
        subdivisionIndex += 4;
    }

    // These need to be created every time, since temporaries
    // outside of the scope will be rewritten in recursion.
    var p01 = vec4.create();
    var p02 = vec4.create();
    var p12 = vec4.create();
    var t01 = vec2.create();
    var t02 = vec2.create();
    var t12 = vec2.create();

    // Calculate the position before w-divide.
    for (var i = 0; i < 2; ++i) {
      p0[i] *= p0[2];
      p1[i] *= p1[2];
      p2[i] *= p2[2];
    }

    // Interpolate the 3d position.
    for (var i = 0; i < 4; ++i) {
      p01[i] = (p0[i] + p1[i]) / 2;
      p02[i] = (p0[i] + p2[i]) / 2;
      p12[i] = (p1[i] + p2[i]) / 2;
    }

    // Re-apply w-divide to the original points and the interpolated ones.
    for (var i = 0; i < 2; ++i) {
      p0[i] /= p0[2];
      p1[i] /= p1[2];
      p2[i] /= p2[2];

      p01[i] /= p01[2];
      p02[i] /= p02[2];
      p12[i] /= p12[2];
    }

    // Interpolate the texture coordinates.
    for (var i = 0; i < 2; ++i) {
      t01[i] = (t0[i] + t1[i]) / 2;
      t02[i] = (t0[i] + t2[i]) / 2;
      t12[i] = (t1[i] + t2[i]) / 2;
    }

    // Based on the index, we subdivide the triangle differently.
    // Assuming the triangle is p0, p1, p2 and points between i j
    // are represented as pij (that is, a point between p2 and p0
    // is p02, etc), then the new triangles are defined by
    // the 3rd 4th and 5th arguments into the function.
    switch (subdivisionIndex) {
      case 1:
        drawTriangleSub(ctx, img, p0, p01, p2, t0, t01, t2, depth + 1);
        drawTriangleSub(ctx, img, p01, p1, p2, t01, t1, t2, depth + 1);
        break;
      case 2:
        drawTriangleSub(ctx, img, p0, p1, p02, t0, t1, t02, depth + 1);
        drawTriangleSub(ctx, img, p1, p02, p2, t1, t02, t2, depth + 1);
        break;
      case 3:
        drawTriangleSub(ctx, img, p0, p01, p02, t0, t01, t02, depth + 1);
        drawTriangleSub(ctx, img, p02, p01, p2, t02, t01, t2, depth + 1);
        drawTriangleSub(ctx, img, p01, p1, p2, t01, t1, t2, depth + 1);
        break;
      case 4:
        drawTriangleSub(ctx, img, p0, p12, p2, t0, t12, t2, depth + 1);
        drawTriangleSub(ctx, img, p0, p1, p12, t0, t1, t12, depth + 1);
        break;
      case 5:
        drawTriangleSub(ctx, img, p0, p01, p2, t0, t01, t2, depth + 1);
        drawTriangleSub(ctx, img, p2, p01, p12, t2, t01, t12, depth + 1);
        drawTriangleSub(ctx, img, p01, p1, p12, t01, t1, t12, depth + 1);
        break;
      case 6:
        drawTriangleSub(ctx, img, p0, p12, p02, t0, t12, t02, depth + 1);
        drawTriangleSub(ctx, img, p0, p1, p12, t0, t1, t12, depth + 1);
        drawTriangleSub(ctx, img, p02, p12, p2, t02, t12, t2, depth + 1);
        break;
      case 7:
        drawTriangleSub(ctx, img, p0, p01, p02, t0, t01, t02, depth + 1);
        drawTriangleSub(ctx, img, p01, p12, p02, t01, t12, t02, depth + 1);
        drawTriangleSub(ctx, img, p01, p1, p12, t01, t1, t12, depth + 1);
        drawTriangleSub(ctx, img, p02, p12, p2, t02, t12, t2, depth + 1);
        break;
      default:
        // In the 0 case and all other cases, we simply draw the triangle.
        drawTexturedTriangle(ctx, img, p0, p1, p2, t0, t1, t2);
        break;
    }
  }

  // Created to avoid creating garbage when doing bulk transforms.
  var tmp_vec4 = vec4.create();
  function transform(transformed, point, matrix, viewport) {
    vec4.set(tmp_vec4, point[0], point[1], 0, 1);
    vec4.transformMat4(tmp_vec4, tmp_vec4, matrix);

    var w = tmp_vec4[3];
    if (w < 1e-6) w = 1e-6;

    transformed[0] = ((tmp_vec4[0] / w) + 1) * viewport.width / 2;
    transformed[1] = ((tmp_vec4[1] / w) + 1) * viewport.height / 2;
    transformed[2] = w;
  }

  function drawProjectedQuadBackgroundToContext(
      quad, p1, p2, p3, p4, ctx, quadCanvas) {
    if (quad.imageData) {
      quadCanvas.width = quad.imageData.width;
      quadCanvas.height = quad.imageData.height;
      quadCanvas.getContext('2d').putImageData(quad.imageData, 0, 0);
      var quadBBox = new tr.b.BBox2();
      quadBBox.addQuad(quad);
      var iw = quadCanvas.width;
      var ih = quadCanvas.height;
      drawTriangleSub(
          ctx, quadCanvas,
          p1, p2, p4,
          [0, 0], [iw, 0], [0, ih]);
      drawTriangleSub(
          ctx, quadCanvas,
          p2, p3, p4,
          [iw, 0], [iw, ih], [0, ih]);
    }

    if (quad.backgroundColor) {
      ctx.fillStyle = quad.backgroundColor;
      ctx.beginPath();
      ctx.moveTo(p1[0], p1[1]);
      ctx.lineTo(p2[0], p2[1]);
      ctx.lineTo(p3[0], p3[1]);
      ctx.lineTo(p4[0], p4[1]);
      ctx.closePath();
      ctx.fill();
    }
  }

  function drawProjectedQuadOutlineToContext(
      quad, p1, p2, p3, p4, ctx, quadCanvas) {
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]);
    ctx.lineTo(p2[0], p2[1]);
    ctx.lineTo(p3[0], p3[1]);
    ctx.lineTo(p4[0], p4[1]);
    ctx.closePath();
    ctx.save();
    if (quad.borderColor)
      ctx.strokeStyle = quad.borderColor;
    else
      ctx.strokeStyle = 'rgb(128,128,128)';

    if (quad.shadowOffset) {
      ctx.shadowColor = 'rgb(0, 0, 0)';
      ctx.shadowOffsetX = quad.shadowOffset[0];
      ctx.shadowOffsetY = quad.shadowOffset[1];
      if (quad.shadowBlur)
        ctx.shadowBlur = quad.shadowBlur;
    }

    if (quad.borderWidth)
      ctx.lineWidth = quad.borderWidth;
    else
      ctx.lineWidth = 1;

    ctx.stroke();
    ctx.restore();
  }

  function drawProjectedQuadSelectionOutlineToContext(
      quad, p1, p2, p3, p4, ctx, quadCanvas) {
    if (!quad.upperBorderColor)
      return;

    ctx.lineWidth = 8;
    ctx.strokeStyle = quad.upperBorderColor;

    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]);
    ctx.lineTo(p2[0], p2[1]);
    ctx.lineTo(p3[0], p3[1]);
    ctx.lineTo(p4[0], p4[1]);
    ctx.closePath();
    ctx.stroke();
  }

  function drawProjectedQuadToContext(
      passNumber, quad, p1, p2, p3, p4, ctx, quadCanvas) {
    if (passNumber === 0) {
      drawProjectedQuadBackgroundToContext(
          quad, p1, p2, p3, p4, ctx, quadCanvas);
    } else if (passNumber === 1) {
      drawProjectedQuadOutlineToContext(
          quad, p1, p2, p3, p4, ctx, quadCanvas);
    } else if (passNumber === 2) {
      drawProjectedQuadSelectionOutlineToContext(
          quad, p1, p2, p3, p4, ctx, quadCanvas);
    } else {
      throw new Error('Invalid pass number');
    }
  }

  var tmp_p1 = vec3.create();
  var tmp_p2 = vec3.create();
  var tmp_p3 = vec3.create();
  var tmp_p4 = vec3.create();
  function transformAndProcessQuads(
      matrix, viewport, quads, numPasses, handleQuadFunc, opt_arg1, opt_arg2) {

    for (var passNumber = 0; passNumber < numPasses; passNumber++) {
      for (var i = 0; i < quads.length; i++) {
        var quad = quads[i];
        transform(tmp_p1, quad.p1, matrix, viewport);
        transform(tmp_p2, quad.p2, matrix, viewport);
        transform(tmp_p3, quad.p3, matrix, viewport);
        transform(tmp_p4, quad.p4, matrix, viewport);
        handleQuadFunc(passNumber, quad,
                       tmp_p1, tmp_p2, tmp_p3, tmp_p4,
                       opt_arg1, opt_arg2);
      }
    }
  }

  /**
   * @constructor
   */
  var QuadStackView = tr.ui.b.define('quad-stack-view');

  QuadStackView.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.className = 'quad-stack-view';

      var node = tr.ui.b.instantiateTemplate('#quad-stack-view-template',
                                          THIS_DOC);
      this.appendChild(node);
      this.updateHeaderVisibility_();
      this.canvas_ = this.querySelector('#canvas');
      this.chromeImages_ = {
        left: this.querySelector('#chrome-left'),
        mid: this.querySelector('#chrome-mid'),
        right: this.querySelector('#chrome-right')
      };

      var stackingDistanceSlider = this.querySelector(
          '#stacking-distance-slider');
      stackingDistanceSlider.value = tr.b.Settings.get(
          'quadStackView.stackingDistance', 45);
      stackingDistanceSlider.addEventListener(
          'change', this.onStackingDistanceChange_.bind(this));
      stackingDistanceSlider.addEventListener(
          'input', this.onStackingDistanceChange_.bind(this));

      this.trackMouse_();

      this.camera_ = new tr.ui.b.Camera(this.mouseModeSelector_);
      this.camera_.addEventListener('renderrequired',
          this.onRenderRequired_.bind(this));
      this.cameraWasReset_ = false;
      this.camera_.canvas = this.canvas_;

      this.viewportRect_ = tr.b.Rect.fromXYWH(0, 0, 0, 0);

      this.pixelRatio_ = window.devicePixelRatio || 1;
    },

    updateHeaderVisibility_: function() {
      if (this.headerText)
        this.querySelector('#header').style.display = '';
      else
        this.querySelector('#header').style.display = 'none';
    },

    get headerText() {
      return this.querySelector('#header').textContent;
    },

    set headerText(headerText) {
      this.querySelector('#header').textContent = headerText;
      this.updateHeaderVisibility_();
    },

    onStackingDistanceChange_: function(e) {
      tr.b.Settings.set('quadStackView.stackingDistance',
                        this.stackingDistance);
      this.scheduleRender();
      e.stopPropagation();
    },

    get stackingDistance() {
      return this.querySelector('#stacking-distance-slider').value;
    },

    get mouseModeSelector() {
      return this.mouseModeSelector_;
    },

    get camera() {
      return this.camera_;
    },

    set quads(q) {
      this.quads_ = q;
      this.scheduleRender();
    },

    set deviceRect(rect) {
      if (!rect || rect.equalTo(this.deviceRect_))
        return;

      this.deviceRect_ = rect;
      this.camera_.deviceRect = rect;
      this.chromeQuad_ = undefined;
    },

    resize: function() {
      if (!this.offsetParent)
        return true;

      var width = parseInt(window.getComputedStyle(this.offsetParent).width);
      var height = parseInt(window.getComputedStyle(this.offsetParent).height);
      var rect = tr.b.Rect.fromXYWH(0, 0, width, height);

      if (rect.equalTo(this.viewportRect_))
        return false;

      this.viewportRect_ = rect;
      this.style.width = width + 'px';
      this.style.height = height + 'px';
      this.canvas_.style.width = width + 'px';
      this.canvas_.style.height = height + 'px';
      this.canvas_.width = this.pixelRatio_ * width;
      this.canvas_.height = this.pixelRatio_ * height;
      if (!this.cameraWasReset_) {
        this.camera_.resetCamera();
        this.cameraWasReset_ = true;
      }
      return true;
    },

    readyToDraw: function() {
      // If src isn't set yet, set it to ensure we can use
      // the image to draw onto a canvas.
      if (!this.chromeImages_.left.src) {
        var leftContent =
            window.getComputedStyle(this.chromeImages_.left).content;
        leftContent = leftContent.replace(/url\((.*)\)/, '$1');

        var midContent =
            window.getComputedStyle(this.chromeImages_.mid).content;
        midContent = midContent.replace(/url\((.*)\)/, '$1');

        var rightContent =
            window.getComputedStyle(this.chromeImages_.right).content;
        rightContent = rightContent.replace(/url\((.*)\)/, '$1');

        this.chromeImages_.left.src = leftContent;
        this.chromeImages_.mid.src = midContent;
        this.chromeImages_.right.src = rightContent;
      }

      // If all of the images are loaded (height > 0), then
      // we are ready to draw.
      return (this.chromeImages_.left.height > 0) &&
             (this.chromeImages_.mid.height > 0) &&
             (this.chromeImages_.right.height > 0);
    },

    get chromeQuad() {
      if (this.chromeQuad_)
        return this.chromeQuad_;

      // Draw the chrome border into a separate canvas.
      var chromeCanvas = document.createElement('canvas');
      var offsetY = this.chromeImages_.left.height;

      chromeCanvas.width = this.deviceRect_.width;
      chromeCanvas.height = this.deviceRect_.height + offsetY;

      var leftWidth = this.chromeImages_.left.width;
      var midWidth = this.chromeImages_.mid.width;
      var rightWidth = this.chromeImages_.right.width;

      var chromeCtx = chromeCanvas.getContext('2d');
      chromeCtx.drawImage(this.chromeImages_.left, 0, 0);

      chromeCtx.save();
      chromeCtx.translate(leftWidth, 0);

      // Calculate the scale of the mid image.
      var s = (this.deviceRect_.width - leftWidth - rightWidth) / midWidth;
      chromeCtx.scale(s, 1);

      chromeCtx.drawImage(this.chromeImages_.mid, 0, 0);
      chromeCtx.restore();

      chromeCtx.drawImage(
          this.chromeImages_.right, leftWidth + s * midWidth, 0);

      // Construct the quad.
      var chromeRect = tr.b.Rect.fromXYWH(
          this.deviceRect_.x,
          this.deviceRect_.y - offsetY,
          this.deviceRect_.width,
          this.deviceRect_.height + offsetY);
      var chromeQuad = tr.b.Quad.fromRect(chromeRect);
      chromeQuad.stackingGroupId = this.maxStackingGroupId_ + 1;
      chromeQuad.imageData = chromeCtx.getImageData(
          0, 0, chromeCanvas.width, chromeCanvas.height);
      chromeQuad.shadowOffset = [0, 0];
      chromeQuad.shadowBlur = 5;
      chromeQuad.borderWidth = 3;
      this.chromeQuad_ = chromeQuad;
      return this.chromeQuad_;
    },

    scheduleRender: function() {
      if (this.redrawScheduled_)
        return false;
      this.redrawScheduled_ = true;
      tr.b.requestAnimationFrame(this.render, this);
    },

    onRenderRequired_: function(e) {
      this.scheduleRender();
    },

    stackTransformAndProcessQuads_: function(
        numPasses, handleQuadFunc, includeChromeQuad, opt_arg1, opt_arg2) {
      var mv = this.camera_.modelViewMatrix;
      var p = this.camera_.projectionMatrix;

      var viewport = tr.b.Rect.fromXYWH(
          0, 0, this.canvas_.width, this.canvas_.height);

      // Calculate the quad stacks.
      var quadStacks = [];
      for (var i = 0; i < this.quads_.length; ++i) {
        var quad = this.quads_[i];
        var stackingId = quad.stackingGroupId || 0;
        while (stackingId >= quadStacks.length)
          quadStacks.push([]);

        quadStacks[stackingId].push(quad);
      }

      var mvp = mat4.create();
      this.maxStackingGroupId_ = quadStacks.length;
      var effectiveStackingDistance =
          this.stackingDistance * this.camera_.stackingDistanceDampening;

      // Draw the quad stacks, raising each subsequent level.
      mat4.multiply(mvp, p, mv);
      for (var i = 0; i < quadStacks.length; ++i) {
        transformAndProcessQuads(mvp, viewport, quadStacks[i],
                                 numPasses, handleQuadFunc,
                                 opt_arg1, opt_arg2);

        mat4.translate(mv, mv, [0, 0, effectiveStackingDistance]);
        mat4.multiply(mvp, p, mv);
      }

      if (includeChromeQuad && this.deviceRect_) {
        transformAndProcessQuads(mvp, viewport, [this.chromeQuad],
                                 numPasses, drawProjectedQuadToContext,
                                 opt_arg1, opt_arg2);
      }
    },

    render: function() {
      this.redrawScheduled_ = false;

      if (!this.readyToDraw()) {
        setTimeout(this.scheduleRender.bind(this),
                   constants.IMAGE_LOAD_RETRY_TIME_MS);
        return;
      }

      if (!this.quads_)
        return;

      var canvasCtx = this.canvas_.getContext('2d');
      if (!this.resize())
        canvasCtx.clearRect(0, 0, this.canvas_.width, this.canvas_.height);

      var quadCanvas = document.createElement('canvas');
      this.stackTransformAndProcessQuads_(
          3, drawProjectedQuadToContext, true,
          canvasCtx, quadCanvas);
      quadCanvas.width = 0; // Hack: Frees the quadCanvas' resources.
    },

    trackMouse_: function() {
      this.mouseModeSelector_ = document.createElement(
          'tr-ui-b-mouse-mode-selector');
      this.mouseModeSelector_.targetElement = this.canvas_;
      this.mouseModeSelector_.supportedModeMask =
          tr.ui.b.MOUSE_SELECTOR_MODE.SELECTION |
          tr.ui.b.MOUSE_SELECTOR_MODE.PANSCAN |
          tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM |
          tr.ui.b.MOUSE_SELECTOR_MODE.ROTATE;
      this.mouseModeSelector_.mode = tr.ui.b.MOUSE_SELECTOR_MODE.PANSCAN;
      this.mouseModeSelector_.pos = {x: 0, y: 100};
      this.appendChild(this.mouseModeSelector_);
      this.mouseModeSelector_.settingsKey =
          'quadStackView.mouseModeSelector';

      this.mouseModeSelector_.setModifierForAlternateMode(
          tr.ui.b.MOUSE_SELECTOR_MODE.ROTATE, tr.ui.b.MODIFIER.SHIFT);
      this.mouseModeSelector_.setModifierForAlternateMode(
          tr.ui.b.MOUSE_SELECTOR_MODE.PANSCAN, tr.ui.b.MODIFIER.SPACE);
      this.mouseModeSelector_.setModifierForAlternateMode(
          tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM, tr.ui.b.MODIFIER.CMD_OR_CTRL);

      this.mouseModeSelector_.addEventListener('updateselection',
          this.onSelectionUpdate_.bind(this));
      this.mouseModeSelector_.addEventListener('endselection',
          this.onSelectionUpdate_.bind(this));
    },

    extractRelativeMousePosition_: function(e) {
      var br = this.canvas_.getBoundingClientRect();
      return [
        this.pixelRatio_ * (e.clientX - this.canvas_.offsetLeft - br.left),
        this.pixelRatio_ * (e.clientY - this.canvas_.offsetTop - br.top)
      ];
    },

    onSelectionUpdate_: function(e) {
      var mousePos = this.extractRelativeMousePosition_(e);
      var res = [];
      function handleQuad(passNumber, quad, p1, p2, p3, p4) {
        if (tr.b.pointInImplicitQuad(mousePos, p1, p2, p3, p4))
          res.push(quad);
      }
      this.stackTransformAndProcessQuads_(1, handleQuad, false);
      var e = new tr.b.Event('selectionchange');
      e.quads = res;
      this.dispatchEvent(e);
    }
  };

  return {
    QuadStackView: QuadStackView
  };
});


'use strict';

/**
 * @fileoverview Graphical view of  LayerTreeImpl, with controls for
 * type of layer content shown and info bar for content-loading warnings.
 */
tr.exportTo('tr.ui.e.chrome.cc', function() {

  var THIS_DOC = document.currentScript.ownerDocument;
  var TILE_HEATMAP_TYPE = {};
  TILE_HEATMAP_TYPE.NONE = 'none';
  TILE_HEATMAP_TYPE.SCHEDULED_PRIORITY = 'scheduledPriority';
  TILE_HEATMAP_TYPE.USING_GPU_MEMORY = 'usingGpuMemory';

  var cc = tr.ui.e.chrome.cc;

  function createTileRectsSelectorBaseOptions() {
    return [{label: 'None', value: 'none'},
            {label: 'Coverage Rects', value: 'coverage'}];
  }

  var bytesToRoundedMegabytes = tr.e.cc.bytesToRoundedMegabytes;


  /**
   * @constructor
   */
  var LayerTreeQuadStackView =
      tr.ui.b.define('tr-ui-e-chrome-cc-layer-tree-quad-stack-view');

  LayerTreeQuadStackView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate: function() {
      this.isRenderPassQuads_ = false;
      this.pictureAsImageData_ = {}; // Maps picture.guid to PictureAsImageData.
      this.messages_ = [];
      this.controls_ = document.createElement('top-controls');
      this.infoBar_ = document.createElement('tr-ui-b-info-bar');
      this.quadStackView_ = new tr.ui.b.QuadStackView();
      this.quadStackView_.addEventListener(
          'selectionchange', this.onQuadStackViewSelectionChange_.bind(this));
      this.extraHighlightsByLayerId_ = undefined;
      this.inputEventImageData_ = undefined;

      var m = tr.ui.b.MOUSE_SELECTOR_MODE;
      var mms = this.quadStackView_.mouseModeSelector;
      mms.settingsKey = 'tr.e.cc.layerTreeQuadStackView.mouseModeSelector';
      mms.setKeyCodeForMode(m.SELECTION, 'Z'.charCodeAt(0));
      mms.setKeyCodeForMode(m.PANSCAN, 'X'.charCodeAt(0));
      mms.setKeyCodeForMode(m.ZOOM, 'C'.charCodeAt(0));
      mms.setKeyCodeForMode(m.ROTATE, 'V'.charCodeAt(0));

      var node = tr.ui.b.instantiateTemplate(
          '#tr-ui-e-chrome-cc-layer-tree-quad-stack-view-template', THIS_DOC);
      this.appendChild(node);
      this.appendChild(this.controls_);
      this.appendChild(this.infoBar_);
      this.appendChild(this.quadStackView_);

      this.tileRectsSelector_ = tr.ui.b.createSelector(
          this, 'howToShowTiles',
          'layerView.howToShowTiles', 'none',
          createTileRectsSelectorBaseOptions());
      this.controls_.appendChild(this.tileRectsSelector_);

      var tileHeatmapText = tr.ui.b.createSpan({
        textContent: 'Tile heatmap:'
      });
      this.controls_.appendChild(tileHeatmapText);

      var tileHeatmapSelector = tr.ui.b.createSelector(
          this, 'tileHeatmapType',
          'layerView.tileHeatmapType', TILE_HEATMAP_TYPE.NONE,
          [{label: 'None',
            value: TILE_HEATMAP_TYPE.NONE},
           {label: 'Scheduled Priority',
            value: TILE_HEATMAP_TYPE.SCHEDULED_PRIORITY},
           {label: 'Is using GPU memory',
            value: TILE_HEATMAP_TYPE.USING_GPU_MEMORY}
          ]);
      this.controls_.appendChild(tileHeatmapSelector);

      var showOtherLayersCheckbox = tr.ui.b.createCheckBox(
          this, 'showOtherLayers',
          'layerView.showOtherLayers', true,
          'Other layers/passes');
      showOtherLayersCheckbox.title =
          'When checked, show all layers, selected or not.';
      this.controls_.appendChild(showOtherLayersCheckbox);

      var showInvalidationsCheckbox = tr.ui.b.createCheckBox(
          this, 'showInvalidations',
          'layerView.showInvalidations', true,
          'Invalidations');
      showInvalidationsCheckbox.title =
          'When checked, compositing invalidations are highlighted in red';
      this.controls_.appendChild(showInvalidationsCheckbox);

      var showUnrecordedRegionCheckbox = tr.ui.b.createCheckBox(
          this, 'showUnrecordedRegion',
          'layerView.showUnrecordedRegion', true,
          'Unrecorded area');
      showUnrecordedRegionCheckbox.title =
          'When checked, unrecorded areas are highlighted in yellow';
      this.controls_.appendChild(showUnrecordedRegionCheckbox);

      var showBottlenecksCheckbox = tr.ui.b.createCheckBox(
          this, 'showBottlenecks',
          'layerView.showBottlenecks', true,
          'Bottlenecks');
      showBottlenecksCheckbox.title =
          'When checked, scroll bottlenecks are highlighted';
      this.controls_.appendChild(showBottlenecksCheckbox);

      var showLayoutRectsCheckbox = tr.ui.b.createCheckBox(
          this, 'showLayoutRects',
          'layerView.showLayoutRects', false,
          'Layout rects');
      showLayoutRectsCheckbox.title =
          'When checked, shows rects for regions where layout happened';
      this.controls_.appendChild(showLayoutRectsCheckbox);

      var showContentsCheckbox = tr.ui.b.createCheckBox(
          this, 'showContents',
          'layerView.showContents', true,
          'Contents');
      showContentsCheckbox.title =
          'When checked, show the rendered contents inside the layer outlines';
      this.controls_.appendChild(showContentsCheckbox);

      var showAnimationBoundsCheckbox = tr.ui.b.createCheckBox(
          this, 'showAnimationBounds',
          'layerView.showAnimationBounds', false,
          'Animation Bounds');
      showAnimationBoundsCheckbox.title = 'When checked, show a border around' +
          ' a layer showing the extent of its animation.';
      this.controls_.appendChild(showAnimationBoundsCheckbox);

      var showInputEventsCheckbox = tr.ui.b.createCheckBox(
          this, 'showInputEvents',
          'layerView.showInputEvents', true,
          'Input events');
      showInputEventsCheckbox.title = 'When checked, input events are ' +
          'displayed as circles.';
      this.controls_.appendChild(showInputEventsCheckbox);

      this.whatRasterizedLink_ = document.createElement('a');
      this.whatRasterizedLink_.classList.add('what-rasterized');
      this.whatRasterizedLink_.textContent = 'What rasterized?';
      this.whatRasterizedLink_.addEventListener(
          'click', this.onWhatRasterizedLinkClicked_.bind(this));
      this.appendChild(this.whatRasterizedLink_);
    },

    get layerTreeImpl() {
      return this.layerTreeImpl_;
    },

    set isRenderPassQuads(newValue) {
      this.isRenderPassQuads_ = newValue;
    },

    set layerTreeImpl(layerTreeImpl) {
      if (this.layerTreeImpl_ === layerTreeImpl)
        return;

      // FIXME(pdr): We may want to clear pictureAsImageData_ here to save
      //             memory at the cost of performance. Note that
      //             pictureAsImageData_ will be cleared when this is
      //             destructed, but this view might live for several
      //             layerTreeImpls.
      this.layerTreeImpl_ = layerTreeImpl;
      this.selection = undefined;
    },

    get extraHighlightsByLayerId() {
      return this.extraHighlightsByLayerId_;
    },

    set extraHighlightsByLayerId(extraHighlightsByLayerId) {
      this.extraHighlightsByLayerId_ = extraHighlightsByLayerId;
      this.scheduleUpdateContents_();
    },

    get showOtherLayers() {
      return this.showOtherLayers_;
    },

    set showOtherLayers(show) {
      this.showOtherLayers_ = show;
      this.updateContents_();
    },

    get showAnimationBounds() {
      return this.showAnimationBounds_;
    },

    set showAnimationBounds(show) {
      this.showAnimationBounds_ = show;
      this.updateContents_();
    },

    get showInputEvents() {
      return this.showInputEvents_;
    },

    set showInputEvents(show) {
      this.showInputEvents_ = show;
      this.updateContents_();
    },

    get showContents() {
      return this.showContents_;
    },

    set showContents(show) {
      this.showContents_ = show;
      this.updateContents_();
    },

    get showInvalidations() {
      return this.showInvalidations_;
    },

    set showInvalidations(show) {
      this.showInvalidations_ = show;
      this.updateContents_();
    },

    get showUnrecordedRegion() {
      return this.showUnrecordedRegion_;
    },

    set showUnrecordedRegion(show) {
      this.showUnrecordedRegion_ = show;
      this.updateContents_();
    },

    get showBottlenecks() {
      return this.showBottlenecks_;
    },

    set showBottlenecks(show) {
      this.showBottlenecks_ = show;
      this.updateContents_();
    },

    get showLayoutRects() {
      return this.showLayoutRects_;
    },

    set showLayoutRects(show) {
      this.showLayoutRects_ = show;
      this.updateContents_();
    },

    get howToShowTiles() {
      return this.howToShowTiles_;
    },

    set howToShowTiles(val) {
      // Make sure val is something we expect.
      console.assert(
          (val === 'none') ||
          (val === 'coverage') ||
          !isNaN(parseFloat(val)));

      this.howToShowTiles_ = val;
      this.updateContents_();
    },

    get tileHeatmapType() {
      return this.tileHeatmapType_;
    },

    set tileHeatmapType(val) {
      this.tileHeatmapType_ = val;
      this.updateContents_();
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (this.selection === selection)
        return;
      this.selection_ = selection;
      tr.b.dispatchSimpleEvent(this, 'selection-change');
      this.updateContents_();
    },

    regenerateContent: function() {
      this.updateTilesSelector_();
      this.updateContents_();
    },

    loadDataForImageElement_: function(image, callback) {
      var imageContent = window.getComputedStyle(image).content;
      image.src = imageContent.replace(/url\((.*)\)/, '$1');
      image.onload = function() {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);
        var imageData = ctx.getImageData(
            0, 0, canvas.width, canvas.height);
        callback(imageData);
      }
    },

    onQuadStackViewSelectionChange_: function(e) {
      var selectableQuads = e.quads.filter(function(q) {
        return q.selectionToSetIfClicked !== undefined;
      });
      if (selectableQuads.length == 0) {
        this.selection = undefined;
        return;
      }

      // Sort the quads low to high on stackingGroupId.
      selectableQuads.sort(function(x, y) {
        var z = x.stackingGroupId - y.stackingGroupId;
        if (z != 0)
          return z;
        return x.selectionToSetIfClicked.specicifity -
            y.selectionToSetIfClicked.specicifity;
      });

      // TODO(nduca): Support selecting N things at once.
      var quadToSelect = selectableQuads[selectableQuads.length - 1];
      this.selection = quadToSelect.selectionToSetIfClicked;
    },

    scheduleUpdateContents_: function() {
      if (this.updateContentsPending_)
        return;
      this.updateContentsPending_ = true;
      tr.b.requestAnimationFrameInThisFrameIfPossible(
          this.updateContents_, this);
    },

    updateContents_: function() {
      if (!this.layerTreeImpl_) {
        this.quadStackView_.headerText = 'No tree';
        this.quadStackView_.quads = [];
        return;
      }


      var status = this.computePictureLoadingStatus_();
      if (!status.picturesComplete)
        return;

      var lthi = this.layerTreeImpl_.layerTreeHostImpl;
      var lthiInstance = lthi.objectInstance;
      var worldViewportRect = tr.b.Rect.fromXYWH(
          0, 0,
          lthi.deviceViewportSize.width, lthi.deviceViewportSize.height);
      this.quadStackView_.deviceRect = worldViewportRect;
      if (this.isRenderPassQuads_)
        this.quadStackView_.quads = this.generateRenderPassQuads();
      else
        this.quadStackView_.quads = this.generateLayerQuads();

      this.updateWhatRasterizedLinkState_();

      var message = '';
      if (lthi.tilesHaveGpuMemoryUsageInfo) {
        var thisTreeUsageInBytes = this.layerTreeImpl_.gpuMemoryUsageInBytes;
        var otherTreeUsageInBytes = lthi.gpuMemoryUsageInBytes -
            thisTreeUsageInBytes;
        message += bytesToRoundedMegabytes(thisTreeUsageInBytes) +
                'MB on this tree';
        if (otherTreeUsageInBytes) {
          message += ', ' +
              bytesToRoundedMegabytes(otherTreeUsageInBytes) +
              'MB on the other tree';
        }
      } else {
        if (this.layerTreeImpl_) {
          var thisTreeUsageInBytes = this.layerTreeImpl_.gpuMemoryUsageInBytes;
          message += bytesToRoundedMegabytes(thisTreeUsageInBytes) +
              'MB on this tree';

          if (this.layerTreeImpl_.otherTree) {
            // Older Chromes don't report enough data to know how much memory is
            // being used across both trees. We know the memory consumed by each
            // tree, but there is resource sharing *between the trees* so we
            // can't simply sum up the per-tree costs. We need either the total
            // plus one tree, to guess the unique on the other tree, etc. Newer
            // chromes report memory per tile, which allows LTHI to compute the
            // total tile memory usage, letting us figure things out properly.
            message += ', ???MB on other tree. ';
          }
        }
      }

      if (lthi.args.tileManagerBasicState) {
        var tmgs = lthi.args.tileManagerBasicState.globalState;
        message += ' (softMax=' +
          bytesToRoundedMegabytes(tmgs.softMemoryLimitInBytes) +
          'MB, hardMax=' +
          bytesToRoundedMegabytes(tmgs.hardMemoryLimitInBytes) + 'MB, ' +
          tmgs.memoryLimitPolicy + ')';

      } else {
        // Old Chromes do not have a globalState on the LTHI dump.
        // But they do issue a DidManage event wiht the globalstate. Find that
        // event so that we show some global state.
        var thread = lthi.snapshottedOnThread;
        var didManageTilesSlices = thread.sliceGroup.slices.filter(function(s) {
          if (s.category !== 'tr.e.cc')
            return false;
          if (s.title !== 'DidManage')
            return false;
          if (s.end > lthi.ts)
            return false;
          return true;
        });
        didManageTilesSlices.sort(function(x, y) {
          return x.end - y.end;
        });
        if (didManageTilesSlices.length > 0) {
          var newest = didManageTilesSlices[didManageTilesSlices.length - 1];
          var tmgs = newest.args.state.global_state;
          message += ' (softMax=' +
            bytesToRoundedMegabytes(tmgs.soft_memory_limit_in_bytes) +
            'MB, hardMax=' +
            bytesToRoundedMegabytes(tmgs.hard_memory_limit_in_bytes) + 'MB, ' +
            tmgs.memory_limit_policy + ')';
        }
      }

      if (this.layerTreeImpl_.otherTree)
        message += ' (Another tree exists)';


      if (message.length)
        this.quadStackView_.headerText = message;
      else
        this.quadStackView_.headerText = undefined;

      this.updateInfoBar_(status.messages);
    },

    updateTilesSelector_: function() {
      var data = createTileRectsSelectorBaseOptions();

      if (this.layerTreeImpl_) {
        // First get all of the scales information from LTHI.
        var lthi = this.layerTreeImpl_.layerTreeHostImpl;
        var scaleNames = lthi.getContentsScaleNames();
        for (var scale in scaleNames) {
          data.push({
            label: 'Scale ' + scale + ' (' + scaleNames[scale] + ')',
            value: scale
          });
        }
      }

      // Then create a new selector and replace the old one.
      var new_selector = tr.ui.b.createSelector(
          this, 'howToShowTiles',
          'layerView.howToShowTiles', 'none',
          data);
      this.controls_.replaceChild(new_selector, this.tileRectsSelector_);
      this.tileRectsSelector_ = new_selector;
    },

    computePictureLoadingStatus_: function() {
      // Figure out if we can draw the quads yet. While we're at it, figure out
      // if we have any warnings we need to show.
      var layers = this.layers;
      var status = {
        messages: [],
        picturesComplete: true
      };
      if (this.showContents) {
        var hasPendingRasterizeImage = false;
        var firstPictureError = undefined;
        var hasMissingLayerRect = false;
        var hasUnresolvedPictureRef = false;
        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          for (var ir = 0; ir < layer.pictures.length; ++ir) {
            var picture = layer.pictures[ir];

            if (picture.idRef) {
              hasUnresolvedPictureRef = true;
              continue;
            }
            if (!picture.layerRect) {
              hasMissingLayerRect = true;
              continue;
            }

            var pictureAsImageData = this.pictureAsImageData_[picture.guid];
            if (!pictureAsImageData) {
              hasPendingRasterizeImage = true;
              this.pictureAsImageData_[picture.guid] =
                  tr.e.cc.PictureAsImageData.Pending(this);
              picture.rasterize(
                  {stopIndex: undefined},
                  function(pictureImageData) {
                    var picture_ = pictureImageData.picture;
                    this.pictureAsImageData_[picture_.guid] = pictureImageData;
                    this.scheduleUpdateContents_();
                  }.bind(this));
              continue;
            }
            if (pictureAsImageData.isPending()) {
              hasPendingRasterizeImage = true;
              continue;
            }
            if (pictureAsImageData.error) {
              if (!firstPictureError)
                firstPictureError = pictureAsImageData.error;
              break;
            }
          }
        }
        if (hasPendingRasterizeImage) {
          status.picturesComplete = false;
        } else {
          if (hasUnresolvedPictureRef) {
            status.messages.push({
              header: 'Missing picture',
              details: 'Your trace didnt have pictures for every layer. ' +
                  'Old chrome versions had this problem'});
          }
          if (hasMissingLayerRect) {
            status.messages.push({
              header: 'Missing layer rect',
              details: 'Your trace may be corrupt or from a very old ' +
                  'Chrome revision.'});
          }
          if (firstPictureError) {
            status.messages.push({
              header: 'Cannot rasterize',
              details: firstPictureError});
          }
        }
      }
      if (this.showInputEvents && this.layerTreeImpl.tracedInputLatencies &&
          this.inputEventImageData_ === undefined) {
        var image = this.querySelector('#input-event');
        if (!image.src) {
          this.loadDataForImageElement_(image, function(imageData) {
            this.inputEventImageData_ = imageData;
            this.updateContentsPending_ = false;
            this.scheduleUpdateContents_();
          }.bind(this));
        }
        status.picturesComplete = false;
      }
      return status;
    },

    get selectedRenderPass() {
      if (this.selection)
        return this.selection.renderPass_;
    },

    get selectedLayer() {
      if (this.selection) {
        var selectedLayerId = this.selection.associatedLayerId;
        return this.layerTreeImpl_.findLayerWithId(selectedLayerId);
      }
    },

    get renderPasses() {
      var renderPasses =
          this.layerTreeImpl.layerTreeHostImpl.args.frame.renderPasses;
      if (!this.showOtherLayers) {
        var selectedRenderPass = this.selectedRenderPass;
        if (selectedRenderPass)
          renderPasses = [selectedRenderPass];
      }
      return renderPasses;
    },

    get layers() {
      var layers = this.layerTreeImpl.renderSurfaceLayerList;
      if (!this.showOtherLayers) {
        var selectedLayer = this.selectedLayer;
        if (selectedLayer)
          layers = [selectedLayer];
      }
      return layers;
    },

    appendImageQuads_: function(quads, layer, layerQuad) {
      // Generate image quads for the layer
      for (var ir = 0; ir < layer.pictures.length; ++ir) {
        var picture = layer.pictures[ir];
        if (!picture.layerRect)
          continue;

        var unitRect = picture.layerRect.asUVRectInside(layer.bounds);
        var iq = layerQuad.projectUnitRect(unitRect);

        var pictureData = this.pictureAsImageData_[picture.guid];
        if (this.showContents && pictureData && pictureData.imageData) {
          iq.imageData = pictureData.imageData;
          iq.borderColor = 'rgba(0,0,0,0)';
        } else {
          iq.imageData = undefined;
        }

        iq.stackingGroupId = layerQuad.stackingGroupId;
        quads.push(iq);
      }
    },

    appendAnimationQuads_: function(quads, layer, layerQuad) {
      if (!layer.animationBoundsRect)
        return;

      var rect = layer.animationBoundsRect;
      var abq = tr.b.Quad.fromRect(rect);

      abq.backgroundColor = 'rgba(164,191,48,0.5)';
      abq.borderColor = 'rgba(205,255,0,0.75)';
      abq.borderWidth = 3.0;
      abq.stackingGroupId = layerQuad.stackingGroupId;
      abq.selectionToSetIfClicked = new cc.AnimationRectSelection(
          layer, rect);
      quads.push(abq);
    },

    appendInvalidationQuads_: function(quads, layer, layerQuad) {
      if (layer.layerTreeImpl.hasSourceFrameBeenDrawnBefore)
        return;

      // Generate the invalidation rect quads.
      for (var ir = 0; ir < layer.annotatedInvalidation.rects.length; ir++) {
        var rect = layer.annotatedInvalidation.rects[ir];
        var unitRect = rect.asUVRectInside(layer.bounds);
        var iq = layerQuad.projectUnitRect(unitRect);
        iq.backgroundColor = 'rgba(0, 255, 0, 0.1)';
        if (rect.reason === 'renderer insertion')
            iq.backgroundColor = 'rgba(0, 255, 128, 0.1)';
        iq.borderColor = 'rgba(0, 255, 0, 1)';
        iq.stackingGroupId = layerQuad.stackingGroupId;
        iq.selectionToSetIfClicked = new cc.LayerRectSelection(
            layer, 'Invalidation rect (' + rect.reason + ')', rect, rect);
        quads.push(iq);
      }

      // Show unannotated invalidation rect quads if no annotated rects are
      // available.
      if (layer.annotatedInvalidation.rects.length === 0) {
        for (var ir = 0; ir < layer.invalidation.rects.length; ir++) {
          var rect = layer.invalidation.rects[ir];
          var unitRect = rect.asUVRectInside(layer.bounds);
          var iq = layerQuad.projectUnitRect(unitRect);
          iq.backgroundColor = 'rgba(0, 255, 0, 0.1)';
          iq.borderColor = 'rgba(0, 255, 0, 1)';
          iq.stackingGroupId = layerQuad.stackingGroupId;
          iq.selectionToSetIfClicked = new cc.LayerRectSelection(
              layer, 'Invalidation rect', rect, rect);
          quads.push(iq);
        }
      }
    },

    appendUnrecordedRegionQuads_: function(quads, layer, layerQuad) {
      // Generate the unrecorded region quads.
      for (var ir = 0; ir < layer.unrecordedRegion.rects.length; ir++) {
        var rect = layer.unrecordedRegion.rects[ir];
        var unitRect = rect.asUVRectInside(layer.bounds);
        var iq = layerQuad.projectUnitRect(unitRect);
        iq.backgroundColor = 'rgba(240, 230, 140, 0.3)';
        iq.borderColor = 'rgba(240, 230, 140, 1)';
        iq.stackingGroupId = layerQuad.stackingGroupId;
        iq.selectionToSetIfClicked = new cc.LayerRectSelection(
            layer, 'Unrecorded area', rect, rect);
        quads.push(iq);
      }
    },

    appendBottleneckQuads_: function(quads, layer, layerQuad, stackingGroupId) {
      function processRegion(region, label, borderColor) {
        var backgroundColor = borderColor.clone();
        backgroundColor.a = 0.4 * (borderColor.a || 1.0);

        if (!region || !region.rects)
          return;

        for (var ir = 0; ir < region.rects.length; ir++) {
          var rect = region.rects[ir];
          var unitRect = rect.asUVRectInside(layer.bounds);
          var iq = layerQuad.projectUnitRect(unitRect);
          iq.backgroundColor = backgroundColor.toString();
          iq.borderColor = borderColor.toString();
          iq.borderWidth = 4.0;
          iq.stackingGroupId = stackingGroupId;
          iq.selectionToSetIfClicked = new cc.LayerRectSelection(
              layer, label, rect, rect);
          quads.push(iq);
        }
      }

      processRegion(layer.touchEventHandlerRegion, 'Touch listener',
                    tr.b.Color.fromString('rgb(228, 226, 27)'));
      processRegion(layer.wheelEventHandlerRegion, 'Wheel listener',
                    tr.b.Color.fromString('rgb(176, 205, 29)'));
      processRegion(layer.nonFastScrollableRegion, 'Repaints on scroll',
                    tr.b.Color.fromString('rgb(213, 134, 32)'));
    },

    appendTileCoverageRectQuads_: function(
        quads, layer, layerQuad, heatmapType) {
      if (!layer.tileCoverageRects)
        return;

      var tiles = [];
      for (var ct = 0; ct < layer.tileCoverageRects.length; ++ct) {
        var tile = layer.tileCoverageRects[ct].tile;
        if (tile !== undefined)
          tiles.push(tile);
      }

      var lthi = this.layerTreeImpl_.layerTreeHostImpl;
      var minMax =
          this.getMinMaxForHeatmap_(lthi.activeTiles, heatmapType);
      var heatmapResult =
          this.computeHeatmapColors_(tiles, minMax, heatmapType);
      var heatIndex = 0;

      for (var ct = 0; ct < layer.tileCoverageRects.length; ++ct) {
        var rect = layer.tileCoverageRects[ct].geometryRect;
        rect = rect.scale(1.0 / layer.geometryContentsScale);

        var tile = layer.tileCoverageRects[ct].tile;

        var unitRect = rect.asUVRectInside(layer.bounds);
        var quad = layerQuad.projectUnitRect(unitRect);

        quad.backgroundColor = 'rgba(0, 0, 0, 0)';
        quad.stackingGroupId = layerQuad.stackingGroupId;
        var type = tr.e.cc.tileTypes.missing;
        if (tile) {
          type = tile.getTypeForLayer(layer);
          quad.backgroundColor = heatmapResult[heatIndex].color;
          ++heatIndex;
        }

        quad.borderColor = tr.e.cc.tileBorder[type].color;
        quad.borderWidth = tr.e.cc.tileBorder[type].width;
        var label;
        if (tile)
          label = 'coverageRect';
        else
          label = 'checkerboard coverageRect';
        quad.selectionToSetIfClicked = new cc.LayerRectSelection(
            layer, label, rect, layer.tileCoverageRects[ct]);

        quads.push(quad);
      }
    },

    appendLayoutRectQuads_: function(quads, layer, layerQuad) {
      if (!layer.layoutRects) {
        return;
      }

      for (var ct = 0; ct < layer.layoutRects.length; ++ct) {
        var rect = layer.layoutRects[ct].geometryRect;
        rect = rect.scale(1.0 / layer.geometryContentsScale);

        var unitRect = rect.asUVRectInside(layer.bounds);
        var quad = layerQuad.projectUnitRect(unitRect);

        quad.backgroundColor = 'rgba(0, 0, 0, 0)';
        quad.stackingGroupId = layerQuad.stackingGroupId;

        quad.borderColor = 'rgba(0, 0, 200, 0.7)';
        quad.borderWidth = 2;
        var label;
        label = 'Layout rect';
        quad.selectionToSetIfClicked = new cc.LayerRectSelection(
            layer, label, rect);

        quads.push(quad);
      }
    },

    getValueForHeatmap_: function(tile, heatmapType) {
      if (heatmapType == TILE_HEATMAP_TYPE.SCHEDULED_PRIORITY) {
        return tile.scheduledPriority == 0 ?
            undefined :
            tile.scheduledPriority;
      } else if (heatmapType == TILE_HEATMAP_TYPE.USING_GPU_MEMORY) {
        if (tile.isSolidColor)
          return 0.5;
        return tile.isUsingGpuMemory ? 0 : 1;
      }
    },

    getMinMaxForHeatmap_: function(tiles, heatmapType) {
      var range = new tr.b.Range();
      if (heatmapType == TILE_HEATMAP_TYPE.USING_GPU_MEMORY) {
        range.addValue(0);
        range.addValue(1);
        return range;
      }

      for (var i = 0; i < tiles.length; ++i) {
        var value = this.getValueForHeatmap_(tiles[i], heatmapType);
        if (value === undefined)
          continue;
        range.addValue(value);
      }
      if (range.range === 0)
        range.addValue(1);
      return range;
    },

    computeHeatmapColors_: function(tiles, minMax, heatmapType) {
      var min = minMax.min;
      var max = minMax.max;

      var color = function(value) {
        var hue = 120 * (1 - (value - min) / (max - min));
        if (hue < 0)
          hue = 0;
        return 'hsla(' + hue + ', 100%, 50%, 0.5)';
      };

      var values = [];
      for (var i = 0; i < tiles.length; ++i) {
        var tile = tiles[i];
        var value = this.getValueForHeatmap_(tile, heatmapType);
        var res = {
          value: value,
          color: value !== undefined ? color(value) : undefined
        };
        values.push(res);
      }

      return values;
    },

    appendTilesWithScaleQuads_: function(
        quads, layer, layerQuad, scale, heatmapType) {
      var lthi = this.layerTreeImpl_.layerTreeHostImpl;

      var tiles = [];
      for (var i = 0; i < lthi.activeTiles.length; ++i) {
        var tile = lthi.activeTiles[i];

        if (Math.abs(tile.contentsScale - scale) > 1e-6)
          continue;

        // TODO(vmpstr): Make the stiching of tiles and layers a part of
        // tile construction (issue 346)
        if (layer.layerId != tile.layerId)
          continue;

        tiles.push(tile);
      }

      var minMax =
          this.getMinMaxForHeatmap_(lthi.activeTiles, heatmapType);
      var heatmapResult =
          this.computeHeatmapColors_(tiles, minMax, heatmapType);

      for (var i = 0; i < tiles.length; ++i) {
        var tile = tiles[i];
        var rect = tile.layerRect;
        if (!tile.layerRect)
          continue;
        var unitRect = rect.asUVRectInside(layer.bounds);
        var quad = layerQuad.projectUnitRect(unitRect);

        quad.backgroundColor = 'rgba(0, 0, 0, 0)';
        quad.stackingGroupId = layerQuad.stackingGroupId;

        var type = tile.getTypeForLayer(layer);
        quad.borderColor = tr.e.cc.tileBorder[type].color;
        quad.borderWidth = tr.e.cc.tileBorder[type].width;

        quad.backgroundColor = heatmapResult[i].color;
        var data = {
          tileType: type
        };
        if (heatmapType !== TILE_HEATMAP_TYPE.NONE)
          data[heatmapType] = heatmapResult[i].value;
        quad.selectionToSetIfClicked = new cc.TileSelection(tile, data);
        quads.push(quad);
      }
    },

    appendHighlightQuadsForLayer_: function(
        quads, layer, layerQuad, highlights) {
      highlights.forEach(function(highlight) {
        var rect = highlight.rect;

        var unitRect = rect.asUVRectInside(layer.bounds);
        var quad = layerQuad.projectUnitRect(unitRect);

        var colorId = tr.ui.b.getColorIdForGeneralPurposeString(
            highlight.colorKey);
        colorId += tr.ui.b.getColorPaletteHighlightIdBoost();

        var color = tr.b.Color.fromString(tr.ui.b.getColorPalette()[colorId]);

        var quadForDrawing = quad.clone();
        quadForDrawing.backgroundColor = color.withAlpha(0.5).toString();
        quadForDrawing.borderColor = color.withAlpha(1.0).darken().toString();
        quadForDrawing.stackingGroupId = layerQuad.stackingGroupId;
        quads.push(quadForDrawing);

      }, this);
    },

    generateRenderPassQuads: function() {
      if (!this.layerTreeImpl.layerTreeHostImpl.args.frame)
        return [];
      var renderPasses = this.renderPasses;
      if (!renderPasses)
        return [];

      var quads = [];
      for (var i = 0; i < renderPasses.length; ++i) {
        var quadList = renderPasses[i].quadList;
        for (var j = 0; j < quadList.length; ++j) {
          var drawQuad = quadList[j];
          var quad = drawQuad.rectAsTargetSpaceQuad.clone();
          quad.borderColor = 'rgb(170, 204, 238)';
          quad.borderWidth = 2;
          quad.stackingGroupId = i;
          quads.push(quad);
        }
      }
      return quads;
    },

    generateLayerQuads: function() {
      this.updateContentsPending_ = false;

      // Generate the quads for the view.
      var layers = this.layers;
      var quads = [];
      var nextStackingGroupId = 0;
      var alreadyVisitedLayerIds = {};


      var selectionHighlightsByLayerId;
      if (this.selection)
        selectionHighlightsByLayerId = this.selection.highlightsByLayerId;
      else
        selectionHighlightsByLayerId = {};

      var extraHighlightsByLayerId = this.extraHighlightsByLayerId || {};

      for (var i = 1; i <= layers.length; i++) {
        // Generate quads back-to-front.
        var layer = layers[layers.length - i];
        alreadyVisitedLayerIds[layer.layerId] = true;
        if (layer.objectInstance.name == 'cc::NinePatchLayerImpl')
          continue;

        var layerQuad = layer.layerQuad.clone();
        if (layer.usingGpuRasterization) {
          var pixelRatio = window.devicePixelRatio || 1;
          layerQuad.borderWidth = 2.0 * pixelRatio;
          layerQuad.borderColor = 'rgba(154,205,50,0.75)';
        } else {
          layerQuad.borderColor = 'rgba(0,0,0,0.75)';
        }
        layerQuad.stackingGroupId = nextStackingGroupId++;
        layerQuad.selectionToSetIfClicked = new cc.LayerSelection(layer);
        layerQuad.layer = layer;
        if (this.showOtherLayers && this.selectedLayer == layer)
          layerQuad.upperBorderColor = 'rgb(156,189,45)';

        if (this.showAnimationBounds)
          this.appendAnimationQuads_(quads, layer, layerQuad);

        this.appendImageQuads_(quads, layer, layerQuad);
        quads.push(layerQuad);


        if (this.showInvalidations)
          this.appendInvalidationQuads_(quads, layer, layerQuad);
        if (this.showUnrecordedRegion)
          this.appendUnrecordedRegionQuads_(quads, layer, layerQuad);
        if (this.showBottlenecks)
          this.appendBottleneckQuads_(quads, layer, layerQuad,
                                      layerQuad.stackingGroupId);
        if (this.showLayoutRects)
          this.appendLayoutRectQuads_(quads, layer, layerQuad);

        if (this.howToShowTiles === 'coverage') {
          this.appendTileCoverageRectQuads_(
              quads, layer, layerQuad, this.tileHeatmapType);
        } else if (this.howToShowTiles !== 'none') {
          this.appendTilesWithScaleQuads_(
              quads, layer, layerQuad,
              this.howToShowTiles, this.tileHeatmapType);
        }

        var highlights;
        highlights = extraHighlightsByLayerId[layer.layerId];
        if (highlights) {
          this.appendHighlightQuadsForLayer_(
              quads, layer, layerQuad, highlights);
        }

        highlights = selectionHighlightsByLayerId[layer.layerId];
        if (highlights) {
          this.appendHighlightQuadsForLayer_(
              quads, layer, layerQuad, highlights);
        }
      }

      this.layerTreeImpl.iterLayers(function(layer, depth, isMask, isReplica) {
        if (!this.showOtherLayers && this.selectedLayer != layer)
          return;
        if (alreadyVisitedLayerIds[layer.layerId])
          return;
        var layerQuad = layer.layerQuad;
        var stackingGroupId = nextStackingGroupId++;
        if (this.showBottlenecks)
          this.appendBottleneckQuads_(quads, layer, layerQuad, stackingGroupId);
      }, this);

      var tracedInputLatencies = this.layerTreeImpl.tracedInputLatencies;
      if (this.showInputEvents && tracedInputLatencies) {
        for (var i = 0; i < tracedInputLatencies.length; i++) {
          var coordinatesArray = tracedInputLatencies[i].args.data.coordinates;
          for (var j = 0; j < coordinatesArray.length; j++) {
            var inputQuad = tr.b.Quad.fromXYWH(
                coordinatesArray[j].x - 25,
                coordinatesArray[j].y - 25,
                50,
                50);
            inputQuad.borderColor = 'rgba(0, 0, 0, 0)';
            inputQuad.imageData = this.inputEventImageData_;
            quads.push(inputQuad);
          }
        }
      }

      return quads;
    },

    updateInfoBar_: function(infoBarMessages) {
      if (infoBarMessages.length) {
        this.infoBar_.removeAllButtons();
        this.infoBar_.message = 'Some problems were encountered...';
        this.infoBar_.addButton('More info...', function(e) {
          var overlay = new tr.ui.b.Overlay();
          overlay.textContent = '';
          infoBarMessages.forEach(function(message) {
            var title = document.createElement('h3');
            title.textContent = message.header;

            var details = document.createElement('div');
            details.textContent = message.details;

            overlay.appendChild(title);
            overlay.appendChild(details);
          });
          overlay.visible = true;

          e.stopPropagation();
          return false;
        });
        this.infoBar_.visible = true;
      } else {
        this.infoBar_.removeAllButtons();
        this.infoBar_.message = '';
        this.infoBar_.visible = false;
      }
    },

    getWhatRasterized_: function() {
      var lthi = this.layerTreeImpl_.layerTreeHostImpl;
      var renderProcess = lthi.objectInstance.parent;
      var tasks = [];
      renderProcess.iterateAllEvents(function(event) {
        if (!(event instanceof tr.model.Slice))
          return;

        var tile = tr.e.cc.getTileFromRasterTaskSlice(event);
        if (tile === undefined)
          return false;

        if (tile.containingSnapshot == lthi)
          tasks.push(event);
      }, this);
      return tasks;
    },

    updateWhatRasterizedLinkState_: function() {
      var tasks = this.getWhatRasterized_();
      if (tasks.length) {
        this.whatRasterizedLink_.textContent = tasks.length + ' raster tasks';
        this.whatRasterizedLink_.style.display = '';
      } else {
        this.whatRasterizedLink_.textContent = '';
        this.whatRasterizedLink_.style.display = 'none';
      }
    },

    onWhatRasterizedLinkClicked_: function() {
      var tasks = this.getWhatRasterized_();
      var event = new tr.model.RequestSelectionChangeEvent();
      event.selection = new tr.model.EventSet(tasks);
      this.dispatchEvent(event);
    }
  };

  return {
    LayerTreeQuadStackView: LayerTreeQuadStackView
  };
});


'use strict';

/**
 * @fileoverview LayerView coordinates graphical and analysis views of layers.
 */

tr.exportTo('tr.ui.e.chrome.cc', function() {
  var constants = tr.e.cc.constants;

  /**
   * @constructor
   */
  var LayerView = tr.ui.b.define('tr-ui-e-chrome-cc-layer-view');

  LayerView.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.layerTreeQuadStackView_ =
          new tr.ui.e.chrome.cc.LayerTreeQuadStackView();
      this.dragBar_ = new tr.ui.b.DragHandle();
      this.analysisEl_ =
          document.createElement('tr-ui-e-chrome-cc-layer-view-analysis');
      this.analysisEl_.addEventListener('requestSelectionChange',
          this.onRequestSelectionChangeFromAnalysisEl_.bind(this));

      this.dragBar_.target = this.analysisEl_;

      this.appendChild(this.layerTreeQuadStackView_);
      this.appendChild(this.dragBar_);
      this.appendChild(this.analysisEl_);

      this.layerTreeQuadStackView_.addEventListener('selection-change',
          function() {
            this.layerTreeQuadStackViewSelectionChanged_();
          }.bind(this));
      this.layerTreeQuadStackViewSelectionChanged_();
    },

    get layerTreeImpl() {
      return this.layerTreeQuadStackView_.layerTreeImpl;
    },

    set layerTreeImpl(newValue) {
      return this.layerTreeQuadStackView_.layerTreeImpl = newValue;
    },

    set isRenderPassQuads(newValue) {
      return this.layerTreeQuadStackView_.isRenderPassQuads = newValue;
    },

    get selection() {
      return this.layerTreeQuadStackView_.selection;
    },

    set selection(newValue) {
      this.layerTreeQuadStackView_.selection = newValue;
    },

    regenerateContent: function() {
      this.layerTreeQuadStackView_.regenerateContent();
    },

    layerTreeQuadStackViewSelectionChanged_: function() {
      var selection = this.layerTreeQuadStackView_.selection;
      if (selection) {
        this.dragBar_.style.display = '';
        this.analysisEl_.style.display = '';
        this.analysisEl_.textContent = '';

        var layer = selection.layer;
        if (layer && layer.args && layer.args.pictures) {
          this.analysisEl_.appendChild(
              this.createPictureBtn_(layer.args.pictures));
        }

        var analysis = selection.createAnalysis();
        this.analysisEl_.appendChild(analysis);
      } else {
        this.dragBar_.style.display = 'none';
        this.analysisEl_.style.display = 'none';
        var analysis = this.analysisEl_.firstChild;
        if (analysis)
          this.analysisEl_.removeChild(analysis);
        this.layerTreeQuadStackView_.style.height =
            window.getComputedStyle(this).height;
      }
      tr.b.dispatchSimpleEvent(this, 'selection-change');
    },

    createPictureBtn_: function(pictures) {
      if (!(pictures instanceof Array))
        pictures = [pictures];

      var link = document.createElement('tr-ui-a-analysis-link');
      link.selection = function() {
        var layeredPicture = new tr.e.cc.LayeredPicture(pictures);
        var snapshot = new tr.e.cc.PictureSnapshot(layeredPicture);
        snapshot.picture = layeredPicture;

        var selection = new tr.model.EventSet();
        selection.push(snapshot);
        return selection;
      };
      link.textContent = 'View in Picture Debugger';
      return link;
    },

    onRequestSelectionChangeFromAnalysisEl_: function(e) {
      if (!(e.selection instanceof tr.ui.e.chrome.cc.Selection))
        return;

      e.stopPropagation();
      this.selection = e.selection;
    },

    get extraHighlightsByLayerId() {
      return this.layerTreeQuadStackView_.extraHighlightsByLayerId;
    },

    set extraHighlightsByLayerId(extraHighlightsByLayerId) {
      this.layerTreeQuadStackView_.extraHighlightsByLayerId =
          extraHighlightsByLayerId;
    }
  };

  return {
    LayerView: LayerView
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /*
   * Displays a LayerTreeHostImpl snapshot in a human readable form.
   * @constructor
   */
  var LayerTreeHostImplSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-layer-tree-host-impl-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  LayerTreeHostImplSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate: function() {
      this.classList.add('tr-ui-e-chrome-cc-lthi-s-view');

      this.selection_ = undefined;

      this.layerPicker_ = new tr.ui.e.chrome.cc.LayerPicker();
      this.layerPicker_.addEventListener(
          'selection-change',
          this.onLayerPickerSelectionChanged_.bind(this));

      this.layerView_ = new tr.ui.e.chrome.cc.LayerView();
      this.layerView_.addEventListener(
          'selection-change',
          this.onLayerViewSelectionChanged_.bind(this));
      this.dragHandle_ = new tr.ui.b.DragHandle();
      this.dragHandle_.horizontal = false;
      this.dragHandle_.target = this.layerView_;

      this.appendChild(this.layerPicker_);
      this.appendChild(this.dragHandle_);
      this.appendChild(this.layerView_);

      // Make sure we have the current values from layerView_ and layerPicker_,
      // since those might have been created before we added the listener.
      this.onLayerViewSelectionChanged_();
      this.onLayerPickerSelectionChanged_();

    },

    get objectSnapshot() {
      return this.objectSnapshot_;
    },

    set objectSnapshot(objectSnapshot) {
      this.objectSnapshot_ = objectSnapshot;

      var lthi = this.objectSnapshot;
      var layerTreeImpl;
      if (lthi)
        layerTreeImpl = lthi.getTree(this.layerPicker_.whichTree);

      this.layerPicker_.lthiSnapshot = lthi;
      this.layerView_.layerTreeImpl = layerTreeImpl;
      this.layerView_.regenerateContent();

      if (!this.selection_)
        return;
      this.selection = this.selection_.findEquivalent(lthi);
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (this.selection_ == selection)
        return;
      this.selection_ = selection;
      this.layerPicker_.selection = selection;
      this.layerView_.selection = selection;
      tr.b.dispatchSimpleEvent(this, 'cc-selection-change');
    },

    onLayerPickerSelectionChanged_: function() {
      this.selection_ = this.layerPicker_.selection;
      this.layerView_.selection = this.selection;
      this.layerView_.layerTreeImpl = this.layerPicker_.layerTreeImpl;
      this.layerView_.isRenderPassQuads = this.layerPicker_.isRenderPassQuads;
      this.layerView_.regenerateContent();
      tr.b.dispatchSimpleEvent(this, 'cc-selection-change');
    },

    onLayerViewSelectionChanged_: function() {
      this.selection_ = this.layerView_.selection;
      this.layerPicker_.selection = this.selection;
      tr.b.dispatchSimpleEvent(this, 'cc-selection-change');
    },

    get extraHighlightsByLayerId() {
      return this.layerView_.extraHighlightsByLayerId;
    },

    set extraHighlightsByLayerId(extraHighlightsByLayerId) {
      this.layerView_.extraHighlightsByLayerId = extraHighlightsByLayerId;
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      LayerTreeHostImplSnapshotView, {typeName: 'cc::LayerTreeHostImpl'});

  return {
    LayerTreeHostImplSnapshotView: LayerTreeHostImplSnapshotView
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  var OPS_TIMING_ITERATIONS = 3;
  var CHART_PADDING_LEFT = 65;
  var CHART_PADDING_RIGHT = 40;
  var AXIS_PADDING_LEFT = 60;
  var AXIS_PADDING_RIGHT = 35;
  var AXIS_PADDING_TOP = 25;
  var AXIS_PADDING_BOTTOM = 45;
  var AXIS_LABEL_PADDING = 5;
  var AXIS_TICK_SIZE = 10;
  var LABEL_PADDING = 5;
  var LABEL_INTERLEAVE_OFFSET = 15;
  var BAR_PADDING = 5;
  var VERTICAL_TICKS = 5;
  var HUE_CHAR_CODE_ADJUSTMENT = 5.7;

  /**
   * Provides a chart showing the cumulative time spent in Skia operations
   * during picture rasterization.
   *
   * @constructor
   */
  var PictureOpsChartSummaryView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-picture-ops-chart-summary-view');

  PictureOpsChartSummaryView.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.picture_ = undefined;
      this.pictureDataProcessed_ = false;

      this.chartScale_ = window.devicePixelRatio;

      this.chart_ = document.createElement('canvas');
      this.chartCtx_ = this.chart_.getContext('2d');
      this.appendChild(this.chart_);

      this.opsTimingData_ = [];

      this.chartWidth_ = 0;
      this.chartHeight_ = 0;
      this.requiresRedraw_ = true;

      this.currentBarMouseOverTarget_ = null;

      this.chart_.addEventListener('mousemove', this.onMouseMove_.bind(this));
    },

    get requiresRedraw() {
      return this.requiresRedraw_;
    },

    set requiresRedraw(requiresRedraw) {
      this.requiresRedraw_ = requiresRedraw;
    },

    get picture() {
      return this.picture_;
    },

    set picture(picture) {
      this.picture_ = picture;
      this.pictureDataProcessed_ = false;

      if (this.classList.contains('hidden'))
        return;

      this.processPictureData_();
      this.requiresRedraw = true;
      this.updateChartContents();
    },

    hide: function() {
      this.classList.add('hidden');
    },

    show: function() {

      this.classList.remove('hidden');

      if (this.pictureDataProcessed_)
        return;

      this.processPictureData_();
      this.requiresRedraw = true;
      this.updateChartContents();

    },

    onMouseMove_: function(e) {

      var lastBarMouseOverTarget = this.currentBarMouseOverTarget_;
      this.currentBarMouseOverTarget_ = null;

      var x = e.offsetX;
      var y = e.offsetY;

      var chartLeft = CHART_PADDING_LEFT;
      var chartRight = this.chartWidth_ - CHART_PADDING_RIGHT;
      var chartTop = AXIS_PADDING_TOP;
      var chartBottom = this.chartHeight_ - AXIS_PADDING_BOTTOM;
      var chartInnerWidth = chartRight - chartLeft;

      if (x > chartLeft && x < chartRight && y > chartTop && y < chartBottom) {

        this.currentBarMouseOverTarget_ = Math.floor(
            (x - chartLeft) / chartInnerWidth * this.opsTimingData_.length);

        this.currentBarMouseOverTarget_ = tr.b.clamp(
            this.currentBarMouseOverTarget_, 0, this.opsTimingData_.length - 1);

      }

      if (this.currentBarMouseOverTarget_ === lastBarMouseOverTarget)
        return;

      this.drawChartContents_();
    },

    updateChartContents: function() {

      if (this.requiresRedraw)
        this.updateChartDimensions_();

      this.drawChartContents_();
    },

    updateChartDimensions_: function() {
      this.chartWidth_ = this.offsetWidth;
      this.chartHeight_ = this.offsetHeight;

      // Scale up the canvas according to the devicePixelRatio, then reduce it
      // down again via CSS. Finally we apply a scale to the canvas so that
      // things are drawn at the correct size.
      this.chart_.width = this.chartWidth_ * this.chartScale_;
      this.chart_.height = this.chartHeight_ * this.chartScale_;

      this.chart_.style.width = this.chartWidth_ + 'px';
      this.chart_.style.height = this.chartHeight_ + 'px';

      this.chartCtx_.scale(this.chartScale_, this.chartScale_);
    },

    processPictureData_: function() {

      this.resetOpsTimingData_();
      this.pictureDataProcessed_ = true;

      if (!this.picture_)
        return;

      var ops = this.picture_.getOps();
      if (!ops)
        return;

      ops = this.picture_.tagOpsWithTimings(ops);

      // Check that there are valid times.
      if (ops[0].cmd_time === undefined)
        return;

      this.collapseOpsToTimingBuckets_(ops);
    },

    drawChartContents_: function() {

      this.clearChartContents_();

      if (this.opsTimingData_.length === 0) {
        this.showNoTimingDataMessage_();
        return;
      }

      this.drawChartAxes_();
      this.drawBars_();
      this.drawLineAtBottomOfChart_();

      if (this.currentBarMouseOverTarget_ === null)
        return;

      this.drawTooltip_();
    },

    drawLineAtBottomOfChart_: function() {
      this.chartCtx_.strokeStyle = '#AAA';
      this.chartCtx_.moveTo(0, this.chartHeight_ - 0.5);
      this.chartCtx_.lineTo(this.chartWidth_, this.chartHeight_ - 0.5);
      this.chartCtx_.stroke();
    },

    drawTooltip_: function() {

      var tooltipData = this.opsTimingData_[this.currentBarMouseOverTarget_];
      var tooltipTitle = tooltipData.cmd_string;
      var tooltipTime = tooltipData.cmd_time.toFixed(4);

      var tooltipWidth = 110;
      var tooltipHeight = 40;
      var chartInnerWidth = this.chartWidth_ - CHART_PADDING_RIGHT -
          CHART_PADDING_LEFT;
      var barWidth = chartInnerWidth / this.opsTimingData_.length;
      var tooltipOffset = Math.round((tooltipWidth - barWidth) * 0.5);

      var left = CHART_PADDING_LEFT + this.currentBarMouseOverTarget_ *
          barWidth - tooltipOffset;
      var top = Math.round((this.chartHeight_ - tooltipHeight) * 0.5);

      this.chartCtx_.save();

      this.chartCtx_.shadowOffsetX = 0;
      this.chartCtx_.shadowOffsetY = 5;
      this.chartCtx_.shadowBlur = 4;
      this.chartCtx_.shadowColor = 'rgba(0,0,0,0.4)';

      this.chartCtx_.strokeStyle = '#888';
      this.chartCtx_.fillStyle = '#EEE';
      this.chartCtx_.fillRect(left, top, tooltipWidth, tooltipHeight);

      this.chartCtx_.shadowColor = 'transparent';
      this.chartCtx_.translate(0.5, 0.5);
      this.chartCtx_.strokeRect(left, top, tooltipWidth, tooltipHeight);

      this.chartCtx_.restore();

      this.chartCtx_.fillStyle = '#222';
      this.chartCtx_.textBaseline = 'top';
      this.chartCtx_.font = '800 12px Arial';
      this.chartCtx_.fillText(tooltipTitle, left + 8, top + 8);

      this.chartCtx_.fillStyle = '#555';
      this.chartCtx_.textBaseline = 'top';
      this.chartCtx_.font = '400 italic 10px Arial';
      this.chartCtx_.fillText('Total: ' + tooltipTime + 'ms',
          left + 8, top + 22);
    },

    drawBars_: function() {

      var len = this.opsTimingData_.length;
      var max = this.opsTimingData_[0].cmd_time;
      var min = this.opsTimingData_[len - 1].cmd_time;

      var width = this.chartWidth_ - CHART_PADDING_LEFT - CHART_PADDING_RIGHT;
      var height = this.chartHeight_ - AXIS_PADDING_TOP - AXIS_PADDING_BOTTOM;
      var barWidth = Math.floor(width / len);

      var opData;
      var opTiming;
      var opHeight;
      var opLabel;
      var barLeft;

      for (var b = 0; b < len; b++) {

        opData = this.opsTimingData_[b];
        opTiming = opData.cmd_time / max;

        opHeight = Math.round(Math.max(1, opTiming * height));
        opLabel = opData.cmd_string;
        barLeft = CHART_PADDING_LEFT + b * barWidth;

        this.chartCtx_.fillStyle = this.getOpColor_(opLabel);

        this.chartCtx_.fillRect(barLeft + BAR_PADDING, AXIS_PADDING_TOP +
            height - opHeight, barWidth - 2 * BAR_PADDING, opHeight);
      }

    },

    getOpColor_: function(opName) {

      var characters = opName.split('');
      var hue = characters.reduce(this.reduceNameToHue, 0) % 360;

      return 'hsl(' + hue + ', 30%, 50%)';
    },

    reduceNameToHue: function(previousValue, currentValue, index, array) {
      // Get the char code and apply a magic adjustment value so we get
      // pretty colors from around the rainbow.
      return Math.round(previousValue + currentValue.charCodeAt(0) *
          HUE_CHAR_CODE_ADJUSTMENT);
    },

    drawChartAxes_: function() {

      var len = this.opsTimingData_.length;
      var max = this.opsTimingData_[0].cmd_time;
      var min = this.opsTimingData_[len - 1].cmd_time;

      var width = this.chartWidth_ - AXIS_PADDING_LEFT - AXIS_PADDING_RIGHT;
      var height = this.chartHeight_ - AXIS_PADDING_TOP - AXIS_PADDING_BOTTOM;

      var totalBarWidth = this.chartWidth_ - CHART_PADDING_LEFT -
          CHART_PADDING_RIGHT;
      var barWidth = Math.floor(totalBarWidth / len);
      var tickYInterval = height / (VERTICAL_TICKS - 1);
      var tickYPosition = 0;
      var tickValInterval = (max - min) / (VERTICAL_TICKS - 1);
      var tickVal = 0;

      this.chartCtx_.fillStyle = '#333';
      this.chartCtx_.strokeStyle = '#777';
      this.chartCtx_.save();

      // Translate half a pixel to avoid blurry lines.
      this.chartCtx_.translate(0.5, 0.5);

      // Sides.

      this.chartCtx_.save();

      this.chartCtx_.translate(AXIS_PADDING_LEFT, AXIS_PADDING_TOP);
      this.chartCtx_.moveTo(0, 0);
      this.chartCtx_.lineTo(0, height);
      this.chartCtx_.lineTo(width, height);

      // Y-axis ticks.
      this.chartCtx_.font = '10px Arial';
      this.chartCtx_.textAlign = 'right';
      this.chartCtx_.textBaseline = 'middle';

      for (var t = 0; t < VERTICAL_TICKS; t++) {

        tickYPosition = Math.round(t * tickYInterval);
        tickVal = (max - t * tickValInterval).toFixed(4);

        this.chartCtx_.moveTo(0, tickYPosition);
        this.chartCtx_.lineTo(-AXIS_TICK_SIZE, tickYPosition);
        this.chartCtx_.fillText(tickVal,
            -AXIS_TICK_SIZE - AXIS_LABEL_PADDING, tickYPosition);

      }

      this.chartCtx_.stroke();

      this.chartCtx_.restore();


      // Labels.

      this.chartCtx_.save();

      this.chartCtx_.translate(CHART_PADDING_LEFT + Math.round(barWidth * 0.5),
          AXIS_PADDING_TOP + height + LABEL_PADDING);

      this.chartCtx_.font = '10px Arial';
      this.chartCtx_.textAlign = 'center';
      this.chartCtx_.textBaseline = 'top';

      var labelTickLeft;
      var labelTickBottom;
      for (var l = 0; l < len; l++) {

        labelTickLeft = Math.round(l * barWidth);
        labelTickBottom = l % 2 * LABEL_INTERLEAVE_OFFSET;

        this.chartCtx_.save();
        this.chartCtx_.moveTo(labelTickLeft, -LABEL_PADDING);
        this.chartCtx_.lineTo(labelTickLeft, labelTickBottom);
        this.chartCtx_.stroke();
        this.chartCtx_.restore();

        this.chartCtx_.fillText(this.opsTimingData_[l].cmd_string,
            labelTickLeft, labelTickBottom);
      }

      this.chartCtx_.restore();

      this.chartCtx_.restore();
    },

    clearChartContents_: function() {
      this.chartCtx_.clearRect(0, 0, this.chartWidth_, this.chartHeight_);
    },

    showNoTimingDataMessage_: function() {
      this.chartCtx_.font = '800 italic 14px Arial';
      this.chartCtx_.fillStyle = '#333';
      this.chartCtx_.textAlign = 'center';
      this.chartCtx_.textBaseline = 'middle';
      this.chartCtx_.fillText('No timing data available.',
          this.chartWidth_ * 0.5, this.chartHeight_ * 0.5);
    },

    collapseOpsToTimingBuckets_: function(ops) {

      var opsTimingDataIndexHash_ = {};
      var timingData = this.opsTimingData_;
      var op;
      var opIndex;

      for (var i = 0; i < ops.length; i++) {

        op = ops[i];

        if (op.cmd_time === undefined)
          continue;

        // Try to locate the entry for the current operation
        // based on its name. If that fails, then create one for it.
        opIndex = opsTimingDataIndexHash_[op.cmd_string] || null;

        if (opIndex === null) {
          timingData.push({
            cmd_time: 0,
            cmd_string: op.cmd_string
          });

          opIndex = timingData.length - 1;
          opsTimingDataIndexHash_[op.cmd_string] = opIndex;
        }

        timingData[opIndex].cmd_time += op.cmd_time;

      }

      timingData.sort(this.sortTimingBucketsByOpTimeDescending_);

      this.collapseTimingBucketsToOther_(4);
    },

    collapseTimingBucketsToOther_: function(count) {

      var timingData = this.opsTimingData_;
      var otherSource = timingData.splice(count, timingData.length - count);
      var otherDestination = null;

      if (!otherSource.length)
        return;

      timingData.push({
        cmd_time: 0,
        cmd_string: 'Other'
      });

      otherDestination = timingData[timingData.length - 1];
      for (var i = 0; i < otherSource.length; i++) {
        otherDestination.cmd_time += otherSource[i].cmd_time;
      }
    },

    sortTimingBucketsByOpTimeDescending_: function(a, b) {
      return b.cmd_time - a.cmd_time;
    },

    resetOpsTimingData_: function() {
      this.opsTimingData_.length = 0;
    }
  };

  return {
    PictureOpsChartSummaryView: PictureOpsChartSummaryView
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  var BAR_PADDING = 1;
  var BAR_WIDTH = 5;
  var CHART_PADDING_LEFT = 65;
  var CHART_PADDING_RIGHT = 30;
  var CHART_PADDING_BOTTOM = 35;
  var CHART_PADDING_TOP = 20;
  var AXIS_PADDING_LEFT = 55;
  var AXIS_PADDING_RIGHT = 30;
  var AXIS_PADDING_BOTTOM = 35;
  var AXIS_PADDING_TOP = 20;
  var AXIS_TICK_SIZE = 5;
  var AXIS_LABEL_PADDING = 5;
  var VERTICAL_TICKS = 5;
  var HUE_CHAR_CODE_ADJUSTMENT = 5.7;

  /**
   * Provides a chart showing the cumulative time spent in Skia operations
   * during picture rasterization.
   *
   * @constructor
   */
  var PictureOpsChartView =
      tr.ui.b.define('tr-ui-e-chrome-cc-picture-ops-chart-view');

  PictureOpsChartView.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      this.picture_ = undefined;
      this.pictureOps_ = undefined;
      this.opCosts_ = undefined;

      this.chartScale_ = window.devicePixelRatio;

      this.chart_ = document.createElement('canvas');
      this.chartCtx_ = this.chart_.getContext('2d');
      this.appendChild(this.chart_);

      this.selectedOpIndex_ = undefined;
      this.chartWidth_ = 0;
      this.chartHeight_ = 0;
      this.dimensionsHaveChanged_ = true;

      this.currentBarMouseOverTarget_ = undefined;

      this.ninetyFifthPercentileCost_ = 0;
      this.totalOpCost_ = 0;

      this.chart_.addEventListener('click', this.onClick_.bind(this));
      this.chart_.addEventListener('mousemove', this.onMouseMove_.bind(this));

      this.usePercentileScale_ = false;
      this.usePercentileScaleCheckbox_ = tr.ui.b.createCheckBox(
          this, 'usePercentileScale',
          'PictureOpsChartView.usePercentileScale', false,
          'Limit to 95%-ile');
      this.usePercentileScaleCheckbox_.classList.add('use-percentile-scale');
      this.appendChild(this.usePercentileScaleCheckbox_);
    },

    get dimensionsHaveChanged() {
      return this.dimensionsHaveChanged_;
    },

    set dimensionsHaveChanged(dimensionsHaveChanged) {
      this.dimensionsHaveChanged_ = dimensionsHaveChanged;
    },

    get usePercentileScale() {
      return this.usePercentileScale_;
    },

    set usePercentileScale(usePercentileScale) {
      this.usePercentileScale_ = usePercentileScale;
      this.drawChartContents_();
    },

    get numOps() {
      return this.opCosts_.length;
    },

    get selectedOpIndex() {
      return this.selectedOpIndex_;
    },

    set selectedOpIndex(selectedOpIndex) {
      if (selectedOpIndex < 0) throw new Error('Invalid index');
      if (selectedOpIndex >= this.numOps) throw new Error('Invalid index');

      this.selectedOpIndex_ = selectedOpIndex;
    },

    get picture() {
      return this.picture_;
    },

    set picture(picture) {
      this.picture_ = picture;
      this.pictureOps_ = picture.tagOpsWithTimings(picture.getOps());
      this.currentBarMouseOverTarget_ = undefined;
      this.processPictureData_();
      this.dimensionsHaveChanged = true;
    },

    processPictureData_: function() {
      if (this.pictureOps_ === undefined)
        return;

      var totalOpCost = 0;

      // Take a copy of the picture ops data for sorting.
      this.opCosts_ = this.pictureOps_.map(function(op) {
        totalOpCost += op.cmd_time;
        return op.cmd_time;
      });
      this.opCosts_.sort();

      var ninetyFifthPercentileCostIndex = Math.floor(
          this.opCosts_.length * 0.95);
      this.ninetyFifthPercentileCost_ =
          this.opCosts_[ninetyFifthPercentileCostIndex];
      this.maxCost_ = this.opCosts_[this.opCosts_.length - 1];

      this.totalOpCost_ = totalOpCost;
    },

    extractBarIndex_: function(e) {

      var index = undefined;

      if (this.pictureOps_ === undefined ||
          this.pictureOps_.length === 0)
        return index;

      var x = e.offsetX;
      var y = e.offsetY;

      var totalBarWidth = (BAR_WIDTH + BAR_PADDING) * this.pictureOps_.length;

      var chartLeft = CHART_PADDING_LEFT;
      var chartTop = 0;
      var chartBottom = this.chartHeight_ - CHART_PADDING_BOTTOM;
      var chartRight = chartLeft + totalBarWidth;

      if (x < chartLeft || x > chartRight || y < chartTop || y > chartBottom)
        return index;

      index = Math.floor((x - chartLeft) / totalBarWidth *
          this.pictureOps_.length);

      index = tr.b.clamp(index, 0, this.pictureOps_.length - 1);

      return index;
    },

    onClick_: function(e) {

      var barClicked = this.extractBarIndex_(e);

      if (barClicked === undefined)
        return;

      // If we click on the already selected item we should deselect.
      if (barClicked === this.selectedOpIndex)
        this.selectedOpIndex = undefined;
      else
        this.selectedOpIndex = barClicked;

      e.preventDefault();

      tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
    },

    onMouseMove_: function(e) {

      var lastBarMouseOverTarget = this.currentBarMouseOverTarget_;
      this.currentBarMouseOverTarget_ = this.extractBarIndex_(e);

      if (this.currentBarMouseOverTarget_ === lastBarMouseOverTarget)
        return;

      this.drawChartContents_();
    },

    scrollSelectedItemIntoViewIfNecessary: function() {

      if (this.selectedOpIndex === undefined)
        return;

      var width = this.offsetWidth;
      var left = this.scrollLeft;
      var right = left + width;
      var targetLeft = CHART_PADDING_LEFT +
          (BAR_WIDTH + BAR_PADDING) * this.selectedOpIndex;

      if (targetLeft > left && targetLeft < right)
        return;

      this.scrollLeft = (targetLeft - width * 0.5);
    },

    updateChartContents: function() {

      if (this.dimensionsHaveChanged)
        this.updateChartDimensions_();

      this.drawChartContents_();
    },

    updateChartDimensions_: function() {

      if (!this.pictureOps_)
        return;

      var width = CHART_PADDING_LEFT + CHART_PADDING_RIGHT +
          ((BAR_WIDTH + BAR_PADDING) * this.pictureOps_.length);

      if (width < this.offsetWidth)
        width = this.offsetWidth;

      // Allow the element to be its natural size as set by flexbox, then lock
      // the width in before we set the width of the canvas.
      this.chartWidth_ = width;
      this.chartHeight_ = this.getBoundingClientRect().height;

      // Scale up the canvas according to the devicePixelRatio, then reduce it
      // down again via CSS. Finally we apply a scale to the canvas so that
      // things are drawn at the correct size.
      this.chart_.width = this.chartWidth_ * this.chartScale_;
      this.chart_.height = this.chartHeight_ * this.chartScale_;

      this.chart_.style.width = this.chartWidth_ + 'px';
      this.chart_.style.height = this.chartHeight_ + 'px';

      this.chartCtx_.scale(this.chartScale_, this.chartScale_);

      this.dimensionsHaveChanged = false;
    },

    drawChartContents_: function() {

      this.clearChartContents_();

      if (this.pictureOps_ === undefined ||
          this.pictureOps_.length === 0 ||
          this.pictureOps_[0].cmd_time === undefined) {

        this.showNoTimingDataMessage_();
        return;
      }

      this.drawSelection_();
      this.drawBars_();
      this.drawChartAxes_();
      this.drawLinesAtTickMarks_();
      this.drawLineAtBottomOfChart_();

      if (this.currentBarMouseOverTarget_ === undefined)
        return;

      this.drawTooltip_();
    },

    drawSelection_: function() {

      if (this.selectedOpIndex === undefined)
        return;

      var width = (BAR_WIDTH + BAR_PADDING) * this.selectedOpIndex;
      this.chartCtx_.fillStyle = 'rgb(223, 235, 230)';
      this.chartCtx_.fillRect(CHART_PADDING_LEFT, CHART_PADDING_TOP,
          width, this.chartHeight_ - CHART_PADDING_TOP - CHART_PADDING_BOTTOM);
    },

    drawChartAxes_: function() {

      var min = this.opCosts_[0];
      var max = this.opCosts_[this.opCosts_.length - 1];
      var height = this.chartHeight_ - AXIS_PADDING_TOP - AXIS_PADDING_BOTTOM;

      var tickYInterval = height / (VERTICAL_TICKS - 1);
      var tickYPosition = 0;
      var tickValInterval = (max - min) / (VERTICAL_TICKS - 1);
      var tickVal = 0;

      this.chartCtx_.fillStyle = '#333';
      this.chartCtx_.strokeStyle = '#777';
      this.chartCtx_.save();

      // Translate half a pixel to avoid blurry lines.
      this.chartCtx_.translate(0.5, 0.5);

      // Sides.
      this.chartCtx_.beginPath();
      this.chartCtx_.moveTo(AXIS_PADDING_LEFT, AXIS_PADDING_TOP);
      this.chartCtx_.lineTo(AXIS_PADDING_LEFT, this.chartHeight_ -
          AXIS_PADDING_BOTTOM);
      this.chartCtx_.lineTo(this.chartWidth_ - AXIS_PADDING_RIGHT,
          this.chartHeight_ - AXIS_PADDING_BOTTOM);
      this.chartCtx_.stroke();
      this.chartCtx_.closePath();

      // Y-axis ticks.
      this.chartCtx_.translate(AXIS_PADDING_LEFT, AXIS_PADDING_TOP);

      this.chartCtx_.font = '10px Arial';
      this.chartCtx_.textAlign = 'right';
      this.chartCtx_.textBaseline = 'middle';

      this.chartCtx_.beginPath();
      for (var t = 0; t < VERTICAL_TICKS; t++) {

        tickYPosition = Math.round(t * tickYInterval);
        tickVal = (max - t * tickValInterval).toFixed(4);

        this.chartCtx_.moveTo(0, tickYPosition);
        this.chartCtx_.lineTo(-AXIS_TICK_SIZE, tickYPosition);
        this.chartCtx_.fillText(tickVal,
            -AXIS_TICK_SIZE - AXIS_LABEL_PADDING, tickYPosition);

      }

      this.chartCtx_.stroke();
      this.chartCtx_.closePath();

      this.chartCtx_.restore();
    },

    drawLinesAtTickMarks_: function() {

      var height = this.chartHeight_ - AXIS_PADDING_TOP - AXIS_PADDING_BOTTOM;
      var width = this.chartWidth_ - AXIS_PADDING_LEFT - AXIS_PADDING_RIGHT;
      var tickYInterval = height / (VERTICAL_TICKS - 1);
      var tickYPosition = 0;

      this.chartCtx_.save();

      this.chartCtx_.translate(AXIS_PADDING_LEFT + 0.5, AXIS_PADDING_TOP + 0.5);
      this.chartCtx_.beginPath();
      this.chartCtx_.strokeStyle = 'rgba(0,0,0,0.05)';

      for (var t = 0; t < VERTICAL_TICKS; t++) {
        tickYPosition = Math.round(t * tickYInterval);

        this.chartCtx_.moveTo(0, tickYPosition);
        this.chartCtx_.lineTo(width, tickYPosition);
        this.chartCtx_.stroke();
      }

      this.chartCtx_.restore();
      this.chartCtx_.closePath();
    },

    drawLineAtBottomOfChart_: function() {
      this.chartCtx_.strokeStyle = '#AAA';
      this.chartCtx_.beginPath();
      this.chartCtx_.moveTo(0, this.chartHeight_ - 0.5);
      this.chartCtx_.lineTo(this.chartWidth_, this.chartHeight_ - 0.5);
      this.chartCtx_.stroke();
      this.chartCtx_.closePath();
    },

    drawTooltip_: function() {

      var tooltipData = this.pictureOps_[this.currentBarMouseOverTarget_];
      var tooltipTitle = tooltipData.cmd_string;
      var tooltipTime = tooltipData.cmd_time.toFixed(4);
      var toolTipTimePercentage =
          ((tooltipData.cmd_time / this.totalOpCost_) * 100).toFixed(2);

      var tooltipWidth = 120;
      var tooltipHeight = 40;
      var chartInnerWidth = this.chartWidth_ - CHART_PADDING_RIGHT -
          CHART_PADDING_LEFT;
      var barWidth = BAR_WIDTH + BAR_PADDING;
      var tooltipOffset = Math.round((tooltipWidth - barWidth) * 0.5);

      var left = CHART_PADDING_LEFT + this.currentBarMouseOverTarget_ *
          barWidth - tooltipOffset;
      var top = Math.round((this.chartHeight_ - tooltipHeight) * 0.5);

      this.chartCtx_.save();

      this.chartCtx_.shadowOffsetX = 0;
      this.chartCtx_.shadowOffsetY = 5;
      this.chartCtx_.shadowBlur = 4;
      this.chartCtx_.shadowColor = 'rgba(0,0,0,0.4)';

      this.chartCtx_.strokeStyle = '#888';
      this.chartCtx_.fillStyle = '#EEE';
      this.chartCtx_.fillRect(left, top, tooltipWidth, tooltipHeight);

      this.chartCtx_.shadowColor = 'transparent';
      this.chartCtx_.translate(0.5, 0.5);
      this.chartCtx_.strokeRect(left, top, tooltipWidth, tooltipHeight);

      this.chartCtx_.restore();

      this.chartCtx_.fillStyle = '#222';
      this.chartCtx_.textAlign = 'left';
      this.chartCtx_.textBaseline = 'top';
      this.chartCtx_.font = '800 12px Arial';
      this.chartCtx_.fillText(tooltipTitle, left + 8, top + 8);

      this.chartCtx_.fillStyle = '#555';
      this.chartCtx_.font = '400 italic 10px Arial';
      this.chartCtx_.fillText(tooltipTime + 'ms (' +
          toolTipTimePercentage + '%)', left + 8, top + 22);
    },

    drawBars_: function() {

      var op;
      var opColor = 0;
      var opHeight = 0;
      var opWidth = BAR_WIDTH + BAR_PADDING;
      var opHover = false;

      var bottom = this.chartHeight_ - CHART_PADDING_BOTTOM;
      var maxHeight = this.chartHeight_ - CHART_PADDING_BOTTOM -
          CHART_PADDING_TOP;

      var maxValue;
      if (this.usePercentileScale)
        maxValue = this.ninetyFifthPercentileCost_;
      else
        maxValue = this.maxCost_;

      for (var b = 0; b < this.pictureOps_.length; b++) {

        op = this.pictureOps_[b];
        opHeight = Math.round(
            (op.cmd_time / maxValue) * maxHeight);
        opHeight = Math.max(opHeight, 1);
        opHover = (b === this.currentBarMouseOverTarget_);
        opColor = this.getOpColor_(op.cmd_string, opHover);

        if (b === this.selectedOpIndex)
          this.chartCtx_.fillStyle = '#FFFF00';
        else
          this.chartCtx_.fillStyle = opColor;

        this.chartCtx_.fillRect(CHART_PADDING_LEFT + b * opWidth,
            bottom - opHeight, BAR_WIDTH, opHeight);
      }

    },

    getOpColor_: function(opName, hover) {

      var characters = opName.split('');

      var hue = characters.reduce(this.reduceNameToHue, 0) % 360;
      var saturation = 30;
      var lightness = hover ? '75%' : '50%';

      return 'hsl(' + hue + ', ' + saturation + '%, ' + lightness + '%)';
    },

    reduceNameToHue: function(previousValue, currentValue, index, array) {
      // Get the char code and apply a magic adjustment value so we get
      // pretty colors from around the rainbow.
      return Math.round(previousValue + currentValue.charCodeAt(0) *
          HUE_CHAR_CODE_ADJUSTMENT);
    },

    clearChartContents_: function() {
      this.chartCtx_.clearRect(0, 0, this.chartWidth_, this.chartHeight_);
    },

    showNoTimingDataMessage_: function() {
      this.chartCtx_.font = '800 italic 14px Arial';
      this.chartCtx_.fillStyle = '#333';
      this.chartCtx_.textAlign = 'center';
      this.chartCtx_.textBaseline = 'middle';
      this.chartCtx_.fillText('No timing data available.',
          this.chartWidth_ * 0.5, this.chartHeight_ * 0.5);
    }
  };

  return {
    PictureOpsChartView: PictureOpsChartView
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  var THIS_DOC = document.currentScript.ownerDocument;

  /**
   * PictureDebugger is a view of a PictureSnapshot for inspecting
   * the picture in detail. (e.g., timing information, etc.)
   *
   * @constructor
   */
  var PictureDebugger = tr.ui.b.define('tr-ui-e-chrome-cc-picture-debugger');

  PictureDebugger.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate: function() {
      var node = tr.ui.b.instantiateTemplate(
          '#tr-ui-e-chrome-cc-picture-debugger-template', THIS_DOC);

      this.appendChild(node);

      this.pictureAsImageData_ = undefined;
      this.showOverdraw_ = false;
      this.zoomScaleValue_ = 1;

      this.sizeInfo_ = this.querySelector('.size');
      this.rasterArea_ = this.querySelector('raster-area');
      this.rasterCanvas_ = this.rasterArea_.querySelector('canvas');
      this.rasterCtx_ = this.rasterCanvas_.getContext('2d');

      this.filename_ = this.querySelector('.filename');

      this.drawOpsChartSummaryView_ =
          new tr.ui.e.chrome.cc.PictureOpsChartSummaryView();
      this.drawOpsChartView_ = new tr.ui.e.chrome.cc.PictureOpsChartView();
      this.drawOpsChartView_.addEventListener(
          'selection-changed', this.onChartBarClicked_.bind(this));

      this.exportButton_ = this.querySelector('.export');
      this.exportButton_.addEventListener(
          'click', this.onSaveAsSkPictureClicked_.bind(this));

      this.trackMouse_();

      var overdrawCheckbox = tr.ui.b.createCheckBox(
          this, 'showOverdraw',
          'pictureView.showOverdraw', false,
          'Show overdraw');

      var chartCheckbox = tr.ui.b.createCheckBox(
          this, 'showSummaryChart',
          'pictureView.showSummaryChart', false,
          'Show timing summary');

      var pictureInfo = this.querySelector('picture-info');
      pictureInfo.appendChild(overdrawCheckbox);
      pictureInfo.appendChild(chartCheckbox);

      this.drawOpsView_ = new tr.ui.e.chrome.cc.PictureOpsListView();
      this.drawOpsView_.addEventListener(
          'selection-changed', this.onChangeDrawOps_.bind(this));

      var leftPanel = this.querySelector('left-panel');
      leftPanel.appendChild(this.drawOpsChartSummaryView_);
      leftPanel.appendChild(this.drawOpsView_);

      var middleDragHandle = new tr.ui.b.DragHandle();
      middleDragHandle.horizontal = false;
      middleDragHandle.target = leftPanel;

      var rightPanel = this.querySelector('right-panel');
      rightPanel.replaceChild(
          this.drawOpsChartView_,
          rightPanel.querySelector('tr-ui-e-chrome-cc-picture-ops-chart-view'));

      this.infoBar_ = document.createElement('tr-ui-b-info-bar');
      this.rasterArea_.appendChild(this.infoBar_);

      this.insertBefore(middleDragHandle, rightPanel);

      this.picture_ = undefined;

      var hkc = document.createElement('tv-ui-b-hotkey-controller');
      hkc.addHotKey(new tr.ui.b.HotKey({
        eventType: 'keypress',
        thisArg: this,
        keyCode: 'h'.charCodeAt(0),
        callback: function(e) {
          this.moveSelectedOpBy(-1);
          e.stopPropagation();
        }
      }));
      hkc.addHotKey(new tr.ui.b.HotKey({
        eventType: 'keypress',
        thisArg: this,
        keyCode: 'l'.charCodeAt(0),
        callback: function(e) {
          this.moveSelectedOpBy(1);
          e.stopPropagation();
        }
      }));
      this.appendChild(hkc);

      // Add a mutation observer so that when the view is resized we can
      // update the chart summary view.
      this.mutationObserver_ = new MutationObserver(
          this.onMutation_.bind(this));
      this.mutationObserver_.observe(leftPanel, { attributes: true });
    },

    onMutation_: function(mutations) {

      for (var m = 0; m < mutations.length; m++) {
        // A style change would indicate that the element has resized
        // so we should re-render the chart.
        if (mutations[m].attributeName === 'style') {
          this.drawOpsChartSummaryView_.requiresRedraw = true;
          this.drawOpsChartSummaryView_.updateChartContents();

          this.drawOpsChartView_.dimensionsHaveChanged = true;
          this.drawOpsChartView_.updateChartContents();
          break;
        }
      }
    },

    onSaveAsSkPictureClicked_: function() {
      // Decode base64 data into a String
      var rawData = atob(this.picture_.getBase64SkpData());

      // Convert this String into an Uint8Array
      var length = rawData.length;
      var arrayBuffer = new ArrayBuffer(length);
      var uint8Array = new Uint8Array(arrayBuffer);
      for (var c = 0; c < length; c++)
        uint8Array[c] = rawData.charCodeAt(c);

      // Create a blob URL from the binary array.
      var blob = new Blob([uint8Array], {type: 'application/octet-binary'});
      var blobUrl = window.webkitURL.createObjectURL(blob);

      // Create a link and click on it. BEST API EVAR!
      var link = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
      link.href = blobUrl;
      link.download = this.filename_.value;
      var event = document.createEvent('MouseEvents');
      event.initMouseEvent(
          'click', true, false, window, 0, 0, 0, 0, 0,
          false, false, false, false, 0, null);
      link.dispatchEvent(event);
    },

    get picture() {
      return this.picture_;
    },

    set picture(picture) {
      this.drawOpsView_.picture = picture;
      this.drawOpsChartView_.picture = picture;
      this.drawOpsChartSummaryView_.picture = picture;
      this.picture_ = picture;

      this.exportButton_.disabled = !this.picture_.canSave;

      if (picture) {
        var size = this.getRasterCanvasSize_();
        this.rasterCanvas_.width = size.width;
        this.rasterCanvas_.height = size.height;
      }

      var bounds = this.rasterArea_.getBoundingClientRect();
      var selectorBounds = this.mouseModeSelector_.getBoundingClientRect();
      this.mouseModeSelector_.pos = {
        x: (bounds.right - selectorBounds.width - 10),
        y: bounds.top
      };

      this.rasterize_();

      this.scheduleUpdateContents_();
    },

    getRasterCanvasSize_: function() {
      var style = window.getComputedStyle(this.rasterArea_);
      var width =
          Math.max(parseInt(style.width), this.picture_.layerRect.width);
      var height =
          Math.max(parseInt(style.height), this.picture_.layerRect.height);

      return {
        width: width,
        height: height
      };
    },

    scheduleUpdateContents_: function() {
      if (this.updateContentsPending_)
        return;
      this.updateContentsPending_ = true;
      tr.b.requestAnimationFrameInThisFrameIfPossible(
          this.updateContents_.bind(this)
      );
    },

    updateContents_: function() {
      this.updateContentsPending_ = false;

      if (this.picture_) {
        this.sizeInfo_.textContent = '(' +
            this.picture_.layerRect.width + ' x ' +
            this.picture_.layerRect.height + ')';
      }

      this.drawOpsChartView_.updateChartContents();
      this.drawOpsChartView_.scrollSelectedItemIntoViewIfNecessary();

      // Return if picture hasn't finished rasterizing.
      if (!this.pictureAsImageData_)
        return;

      this.infoBar_.visible = false;
      this.infoBar_.removeAllButtons();
      if (this.pictureAsImageData_.error) {
        this.infoBar_.message = 'Cannot rasterize...';
        this.infoBar_.addButton('More info...', function(e) {
          var overlay = new tr.ui.b.Overlay();
          overlay.textContent = this.pictureAsImageData_.error;
          overlay.visible = true;
          e.stopPropagation();
          return false;
        }.bind(this));
        this.infoBar_.visible = true;
      }

      this.drawPicture_();
    },

    drawPicture_: function() {
      var size = this.getRasterCanvasSize_();
      if (size.width !== this.rasterCanvas_.width)
        this.rasterCanvas_.width = size.width;
      if (size.height !== this.rasterCanvas_.height)
        this.rasterCanvas_.height = size.height;

      this.rasterCtx_.clearRect(0, 0, size.width, size.height);

      if (!this.pictureAsImageData_.imageData)
        return;

      var imgCanvas = this.pictureAsImageData_.asCanvas();
      var w = imgCanvas.width;
      var h = imgCanvas.height;
      this.rasterCtx_.drawImage(imgCanvas, 0, 0, w, h,
                                0, 0, w * this.zoomScaleValue_,
                                h * this.zoomScaleValue_);
    },

    rasterize_: function() {
      if (this.picture_) {
        this.picture_.rasterize(
            {
              stopIndex: this.drawOpsView_.selectedOpIndex,
              showOverdraw: this.showOverdraw_
            },
            this.onRasterComplete_.bind(this));
      }
    },

    onRasterComplete_: function(pictureAsImageData) {
      this.pictureAsImageData_ = pictureAsImageData;
      this.scheduleUpdateContents_();
    },

    moveSelectedOpBy: function(increment) {
      if (this.selectedOpIndex === undefined) {
        this.selectedOpIndex = 0;
        return;
      }
      this.selectedOpIndex = tr.b.clamp(
          this.selectedOpIndex + increment,
          0, this.numOps);
    },

    get numOps() {
      return this.drawOpsView_.numOps;
    },

    get selectedOpIndex() {
      return this.drawOpsView_.selectedOpIndex;
    },

    set selectedOpIndex(index) {
      this.drawOpsView_.selectedOpIndex = index;
      this.drawOpsChartView_.selectedOpIndex = index;
    },

    onChartBarClicked_: function(e) {
      this.drawOpsView_.selectedOpIndex =
          this.drawOpsChartView_.selectedOpIndex;
    },

    onChangeDrawOps_: function(e) {
      this.rasterize_();
      this.scheduleUpdateContents_();

      this.drawOpsChartView_.selectedOpIndex =
          this.drawOpsView_.selectedOpIndex;
    },

    set showOverdraw(v) {
      this.showOverdraw_ = v;
      this.rasterize_();
    },

    set showSummaryChart(chartShouldBeVisible) {
      if (chartShouldBeVisible)
        this.drawOpsChartSummaryView_.show();
      else
        this.drawOpsChartSummaryView_.hide();
    },

    trackMouse_: function() {
      this.mouseModeSelector_ = document.createElement(
          'tr-ui-b-mouse-mode-selector');
      this.mouseModeSelector_.targetElement = this.rasterArea_;
      this.rasterArea_.appendChild(this.mouseModeSelector_);

      this.mouseModeSelector_.supportedModeMask =
          tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.mode = tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.defaultMode = tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.settingsKey = 'pictureDebugger.mouseModeSelector';

      this.mouseModeSelector_.addEventListener('beginzoom',
          this.onBeginZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('updatezoom',
          this.onUpdateZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('endzoom',
          this.onEndZoom_.bind(this));
    },

    onBeginZoom_: function(e) {
      this.isZooming_ = true;

      this.lastMouseViewPos_ = this.extractRelativeMousePosition_(e);

      e.preventDefault();
    },

    onUpdateZoom_: function(e) {
      if (!this.isZooming_)
        return;

      var currentMouseViewPos = this.extractRelativeMousePosition_(e);

      // Take the distance the mouse has moved and we want to zoom at about
      // 1/1000th of that speed. 0.01 feels jumpy. This could possibly be tuned
      // more if people feel it's too slow.
      this.zoomScaleValue_ +=
          ((this.lastMouseViewPos_.y - currentMouseViewPos.y) * 0.001);
      this.zoomScaleValue_ = Math.max(this.zoomScaleValue_, 0.1);

      this.drawPicture_();

      this.lastMouseViewPos_ = currentMouseViewPos;
    },

    onEndZoom_: function(e) {
      this.lastMouseViewPos_ = undefined;
      this.isZooming_ = false;
      e.preventDefault();
    },

    extractRelativeMousePosition_: function(e) {
      return {
        x: e.clientX - this.rasterArea_.offsetLeft,
        y: e.clientY - this.rasterArea_.offsetTop
      };
    }
  };

  return {
    PictureDebugger: PictureDebugger
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /*
   * Displays a picture snapshot in a human readable form.
   * @constructor
   */
  var PictureSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-picture-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  PictureSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate: function() {
      this.classList.add('tr-ui-e-chrome-cc-picture-snapshot-view');
      this.pictureDebugger_ = new tr.ui.e.chrome.cc.PictureDebugger();
      this.appendChild(this.pictureDebugger_);
    },

    updateContents: function() {
      if (this.objectSnapshot_ && this.pictureDebugger_)
        this.pictureDebugger_.picture = this.objectSnapshot_;
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      PictureSnapshotView,
      {
        typeNames: ['cc::Picture', 'cc::LayeredPicture'],
        showInstances: false
      });

  return {
    PictureSnapshotView: PictureSnapshotView
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {

  var knownRasterTaskNames = [
      'TileManager::RunRasterTask',
      'RasterWorkerPoolTaskImpl::RunRasterOnThread',
      'RasterWorkerPoolTaskImpl::Raster',
      'RasterTaskImpl::Raster',
      'cc::RasterTask',
      'RasterTask'
  ];

  var knownAnalysisTaskNames = [
      'TileManager::RunAnalyzeTask',
      'RasterWorkerPoolTaskImpl::RunAnalysisOnThread',
      'RasterWorkerPoolTaskImpl::Analyze',
      'RasterTaskImpl::Analyze',
      'cc::AnalyzeTask',
      'AnalyzeTask'
  ];

  function getTileFromRasterTaskSlice(slice) {
    if (!(isSliceDoingRasterization(slice) || isSliceDoingAnalysis(slice)))
      return undefined;

    var tileData;
    if (slice.args.data)
      tileData = slice.args.data;
    else
      tileData = slice.args.tileData;
    if (tileData === undefined)
      return undefined;
    if (tileData.tile_id)
      return tileData.tile_id;

    var tile = tileData.tileId;
    if (!(tile instanceof tr.e.cc.TileSnapshot))
      return undefined;
    return tileData.tileId;
  }

  function isSliceDoingRasterization(slice) {
    if (knownRasterTaskNames.indexOf(slice.title) !== -1)
      return true;
    return false;
  }

  function isSliceDoingAnalysis(slice) {
    if (knownAnalysisTaskNames.indexOf(slice.title) !== -1)
      return true;
    return false;
  }

  return {
    getTileFromRasterTaskSlice: getTileFromRasterTaskSlice,
    isSliceDoingRasterization: isSliceDoingRasterization,
    isSliceDoingAnalysis: isSliceDoingAnalysis
  };
});


  'use strict';
  Polymer('tr-ui-e-chrome-cc-raster-task-view', {
    created: function() {
      this.selection_ = undefined;
    },

    set selection(selection) {
      this.selection_ = selection;

      this.updateContents_();
    },

    updateColumns_: function(hadCpuDurations) {
      var timeSpanConfig = {ownerDocument: this.ownerDocument};

      var columns = [
        {
          title: 'Layer',
          value: function(row) {
            if (row.isTotals)
              return 'Totals';
            if (row.layer) {
              var linkEl = document.createElement('tr-ui-a-analysis-link');
              linkEl.setSelectionAndContent(
                function() {
                  return new tr.ui.e.chrome.cc.LayerSelection(costs.layer);
                },
                'Layer ' + row.layerId);
              return linkEl;
            } else {
              return 'Layer ' + row.layerId;
            }
          },
          width: '250px'
        },
        {
          title: 'Num Tiles',
          value: function(row) { return row.numTiles; },
          cmp: function(a, b) { return a.numTiles - b.numTiles; }
        },
        {
          title: 'Num Analysis Tasks',
          value: function(row) { return row.numAnalysisTasks; },
          cmp: function(a, b) {
            return a.numAnalysisTasks - b.numAnalysisTasks;
          }
        },
        {
          title: 'Num Raster Tasks',
          value: function(row) { return row.numRasterTasks; },
          cmp: function(a, b) { return a.numRasterTasks - b.numRasterTasks; }
        },
        {
          title: 'Wall Duration (ms)',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(
                row.duration, timeSpanConfig);
          },
          cmp: function(a, b) { return a.duration - b.duration; }
        }
      ];

      if (hadCpuDurations) {
        columns.push({
          title: 'CPU Duration (ms)',
          value: function(row) {
            return tr.ui.units.createTimeDurationSpan(
                row.duration, timeSpanConfig);
          },
          cmp: function(a, b) { return a.cpuDuration - b.cpuDuration; }
        });
      }

      var colWidthPercentage;
      if (columns.length == 1)
        colWidthPercentage = '100%';
      else
        colWidthPercentage = (100 / (columns.length - 1)).toFixed(3) + '%';

      for (var i = 1; i < columns.length; i++)
        columns[i].width = colWidthPercentage;

      this.$.content.tableColumns = columns;
      this.$.content.sortColumnIndex = columns.length - 1;
    },

    updateContents_: function() {
      var table = this.$.content;

      if (this.selection_.length === 0) {
        this.$.link.setSelectionAndContent(undefined, '');
        table.tableRows = [];
        table.footerRows = [];
        table.rebuild();
        return;
      }

            var lthi = tr.e.cc.getTileFromRasterTaskSlice(
          this.selection_[0]).containingSnapshot;
      this.$.link.setSelectionAndContent(function() {
          return new tr.model.EventSet(lthi);
      }, lthi.userFriendlyName);

            var costsByLayerId = {};
      function getCurrentCostsForLayerId(tile) {
        var layerId = tile.layerId;
        var lthi = tile.containingSnapshot;
        var layer;
        if (lthi.activeTree)
          layer = lthi.activeTree.findLayerWithId(layerId);
        if (layer === undefined && lthi.pendingTree)
          layer = lthi.pendingTree.findLayerWithId(layerId);
        if (costsByLayerId[layerId] === undefined) {
          costsByLayerId[layerId] = {
            layerId: layerId,
            layer: layer,
            numTiles: 0,
            numAnalysisTasks: 0,
            numRasterTasks: 0,
            duration: 0,
            cpuDuration: 0
          };
        }
        return costsByLayerId[layerId];
      }

      var totalDuration = 0;
      var totalCpuDuration = 0;
      var totalNumAnalyzeTasks = 0;
      var totalNumRasterizeTasks = 0;
      var hadCpuDurations = false;

      var tilesThatWeHaveSeen = {};

      this.selection_.forEach(function(slice) {
        var tile = tr.e.cc.getTileFromRasterTaskSlice(slice);
        var curCosts = getCurrentCostsForLayerId(tile);

        if (!tilesThatWeHaveSeen[tile.objectInstance.id]) {
          tilesThatWeHaveSeen[tile.objectInstance.id] = true;
          curCosts.numTiles += 1;
        }

        if (tr.e.cc.isSliceDoingAnalysis(slice)) {
          curCosts.numAnalysisTasks += 1;
          totalNumAnalyzeTasks += 1;
        } else {
          curCosts.numRasterTasks += 1;
          totalNumRasterizeTasks += 1;
        }
        curCosts.duration += slice.duration;
        totalDuration += slice.duration;
        if (slice.cpuDuration !== undefined) {
          curCosts.cpuDuration += slice.cpuDuration;
          totalCpuDuration += slice.cpuDuration;
          hadCpuDurations = true;
        }
      });

            this.updateColumns_(hadCpuDurations);
      table.tableRows = tr.b.dictionaryValues(costsByLayerId);
      table.rebuild();

            table.footerRows = [
        {
          isTotals: true,
          numTiles: tr.b.dictionaryLength(tilesThatWeHaveSeen),
          numAnalysisTasks: totalNumAnalyzeTasks,
          numRasterTasks: totalNumRasterizeTasks,
          duration: totalDuration,
          cpuDuration: totalCpuDuration
        }
      ];
    }
  });
  

'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /**
   * @constructor
   */
  function RasterTaskSelection(selection) {
    tr.ui.e.chrome.cc.Selection.call(this);
    var whySupported = RasterTaskSelection.whySuported(selection);
    if (!whySupported.ok)
      throw new Error('Fail: ' + whySupported.why);
    this.slices_ = tr.b.asArray(selection);
    this.tiles_ = this.slices_.map(function(slice) {
      var tile = tr.e.cc.getTileFromRasterTaskSlice(slice);
      if (tile === undefined)
        throw new Error('This should never happen due to .supports check.');
      return tile;
    });
  }
  RasterTaskSelection.whySuported = function(selection) {
    if (!(selection instanceof tr.model.EventSet))
      return {ok: false, why: 'Must be selection'};

    if (selection.length === 0)
      return {ok: false, why: 'Selection must be non empty'};

    var tile0;
    for (var i = 0; i < selection.length; i++) {
      var event = selection[i];
      if (!(event instanceof tr.model.Slice))
        return {ok: false, why: 'Not a slice'};

      var tile = tr.e.cc.getTileFromRasterTaskSlice(selection[i]);
      if (tile === undefined)
        return {ok: false, why: 'No tile found'};

      if (i === 0) {
        tile0 = tile;
      } else {
        if (tile.containingSnapshot != tile0.containingSnapshot) {
          return {
            ok: false,
            why: 'Raster tasks are from different compositor instances'
          };
        }
      }
    }
    return {ok: true};
  }

  RasterTaskSelection.supports = function(selection) {
    return RasterTaskSelection.whySuported(selection).ok;
  };

  RasterTaskSelection.prototype = {
    __proto__: tr.ui.e.chrome.cc.Selection.prototype,

    get specicifity() {
      return 3;
    },

    get associatedLayerId() {
      var tile0 = this.tiles_[0];
      var allSameLayer = this.tiles_.every(function(tile) {
        tile.layerId == tile0.layerId;
      });
      if (allSameLayer)
        return tile0.layerId;
      return undefined;
    },

    get extraHighlightsByLayerId() {
      var highlights = {};
      this.tiles_.forEach(function(tile, i) {
        if (highlights[tile.layerId] === undefined)
          highlights[tile.layerId] = [];
        var slice = this.slices_[i];
        highlights[tile.layerId].push({
          colorKey: slice.title,
          rect: tile.layerRect
        });
      }, this);
      return highlights;
    },

    createAnalysis: function() {
      var sel = new tr.model.EventSet();
      this.slices_.forEach(function(slice) {
        sel.push(slice);
      });

      var analysis;
      if (sel.length == 1)
        analysis = document.createElement('tr-ui-a-single-event-sub-view');
      else
        analysis = document.createElement('tr-ui-e-chrome-cc-raster-task-view');
      analysis.selection = sel;
      return analysis;
    },

    findEquivalent: function(lthi) {
      // Raster tasks are only valid in one LTHI.
      return undefined;
    },

    // RasterTaskSelection specific stuff follows.
    get containingSnapshot() {
      return this.tiles_[0].containingSnapshot;
    }
  };

  return {
    RasterTaskSelection: RasterTaskSelection
  };
});



'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /*
   * Displays a tile in a human readable form.
   * @constructor
   */
  var TileSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-tile-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  TileSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate: function() {
      this.classList.add('tr-ui-e-chrome-cc-tile-snapshot-view');
      this.layerTreeView_ =
          new tr.ui.e.chrome.cc.LayerTreeHostImplSnapshotView();
      this.appendChild(this.layerTreeView_);
    },

    updateContents: function() {
      var tile = this.objectSnapshot_;
      var layerTreeHostImpl = tile.containingSnapshot;
      if (!layerTreeHostImpl)
        return;

      this.layerTreeView_.objectSnapshot = layerTreeHostImpl;
      this.layerTreeView_.selection = new tr.ui.e.chrome.cc.TileSelection(tile);
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      TileSnapshotView,
      {
        typeName: 'cc::Tile',
        showInTrackView: false
      });

  return {
    TileSnapshotView: TileSnapshotView
  };
});


'use strict';

tr.exportTo('tr.e.gpu', function() {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function StateSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  StateSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize: function() {
      this.screenshot_ = undefined;
    },

    initialize: function() {
      if (this.args.screenshot)
        this.screenshot_ = this.args.screenshot;
    },

    /**
     * @return {String} a base64 encoded screenshot if available.
     */
    get screenshot() {
      return this.screenshot_;
    }
  };

  ObjectSnapshot.register(
    StateSnapshot,
    {typeName: 'gpu::State'});

  return {
    StateSnapshot: StateSnapshot
  };
});


'use strict';

tr.exportTo('tr.e.gpu', function() {
  var AsyncSlice = tr.model.AsyncSlice;

  function GpuAsyncSlice() {
    AsyncSlice.apply(this, arguments);
  }

  GpuAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    get viewSubGroupTitle() {
      if (this.args.channel) {
        if (this.category == 'disabled-by-default-gpu.device')
          return 'Device.' + this.args.channel;
        else
          return 'Service.' + this.args.channel;
      }
      return this.title;
    }
  };

  AsyncSlice.register(
    GpuAsyncSlice,
    {
      categoryParts: ['disabled-by-default-gpu.device',
                      'disabled-by-default-gpu.service']
    });

  return {
    GpuAsyncSlice: GpuAsyncSlice
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.gpu', function() {
  /*
   * Displays a GPU state snapshot in a human readable form.
   * @constructor
   */
  var StateSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-gpu-state-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  StateSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate: function() {
      this.classList.add('tr-ui-e-chrome-gpu-state-snapshot-view');
      this.screenshotImage_ = document.createElement('img');
      this.appendChild(this.screenshotImage_);
    },

    updateContents: function() {
      if (this.objectSnapshot_ && this.objectSnapshot_.screenshot) {
        this.screenshotImage_.src = 'data:image/png;base64,' +
            this.objectSnapshot_.screenshot;
      }
    }
  };
  tr.ui.analysis.ObjectSnapshotView.register(
    StateSnapshotView,
    {typeName: 'gpu::State'});

  return {
    StateSnapshotView: StateSnapshotView
  };
});


'use strict';

tr.exportTo('tr.e.system_stats', function() {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function SystemStatsSnapshot(objectInstance, ts, args) {
    ObjectSnapshot.apply(this, arguments);
    this.objectInstance = objectInstance;
    this.ts = ts;
    this.args = args;
    this.stats = args;
  }

  SystemStatsSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    initialize: function() {
      if (this.args.length == 0)
        throw new Error('No system stats snapshot data.');
      this.stats_ = this.args;
    },

    getStats: function() {
      return this.stats_;
    },

    setStats: function(stats) {
      this.stats_ = stats;
    }
  };

  ObjectSnapshot.register(
    SystemStatsSnapshot,
    {typeName: 'base::TraceEventSystemStatsMonitor::SystemStats'});

  return {
    SystemStatsSnapshot: SystemStatsSnapshot
  };
});


'use strict';

tr.exportTo('tr.ui.e.system_stats', function() {
  /*
   * Displays a system stats snapshot in a human readable form. @constructor
   */
  var SystemStatsSnapshotView = tr.ui.b.define(
      'tr-ui-e-system-stats-snapshot-view', tr.ui.analysis.ObjectSnapshotView);

  SystemStatsSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate: function() {
      this.classList.add('tr-ui-e-system-stats-snapshot-view');
    },

    updateContents: function() {
      var snapshot = this.objectSnapshot_;
      if (!snapshot || !snapshot.getStats()) {
        this.textContent = 'No system stats snapshot found.';
        return;
      }
      // Clear old snapshot view.
      this.textContent = '';

      var stats = snapshot.getStats();
      this.appendChild(this.buildList_(stats));
    },

    isFloat: function(n) {
      return typeof n === 'number' && n % 1 !== 0;
    },

    /**
     * Creates nested lists.
     *
     * @param {Object} stats The current trace system stats entry.
     * @return {Element} A ul list element.
     */
    buildList_: function(stats) {
      var statList = document.createElement('ul');

      for (var statName in stats) {
        var statText = document.createElement('li');
        statText.textContent = '' + statName + ': ';
        statList.appendChild(statText);

        if (stats[statName] instanceof Object) {
          statList.appendChild(this.buildList_(stats[statName]));
        } else {
          if (this.isFloat(stats[statName]))
            statText.textContent += stats[statName].toFixed(2);
          else
            statText.textContent += stats[statName];
        }
      }

      return statList;
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      SystemStatsSnapshotView,
      {typeName: 'base::TraceEventSystemStatsMonitor::SystemStats'});

  return {
    SystemStatsSnapshotView: SystemStatsSnapshotView
  };

});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays traces as stacked bars.
   * @constructor
   * @extends {Track}
   */
  var StackedBarsTrack = tr.ui.b.define(
      'stacked-bars-track', tr.ui.tracks.Track);

  StackedBarsTrack.prototype = {

    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      this.classList.add('stacked-bars-track');
      this.objectInstance_ = null;

      this.heading_ = document.createElement('tr-ui-heading');
      this.appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    addEventsToTrackMap: function(eventToTrackMap) {
      var objectSnapshots = this.objectInstance_.snapshots;
      objectSnapshots.forEach(function(obj) {
        eventToTrackMap.addEvent(obj, this);
      }, this);
    },

    /**
     * Used to hit-test clicks in the graph.
     */
    addIntersectingEventsInRangeToSelectionInWorldSpace: function(
        loWX, hiWX, viewPixWidthWorld, selection) {
      function onSnapshot(snapshot) {
        selection.push(snapshot);
      }

      var snapshots = this.objectInstance_.snapshots;
      var maxBounds = this.objectInstance_.parent.model.bounds.max;

      tr.b.iterateOverIntersectingIntervals(
          snapshots,
          function(x) { return x.ts; },
          function(x, i) {
            if (i == snapshots.length - 1) {
              if (snapshots.length == 1)
                return maxBounds;

              return snapshots[i].ts - snapshots[i - 1].ts;
            }

            return snapshots[i + 1].ts - snapshots[i].ts;
          },
          loWX, hiWX,
          onSnapshot);
    },

    /**
     * Add the item to the left or right of the provided item, if any, to the
     * selection.
     * @param {slice} The current slice.
     * @param {Number} offset Number of slices away from the object to look.
     * @param {Selection} selection The selection to add an event to,
     * if found.
     * @return {boolean} Whether an event was found.
     * @private
     */
    addEventNearToProvidedEventToSelection: function(event, offset, selection) {
      if (!(event instanceof tr.model.ObjectSnapshot))
        throw new Error('Unrecognized event');
      var objectSnapshots = this.objectInstance_.snapshots;
      var index = objectSnapshots.indexOf(event);
      var newIndex = index + offset;
      if (newIndex >= 0 && newIndex < objectSnapshots.length) {
        selection.push(objectSnapshots[newIndex]);
        return true;
      }
      return false;
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
    },

    addClosestEventToSelection: function(worldX, worldMaxDist, loY, hiY,
                                         selection) {
      var snapshot = tr.b.findClosestElementInSortedArray(
          this.objectInstance_.snapshots,
          function(x) { return x.ts; },
          worldX,
          worldMaxDist);

      if (!snapshot)
        return;

      selection.push(snapshot);
    }
  };

  return {
    StackedBarsTrack: StackedBarsTrack
  };
});


'use strict';

tr.exportTo('tr.ui.e.system_stats', function() {
  var EventPresenter = tr.ui.b.EventPresenter;

  var palette = tr.ui.b.getColorPalette();
  var highlightIdBoost = tr.ui.b.getColorPaletteHighlightIdBoost();

  var statCount;

  var excludedStats = {'meminfo': {
                        'pswpin': 0,
                        'pswpout': 0,
                        'pgmajfault': 0},
                      'diskinfo': {
                        'io': 0,
                        'io_time': 0,
                        'read_time': 0,
                        'reads': 0,
                        'reads_merged': 0,
                        'sectors_read': 0,
                        'sectors_written': 0,
                        'weighted_io_time': 0,
                        'write_time': 0,
                        'writes': 0,
                        'writes_merged': 0},
                      'swapinfo': {}
                      };

  /**
   * Tracks that display system stats data.
   *
   * @constructor
   * @extends {StackedBarsTrack}
   */

  var SystemStatsInstanceTrack = tr.ui.b.define(
      'tr-ui-e-system-stats-instance-track', tr.ui.tracks.StackedBarsTrack);

  SystemStatsInstanceTrack.prototype = {

    __proto__: tr.ui.tracks.StackedBarsTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.StackedBarsTrack.prototype.decorate.call(this, viewport);
      this.classList.add('tr-ui-e-system-stats-instance-track');
      this.objectInstance_ = null;
    },

    set objectInstances(objectInstances) {
      if (!objectInstances) {
        this.objectInstance_ = [];
        return;
      }
      if (objectInstances.length != 1)
        throw new Error('Bad object instance count.');
      this.objectInstance_ = objectInstances[0];
      if (this.objectInstance_ !== null) {
        this.computeRates_(this.objectInstance_.snapshots);
        this.maxStats_ = this.computeMaxStats_(
            this.objectInstance_.snapshots);
      }
    },

    computeRates_: function(snapshots) {
      for (var i = 0; i < snapshots.length; i++) {
        var snapshot = snapshots[i];
        var stats = snapshot.getStats();
        var prevSnapshot;
        var prevStats;

        if (i == 0) {
          // Deltas will be zero.
          prevSnapshot = snapshots[0];
        } else {
          prevSnapshot = snapshots[i - 1];
        }
        prevStats = prevSnapshot.getStats();
        var timeIntervalSeconds = (snapshot.ts - prevSnapshot.ts) / 1000;
        // Prevent divide by zero.
        if (timeIntervalSeconds == 0)
          timeIntervalSeconds = 1;

        this.computeRatesRecursive_(prevStats, stats,
                                    timeIntervalSeconds);
      }
    },

    computeRatesRecursive_: function(prevStats, stats,
                                     timeIntervalSeconds) {
      for (var statName in stats) {
        if (stats[statName] instanceof Object) {
          this.computeRatesRecursive_(prevStats[statName],
                                      stats[statName],
                                      timeIntervalSeconds);
        } else {
          if (statName == 'sectors_read') {
            stats['bytes_read_per_sec'] = (stats['sectors_read'] -
                                           prevStats['sectors_read']) *
                                          512 / timeIntervalSeconds;
          }
          if (statName == 'sectors_written') {
            stats['bytes_written_per_sec'] =
                (stats['sectors_written'] -
                 prevStats['sectors_written']) *
                512 / timeIntervalSeconds;
          }
          if (statName == 'pgmajfault') {
            stats['pgmajfault_per_sec'] = (stats['pgmajfault'] -
                                           prevStats['pgmajfault']) /
                                          timeIntervalSeconds;
          }
          if (statName == 'pswpin') {
            stats['bytes_swpin_per_sec'] = (stats['pswpin'] -
                                            prevStats['pswpin']) *
                                           1000 / timeIntervalSeconds;
          }
          if (statName == 'pswpout') {
            stats['bytes_swpout_per_sec'] = (stats['pswpout'] -
                                             prevStats['pswpout']) *
                                            1000 / timeIntervalSeconds;
          }
        }
      }
    },

    computeMaxStats_: function(snapshots) {
      var maxStats = new Object();
      statCount = 0;

      for (var i = 0; i < snapshots.length; i++) {
        var snapshot = snapshots[i];
        var stats = snapshot.getStats();

        this.computeMaxStatsRecursive_(stats, maxStats,
                                       excludedStats);
      }

      return maxStats;
    },

    computeMaxStatsRecursive_: function(stats, maxStats, excludedStats) {
      for (var statName in stats) {
        if (stats[statName] instanceof Object) {
          if (!(statName in maxStats))
            maxStats[statName] = new Object();

          var excludedNested;
          if (excludedStats && statName in excludedStats)
            excludedNested = excludedStats[statName];
          else
            excludedNested = null;

          this.computeMaxStatsRecursive_(stats[statName],
                                         maxStats[statName],
                                         excludedNested);
        } else {
          if (excludedStats && statName in excludedStats)
            continue;
          if (!(statName in maxStats)) {
            maxStats[statName] = 0;
            statCount++;
          }
          if (stats[statName] > maxStats[statName])
            maxStats[statName] = stats[statName];
        }
      }
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
    },

    draw: function(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawStatBars_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawStatBars_: function(viewLWorld, viewRWorld) {
      var ctx = this.context();
      var pixelRatio = window.devicePixelRatio || 1;

      var bounds = this.getBoundingClientRect();
      var width = bounds.width * pixelRatio;
      var height = (bounds.height * pixelRatio) / statCount;

      // Culling parameters.
      var vp = this.viewport.currentDisplayTransform;

      // Scale by the size of the largest snapshot.
      var maxStats = this.maxStats_;

      var objectSnapshots = this.objectInstance_.snapshots;
      var lowIndex = tr.b.findLowIndexInSortedArray(
          objectSnapshots,
          function(snapshot) {
            return snapshot.ts;
          },
          viewLWorld);

      // Assure that the stack with the left edge off screen still gets drawn
      if (lowIndex > 0)
        lowIndex -= 1;

      for (var i = lowIndex; i < objectSnapshots.length; ++i) {
        var snapshot = objectSnapshots[i];
        var trace = snapshot.getStats();
        var currentY = height;

        var left = snapshot.ts;
        if (left > viewRWorld)
          break;
        var leftView = vp.xWorldToView(left);
        if (leftView < 0)
          leftView = 0;

        // Compute the edges for the column graph bar.
        var right;
        if (i != objectSnapshots.length - 1) {
          right = objectSnapshots[i + 1].ts;
        } else {
          // If this is the last snaphot of multiple snapshots, use the width of
          // the previous snapshot for the width.
          if (objectSnapshots.length > 1)
            right = objectSnapshots[i].ts + (objectSnapshots[i].ts -
                    objectSnapshots[i - 1].ts);
          else
            // If there's only one snapshot, use max bounds as the width.
            right = this.objectInstance_.parent.model.bounds.max;
        }

        var rightView = vp.xWorldToView(right);
        if (rightView > width)
          rightView = width;

        // Floor the bounds to avoid a small gap between stacks.
        leftView = Math.floor(leftView);
        rightView = Math.floor(rightView);

        // Descend into nested stats.
        this.drawStatBarsRecursive_(snapshot,
                                    leftView,
                                    rightView,
                                    height,
                                    trace,
                                    maxStats,
                                    currentY);

        if (i == lowIndex)
          this.drawStatNames_(leftView, height, currentY, '', maxStats);
      }
      ctx.lineWidth = 1;
    },

    drawStatBarsRecursive_: function(snapshot,
                                     leftView,
                                     rightView,
                                     height,
                                     stats,
                                     maxStats,
                                     currentY) {
      var ctx = this.context();

      for (var statName in maxStats) {
        if (stats[statName] instanceof Object) {
          // Use the y-position returned from the recursive call.
          currentY = this.drawStatBarsRecursive_(snapshot,
                                                 leftView,
                                                 rightView,
                                                 height,
                                                 stats[statName],
                                                 maxStats[statName],
                                                 currentY);
        } else {
          var maxStat = maxStats[statName];

          // Draw a bar for the stat. The height of the bar is scaled
          // against the largest value of the stat across all snapshots.
          ctx.fillStyle = EventPresenter.getBarSnapshotColor(
              snapshot, Math.round(currentY / height));

          var barHeight;

          if (maxStat > 0) {
            barHeight = height * Math.max(stats[statName], 0) / maxStat;
          } else {
            barHeight = 0;
          }

          ctx.fillRect(leftView, currentY - barHeight,
                       Math.max(rightView - leftView, 1), barHeight);

          currentY += height;
        }
      }

      // Return the updated y-position.
      return currentY;
    },

    drawStatNames_: function(leftView, height, currentY, prefix, maxStats) {
      var ctx = this.context();

      ctx.textAlign = 'end';
      ctx.font = '12px Arial';
      ctx.fillStyle = '#000000';
      for (var statName in maxStats) {
        if (maxStats[statName] instanceof Object) {
          currentY = this.drawStatNames_(leftView, height, currentY,
                                         statName, maxStats[statName]);
        } else {
          var fullname = statName;

          if (prefix != '')
            fullname = prefix + ' :: ' + statName;

          ctx.fillText(fullname, leftView - 10, currentY - height / 4);
          currentY += height;
        }
      }

      return currentY;
    }
  };

  tr.ui.tracks.ObjectInstanceTrack.register(
      SystemStatsInstanceTrack,
      {typeName: 'base::TraceEventSystemStatsMonitor::SystemStats'});

  return {
    SystemStatsInstanceTrack: SystemStatsInstanceTrack
  };
});


'use strict';

tr.exportTo('tr.e.tcmalloc', function() {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function HeapSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  HeapSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize: function() {
      tr.e.cc.preInitializeObject(this);
    },

    // TODO(jamescook): This seems to be called before the green dot is clicked.
    // Consider doing it in heap_view.js.
    initialize: function() {
      if (this.args.length == 0)
        throw new Error('No heap snapshot data.');

      // The first entry is total allocations across all stack traces.
      this.total_ = this.args[0];
      // The rest is a list of allocations.
      var allocs = this.args.slice(1);

      // Build a nested dictionary of trace event names.
      this.heap_ = {
        children: {},
        currentBytes: 0,
        currentAllocs: 0,
        totalBytes: 0,
        totalAllocs: 0
      };
      for (var i = 0; i < allocs.length; i++) {
        var alloc = allocs[i];
        var traceNames = alloc.trace.split(' ');
        // We don't want to record allocations caused by the heap profiling
        // system itself, so skip allocations with this special name.
        if (traceNames.indexOf('trace-memory-ignore') != -1)
          continue;
        var heapEntry = this.heap_;
        // Walk down into the heap of stack traces.
        for (var j = 0; j < traceNames.length; j++) {
          // Look for existing children with this trace.
          var traceName = traceNames[j];
          // The empty trace name means "(here)", so don't roll those up into
          // parent traces because they have already been counted.
          if (traceName.length != 0) {
            // Add up the total memory for intermediate entries, so the top of
            // each subtree is the total memory for that tree.
            heapEntry.currentBytes += alloc.currentBytes;
            heapEntry.currentAllocs += alloc.currentAllocs;
            heapEntry.totalBytes += alloc.totalBytes;
            heapEntry.totalAllocs += alloc.totalAllocs;
          }
          if (!heapEntry.children[traceName]) {
            // New trace entry at this depth, so create a child for it.
            heapEntry.children[traceName] = {
              children: {},
              currentBytes: alloc.currentBytes,
              currentAllocs: alloc.currentAllocs,
              totalBytes: alloc.totalBytes,
              totalAllocs: alloc.totalAllocs
            };
          }
          // Descend into the children.
          heapEntry = heapEntry.children[traceName];
        }
      }
    }

  };

  ObjectSnapshot.register(
    HeapSnapshot,
    {typeName: 'memory::Heap'});

  return {
    HeapSnapshot: HeapSnapshot
  };
});


'use strict';

tr.exportTo('tr.ui.e.tcmalloc', function() {
  /**
   * Displays tcmalloc heap memory information over time. A tcmalloc instance
   * has multiple snapshots.
   * @constructor
   */
  var TcmallocInstanceView = tr.ui.b.define(
      'tr-ui-e-tcmalloc-instance-view', tr.ui.analysis.ObjectInstanceView);

  TcmallocInstanceView.prototype = {
    __proto__: tr.ui.analysis.ObjectInstanceView.prototype,

    decorate: function() {
      tr.ui.analysis.ObjectInstanceView.prototype.decorate.apply(this);
      this.classList.add('tr-ui-e-tcmalloc-instance-view');
    },

    updateContents: function() {
      var instance = this.objectInstance_;
      if (!instance || !instance.snapshots || instance.snapshots.length == 0) {
        this.textContent = 'No data found.';
        return;
      }
      // Clear old view.
      this.textContent = '';

      // First, grab the largest N traces from the first snapshot.
      var snapshot = instance.snapshots[0];
      var heapEntry = snapshot.heap_;
      var traceNames = Object.keys(heapEntry.children);
      traceNames.sort(function(a, b) {
        // Sort from large to small.
        return heapEntry.children[b].currentBytes -
            heapEntry.children[a].currentBytes;
      });
      // Only use the largest 5 traces to start
      traceNames = traceNames.slice(0, 5);

      var table = document.createElement('table');
      var titles = ['Total'];
      titles = titles.concat(traceNames);
      table.appendChild(this.buildRow_(null, titles));

      // One array per trace name.
      var chartArrays = [[], [], [], [], []];
      for (var i = 0; i < instance.snapshots.length; i++) {
        var snapshot = instance.snapshots[i];
        var rowData = [snapshot.total_.currentBytes];
        for (var j = 0; j < 5; j++) {
          var bytes = snapshot.heap_.children[traceNames[j]].currentBytes;
          rowData.push(bytes);
          // Associate a megabyte count with a time in seconds.
          chartArrays[j].push(
              [Math.round(snapshot.ts / 1000), bytes / 1024 / 1024]);
        }
        var row = this.buildRow_(snapshot, rowData);
        table.appendChild(row);
      }
      this.appendChild(table);
    },

    buildRow_: function(snapshot, items) {
      var row = document.createElement('tr');
      var td = document.createElement('td');
      if (snapshot) {
        var snapshotLink = document.createElement('tr-ui-a-analysis-link');
        snapshotLink.selection = new tr.model.EventSet(snapshot);
        td.appendChild(snapshotLink);
      }
      row.appendChild(td);
      for (var i = 0; i < items.length; i++) {
        var data = document.createElement('td');
        data.textContent = items[i];
        row.appendChild(data);
      }
      return row;
    },

    /*
     * Returns a human readable string for a size in bytes.
     */
    getByteString_: function(bytes) {
      var mb = bytes / 1024 / 1024;
      return mb.toFixed(1) + ' MB';
    }
  };

  tr.ui.analysis.ObjectInstanceView.register(
      TcmallocInstanceView,
      {typeName: 'memory::Heap'});

  return {
    TcmallocInstanceView: TcmallocInstanceView
  };

});


'use strict';

tr.exportTo('tr.ui.e.tcmalloc', function() {
  /*
   * Displays a heap memory snapshot in a human readable form.
   * @constructor
   */
  var TcmallocSnapshotView = tr.ui.b.define(
      'tr-ui-e-tcmalloc-heap-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  TcmallocSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate: function() {
      this.classList.add('tr-ui-e-tcmalloc-heap-snapshot-view');
    },

    updateContents: function() {
      var snapshot = this.objectSnapshot_;
      if (!snapshot || !snapshot.heap_) {
        this.textContent = 'No heap found.';
        return;
      }
      // Clear old snapshot view.
      this.textContent = '';

      // Note: "total" may actually be less than the largest allocation bin.
      // This might happen if one stack is doing a lot of allocation, then
      // passing off to another stack for deallocation.  That stack will
      // have a high "current bytes" count and the other one might be
      // negative or zero. So "total" may be smaller than the largest trace.
      var subhead = document.createElement('div');
      subhead.textContent = 'Retaining ' +
          this.getByteString_(snapshot.total_.currentBytes) + ' in ' +
          snapshot.total_.currentAllocs +
          ' allocations. Showing > 0.1 MB.';
      subhead.className = 'subhead';
      this.appendChild(subhead);

      // Build a nested tree-view of allocations
      var myList = this.buildAllocList_(snapshot.heap_, false);
      this.appendChild(myList);
    },

    /**
     * Creates a nested list with clickable entries.
     * @param {Object} heapEntry The current trace heap entry.
     * @param {boolean} hide Whether this list is hidden by default.
     * @return {Element} A <ul> list element.
     */
    buildAllocList_: function(heapEntry, hide) {
      var myList = document.createElement('ul');
      myList.hidden = hide;
      var keys = Object.keys(heapEntry.children);
      keys.sort(function(a, b) {
        // Sort from large to small.
        return heapEntry.children[b].currentBytes -
            heapEntry.children[a].currentBytes;
      });
      for (var i = 0; i < keys.length; i++) {
        var traceName = keys[i];
        var trace = heapEntry.children[traceName];
        // Don't show small nodes - they make things harder to see.
        if (trace.currentBytes < 100 * 1024)
          continue;
        var childCount = Object.keys(trace.children).length;
        var isLeaf = childCount == 0;
        var myItem = this.buildItem_(
            traceName, isLeaf, trace.currentBytes, trace.currentAllocs);
        myList.appendChild(myItem);
        // Build a nested <ul> list of my children.
        if (childCount > 0)
          myItem.appendChild(this.buildAllocList_(trace, true));
      }
      return myList;
    },

    /*
     * Returns a <li> for an allocation traceName of size bytes.
     */
    buildItem_: function(traceName, isLeaf, bytes, allocs) {
      var myItem = document.createElement('li');
      myItem.className = 'trace-item';
      myItem.id = traceName;

      var byteDiv = document.createElement('div');
      byteDiv.textContent = this.getByteString_(bytes);
      byteDiv.className = 'trace-bytes';
      myItem.appendChild(byteDiv);

      if (traceName.length == 0) {
        // The empty trace name indicates that the allocations occurred at
        // this trace level, not in a sub-trace. This looks weird as the
        // empty string, so replace it with something non-empty and don't
        // give that line an expander.
        traceName = '(here)';
      } else if (traceName.indexOf('..') == 0) {
        // Tasks in RunTask have special handling. They show the path of the
        // filename. Convert '../../foo.cc' into 'RunTask from foo.cc'.
        var lastSlash = traceName.lastIndexOf('/');
        if (lastSlash != -1)
          traceName = 'Task from ' + traceName.substr(lastSlash + 1);
      }
      var traceDiv = document.createElement('div');
      traceDiv.textContent = traceName;
      traceDiv.className = 'trace-name';
      myItem.appendChild(traceDiv);

      // Don't allow leaf nodes to be expanded.
      if (isLeaf)
        return myItem;

      // Expand the element when it is clicked.
      var self = this;
      myItem.addEventListener('click', function(event) {
        // Allow click on the +/- image (li) or child divs.
        if (this == event.target || this == event.target.parentElement) {
          this.classList.toggle('expanded');
          var child = this.querySelector('ul');
          child.hidden = !child.hidden;
          // Highlight this stack trace in the timeline view.
          self.onItemClicked_(this);
        }
      });
      myItem.classList.add('collapsed');
      return myItem;
    },

    onItemClicked_: function(traceItem) {
      // Compute the full stack trace the user just clicked.
      var traces = [];
      while (traceItem.classList.contains('trace-item')) {
        var traceNameDiv = traceItem.firstElementChild.nextElementSibling;
        traces.unshift(traceNameDiv.textContent);
        var traceNameUl = traceItem.parentElement;
        traceItem = traceNameUl.parentElement;
      }
      // Tell the instance that this stack trace is selected.
      var instance = this.objectSnapshot_.objectInstance;
      instance.selectedTraces = traces;
      // Invalid the viewport to cause a redraw.
      var trackView = document.querySelector('.timeline-track-view');
      trackView.viewport_.dispatchChangeEvent();
    },

    /*
     * Returns a human readable string for a size in bytes.
     */
    getByteString_: function(bytes) {
      var mb = bytes / 1024 / 1024;
      return mb.toFixed(1) + ' MB';
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      TcmallocSnapshotView,
      {typeName: 'memory::Heap'});

  return {
    TcmallocSnapshotView: TcmallocSnapshotView
  };
});


'use strict';

tr.exportTo('tr.ui.e.tcmalloc', function() {
  var EventPresenter = tr.ui.b.EventPresenter;

  /**
   * A track that displays heap memory data.
   * @constructor
   * @extends {StackedBarsTrack}
   */

  var HeapInstanceTrack = tr.ui.b.define(
      'tr-ui-e-tcmalloc-heap-instance-track', tr.ui.tracks.StackedBarsTrack);

  HeapInstanceTrack.prototype = {

    __proto__: tr.ui.tracks.StackedBarsTrack.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.StackedBarsTrack.prototype.decorate.call(this, viewport);
      this.classList.add('tr-ui-e-tcmalloc-heap-instance-track');
      this.objectInstance_ = null;
    },

    set objectInstances(objectInstances) {
      if (!objectInstances) {
        this.objectInstance_ = [];
        return;
      }
      if (objectInstances.length != 1)
        throw new Error('Bad object instance count.');
      this.objectInstance_ = objectInstances[0];
      this.maxBytes_ = this.computeMaxBytes_(
          this.objectInstance_.snapshots);
    },

    computeMaxBytes_: function(snapshots) {
      var maxBytes = 0;
      for (var i = 0; i < snapshots.length; i++) {
        var snapshot = snapshots[i];
        // Sum all the current allocations in this snapshot.
        var traceNames = Object.keys(snapshot.heap_.children);
        var sumBytes = 0;
        for (var j = 0; j < traceNames.length; j++) {
          sumBytes += snapshot.heap_.children[traceNames[j]].currentBytes;
        }
        // Keep track of the maximum across all snapshots.
        if (sumBytes > maxBytes)
          maxBytes = sumBytes;
      }
      return maxBytes;
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
    },

    draw: function(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawEvents_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawEvents_: function(viewLWorld, viewRWorld) {
      var ctx = this.context();
      var pixelRatio = window.devicePixelRatio || 1;

      var bounds = this.getBoundingClientRect();
      var width = bounds.width * pixelRatio;
      var height = bounds.height * pixelRatio;

      // Culling parameters.
      var dt = this.viewport.currentDisplayTransform;

      // Scale by the size of the largest snapshot.
      var maxBytes = this.maxBytes_;

      var objectSnapshots = this.objectInstance_.snapshots;
      var lowIndex = tr.b.findLowIndexInSortedArray(
          objectSnapshots,
          function(snapshot) {
            return snapshot.ts;
          },
          viewLWorld);
      // Assure that the stack with the left edge off screen still gets drawn
      if (lowIndex > 0)
        lowIndex -= 1;

      for (var i = lowIndex; i < objectSnapshots.length; ++i) {
        var snapshot = objectSnapshots[i];

        var left = snapshot.ts;
        if (left > viewRWorld)
          break;
        var leftView = dt.xWorldToView(left);
        if (leftView < 0)
          leftView = 0;

        // Compute the edges for the column graph bar.
        var right;
        if (i != objectSnapshots.length - 1) {
          right = objectSnapshots[i + 1].ts;
        } else {
          // If this is the last snaphot of multiple snapshots, use the width of
          // the previous snapshot for the width.
          if (objectSnapshots.length > 1)
            right = objectSnapshots[i].ts + (objectSnapshots[i].ts -
                    objectSnapshots[i - 1].ts);
          else
            // If there's only one snapshot, use max bounds as the width.
            right = this.objectInstance_.parent.model.bounds.max;
        }

        var rightView = dt.xWorldToView(right);
        if (rightView > width)
          rightView = width;

        // Floor the bounds to avoid a small gap between stacks.
        leftView = Math.floor(leftView);
        rightView = Math.floor(rightView);

        // Draw a stacked bar graph. Largest item is stored first in the
        // heap data structure, so iterate backwards. Likewise draw from
        // the bottom of the bar upwards.
        var currentY = height;
        var keys = Object.keys(snapshot.heap_.children);
        for (var k = keys.length - 1; k >= 0; k--) {
          var trace = snapshot.heap_.children[keys[k]];
          if (this.objectInstance_.selectedTraces &&
              this.objectInstance_.selectedTraces.length > 0 &&
              this.objectInstance_.selectedTraces[0] == keys[k]) {
            // A trace selected in the analysis view is bright yellow.
            ctx.fillStyle = 'rgb(239, 248, 206)';
          } else
            ctx.fillStyle = EventPresenter.getBarSnapshotColor(snapshot, k);

          var barHeight = height * trace.currentBytes / maxBytes;
          ctx.fillRect(leftView, currentY - barHeight,
                       Math.max(rightView - leftView, 1), barHeight);
          currentY -= barHeight;
        }
      }
      ctx.lineWidth = 1;
    }
  };

  tr.ui.tracks.ObjectInstanceTrack.register(
      HeapInstanceTrack,
      {typeName: 'memory::Heap'});

  return {
    HeapInstanceTrack: HeapInstanceTrack
  };
});


  'use strict';

  Polymer('tr-ui-e-s-input-latency-side-panel', {
    ready: function() {
      this.rangeOfInterest_ = new tr.b.Range();
      this.frametimeType_ = tr.e.audits.IMPL_FRAMETIME_TYPE;
      this.latencyChart_ = undefined;
      this.frametimeChart_ = undefined;
      this.selectedProcessId_ = undefined;
      this.mouseDownIndex_ = undefined;
      this.curMouseIndex_ = undefined;
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      if (this.model_)
        this.modelHelper_ = new tr.e.audits.ChromeModelHelper(model);
      else
        this.modelHelper_ = undefined;

      this.updateToolbar_();
      this.updateContents_();
    },

    get frametimeType() {
      return this.frametimeType_;
    },

    set frametimeType(type) {
      if (this.frametimeType_ === type)
        return;
      this.frametimeType_ = type;
      this.updateContents_();
    },

    get selectedProcessId() {
      return this.selectedProcessId_;
    },

    set selectedProcessId(process) {
      if (this.selectedProcessId_ === process)
        return;
      this.selectedProcessId_ = process;
      this.updateContents_();
    },

    set selection(selection) {
      if (this.latencyChart_ === undefined)
        return;
      this.latencyChart_.brushedRange = selection.bounds;
    },

        setBrushedIndices: function(mouseDownIndex, curIndex) {
      this.mouseDownIndex_ = mouseDownIndex;
      this.curMouseIndex_ = curIndex;
      this.updateBrushedRange_();
    },

    updateBrushedRange_: function() {
      if (this.latencyChart_ === undefined)
        return;

      var r = new tr.b.Range();
      if (this.mouseDownIndex_ === undefined) {
        this.latencyChart_.brushedRange = r;
        return;
      }
      r = this.latencyChart_.computeBrushRangeFromIndices(
          this.mouseDownIndex_, this.curMouseIndex_);
      this.latencyChart_.brushedRange = r;

                  var latencySlices = [];
      this.model_.getAllThreads().forEach(function(thread) {
        thread.iterateAllEvents(function(event) {
          if (event.title.indexOf('InputLatency:') === 0)
            latencySlices.push(event);
        });
      });
      latencySlices = tr.e.audits.getSlicesIntersectingRange(r, latencySlices);

      var event = new tr.model.RequestSelectionChangeEvent();
      event.selection = new tr.model.EventSet(latencySlices);
      this.latencyChart_.dispatchEvent(event);
    },

    registerMouseEventForLatencyChart_: function() {
      this.latencyChart_.addEventListener('item-mousedown', function(e) {
        this.mouseDownIndex_ = e.index;
        this.curMouseIndex_ = e.index;
        this.updateBrushedRange_();
      }.bind(this));

      this.latencyChart_.addEventListener('item-mousemove', function(e) {
        if (e.button == undefined)
          return;
        this.curMouseIndex_ = e.index;
        this.updateBrushedRange_();
      }.bind(this));

      this.latencyChart_.addEventListener('item-mouseup', function(e) {
        this.curMouseIndex = e.index;
        this.updateBrushedRange_();
      }.bind(this));
    },

    updateToolbar_: function() {
      var browserProcess = this.modelHelper_.browserProcess;
      var labels = [];

      if (browserProcess !== undefined) {
        var label_str = 'Browser: ' + browserProcess.pid;
        labels.push({label: label_str, value: browserProcess.pid});
      }

      tr.b.iterItems(this.modelHelper_.rendererHelpers,
        function(pid, rendererHelper) {
          var rendererProcess = rendererHelper.process;
          var label_str = 'Renderer: ' + rendererProcess.userFriendlyName;
          labels.push({label: label_str, value: rendererProcess.userFriendlyName
        });
      }, this);

      if (labels.length === 0)
        return;

      this.selectedProcessId_ = labels[0].value;
      var toolbarEl = this.$.toolbar;
      toolbarEl.appendChild(tr.ui.b.createSelector(
          this, 'frametimeType',
          'inputLatencySidePanel.frametimeType', this.frametimeType_,
          [{label: 'Main Thread Frame Times',
            value: tr.e.audits.MAIN_FRAMETIME_TYPE},
           {label: 'Impl Thread Frame Times',
            value: tr.e.audits.IMPL_FRAMETIME_TYPE}
          ]));
      toolbarEl.appendChild(tr.ui.b.createSelector(
          this, 'selectedProcessId',
          'inputLatencySidePanel.selectedProcessId',
          this.selectedProcessId_,
          labels));
    },

    get currentRangeOfInterest() {
      if (this.rangeOfInterest_.isEmpty)
        return this.model_.bounds;
      else
        return this.rangeOfInterest_;
    },

    createLatencyLineChart: function(data, title) {
      var chart = new tr.ui.b.LineChart();
      var width = 600;
      if (document.body.clientWidth != undefined)
        width = document.body.clientWidth * 0.5;
      chart.setSize({width: width, height: chart.height});
      chart.chartTitle = title;
      chart.data = data;
      return chart;
    },

    updateContents_: function() {
      var resultArea = this.$.result_area;
      this.latencyChart_ = undefined;
      this.frametimeChart_ = undefined;
      resultArea.textContent = '';

      if (this.modelHelper_ === undefined)
        return;

      var rangeOfInterest = this.currentRangeOfInterest;

      var chromeProcess;
      if (this.modelHelper_.rendererHelpers[this.selectedProcessId_])
        chromeProcess = this.modelHelper_.rendererHelpers[
          this.selectedProcessId_
        ];
      else
        chromeProcess = this.modelHelper_.browserHelper;

      var frameEvents = chromeProcess.getFrameEventsInRange(
          this.frametimeType, rangeOfInterest);

      var frametimeData = tr.e.audits.getFrametimeDataFromEvents(frameEvents);
      var averageFrametime = tr.b.Statistics.mean(frametimeData, function(d) {
        return d.frametime;
      });

      var latencyEvents = this.modelHelper_.browserHelper.
        getLatencyEventsInRange(
          rangeOfInterest);

      var latencyData = [];
      latencyEvents.forEach(function(event) {
        if (event.inputLatency === undefined)
          return;
        latencyData.push({
          x: event.start,
          latency: event.inputLatency / 1000
        });
      });

      var averageLatency = tr.b.Statistics.mean(latencyData, function(d) {
        return d.latency;
      });

            var latencySummaryText = document.createElement('div');
      latencySummaryText.appendChild(tr.ui.b.createSpan({
        textContent: 'Average Latency ' + averageLatency + ' ms',
        bold: true}));
      resultArea.appendChild(latencySummaryText);

      var frametimeSummaryText = document.createElement('div');
      frametimeSummaryText.appendChild(tr.ui.b.createSpan({
        textContent: 'Average Frame Time ' + averageFrametime + ' ms',
        bold: true}));
      resultArea.appendChild(frametimeSummaryText);

      if (latencyData.length !== 0) {
        this.latencyChart_ = this.createLatencyLineChart(
            latencyData, 'Latency Over Time');
        this.registerMouseEventForLatencyChart_();
        resultArea.appendChild(this.latencyChart_);
      }

      if (frametimeData.length != 0) {
        this.frametimeChart_ = this.createLatencyLineChart(
            frametimeData, 'Frame Times');
        this.frametimeChart_.style.display = 'block';
        resultArea.appendChild(this.frametimeChart_);
      }
    },

    get rangeOfInterest() {
      return this.rangeOfInterest_;
    },

    set rangeOfInterest(rangeOfInterest) {
      this.rangeOfInterest_ = rangeOfInterest;
      this.updateContents_();
    },

    supportsModel: function(m) {
      if (m == undefined) {
        return {
          supported: false,
          reason: 'Unknown tracing model'
        };
      }

      if (!tr.e.audits.ChromeModelHelper.supportsModel(m)) {
        return {
          supported: false,
          reason: 'No Chrome browser or renderer process found'
        };
      }

      var modelHelper = new tr.e.audits.ChromeModelHelper(m);
      if (modelHelper.browserHelper &&
        modelHelper.browserHelper.hasLatencyEvents) {
          return {
            supported: true
          };
      }

      return {
        supported: false,
        reason: 'No InputLatency events trace. Consider enabling ' +
            'benchmark" and "input" category when recording the trace'
      };
    },

    get textLabel() {
      return 'Input Latency';
    }
  });
  

'use strict';

tr.exportTo('tr.ui.b', function() {
  var ChartBase = tr.ui.b.ChartBase;
  var getColorOfKey = tr.ui.b.getColorOfKey;

  var MIN_RADIUS = 100;

  /**
   * @constructor
   */
  var PieChart = tr.ui.b.define('pie-chart', ChartBase);

  PieChart.prototype = {
    __proto__: ChartBase.prototype,

    decorate: function() {
      ChartBase.prototype.decorate.call(this);
      this.classList.add('pie-chart');

      this.data_ = undefined;
      this.seriesKeys_ = undefined;

      var chartAreaSel = d3.select(this.chartAreaElement);
      var pieGroupSel = chartAreaSel.append('g')
        .attr('class', 'pie-group');
      this.pieGroup_ = pieGroupSel.node();

      this.pathsGroup_ = pieGroupSel.append('g')
        .attr('class', 'paths')
        .node();
      this.labelsGroup_ = pieGroupSel.append('g')
        .attr('class', 'labels')
        .node();
      this.linesGroup_ = pieGroupSel.append('g')
        .attr('class', 'lines')
        .node();
    },

    get data() {
      return this.data_;
    },


    /**
     * @param {Array} data Data for the chart, where each element in the array
     * must be of the form {label: str, value: number}.
     */
    set data(data) {
      if (data !== undefined) {
        // Figure out the label values in the data set. E.g. from
        //   [{label: 'a', ...}, {label: 'b', ...}]
        // we would commpute ['a', 'y']. These become the series keys.
        var seriesKeys = [];
        var seenSeriesKeys = {};
        data.forEach(function(d) {
          var k = d.label;
          if (seenSeriesKeys[k])
            throw new Error('Label ' + k + ' has been used already');
          seriesKeys.push(k);
          seenSeriesKeys[k] = true;
        }, this);
        this.seriesKeys_ = seriesKeys;
      } else {
        this.seriesKeys_ = undefined;
      }
      this.data_ = data;
      this.updateContents_();
    },

    get margin() {
      var margin = {top: 0, right: 0, bottom: 0, left: 0};
      if (this.chartTitle_)
        margin.top += 40;
      return margin;
    },

    getMinSize: function() {
      this.updateContents_();

      var labelSel = d3.select(this.labelsGroup_).selectAll('.label');
      var maxLabelWidth = -Number.MAX_VALUE;
      var leftTextHeightSum = 0;
      var rightTextHeightSum = 0;
      labelSel.each(function(l) {
        var r = this.getBoundingClientRect();
        maxLabelWidth = Math.max(maxLabelWidth, r.width + 32);
        if (this.style.textAnchor == 'end') {
          leftTextHeightSum += r.height;
        } else {
          rightTextHeightSum += r.height;
        }
      });

      var titleWidth = this.querySelector(
          '#title').getBoundingClientRect().width;
      var margin = this.margin;
      var marginWidth = margin.left + margin.right;
      var marginHeight = margin.top + margin.bottom;
      return {
        width: Math.max(2 * MIN_RADIUS + 2 * maxLabelWidth,
                        titleWidth * 1.1) + marginWidth,
        height: marginHeight + Math.max(2 * MIN_RADIUS,
                                        leftTextHeightSum,
                                        rightTextHeightSum) * 1.25
      };
    },


    getLegendKeys_: function() {
      // This class creates its own legend, instead of using ChartBase.
      return undefined;
    },

    updateScales_: function(width, height) {
      if (this.data_ === undefined)
        return;
    },

    updateContents_: function() {
      ChartBase.prototype.updateContents_.call(this);
      if (!this.data_)
        return;

      var width = this.chartAreaSize.width;
      var height = this.chartAreaSize.height;
      var radius = Math.max(MIN_RADIUS, Math.min(width, height * 0.95) / 2);

      d3.select(this.pieGroup_).attr(
          'transform',
          'translate(' + width / 2 + ',' + height / 2 + ')');

      // Bind the pie layout to its data
      var pieLayout = d3.layout.pie()
        .value(function(d) { return d.value; })
        .sort(null);

      var piePathsSel = d3.select(this.pathsGroup_)
          .datum(this.data_)
          .selectAll('path')
          .data(pieLayout);

      function midAngle(d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
      }

      var pathsArc = d3.svg.arc()
        .innerRadius(0)
        .outerRadius(radius - 30);

      var valueLabelArc = d3.svg.arc()
        .innerRadius(radius - 100)
        .outerRadius(radius - 30);

      var lineBeginArc = d3.svg.arc()
        .innerRadius(radius - 50)
        .outerRadius(radius - 50);

      var lineEndArc = d3.svg.arc()
        .innerRadius(radius)
        .outerRadius(radius);

      // Paths.
      piePathsSel.enter().append('path')
        .attr('class', 'arc')
        .attr('fill', function(d, i) {
            var origData = this.data_[i];
            var highlighted = (origData.label ===
                               this.currentHighlightedLegendKey);
            return getColorOfKey(origData.label, highlighted);
          }.bind(this))
        .attr('d', pathsArc)
        .on('click', function(d, i) {
            var origData = this.data_[i];
            var event = new tr.b.Event('item-click');
            event.data = origData;
            event.index = i;
            this.dispatchEvent(event);
            d3.event.stopPropagation();
          }.bind(this))
        .on('mouseenter', function(d, i) {
            var origData = this.data_[i];
            this.pushTempHighlightedLegendKey(origData.label);
          }.bind(this))
        .on('mouseleave', function(d, i) {
            var origData = this.data_[i];
            this.popTempHighlightedLegendKey(origData.label);
          }.bind(this));

      // Value labels.
      piePathsSel.enter().append('text')
        .attr('class', 'arc-text')
        .attr('transform', function(d) {
            return 'translate(' + valueLabelArc.centroid(d) + ')';
          })
        .attr('dy', '.35em')
        .style('text-anchor', 'middle')
        .text(function(d, i) {
            var origData = this.data_[i];
            if (origData.valueText === undefined)
              return '';

            if (d.endAngle - d.startAngle < 0.4)
              return '';
            return origData.valueText;
          }.bind(this));

      piePathsSel.exit().remove();

      // Labels.
      var labelSel = d3.select(this.labelsGroup_).selectAll('.label')
          .data(pieLayout(this.data_));
      labelSel.enter()
          .append('text')
          .attr('class', 'label')
          .attr('dy', '.35em');

      labelSel.text(function(d) {
        if (d.data.label.length > 40)
          return d.data.label.substr(0, 40) + '...';
        return d.data.label;
      });
      labelSel.attr('transform', function(d) {
        var pos = lineEndArc.centroid(d);
        pos[0] = radius * (midAngle(d) < Math.PI ? 1 : -1);
        return 'translate(' + pos + ')';
      });
      labelSel.style('text-anchor', function(d) {
        return midAngle(d) < Math.PI ? 'start' : 'end';
      });

      // Lines.
      var lineSel = d3.select(this.linesGroup_).selectAll('.line')
          .data(pieLayout(this.data_));
      lineSel.enter()
        .append('polyline')
        .attr('class', 'line')
        .attr('dy', '.35em');
      lineSel.attr('points', function(d) {
        var pos = lineEndArc.centroid(d);
        pos[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);
        return [lineBeginArc.centroid(d), lineEndArc.centroid(d), pos];
      });
    },

    updateHighlight_: function() {
      ChartBase.prototype.updateHighlight_.call(this);
      // Update color of pie segments.
      var pathsGroupSel = d3.select(this.pathsGroup_);
      var that = this;
      pathsGroupSel.selectAll('.arc').each(function(d, i) {
        var origData = that.data_[i];
        var highlighted = origData.label == that.currentHighlightedLegendKey;
        var color = getColorOfKey(origData.label, highlighted);
        this.style.fill = color;
      });
    }
  };

  return {
    PieChart: PieChart
  };
});


  'use strict';
  (function() {
    var GROUP_BY_PROCESS_NAME = 'process';
    var GROUP_BY_THREAD_NAME = 'thread';

    var WALL_TIME_GROUPING_UNIT = 'Wall time';
    var CPU_TIME_GROUPING_UNIT = 'CPU time';

    
    function ResultsForGroup(model, name) {
      this.model = model;
      this.name = name;
      this.topLevelSlices = [];
      this.allSlices = [];
    }

    ResultsForGroup.prototype = {
      get wallTime() {
        var wallSum = tr.b.Statistics.sum(
            this.topLevelSlices, function(x) { return x.duration; });
        return wallSum;
      },

      get cpuTime() {
        var cpuDuration = 0;
        for (var i = 0; i < this.topLevelSlices.length; i++) {
          var x = this.topLevelSlices[i];
                                                  if (x.cpuDuration === undefined) {
            if (x.duration === undefined)
              continue;
            return 0;
          }
          cpuDuration += x.cpuDuration;
        }
        return cpuDuration;
      },

      appendGroupContents: function(group) {
        if (group.model != this.model)
          throw new Error('Models must be the same');

        group.allSlices.forEach(function(slice) {
          this.allSlices.push(slice);
        }, this);
        group.topLevelSlices.forEach(function(slice) {
          this.topLevelSlices.push(slice);
        }, this);
      },

      appendThreadSlices: function(rangeOfInterest, thread) {
        var tmp = this.getSlicesIntersectingRange(
            rangeOfInterest, thread.sliceGroup.slices);
        tmp.forEach(function(slice) {
          this.allSlices.push(slice);
        }, this);
        tmp = this.getSlicesIntersectingRange(
            rangeOfInterest, thread.sliceGroup.topLevelSlices);
        tmp.forEach(function(slice) {
          this.topLevelSlices.push(slice);
        }, this);
      },

      getSlicesIntersectingRange: function(rangeOfInterest, slices) {
        var slicesInFilterRange = [];
        for (var i = 0; i < slices.length; i++) {
          var slice = slices[i];
          if (rangeOfInterest.intersectsExplicitRange(slice.start, slice.end))
            slicesInFilterRange.push(slice);
        }
        return slicesInFilterRange;
      }
    };

    Polymer('tr-ui-e-s-time-summary-side-panel', {
      ready: function() {
        this.rangeOfInterest_ = new tr.b.Range();
        this.selection_ = undefined;
        this.groupBy_ = GROUP_BY_PROCESS_NAME;
        this.groupingUnit_ = CPU_TIME_GROUPING_UNIT;
        this.showCpuIdleTime_ = true;
        this.chart_ = undefined;

        var toolbarEl = this.$.toolbar;
        this.groupBySelector_ = tr.ui.b.createSelector(
            this, 'groupBy',
            'timeSummarySidePanel.groupBy', this.groupBy_,
            [{label: 'Group by process', value: GROUP_BY_PROCESS_NAME},
             {label: 'Group by thread', value: GROUP_BY_THREAD_NAME}
            ]);
        toolbarEl.appendChild(this.groupBySelector_);

        this.groupingUnitSelector_ = tr.ui.b.createSelector(
            this, 'groupingUnit',
            'timeSummarySidePanel.groupingUnit', this.groupingUnit_,
            [{label: 'Wall time', value: WALL_TIME_GROUPING_UNIT},
             {label: 'CPU time', value: CPU_TIME_GROUPING_UNIT}
            ]);
        toolbarEl.appendChild(this.groupingUnitSelector_);

        this.showCpuIdleTimeCheckbox_ = tr.ui.b.createCheckBox(
            this, 'showCpuIdleTime',
            'timeSummarySidePanel.showCpuIdleTime', this.showCpuIdleTime_,
            'Show CPU idle time');
        toolbarEl.appendChild(this.showCpuIdleTimeCheckbox_);
        this.updateShowCpuIdleTimeCheckboxVisibility_();
      },

      
      trimPieChartData: function(groups, otherGroup, getValue, opt_extraValue) {
                groups = groups.filter(function(d) {
          return getValue(d) != 0;
        });

                var sum = tr.b.Statistics.sum(groups, getValue);
        if (opt_extraValue !== undefined)
          sum += opt_extraValue;

                function compareByValue(a, b) {
          return getValue(a) - getValue(b);
        }
        groups.sort(compareByValue);

                var thresshold = 0.1 * sum;
        while (groups.length > 1) {
          var group = groups[0];
          if (getValue(group) >= thresshold)
            break;

          var v = getValue(group);
          if (v + getValue(otherGroup) > thresshold)
            break;

                    groups.splice(0, 1);
          otherGroup.appendGroupContents(group);
        }

                if (getValue(otherGroup) > 0)
          groups.push(otherGroup);

        groups.sort(compareByValue);

        return groups;
      },

      generateResultsForGroup: function(model, name) {
        return new ResultsForGroup(model, name);
      },

      createPieChartFromResultGroups: function(
          groups, title, getValue, opt_extraData) {
        var chart = new tr.ui.b.PieChart();

        function pushDataForGroup(data, resultsForGroup, value) {
          data.push({
            label: resultsForGroup.name,
            value: value,
            valueText: tr.b.u.TimeDuration.format(value),
            resultsForGroup: resultsForGroup
          });
        }
        chart.addEventListener('item-click', function(clickEvent) {
          var resultsForGroup = clickEvent.data.resultsForGroup;
          if (resultsForGroup === undefined)
            return;

          var event = new tr.model.RequestSelectionChangeEvent();
          event.selection = new tr.model.EventSet(resultsForGroup.allSlices);
          event.selection.timeSummaryGroupName = resultsForGroup.name;
          chart.dispatchEvent(event);
        });


                var data = [];
        groups.forEach(function(resultsForGroup) {
          var value = getValue(resultsForGroup);
          if (value === 0)
            return;
          pushDataForGroup(data, resultsForGroup, value);
        });
        if (opt_extraData)
          data.push.apply(data, opt_extraData);

        chart.chartTitle = title;
        chart.data = data;
        return chart;
      },

      get model() {
        return this.model_;
      },

      set model(model) {
        this.model_ = model;
        this.updateContents_();
      },

      get listeningToKeys() {
        return false;
      },

      get groupBy() {
        return groupBy_;
      },

      set groupBy(groupBy) {
        this.groupBy_ = groupBy;
        if (this.groupBySelector_)
          this.groupBySelector_.selectedValue = groupBy;
        this.updateContents_();
      },

      get groupingUnit() {
        return groupingUnit_;
      },

      set groupingUnit(groupingUnit) {
        this.groupingUnit_ = groupingUnit;
        if (this.groupingUnitSelector_)
          this.groupingUnitSelector_.selectedValue = groupingUnit;
        this.updateShowCpuIdleTimeCheckboxVisibility_();
        this.updateContents_();
      },

      get showCpuIdleTime() {
        return this.showCpuIdleTime_;
      },

      set showCpuIdleTime(showCpuIdleTime) {
        this.showCpuIdleTime_ = showCpuIdleTime;
        if (this.showCpuIdleTimeCheckbox_)
          this.showCpuIdleTimeCheckbox_.checked = showCpuIdleTime;
        this.updateContents_();
      },

      updateShowCpuIdleTimeCheckboxVisibility_: function() {
        if (!this.showCpuIdleTimeCheckbox_)
          return;
        var visible = this.groupingUnit_ == CPU_TIME_GROUPING_UNIT;
        if (visible)
          this.showCpuIdleTimeCheckbox_.style.display = '';
        else
          this.showCpuIdleTimeCheckbox_.style.display = 'none';
      },

      getGroupNameForThread_: function(thread) {
        if (this.groupBy_ == GROUP_BY_THREAD_NAME)
          return thread.name ? thread.name : thread.userFriendlyName;

        if (this.groupBy_ == GROUP_BY_PROCESS_NAME)
          return thread.parent.userFriendlyName;
      },

      updateContents_: function() {
        var resultArea = this.$.result_area;
        this.chart_ = undefined;
        resultArea.textContent = '';

        if (this.model_ === undefined)
          return;

        var rangeOfInterest;
        if (this.rangeOfInterest_.isEmpty)
          rangeOfInterest = this.model_.bounds;
        else
          rangeOfInterest = this.rangeOfInterest_;

        var allGroup = this.generateResultsForGroup(this.model_, 'all');
        var resultsByGroupName = {};
        this.model_.getAllThreads().forEach(function(thread) {
          var groupName = this.getGroupNameForThread_(thread);
          if (resultsByGroupName[groupName] === undefined) {
            resultsByGroupName[groupName] = this.generateResultsForGroup(
                this.model_, groupName);
          }
          resultsByGroupName[groupName].appendThreadSlices(
              rangeOfInterest, thread);

          allGroup.appendThreadSlices(rangeOfInterest, thread);
        }, this);

                var getValueFromGroup = function(group) {
          if (this.groupingUnit_ == WALL_TIME_GROUPING_UNIT)
            return group.wallTime;
          return group.cpuTime;
        }.bind(this);

                var summaryText = document.createElement('div');
        summaryText.appendChild(tr.ui.b.createSpan({
          textContent: 'Total ' + this.groupingUnit_ + ': ',
          bold: true}));
        summaryText.appendChild(tr.ui.units.createTimeDurationSpan(
            getValueFromGroup(allGroup), {ownerDocument: this.ownerDocument}));
        resultArea.appendChild(summaryText);

                var extraValue = 0;
        var extraData = [];
        if (this.showCpuIdleTime_ &&
            this.groupingUnit_ === CPU_TIME_GROUPING_UNIT &&
            this.model.kernel.bestGuessAtCpuCount !== undefined) {
          var maxCpuTime = rangeOfInterest.range *
              this.model.kernel.bestGuessAtCpuCount;
          var idleTime = Math.max(0, maxCpuTime - allGroup.cpuTime);
          extraData.push({
            label: 'CPU Idle',
            value: idleTime,
            valueText: tr.b.u.TimeDuration.format(idleTime)
          });
          extraValue += idleTime;
        }

                var otherGroup = this.generateResultsForGroup(this.model_, 'Other');
        var groups = this.trimPieChartData(
            tr.b.dictionaryValues(resultsByGroupName),
            otherGroup,
            getValueFromGroup,
            extraValue);

        if (groups.length == 0) {
          resultArea.appendChild(tr.ui.b.createSpan({textContent: 'No data'}));
          return undefined;
        }

        this.chart_ = this.createPieChartFromResultGroups(
            groups,
            this.groupingUnit_ + ' breakdown by ' + this.groupBy_,
            getValueFromGroup, extraData);
        resultArea.appendChild(this.chart_);

        this.chart_.addEventListener('click', function() {
          var event = new tr.model.RequestSelectionChangeEvent();
          event.selection = new tr.c.EventSet([]);
          this.dispatchEvent(event);
        });
        this.chart_.setSize(this.chart_.getMinSize());
      },

      get selection() {
        return selection_;
      },

      set selection(selection) {
        this.selection_ = selection;

        if (this.chart_ === undefined)
          return;

        if (selection.timeSummaryGroupName)
          this.chart_.highlightedLegendKey = selection.timeSummaryGroupName;
        else
          this.chart_.highlightedLegendKey = undefined;
      },

      get rangeOfInterest() {
        return this.rangeOfInterest_;
      },

      set rangeOfInterest(rangeOfInterest) {
        this.rangeOfInterest_ = rangeOfInterest;
        this.updateContents_();
      },

      supportsModel: function(model) {
        return {
          supported: false
        };
      },

      get textLabel() {
        return 'Time Summary';
      }
    });
  }());
  

'use strict';

tr.exportTo('tr.e.rail', function() {
  function RAILScore(opt_irs) {
    this.interactionRecords_ = [];
    if (opt_irs)
      this.interactionRecords_.push.apply(this.interactionRecords_, opt_irs);
  };

  RAILScore.prototype = {
    get interactionRecords() {
      return this.interactionRecords_;
    },

    get overallScore() {
      // The design of this algorithm is discussed here: https://goo.gl/Cc0H1z
      // TODO(benjhayden): Make doc public and remove below comment?
      // Until the doc is made public, this is basically a weighted average,
      // where the weights are tunable. The weights are recommended to be higher
      // for lower scores, so that lower scores will bring down the overallScore
      // more than higher scores bring it up. The optional fields provide an
      // opportunity to customize the tunable parameters based on IR type,
      // duration, etc. The continuity and monotonicity of the weighting
      // function are also important characteristics. The weighting function is
      // not composed of meaningful sub-expressions; it is a monolithic
      // combination of the score and tunable parameters, and is open to
      // reformulation.
      // The weighting function is graphed here: https://goo.gl/1blsXW
      if (!this.interactionRecords.length)
        return undefined;

      var numerator = 0;
      var denominator = 0;
      this.interactionRecords.forEach(function(ir) {
        var score = ir.railScore;

        var scale = ir.railScoreScale;
        if (scale === undefined)
          scale = 3;

        var power = ir.railScorePower;
        if (power === undefined)
          power = 0.3;

        var base = ir.railScoreBase;
        if (base === undefined)
          base = Math.exp(1);

        var weight = Math.pow(base, -scale * Math.pow(score, power));
        numerator += score * weight;
        denominator += weight;
      });
      return numerator / denominator;
    },

    asDict: function() {
      return {
        overallScore: this.overallScore
      };
    }
  };

  RAILScore.fromModel = function(model) {
    var rirs = model.interactionRecords.filter(function(ir) {
      return ir instanceof tr.e.rail.RAILInteractionRecord;
    });
    if (rirs.length === 0)
      return undefined;
    return new RAILScore(rirs);
  };

  return {
    RAILScore: RAILScore
  };
});


  'use strict';

  Polymer('tr-ui-e-rail-rail-score-span', {
    created: function() {
      this.railScore_ = undefined;
    },

    ready: function() {
      this.updateContent_();
    },

    get railScore() {
      return this.railScore_;
    },

    set railScore(railScore) {
      this.railScore_ = railScore;
      this.updateContent_();
    },

    updateContent_: function() {
      if (this.railScore_ === undefined) {
        this.$.content.style.display = 'none';
        return;
      }
      this.$.content.style.display = '';
      var overallScore = this.railScore_.overallScore;
      if (overallScore === undefined)
        return;
      this.$.score.textContent = overallScore.toLocaleString(
          undefined,
          {minimumFractionDigits: 3});
    }
  });
  

'use strict';
(function() {
  function setCoverageLink(
      link, labelString, events, eventRatio, cpuMs, cpuRatio) {
    link.setSelectionAndContent(events);

    labelString += ' ' + events.length + ' events';
    labelString += ' (' + parseInt(100 * eventRatio) + '%)';
    if (cpuRatio !== undefined)
      labelString += ', ';
    link.appendChild(document.createTextNode(labelString));

    if (cpuRatio === undefined)
      return;

    var cpuMsSpan = document.createElement('tr-ui-u-time-duration-span');
    // There will be some text after the cpuMsSpan, that should be on the same
    // line if it fits. This "span" has display: block for its sparkline... so I
    // guess I'll set it inline here?
    cpuMsSpan.style.display = 'inline';
    cpuMsSpan.duration = cpuMs;
    cpuMsSpan.contentTextDecoration = 'underline';
    link.appendChild(cpuMsSpan);

    var cpuString = ' (' + parseInt(100 * cpuRatio) + '%)';
    link.appendChild(document.createTextNode(cpuString));
  }

  Polymer('tr-ui-e-rail-rail-score-side-panel', {
    ready: function() {
      this.rangeOfInterest_ = new tr.b.Range();
      this.model_ = undefined;
      this.railScore_ = undefined;
      this.selection_ = new tr.model.EventSet();
      this.$.test.addEventListener('click', this.createTest_.bind(this));
    },

    createTest_: function() {
      var overlay = new tr.ui.b.Overlay();
      overlay.title = 'RAILIRFinder test';
      var textarea = document.createElement('textarea');
      textarea.textContent = tr.e.rail.createIRFinderTestCaseStringFromModel(
          this.model_);
      textarea.rows = textarea.textContent.split('\n').length;
      textarea.cols = 80;
      overlay.appendChild(textarea);
      overlay.visible = true;
      textarea.select();
      textarea.focus();
    },

    get textLabel() {
     return 'RAIL Info';
    },

    supportsModel: function(m) {
      if (m === undefined) {
        return {
          supported: false,
          reason: 'Unknown tracing model'
        };
      }

      var railScore = tr.e.rail.RAILScore.fromModel(m);
      if (railScore === undefined) {
        return {
          supported: false,
          reason: 'RAIL interactions were not found on the model'
        };
      }

      return {
        supported: true
      };
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      this.railScore_ = tr.e.rail.RAILScore.fromModel(model);
      this.$.score.railScore = this.railScore_;

      var coverage = tr.model.getIRCoverageFromModel(model);
      if (coverage) {
        var associatedEvents =
            tr.model.getAssociatedEvents(model.interactionRecords);

        setCoverageLink(this.shadowRoot.querySelector('#associated-events'),
                        'Associated',
                        associatedEvents,
                        coverage.coveredEventsCountRatio,
                        coverage.associatedEventsCpuTimeMs,
                        coverage.coveredEventsCpuTimeRatio);
        setCoverageLink(this.shadowRoot.querySelector('#unassociated-events'),
                        'Unassociated',
                        tr.model.getUnassociatedEvents(model, associatedEvents),
                        1.0 - coverage.coveredEventsCountRatio,
                        coverage.unassociatedEventsCpuTimeMs,
                        1.0 - coverage.coveredEventsCpuTimeRatio);
      }

      this.updateTable_();
    },

    get listeningToKeys() {
      return false;
    },

    set rangeOfInterest(rangeOfInterest) {
    },

    updateTable_: function() {
      function toThreeDigitLocaleString(value) {
        return value.toLocaleString(undefined,
                                    {minimumFractionDigits: 3,
                                     maximumFractionDigits: 3});
      }

      var columns = [
        {
          title: 'Type',
          width: '150px',
          value: function(ir) {
            var el = document.createElement('tr-ui-b-color-legend');
            var linkEl = document.createElement('tr-ui-a-analysis-link');
            linkEl.setSelectionAndContent(new tr.model.EventSet([ir]),
                                          ir.railTypeName);
            el.setLabelAndColorId(linkEl, ir.colorId);
            el.compoundEventSelectionState =
                ir.computeCompoundEvenSelectionState(this.selection_);
            return el;
          }.bind(this),
          cmp: function(a, b) {
            return a.railTypeName.localeCompare(b.railTypeName);
          }
        },
        {
          title: 'Efficiency',
          width: '33%',
          value: function(ir) {
            return toThreeDigitLocaleString(ir.normalizedEfficiency);
          },
          cmp: function(a, b) {
            return a.normalizedEfficiency - b.normalizedEfficiency;
          }
        },
        {
          title: 'Pain',
          width: '33%',
          value: function(ir) {
            return toThreeDigitLocaleString(ir.normalizedUserPain);
          },
          cmp: function(a, b) {
            return a.normalizedUserPain - b.normalizedUserPain;
          }
        },
        {
          title: 'Score',
          width: '33%',
          value: function(ir) {
            var span = document.createElement('span');
            span.style.fontWeight = 'bold';
            span.textContent = toThreeDigitLocaleString(ir.railScore);
            return span;
          },
          cmp: function(a, b) {
            return a.railScore - b.railScore;
          }
        }
      ];

      this.$.table.tableColumns = columns;
      if (this.railScore_)
        this.$.table.tableRows = this.railScore_.interactionRecords;
      else
        this.$.table.tableRows = [];
      this.$.table.rebuild();
    },

    onTableSelectionChanged_: function() {
      var selectedIR = this.$.table.selectedTableRow;

      var event = new tr.c.RequestSelectionChangeEvent();
      event.selection = new tr.c.Selection([selectedIR]);
      this.dispatchEvent(event);
    },

    set selection(selection) {
      if (selection === undefined)
        selection = new tr.model.EventSet();

      if (this.selection_.equals(selection))
        return;

      this.selection_ = selection;
      this.updateTable_();
    }
  });
})();


  'use strict';

  Polymer('tr-ui-e-s-alerts-side-panel', {
    ready: function() {
      this.rangeOfInterest_ = new tr.b.Range();
      this.selection_ = undefined;
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      this.updateContents_();
    },

    get listeningToKeys() {
      return false;
    },

    set selection(selection) {
    },

    set rangeOfInterest(rangeOfInterest) {
    },

    
    selectAlertsOfType: function(alertTypeString) {
      var alertsOfType = this.model_.alerts.filter(function(alert) {
        return alert.title === alertTypeString;
      });

      var event = new tr.model.RequestSelectionChangeEvent();
      event.selection = new tr.model.EventSet(alertsOfType);
      this.dispatchEvent(event);
    },

    
    alertsByType_: function(alerts) {
      var alertsByType = {};
      alerts.forEach(function(alert) {
        if (!alertsByType[alert.title])
          alertsByType[alert.title] = [];

        alertsByType[alert.title].push(alert);
      });
      return alertsByType;
    },

    alertsTableRows_: function(alertsByType) {
      return Object.keys(alertsByType).map(function(key) {
        return {
          alertType: key,
          count: alertsByType[key].length
        };
      });
    },

    alertsTableColumns_: function() {
      return [
        {
          title: 'Alert type',
          value: function(row) { return row.alertType; },
          width: '180px'
        },
        {
          title: 'Count',
          width: '100%',
          value: function(row) { return row.count; }
        }
      ];
    },

    createAlertsTable_: function(alerts) {
      var alertsByType = this.alertsByType_(alerts);

      var table = document.createElement('tr-ui-b-table');
      table.tableColumns = this.alertsTableColumns_();
      table.tableRows = this.alertsTableRows_(alertsByType);
      table.supportsSelection = true;
      table.addEventListener('selection-changed', function(e) {
        var row = table.selectedTableRow;
        if (row)
          this.selectAlertsOfType(row.alertType);
      }.bind(this));

      return table;
    },

    updateContents_: function() {
      this.$.result_area.textContent = '';
      if (this.model_ === undefined)
        return;

      var panel = this.createAlertsTable_(this.model_.alerts);
      this.$.result_area.appendChild(panel);
    },

    supportsModel: function(m) {
      if (m == undefined) {
        return {
          supported: false,
          reason: 'Unknown tracing model'
        };
      } else if (m.alerts.length === 0) {
        return {
          supported: false,
          reason: 'No alerts in tracing model'
        };
      }

      return {
        supported: true
      };
    },

    get textLabel() {
      return 'Alerts';
    }
  });
  

'use strict';

/**
 * @fileoverview Provides the VSyncHighlighter class.
 */
tr.exportTo('tr.ui.e.highlighter', function() {

  var Highlighter = tr.ui.tracks.Highlighter;

  /**
   * Highlights VSync events on the model track (using "zebra" striping).
   * @constructor
   */
  function VSyncHighlighter(viewport) {
    Highlighter.call(this, viewport);
    this.times_ = [];
  }

  VSyncHighlighter.VSYNC_HIGHLIGHT_COLOR = {r: 0, g: 0, b: 255};
  VSyncHighlighter.VSYNC_HIGHLIGHT_ALPHA = 0.1;

  VSyncHighlighter.VSYNC_DENSITY_TRANSPARENT = 0.20;
  VSyncHighlighter.VSYNC_DENSITY_OPAQUE = 0.10;
  VSyncHighlighter.VSYNC_DENSITY_RANGE =
      VSyncHighlighter.VSYNC_DENSITY_TRANSPARENT -
      VSyncHighlighter.VSYNC_DENSITY_OPAQUE;

  /**
   * Generate a zebra striping from a list of times.
   */
  VSyncHighlighter.generateStripes = function(times, minTime, maxTime) {
    if (times.length === 0)
      return [];

    var stripes = [];

    // Find the lowest and highest index within the viewport.
    var lowIndex = tr.b.findLowIndexInSortedArray(
        times,
        function(time) { return time; },
        minTime);
    var highIndex = lowIndex - 1;
    while (times[highIndex + 1] <= maxTime) {
      highIndex++;
    }

    // Must start at an even index and end at an odd index.
    for (var i = lowIndex - (lowIndex % 2); i <= highIndex; i += 2) {
      var left = i < lowIndex ? minTime : times[i];
      var right = i + 1 > highIndex ? maxTime : times[i + 1];
      stripes.push([left, right]);
    }

    return stripes;
  }

  VSyncHighlighter.prototype = {
    __proto__: Highlighter.prototype,

    processModel: function(model) {
      this.times_ = model.device.vSyncTimestamps;
    },

    drawHighlight: function(ctx, dt, viewLWorld, viewRWorld, viewHeight) {
      if (!this.viewport_.highlightVSync) {
        return;
      }

      var stripes = VSyncHighlighter.generateStripes(
          this.times_, viewLWorld, viewRWorld);
      if (stripes.length == 0) {
        return;
      }

      var stripeRange = stripes[stripes.length - 1][1] - stripes[0][0];
      var stripeDensity = stripes.length / (dt.scaleX * stripeRange);
      var clampedStripeDensity = tr.b.clamp(stripeDensity,
          VSyncHighlighter.VSYNC_DENSITY_OPAQUE,
          VSyncHighlighter.VSYNC_DENSITY_TRANSPARENT);
      var opacity =
          (VSyncHighlighter.VSYNC_DENSITY_TRANSPARENT - clampedStripeDensity) /
          VSyncHighlighter.VSYNC_DENSITY_RANGE;
      if (opacity == 0) {
        return;
      }

      var pixelRatio = window.devicePixelRatio || 1;
      var height = viewHeight * pixelRatio;
      ctx.fillStyle = tr.ui.b.colorToRGBAString(
          VSyncHighlighter.VSYNC_HIGHLIGHT_COLOR,
          VSyncHighlighter.VSYNC_HIGHLIGHT_ALPHA * opacity);

      for (var i = 0; i < stripes.length; i++) {
        var xLeftView = dt.xWorldToView(stripes[i][0]);
        var xRightView = dt.xWorldToView(stripes[i][1]);
        ctx.fillRect(xLeftView, 0, xRightView - xLeftView, height);
      }
    }
  };

  // Register the highlighter.
  tr.ui.tracks.Highlighter.register(VSyncHighlighter);

  return {
    VSyncHighlighter: VSyncHighlighter
  };
});

</script>
<script id="viewer-data" type="text/plain">
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
</script>
</head>
  <body>
  </body>
</html>
